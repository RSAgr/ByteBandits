# File: https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/asa/assets/pyteal/5-clear.py
from pyteal import *

def clear_state_program():
    return Return(Int(1))

optimize_options = OptimizeOptions(scratch_slots=True)
if __name__ == "__main__":
    print(compileTeal(clear_state_program(), Mode.Application, version = 5, optimize=optimize_options))

# File: https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/kcoin_vault_pyteal.py
from typing import Tuple

from algosdk.abi import Contract
from pyteal import (
    App,
    Approve,
    Assert,
    BareCallActions,
    Bytes,
    Div,
    Expr,
    Global,
    InnerTxn,
    InnerTxnBuilder,
    Int,
    Mul,
    OnCompleteAction,
    Router,
    Seq,
    Subroutine,
    TealType,
    Txn,
    TxnField,
    TxnType,
    abi,
)
from pyteal.compiler.optimizer import optimizer

ASSET_TOTAL = 1000000000
ASSET_DECIMALS = 3
INITIAL_EXCHANGE_RATE = 2000
SCALING_FACTOR = 1000

# The PyTeal router
router = Router(
    name="K-Coin-Vault",
    bare_calls=BareCallActions(
        no_op=OnCompleteAction.create_only(Approve()),
        update_application=OnCompleteAction.never(),
        delete_application=OnCompleteAction.never(),
        clear_state=OnCompleteAction.never(),
    ),
)


@router.method
def init_asset(*, output: abi.Uint64) -> Expr:
    """
    Create the K Coin asset

    Can only be executed by the contract's creator

    Returns: created asset id

    """
    return Seq(
        Assert(Txn.sender() == Global.creator_address()),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_total: Int(ASSET_TOTAL),
                TxnField.config_asset_decimals: Int(ASSET_DECIMALS),
                TxnField.config_asset_manager: Global.current_application_address(),
                TxnField.config_asset_reserve: Global.current_application_address(),
                TxnField.config_asset_freeze: Global.current_application_address(),
                TxnField.config_asset_clawback: Global.current_application_address(),
                TxnField.config_asset_name: Bytes("K Coin"),
                TxnField.config_asset_unit_name: Bytes("microK"),
            }
        ),
        InnerTxnBuilder.Submit(),
        App.globalPut(Bytes("asset_id"), InnerTxn.created_asset_id()),
        App.globalPut(Bytes("exchange_rate"), Int(INITIAL_EXCHANGE_RATE)),
        output.set(InnerTxn.created_asset_id()),
    )


@Subroutine(TealType.uint64)
def algos_to_kcoin(algo_amount: Expr) -> Expr:
    """
    Convert microalgos to microKs:

    microKs = microAlgos * EXCHANGE_RATE / SCALING_FACTOR
    """
    return Div(Mul(algo_amount, App.globalGet(Bytes("exchange_rate"))), Int(SCALING_FACTOR))


@Subroutine(TealType.uint64)
def kcoin_to_algos(asset_amount: Expr) -> Expr:
    """
    Convert microKs to microalgos

    microAlgos = microKs * SCALING_FACTOR / EXCHANGE_RATE
    """
    return Mul(Div(asset_amount, App.globalGet(Bytes("exchange_rate"))), Int(SCALING_FACTOR))


@router.precondition(expr='payment.get().amount() >= Int(10000)')
@router.precondition(expr='payment.get().amount() <= Int(20000)')
@router.postcondition(
    expr=f'output.get() == payment.get().amount() * Int({INITIAL_EXCHANGE_RATE}) / Int({SCALING_FACTOR})'
)
@router.hoare_method
@router.method
def mint(payment: abi.PaymentTransaction, *, output: abi.Uint64) -> Expr:
    """
    Mint K Coins, issuing an inner asset transfer transaction to sender if successful

    Args:
        payment: A payment transaction containing the amount of Algos the user wishes to mint with.
            The receiver of this transaction must be this app's escrow account.

    Returns: minted amount of K Coins that the user gets
    """
    amount_to_mint = algos_to_kcoin(payment.get().amount())
    asset_id = App.globalGet(Bytes("asset_id"))
    return Seq(
        Assert(payment.get().receiver() == Global.current_application_address()),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: asset_id,
                TxnField.asset_receiver: Txn.sender(),
                TxnField.asset_amount: amount_to_mint,
                TxnField.fee: Int(0),
            }
        ),
        InnerTxnBuilder.Submit(),
        output.set(amount_to_mint),
    )


@router.precondition(expr='asset_transfer.get().amount() >= Int(10000)')
@router.precondition(expr='asset_transfer.get().amount() <= Int(20000)')
@router.postcondition(
    expr=f'output.get() == asset_transfer.get().amount() * Int({SCALING_FACTOR}) / Int({INITIAL_EXCHANGE_RATE})'
)
@router.hoare_method
@router.method
def burn(asset_transfer: abi.AssetTransferTransaction, *, output: abi.Uint64) -> Expr:
    """
    Burn K Coins, issuing an inner payment transaction to sender if successful

    Args:
        asset_transfer: An asset transfer transaction containing the amount of K Coins (in microKs) the user wishes to burn.
            The receiver of this transaction must be this app's escrow account.

    Returns: amount of microalgos the users gets
    """
    microalgos_output = kcoin_to_algos(asset_transfer.get().asset_amount())
    return Seq(
        Assert(asset_transfer.get().asset_receiver() == Global.current_application_address()),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.Payment,
                TxnField.receiver: Txn.sender(),
                TxnField.amount: microalgos_output,
                TxnField.fee: Int(0),
            }
        ),
        InnerTxnBuilder.Submit(),
        output.set(microalgos_output),
    )


def compile_to_teal() -> Tuple[str, str, Contract]:
    """Compile approval and clear programs, and generate the contract description object"""
    approval, clear, contract = router.compile_program(
        version=6, optimize=optimizer.OptimizeOptions(scratch_slots=True)
    )
    return approval, clear, contract


# File: https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py
# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913
import json
import sys
import os
from pyteal import *
from .abi_types import *
from .inline import InlineAssembly
from assets.abi import ABI_PATH,system_delima



main_contract_abi = json.load(open(ABI_PATH + f"{system_delima}main-contract.json"))
voting_contract_abi = json.load(open(ABI_PATH + f"{system_delima}voting-contract.json"))
smart_assert_errors = json.load(open(ABI_PATH + f"{system_delima}..{system_delima}smart_assert_errors.json"))

# This is not used as it hard codes the costs of a box
# But is kept here as a record of how it is calculated
# The current method is by checking min balances before
# and after the box is created.
# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):
#     # (2500 per box) + (400 * (key size + box size))
#     if key_size_bytes > 64:
#         raise Exception("key size is over 64 bytes")
#     cost = (
#         Int(2500) + Int(400) * 
#         (
#             Int(key_size_bytes) +
#             Int(box_size_bytes)
#         )
#     )
#     return cost

def get_abi_method(method_name,contract:str):
    method_dict = {
        "main": main_contract_abi["methods"],
        "voting": voting_contract_abi["methods"]
    }
    method_list = method_dict[contract]
    for method in method_list:
        if method["name"] == method_name:
            return method
    return None

def get_method_signature(method_name, contract:str):
    method = get_abi_method(method_name,contract)
    if method is None:
        raise RuntimeError
    signature = method_name + "("
    num_args = len(method["args"])
    for index, arg in enumerate(method["args"]):
        signature += arg["type"] 
        if index < num_args - 1:
            signature += ","
        else:
            signature += f'){method["returns"]["type"]}'
            return signature

@ABIReturnSubroutine
def create_source_tuple(
    source_id: Expr, #Int
    source_arg_list: Expr, #Bytes
    max_age: Expr,
    *,
    output: SourceSpec
) -> Expr: #Int
    return Seq([
        (source_id_param := abi.Uint32()).set(source_id),
        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),
        (max_age_param := abi.Uint64()).set(max_age),
        output.set(
            source_id_param,
            source_arg_list_param,
            max_age_param
        ),
    ])

"""
KEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE 
THE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)

SourceSpec: SourceSpec that is already encoded
aggregation: pyteal.Int
user_data: pyteal.Bytes
method_signature: pyteal.Bytes
app_id: pyteal.Int
goracle_main_app_id: pyteal.Int
request_types: pyteal.Int
key: pyteal.Bytes
"""
@Subroutine(TealType.none)
def make_request(
    source_specs: abi.DynamicArray[SourceSpec],
    aggregation: Expr, #Int
    user_data: Expr, #Bytes
    app_id: Expr, #Int
    method_signature: Expr, #Bytes
    goracle_main_app_id: Expr,  #Int
    request_type: Expr,
    key: Expr,
    app_refs: Expr, #static array of uint64
    asset_refs: Expr, #static array of uint64
    account_refs: Expr, #static array of byte[32]
    box_refs: Expr # dynamic array of  (byte[],uint64)
): # Int

    request_tuple = abi.make(RequestSpec)
    destination_tuple = abi.make(DestinationSpec)

    return Seq([
        (user_data_param := abi.DynamicBytes()).set(user_data),
        (agg_param := abi.Uint32()).set(aggregation),
        (app_id_param := abi.Uint64()).set(app_id),
        (request_type_param := abi.Uint64()).set(request_type),
        (method_sig_param := abi.DynamicBytes()).set(method_signature),
        (key_abi := abi.DynamicBytes()).set(key),

        request_tuple.set(
            source_specs,
            agg_param,
            user_data_param
        ),

        destination_tuple.set(
            app_id_param,
            method_sig_param
        ),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("request","main"),
            args=[
                request_tuple.encode(),
                destination_tuple.encode(),
                request_type_param.encode(),
                key_abi.encode(),
                app_refs,
                asset_refs,
                account_refs,
                box_refs
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
KEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE 
THE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)

SourceSpec: SourceSpec that is already encoded
aggregation: pyteal.Int
user_data: pyteal.Bytes
method_signature: pyteal.Bytes
app_id: pyteal.Int
goracle_main_app_id: pyteal.Int
request_types: pyteal.Int
key: pyteal.Bytes
"""
@Subroutine(TealType.none)
def make_request_constructed(
    request_args_encoded: Expr,
    destination_encoded: Expr,
    request_type_encoded: Expr,
    goracle_main_app_id: Expr,
    key: Expr,
    app_refs: Expr,
    asset_refs: Expr,
    account_refs: Expr,
    box_refs: Expr
):
    return Seq([
        (key_abi := abi.DynamicBytes()).set(key),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("request","main"),
            args=[
                request_args_encoded,
                destination_encoded,
                request_type_encoded,
                key_abi.encode(),
                app_refs,
                asset_refs,
                account_refs,
                box_refs
            ]
        ),
        InnerTxnBuilder.Submit(),
    ])

@Subroutine(TealType.none)
def opt_in(goracle_main_app_id):
    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields({
            TxnField.type_enum: TxnType.ApplicationCall,
            TxnField.application_id: goracle_main_app_id,
            TxnField.on_completion: OnComplete.OptIn,
            # TxnField.fee: Int(0)
        }),
        InnerTxnBuilder.Submit(),
    ])

@Subroutine(TealType.none)
def opt_in_asset(asset_id):
    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields({
            TxnField.type_enum: TxnType.AssetTransfer,
            TxnField.xfer_asset: asset_id,
            TxnField.asset_receiver: Global.current_application_address(),
            TxnField.asset_amount: Int(0),
            # TxnField.fee: Int(0)
        }),
        InnerTxnBuilder.Submit()
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def deposit_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_deposit, account_to_deposit_to):
    asset_transfer = \
    {
        TxnField.type_enum: TxnType.AssetTransfer,
        TxnField.asset_amount: amount_to_deposit,
        TxnField.xfer_asset: gora_token_id,
        TxnField.asset_receiver: goracle_main_app_address,
        TxnField.fee: Int(0)
    }

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("deposit_token","main"),
            args=[
                asset_transfer,
                gora_token_id,
                account_to_deposit_to
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def deposit_algo(goracle_main_app_address, goracle_main_app_id, amount_to_deposit, account_to_deposit_to):
    algo_transfer = \
    {
        TxnField.type_enum: TxnType.Payment,
        TxnField.amount: amount_to_deposit,
        TxnField.receiver: goracle_main_app_address,
        TxnField.fee: Int(0)
    }

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("deposit_algo","main"),
            args=[
                algo_transfer,
                account_to_deposit_to
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
new_key: pyteal.Bytes
"""
@Subroutine(TealType.none)
def register_key(goracle_main_app_id, new_key):

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("register_participation_account","main"),
            args=[
                new_key,
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def withdraw_token(goracle_main_app_id, gora_token_id, amount_to_withdraw):
    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("withdraw_token","main"),
            args=[
                amount_to_withdraw,
                gora_token_id,
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def withdraw_algo(goracle_main_app_id, amount_to_withdraw):

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("withdraw_algo","main"),
            args=[
                amount_to_withdraw
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

'''
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_stake: pyteal.Int
'''
@Subroutine(TealType.none)
def stake_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_stake):
    asset_transfer = \
    {
        TxnField.type_enum: TxnType.AssetTransfer,
        TxnField.asset_amount: amount_to_stake,
        TxnField.xfer_asset: gora_token_id,
        TxnField.asset_receiver: goracle_main_app_address,
        TxnField.fee: Global.min_txn_fee()
    }

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature('stake', 'main'),
            args=[
                asset_transfer,
            ],
            extra_fields={
                TxnField.fee: Global.min_txn_fee(),
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

'''
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_stake: pyteal.Int
'''
@Subroutine(TealType.none)
def unstake_token(goracle_main_app_id, gora_token_id, amount_to_unstake):

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature('unstake', 'main'),
            args=[
                amount_to_unstake,
                gora_token_id
            ],
            extra_fields={
                TxnField.fee : Int(2)*Global.min_txn_fee(),
            }
        ),
        InnerTxnBuilder.Submit(),
    ])


"""
Assert with a number to indentify it in API error message. The message will be:
"shr arg too big, (%d)" where in "%d" 6 lowest decinals are the line number and
any above that are the error code. Error types are defined "error_codes.json"
"""
def SmartAssert(cond, err_type = 0):
    if type(err_type) == str:
        err_type = smart_assert_errors.index(err_type) # map mnemonic to code
    err_line = sys._getframe().f_back.f_lineno # calling line number
    return If(Not(cond)).Then(
        InlineAssembly("int 0\nint {}\nshr\n".format(err_type * 1000000 + err_line))
    )

# File: https://github.com/runvnc/genpyteal/blob/f4db17ad54c0746f25d28d2ebf5ee2ebe21be961/tstclass5.pyteal.py
from pyteal import *

globals().update(TealType.__members__)

def verbatim(x):
  return x

class Senior:
  
  @verbatim
  def __init__(self, name, age):
    self.age = age
    self.name = name
  
  
  def isEligible(self):
    return ( self.age > Int(65) )
  
  
  def evalAndPrint(self):
    a = ScratchVar(TealType.uint64)
    return  Seq(
    	a.store(Int(10)),
    	If( self.isEligible(), 
          Log(Concat(self.name,Concat(Bytes(" is eligible. "),Itob(a.load()))))
        , 
          Log(Concat(self.name,Bytes(" is too young.")))
       ) )
  
  
  
def app():
    mary = Senior(Bytes('Mary'), Int(62))
    tom = Senior(Bytes('Tom'), Int(75))
    return  Seq(
    	mary.evalAndPrint(),
    	tom.evalAndPrint(),
    	Return( Int(1) ) )


if __name__ == "__main__":
    print(compileTeal(app(), mode=Mode.Application, version=7))


# File: https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/lib/iter.py
from pyteal import Expr, For, Int, ScratchVar

__all__ = [
    "Iterate",
]


def Iterate(sub: Expr, n: Int, i: ScratchVar | None = None) -> Expr:
    """Iterate provides a convenience method for calling a method n times

    Args:
        sub: A PyTEAL Expr to call, should not return anything
        n: The number of times to call the expression
        i: (Optional) A ScratchVar to use for iteration, passed if the caller wants to access the iterator

    Returns:
        A Subroutine expression to be passed directly into an Expr tree
    """

    i = i or ScratchVar()
    init = i.store(Int(0))
    cond = i.load() < n
    step = i.store(i.load() + Int(1))
    return For(init, cond, step).Do(sub)


# File: https://github.com/algorand/pyteal-utils/blob/c4976887ddd959d285894cf7d3e0feddef3821ba/pytealutils/strings/string.py
from pyteal import (
    Assert,
    BitLen,
    Btoi,
    Bytes,
    BytesDiv,
    BytesGt,
    BytesMod,
    Concat,
    Extract,
    GetByte,
    If,
    Int,
    Itob,
    Len,
    ScratchVar,
    Seq,
    Subroutine,
    Substring,
    TealType,
)

from pytealutils.math import pow10

# Magic number to convert between ascii chars and integers
_ascii_zero = 48
_ascii_nine = _ascii_zero + 9
ascii_zero = Int(_ascii_zero)
ascii_nine = Int(_ascii_nine)


@Subroutine(TealType.uint64)
def ascii_to_int(arg):
    """ascii_to_int converts the integer representing a character in ascii to the actual integer it represents

    Args:
        arg: uint64 in the range 48-57 that is to be converted to an integer

    Returns:
        uint64 that is the value the ascii character passed in represents

    """
    return Seq(Assert(arg >= ascii_zero), Assert(arg <= ascii_nine), arg - ascii_zero)


@Subroutine(TealType.bytes)
def int_to_ascii(arg):
    """int_to_ascii converts an integer to the ascii byte that represents it"""
    return Extract(Bytes("0123456789"), arg, Int(1))


@Subroutine(TealType.uint64)
def atoi(a):
    """atoi converts a byte string representing a number to the integer value it represents"""
    return If(
        Len(a) > Int(0),
        (ascii_to_int(GetByte(a, Int(0))) * pow10(Len(a) - Int(1)))
        + atoi(Substring(a, Int(1), Len(a))),
        Int(0),
    )


@Subroutine(TealType.bytes)
def itoa(i):
    """itoa converts an integer to the ascii byte string it represents"""
    return If(
        i == Int(0),
        Bytes("0"),
        Concat(
            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes("")),
            int_to_ascii(i % Int(10)),
        ),
    )


@Subroutine(TealType.bytes)
def witoa(i):
    """witoa converts an byte string interpreted as an integer to the ascii byte string it represents"""
    return If(
        BitLen(i) == Int(0),
        Bytes("0"),
        Concat(
            If(
                BytesGt(BytesDiv(i, Bytes("base16", "A0")), Bytes("base16", "A0")),
                witoa(BytesDiv(i, Bytes("base16", "A0"))),
                Bytes(""),
            ),
            int_to_ascii(Btoi(BytesMod(i, Bytes("base16", "A0")))),
        ),
    )


@Subroutine(TealType.bytes)
def head(s):
    """head gets the first byte from a bytestring, returns as bytes"""
    return Extract(s, Int(0), Int(1))


@Subroutine(TealType.bytes)
def tail(s):
    """tail returns the string with the first character removed"""
    return Substring(s, Int(1), Len(s))


@Subroutine(TealType.bytes)
def suffix(s, n):
    """suffix returns the last n bytes of a given byte string"""
    return Substring(s, Len(s) - n, Len(s))


@Subroutine(TealType.bytes)
def prefix(s, n):
    """prefix returns the first n bytes of a given byte string"""
    return Substring(s, Int(0), n)


@Subroutine(TealType.bytes)
def rest(s, n):
    """prefix returns the first n bytes of a given byte string"""
    return Substring(s, n, Len(s))


@Subroutine(TealType.bytes)
def encode_uvarint(val, b):
    """
    Returns the uvarint encoding of an integer

    Useful in the case that the bytecode for a contract is being populated, since
    integers in a contract are uvarint encoded

    This subroutine is recursive, the first call should include
    the integer to be encoded and an empty bytestring

    """
    buff = ScratchVar()
    return Seq(
        buff.store(b),
        Concat(
            buff.load(),
            If(
                val >= Int(128),
                encode_uvarint(
                    val >> Int(7),
                    Extract(Itob((val & Int(255)) | Int(128)), Int(7), Int(1)),
                ),
                Extract(Itob(val & Int(255)), Int(7), Int(1)),
            ),
        ),
    )


# File: https://github.com/ulamlabs/pytealext/blob/203a5f70e204b8fb8d684bf158c9e2cb734f7d41/pytealext/state.py
from pyteal import App, Bytes, Concat, Expr, Int, Itob, MaybeValue, Seq, TealType
from pyteal.types import require_type


class State:
    """
    Wrapper around state vars.
    """

    def __init__(self, name: str | Expr, type_hint: TealType = TealType.anytype):
        """
        Args:
            name: a key in the global state, if it's a string it will be converted to Bytes
            type_hint: a type which is expected to be stored, will be checked with each put()
        """
        self._name: Expr
        self.type_hint = type_hint
        if isinstance(name, str):
            self._name = Bytes(name)
        else:
            self._name = name

    def put(self, value: Expr) -> App:
        """
        Store a value in state schema
        """
        raise NotImplementedError

    def get(self) -> App:
        """
        Get a value from a state schema
        """
        raise NotImplementedError

    def exists(self) -> Expr:
        """
        Check if the key of this state variable is present in current app's schema.
        """
        raise NotImplementedError

    def add_assign(self, value_to_add: Expr) -> App:
        """
        Replace the stored value with stored_value + value_to_add.
        Equivalent to:
            stored_value += value_to_add
        """
        if not isinstance(value_to_add, Expr):
            raise ValueError("value_to_add must be an instance of Expr or Expr subclass")
        return self.put(self.get() + value_to_add)

    def sub_assign(self, value_to_subtract: Expr) -> App:
        """
        Replace the stored value with stored_value - value_to_subtract.
        Equivalent to:
            stored_value -= value_to_subtract
        """
        if not isinstance(value_to_subtract, Expr):
            raise ValueError("value_to_subtract must be an instance of Expr or Expr subclass")
        return self.put(self.get() - value_to_subtract)


class LocalState(State):
    """
    Wrapper for accessing local state
    """

    def put(self, value: Expr) -> App:
        require_type(value, self.type_hint)
        return App.localPut(Int(0), self._name, value)

    def get(self) -> App:
        return App.localGet(Int(0), self._name)

    def exists(self) -> Expr:
        ex = App.localGetEx(Int(0), Int(0), self._name)
        return Seq(ex, ex.hasValue())


class GlobalState(State):
    """
    Wrapper for accessing global state
    """

    def put(self, value: Expr) -> App:
        require_type(value, self.type_hint)
        return App.globalPut(self._name, value)

    def get(self) -> App:
        return App.globalGet(self._name)

    def exists(self) -> Expr:
        ex = App.globalGetEx(Int(0), self._name)
        return Seq(ex, ex.hasValue())


def get_global_state_ex(foreign_id: int, key: str) -> MaybeValue:
    """
    Wrapper for global state getter.
    External state variables need to be evaluated before use.

    https://pyteal.readthedocs.io/en/stable/state.html#external-global
    """
    return App.globalGetEx(Int(foreign_id), Bytes(key))


class StateArray:
    """
    Wrapper for state access which utilizes multiple slots
    """

    def __init__(self, prefix: str | Expr, type_hint: TealType = TealType.anytype):
        """
        Args:
            prefix: a key prefix in the global state, if it's a string it will be converted to Bytes.
            Prefix should be unique to avoid naming conflicts.
        """
        self._prefix = prefix
        self.type_hint = type_hint

    def key_at_index(self, index: int | Expr) -> Expr:
        """
        Get the actual key (bytes) that will be used to access the state information
        """
        if isinstance(index, int):  # pylint: disable=no-else-return
            if isinstance(self._prefix, str):
                # index: int, prefix: str
                return Bytes(self._prefix.encode("utf-8") + index.to_bytes(8, "big"))
            # index: int, prefix: Expr
            return Concat(self._prefix, Bytes(index.to_bytes(8, "big")))
        else:  # isinstance(index, Expr)
            if isinstance(self._prefix, str):
                # index: Expr, prefix: str
                return Concat(Bytes(self._prefix), Itob(index))
            # index: Expr, prefix: Expr (u64)
            return Concat(self._prefix, Itob(index))

    def __getitem__(self, index: int | Expr):
        raise NotImplementedError


class LocalStateArray(StateArray):
    """
    Wrapper for local state access which utilizes multiple slots in local state
    """

    def __getitem__(self, index: int | Expr):
        return LocalState(self.key_at_index(index), self.type_hint)


class LocalStateArray2D(StateArray):
    """
    Wrapper for local state access which utilizes multiple slots in local state organized in 2D array
    """

    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):  # type: ignore
        length, width = indices
        return LocalStateArray(self.key_at_index(length), self.type_hint)[width]


class GlobalStateArray(StateArray):
    """
    Wrapper for global state access which utilizes multiple slots in global state
    """

    def __getitem__(self, index: int | Expr):
        return GlobalState(self.key_at_index(index), self.type_hint)


class GlobalStateArray2D(StateArray):
    """
    Wrapper for global state access which utilizes multiple slots in global state organized in 2D array
    """

    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):  # type: ignore
        length, width = indices
        return GlobalStateArray(self.key_at_index(length), self.type_hint)[width]


# File: https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/examples/printers/cfg.py
# pylint: disable=undefined-variable
# type: ignore[name-defined]
from pyteal import *  # pylint: disable=wildcard-import,unused-wildcard-import

router = Router(
    name="CFGExample",
    bare_calls=BareCallActions(),
)


@router.method(no_op=CallConfig.CREATE)
def create() -> Expr:
    return Return()


@router.method(opt_in=CallConfig.CALL)
def opt_in() -> Expr:
    return Return()


pragma(compiler_version="0.22.0")
application_approval_program, _, _ = router.compile_program(version=7)

if __name__ == "__main__":
    print(application_approval_program)


# File: https://github.com/codomposer/pyteal/blob/b196f5b4c48d0ef579c70e53a21dd02a60694ef9/pyteal/types.py
import re
from enum import Enum
from typing import Any

from .errors import TealTypeError, TealInputError


class TealType(Enum):
    """Teal type enum."""

    """Unsigned 64 bit integer type."""
    uint64 = 0

    """Byte string type."""
    bytes = 1

    """Any type that is not none."""
    anytype = 2

    """Represents no value."""
    none = 3


TealType.__module__ = "pyteal"


def require_type(input: Any, expected: TealType):
    try:
        actual = input.type_of()
    except AttributeError:
        raise TypeError(f"Expected a {expected} object, but got a {type(input)}")

    if actual != expected and (
        expected == TealType.none
        or actual == TealType.none
        or (actual != TealType.anytype and expected != TealType.anytype)
    ):
        raise TealTypeError(actual, expected)


def types_match(type1: TealType, type2: TealType) -> bool:
    if (type1 == TealType.none or type2 == TealType.none) and type1 != type2:
        return False

    if type1 == TealType.anytype or type2 == TealType.anytype:
        return True

    return type1 == type2


def valid_address(address: str):
    """check if address is a valid address with checksum"""
    if type(address) is not str:
        raise TealInputError("An address needs to be a string")

    if len(address) != 58:
        raise TealInputError(
            "Address length is not correct. Should "
            + "be a base 32 string encoded 32 bytes public key + 4 bytes checksum"
        )

    valid_base32(address)


def valid_base32(s: str):
    """check if s is a valid base32 encoding string"""
    pattern = re.compile(
        r"^(?:[A-Z2-7]{8})*(?:([A-Z2-7]{2}([=]{6})?)|([A-Z2-7]{4}([=]{4})?)|([A-Z2-7]{5}([=]{3})?)|([A-Z2-7]{7}([=]{1})?))?"
    )

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid RFC 4648 base 32 string".format(s))


def valid_base64(s: str):
    """check if s is a valid base64 encoding string"""
    pattern = re.compile(
        r"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$"
    )

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid RFC 4648 base 64 string".format(s))


def valid_base16(s: str):
    """check if s is a valid hex encoding string"""
    pattern = re.compile(r"[0-9A-Fa-f]*")

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid RFC 4648 base 16 string".format(s))


def valid_tmpl(s: str):
    """check if s is valid template name"""
    pattern = re.compile(r"TMPL_[A-Z0-9_]+")

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid template variable".format(s))


# File: https://github.com/MarcelloPonzi/TesinaAlgorand-Dev/blob/83f5cfdce3a4f0af4a1a4c125eaa5d8ce4851568/algovenv/Lib/site-packages/pyteal/ast/gload.py
from typing import cast, Union, TYPE_CHECKING

from ..types import TealType, require_type
from ..ir import TealOp, Op, TealBlock
from ..errors import TealInputError, verifyTealVersion
from ..config import MAX_GROUP_SIZE, NUM_SLOTS
from .expr import Expr
from .int import Int
from .leafexpr import LeafExpr

if TYPE_CHECKING:
    from ..compiler import CompileOptions


class ImportScratchValue(LeafExpr):
    """An expression to load a scratch value created by another transaction in the current group"""

    def __init__(self, txnIndex: Union[int, Expr], slotId: int) -> None:
        """Create an expression to load a scratch space slot from a transaction in the current group.

        Requires TEAL version 4 or higher. This operation is only permitted in application mode.

        Args:
            txnIndex: The index of the transaction from which the created ID should be obtained.
                This index may be a Python int, or it may be a PyTeal expression that evaluates at
                runtime. If it's an expression, it must evaluate to a uint64. In all cases, the index
                must be less than the index of the current transaction.
            slotId: The index of the scratch slot that should be loaded. The index must be a Python int
                in the range [0-256).
        """
        super().__init__()
        if type(txnIndex) is int:
            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:
                raise TealInputError(
                    "Invalid transaction index {}, shoud be in [0, {})".format(
                        txnIndex, MAX_GROUP_SIZE
                    )
                )
        else:
            require_type(cast(Expr, txnIndex).type_of(), TealType.uint64)
        if slotId < 0 or slotId >= NUM_SLOTS:
            raise TealInputError(
                "Invalid slot ID {}, shoud be in [0, {})".format(slotId, NUM_SLOTS)
            )

        self.txnIndex = txnIndex
        self.slotId = slotId

    def __str__(self) -> str:
        return "(Gload {} {})".format(self.txnIndex, self.slotId)

    def __teal__(self, options: "CompileOptions"):
        verifyTealVersion(
            Op.gload.min_version,
            options.version,
            "TEAL version too low to use Gload expression",
        )

        if type(self.txnIndex) is int:
            op = TealOp(self, Op.gload, self.txnIndex, self.slotId)
            return TealBlock.FromOp(options, op)

        op = TealOp(self, Op.gloads, self.slotId)
        return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))

    def type_of(self):
        return TealType.anytype


ImportScratchValue.__module__ = "pyteal"


# File: https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py
#Choice Coin Governance Rewards Code.
#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%
from algosdk import account, encoding, mnemonic,algod
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn
from algosdk.future.transaction import AssetFreezeTxn
from algosdk.v2client import algod
from algorand_demo import choice_trade
import json
import urllib3
choice_id  = 42771692

voter_1_address = 
voter_1_mnemonic = 
voter_1_key = mnemonic.to_private_key(voter_1_mnemonic)


def choice_trade(sender, key, receiver, amount, index,comment):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)
    #Defines an inital transaction for choice Coin
    signature = transaction.sign(key)
    #Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    return True, final



def fetch_addresses():
	http = urllib3.PoolManager()
	main = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')
	json_list = json.loads(main.data.decode('utf-8'))
	with open('data.json', 'w', encoding='utf-8') as f:
		json.dump(json_list, f, ensure_ascii=False, indent=4)
	with open('data.json') as json_file:
		data = json.load(json_file)
		transaction_data = data['transactions']

	# now we will open a file for writing
		data_file = open('file.csv', 'w')

	# create the csv writer object
		csv_writer = csv.writer(data_file)

	# Counter variable used for writing
	# headers to the CSV file
		count = 0

		for transaction in transaction_data:
		    if count == 0:

		        # Writing headers of CSV file
		        header = transaction.keys()
		        csv_writer.writerow(header)
		        count += 1

		    # Writing data of CSV file
		    csv_writer.writerow(transaction.values())

		data_file.close()

def give_rewards():
	with open('data.json', 'r') as json_file:
	    # pass the file object to reader() to get the reader object
					data = json.load(json_file)
					transaction_data = data['transactions']
					for transaction in transaction_data:
						amount = transaction["asset-transfer-transaction"]["amount"]
						amount = int(amount)
						amount = amount + amount * 0.12 #Rewards rate hardcoded
						address = transaction['sender']
						id = transaction['id']
						choice_trade(voter_1_address,voter_1_key,address,amount,choice_id,"Rewards!" + id)
fetch_addresses()
give_rewards()


# File: https://github.com/algorand/py-algorand-sdk/blob/a2d610c2f7f7b3b0c19945d0c44ccc88d7bb1888/examples/atc.py
import base64
from algosdk import transaction, abi
from utils import get_accounts, get_algod_client, deploy_calculator_app

from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AccountTransactionSigner,
    TransactionWithSigner,
)


# example: ATC_CREATE
atc = AtomicTransactionComposer()
# example: ATC_CREATE

accts = get_accounts()
acct = accts.pop()

algod_client = get_algod_client()

# example: ATC_ADD_TRANSACTION
addr, sk = acct.address, acct.private_key

# Create signer object
signer = AccountTransactionSigner(sk)

# Get suggested params from the client
sp = algod_client.suggested_params()

# Create a transaction
ptxn = transaction.PaymentTxn(addr, sp, addr, 10000)

# Construct TransactionWithSigner
tws = TransactionWithSigner(ptxn, signer)

# Pass TransactionWithSigner to ATC
atc.add_transaction(tws)
# example: ATC_ADD_TRANSACTION


app_id = deploy_calculator_app(algod_client, acct)

# example: ATC_CONTRACT_INIT
with open("calculator/contract.json") as f:
    js = f.read()
contract = abi.Contract.from_json(js)
# example: ATC_CONTRACT_INIT

# example: ATC_ADD_METHOD_CALL

# Simple call to the `add` method, method_args can be any type but _must_
# match those in the method signature of the contract
atc.add_method_call(
    app_id,
    contract.get_method_by_name("add"),
    addr,
    sp,
    signer,
    method_args=[1, 1],
)
# example: ATC_ADD_METHOD_CALL


# example: ATC_RESULTS
# Other options:
# txngroup = atc.build_group()
# txids = atc.submit(client)
result = atc.execute(algod_client, 4)
for res in result.abi_results:
    print(res.return_value)
# example: ATC_RESULTS


my_method = abi.Method(
    name="box_ref_demo", args=[], returns=abi.Returns("void")
)
# example: ATC_BOX_REF
atc = AtomicTransactionComposer()
atc.add_method_call(
    app_id,
    my_method,
    addr,
    sp,
    signer,
    boxes=[[app_id, b"key"]],
)
# example: ATC_BOX_REF


# File: https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/tinyman/compat.py
# flake8: noqa

try:
    from algosdk.transaction import (
        ApplicationClearStateTxn,
        ApplicationOptInTxn,
        ApplicationNoOpTxn,
        AssetTransferTxn,
        AssetCreateTxn,
        AssetOptInTxn,
        assign_group_id,
        LogicSigAccount,
        LogicSigTransaction,
        PaymentTxn,
        SuggestedParams,
        Transaction,
        OnComplete,
        wait_for_confirmation,
    )
except ImportError:
    from algosdk.future.transaction import (
        ApplicationClearStateTxn,
        ApplicationOptInTxn,
        ApplicationNoOpTxn,
        AssetTransferTxn,
        AssetCreateTxn,
        AssetOptInTxn,
        assign_group_id,
        LogicSigAccount,
        LogicSigTransaction,
        PaymentTxn,
        SuggestedParams,
        Transaction,
        OnComplete,
        wait_for_confirmation,
    )


# File: https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/consts.py
from math import ceil
from typing import Final

from algosdk.constants import APP_PAGE_MAX_SIZE
from pyteal import Int

#: number of microalgos in 1 Algo
algo: Final[int] = int(1e6)
#: number of microalgos in 1 MilliAlgo
milli_algo: Final[int] = int(1e3)

#: Used for runtime algo calculations `Txn.amount()==Algo`
Algo: Final[Int] = Int(algo)
#: Used for runtime algo calculations `Txn.fee()==MilliAlgo`
MilliAlgo: Final[Int] = Int(milli_algo)


#: Used for shorthand for Int(10*algo) like Algos(10)
def Algos(v: int | float) -> Int:  # noqa: N802
    return Int(int(v * algo))


#: Used for shorthand for Int(10*milli_algo) like MilliAlgos(10)
def MilliAlgos(v: int | float) -> Int:  # noqa: N802
    return Int(int(v * milli_algo))


#: Max number of inner transactions that may be called
MAX_INNERS = 255
#: Single app call opcode budget
APP_CALL_BUDGET = 700
#: Max possible opcode budget
MAX_OPS = MAX_INNERS * APP_CALL_BUDGET

#: Single app call budget
AppCallBudget = Int(APP_CALL_BUDGET)
#: Max app call budget possible
MaxOps = Int(MAX_OPS)


#: TRUE used as an alias for 1
TRUE: Final[Int] = Int(1)
#: FALSE used as an alias for 0
FALSE: Final[Int] = Int(0)

#: The max number of local state values that may be declared
MAX_LOCAL_STATE = 16
#: The max number of global state values that may be declared
MAX_GLOBAL_STATE = 64

#: The maximum number of args that may be included in an lsig
LSIG_MAX_ARGS = 255

#: The prefix used when hashing bytecode to produce a unique hash
PROGRAM_DOMAIN_SEPARATOR = "Program"

#: The min balance increase per box created
BOX_FLAT_MIN_BALANCE = 2500

#: The min balance increase per byte of boxes (key included)
BOX_BYTE_MIN_BALANCE = 400

#: The min balance increase for each asset opted into
ASSET_MIN_BALANCE = 100000


def num_extra_program_pages(approval: bytes, clear: bytes) -> int:
    return ceil(((len(approval) + len(clear)) - APP_PAGE_MAX_SIZE) / APP_PAGE_MAX_SIZE)


# File: https://github.com/algorand-devrel/demo-abi/blob/3e6985f89c58b5531adb2ac2436ace7d722edb36/py/abi.py
from algosdk.v2client.algod import AlgodClient
from algosdk.atomic_transaction_composer import (
    AccountTransactionSigner,
    AtomicTransactionComposer,
    TransactionWithSigner,
)
from algosdk.transaction import PaymentTxn, AssetCreateTxn
from algosdk.abi import Contract
from algosdk.logic import get_application_address

from sandbox import get_accounts

client = AlgodClient("a" * 64, "http://localhost:4001")


addr, sk = get_accounts()[0]

with open("../contract.json") as f:
    js = f.read()

with open("../.app_id") as f:
    app_id = int(f.read())

app_addr = get_application_address(app_id)

c = Contract.from_json(js)

signer = AccountTransactionSigner(sk)
sp = client.suggested_params()


box_comp = AtomicTransactionComposer()
box_name = b"cool_box"
box_comp.add_transaction(
    TransactionWithSigner(PaymentTxn(addr, sp, app_addr, 1_000_000_000), signer=signer),
)
box_comp.add_method_call(
    app_id,
    c.get_method_by_name("box_write"),
    addr,
    sp,
    signer,
    method_args=[box_name, (123, 456)],
    boxes=[(0, box_name)],
)
box_comp.add_method_call(
    app_id,
    c.get_method_by_name("box_read"),
    addr,
    sp,
    signer,
    method_args=[box_name],
    # technically not needed since we already ref it in
    # the previous txn in the same group
    boxes=[(0, box_name)],
)
box_result = box_comp.execute(client, 4)
print(f"box_read returned: {box_result.abi_results[-1].return_value}")


comp = AtomicTransactionComposer()
comp.add_method_call(
    app_id, c.get_method_by_name("add"), addr, sp, signer, method_args=[1, 1]
)
comp.add_method_call(
    app_id, c.get_method_by_name("sub"), addr, sp, signer, method_args=[3, 1]
)
comp.add_method_call(
    app_id, c.get_method_by_name("div"), addr, sp, signer, method_args=[4, 2]
)
comp.add_method_call(
    app_id, c.get_method_by_name("mul"), addr, sp, signer, method_args=[3, 2]
)
comp.add_method_call(
    app_id, c.get_method_by_name("qrem"), addr, sp, signer, method_args=[27, 5]
)

comp.add_method_call(
    app_id,
    c.get_method_by_name("reverse"),
    addr,
    sp,
    signer,
    method_args=["desrever yllufsseccus"],
)

ptxn = TransactionWithSigner(PaymentTxn(addr, sp, addr, 10000), signer)
comp.add_method_call(
    app_id,
    c.get_method_by_name("txntest"),
    addr,
    sp,
    signer,
    method_args=[10000, ptxn, 1000],
)

comp.add_method_call(
    app_id, c.get_method_by_name("manyargs"), addr, sp, signer, method_args=[2] * 20
)


comp.add_method_call(
    app_id,
    c.get_method_by_name("min_bal"),
    addr,
    sp,
    signer,
    method_args=["SKCBRBKPIGY5LI2OU63IE5LMNQ5BVVOKPHWTPPWFQOI4NG4TI35SLAA3JQ"],
)

comp.add_method_call(
    app_id,
    c.get_method_by_name("concat_strings"),
    addr,
    sp,
    signer,
    method_args=[["this", "string", "is", "joined"]],
)

# Useable with abi_types.py contract
# comp.add_method_call(
#     app_id,
#     c.get_method_by_name("concat_dynamic_arrays"),
#     addr,
#     sp,
#     signer,
#     method_args=[[1, 2, 3], [4, 5, 6]],
# )
#
# comp.add_method_call(
#     app_id,
#     c.get_method_by_name("concat_static_arrays"),
#     addr,
#     sp,
#     signer,
#     method_args=[[1, 2, 3], [4, 5, 6]],
# )
#
#
# comp.add_method_call(
#     app_id,
#     c.get_method_by_name("concat_dynamic_string_arrays"),
#     addr,
#     sp,
#     signer,
#     method_args=[["a", "b", "c"], ["d", "e", "f"]],
# )


# drr = comp.dryrun(client)
# for txn in drr.trace.txns:
#    if txn.app_call_rejected():
#        print(txn.app_trace())

resp = comp.execute(client, 2)
for result in resp.abi_results:
    # print(result.decode_error)
    # print(result.raw_value.hex())
    print(f"{result.method.name} => {result.return_value}")


# File: https://github.com/Hipo/algojig/blob/71a1bf83204fb70198850024306d91bd041da7d4/algojig/check.py
from algojig import get_suggested_params, generate_accounts, dump
from algojig.ledger import JigLedger
from algosdk.transaction import PaymentTxn

secrets, addresses = generate_accounts(2)

sp = get_suggested_params()

ledger = JigLedger()
ledger.set_account_balance(addresses[0], 1_000_000)

transactions = [
    PaymentTxn(
        sender=addresses[0],
        sp=sp,
        receiver=addresses[1],
        amt=200_000,
    ).sign(secrets[0]),
]
block = ledger.eval_transactions(transactions)
print("Looks like it works!")


# File: https://github.com/Vilijan/TicTacToe_Algorand/blob/61bfd59696f7fec4f2127cb746d7c5470fff95d8/app.py
import streamlit as st
from src.blockchain_utils.credentials import get_client, get_account_credentials, get_indexer
from src.services.game_engine_service import GameEngineService
import algosdk

client = get_client()
indexer = get_indexer()

acc_pk, acc_address = algosdk.account.generate_account()
player_x_pk, player_x_address = algosdk.account.generate_account()
player_o_pk, player_o_address = algosdk.account.generate_account()

if "submitted_transactions" not in st.session_state:
    st.session_state.submitted_transactions = []

if "player_turn" not in st.session_state:
    st.session_state.player_turn = "X"

if "game_state" not in st.session_state:
    st.session_state.game_state = ['-'] * 9

if "x_state" not in st.session_state:
    st.session_state.x_state = 0

if "o_state" not in st.session_state:
    st.session_state.o_state = 0

if "game_state" not in st.session_state:
    st.session_state.game_state = ['-'] * 9

if "game_engine" not in st.session_state:
    st.session_state.game_engine = GameEngineService(app_creator_pk=acc_pk,
                                                     app_creator_address=acc_address,
                                                     player_x_pk=player_x_pk,
                                                     player_x_address=player_x_address,
                                                     player_o_pk=player_o_pk,
                                                     player_o_address=player_o_address)

if "game_status" not in st.session_state:
    st.session_state.game_status = 0

if "is_app_deployed" not in st.session_state:
    st.session_state.is_app_deployed = False

if "is_game_started" not in st.session_state:
    st.session_state.is_game_started = False

st.title("Addresses")
st.write(f"app_creator: {acc_address}")
st.write(f"player_x: {player_x_address}")
st.write(f"player_o: {player_o_address}")

st.write("You need to fund those accounts on the following link: https://bank.testnet.algorand.network/")


# Step 1: App deployment.

def deploy_application():
    if st.session_state.is_app_deployed:
        return

    app_deployment_txn_log = st.session_state.game_engine.deploy_application(client)
    st.session_state.submitted_transactions.append(app_deployment_txn_log)
    st.session_state.is_app_deployed = True


st.title("Step 1: App deployment")
st.write("In this step we deploy the Tic-Tac-Toe Stateful Smart Contract to the Algorand TestNetwork")

if st.session_state.is_app_deployed:
    st.success(f"The app is deployed on TestNet with the following app_id: {st.session_state.game_engine.app_id}")
else:
    st.error(f"The app is not deployed! Press the button below to deploy the application.")
    _ = st.button("Deploy App", on_click=deploy_application)

# Step 2: Start of the game
st.title("Step 2: Mark the start of the game")
st.write("In this step we make atomic transfer of 3 transactions that marks the start of the game.")


def start_game():
    if st.session_state.is_game_started:
        return

    start_game_txn_log = st.session_state.game_engine.start_game(client)
    st.session_state.submitted_transactions.append(start_game_txn_log)
    st.session_state.is_game_started = True


if st.session_state.is_game_started:
    st.success("The game has started")
else:
    st.error(f"The game has not started! Press the button below to start the game.")
    _ = st.button("Start game", on_click=start_game)

st.title("Step 3: Execute game actions")

if st.session_state.player_turn == "X":
    st.warning(f"Current player: {st.session_state.player_turn}")
else:
    st.success(f"Current player: {st.session_state.player_turn}")

mark_position_idx = st.number_input(f'Action position',
                                    value=0,
                                    step=1)


def to_binary(integer):
    return format(integer, 'b').zfill(9)


def get_game_status(indexer, app_id):
    response = indexer.search_applications(application_id=app_id)
    game_status_key = "R2FtZVN0YXRl"

    for global_variable in response['applications'][0]['params']['global-state']:
        if global_variable['key'] == game_status_key:
            return global_variable['value']['uint']


def play_action(action_idx):
    try:
        play_action_txn = st.session_state.game_engine.play_action(client,
                                                                   player_id=st.session_state.player_turn,
                                                                   action_position=action_idx)
    except:
        st.session_state.submitted_transactions.append(f"Rejected transaction. Tried to put "
                                                       f"{st.session_state.player_turn} at {action_idx}")
        return

    st.session_state.game_state[action_idx] = st.session_state.player_turn
    st.session_state.submitted_transactions.append(play_action_txn)
    if st.session_state.player_turn == "X":
        st.session_state.x_state = st.session_state.x_state | (1 << action_idx)
        st.session_state.player_turn = "O"
    else:
        st.session_state.o_state = st.session_state.o_state | (1 << action_idx)
        st.session_state.player_turn = "X"


_ = st.button('Play Action', on_click=play_action,
              args=(mark_position_idx,))

st.title("Game state")

for i in range(3):
    cols = st.columns(3)
    for j in range(3):
        idx = i * 3 + j
        if st.session_state.game_state[idx] == '-':
            cols[j].info('-')
        elif st.session_state.game_state[idx] == 'X':
            cols[j].warning('X')
        else:
            cols[j].success('O')

st.subheader("Binary states")
st.write(f"x_state: {st.session_state.x_state} == {to_binary(st.session_state.x_state)}")
st.write(f"o_state: {st.session_state.o_state} == {to_binary(st.session_state.o_state)}")

# Step 4:

st.title("Step 4: Withdraw funds")


def check_game_status():
    if st.session_state.is_game_started:
        game_status = get_game_status(indexer, app_id=st.session_state.game_engine.app_id)
        st.session_state.game_status = game_status


st.write("Press the button below to use the indexer to query the global state of the application.")
_ = st.button("Check the game status", on_click=check_game_status)


def withdraw_funds(winner):
    if winner is None:
        try:
            fund_escrow_txn = st.session_state.game_engine.fund_escrow(client=client)
            st.session_state.submitted_transactions.append(fund_escrow_txn)

            txn_description = st.session_state.game_engine.tie_money_refund(client)
            st.session_state.submitted_transactions.append(txn_description)
        except:
            st.session_state.submitted_transactions.append("Rejected transaction. Unsuccessful withdrawal.")
    else:
        try:
            fund_escrow_txn = st.session_state.game_engine.fund_escrow(client=client)
            st.session_state.submitted_transactions.append(fund_escrow_txn)

            txn_description = st.session_state.game_engine.win_money_refund(client, player_id=winner)
            st.session_state.submitted_transactions.append(txn_description)
        except:
            st.session_state.submitted_transactions.append("Rejected transaction. Unsuccessful withdrawal.")


if st.session_state.game_status == 0:
    st.write("The game is still active.")
else:
    winner = None
    if st.session_state.game_status == 1:
        st.balloons()
        st.success("Player X won the game.")
        winner = "X"
    elif st.session_state.game_status == 2:
        st.balloons()
        st.success("Player O won the game.")
        winner = "O"
    elif st.session_state.game_status == 3:
        st.warning("The game has ended with a tie.")

    _ = st.button('Withdraw funds', on_click=withdraw_funds,
                  args=(winner,))

st.title("Submitted transactions")

for txn in st.session_state.submitted_transactions:
    if "Rejected transaction." in txn:
        st.error(txn)
    else:
        st.success(txn)


# File: https://github.com/hyplabs/AlgoSwap/blob/4e3f9a977461cd34c246847a0f0d5dbbae5e5ee7/deploy.py
import os
import base64
import time

from algosdk.v2client import algod, indexer
from algosdk.future import transaction
from algosdk import encoding, account, mnemonic, error
from pyteal import compileTeal, Mode

from contracts import manager

ALGOD_ENDPOINT = os.environ['ALGOD_ENDPOINT']
ALGOD_TOKEN = os.environ['ALGOD_TOKEN']
INDEXER_ENDPOINT = os.environ['INDEXER_ENDPOINT']
INDEXER_TOKEN = os.environ['INDEXER_TOKEN']

DEVELOPER_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(
    os.environ['DEVELOPER_ACCOUNT_PRIVATE_KEY'])
DEVELOPER_ACCOUNT_ADDRESS = account.address_from_private_key(
    DEVELOPER_ACCOUNT_PRIVATE_KEY)
ZERO_ADDRESS = encoding.encode_address(bytes(32))

TEST_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(
    os.environ['TEST_ACCOUNT_PRIVATE_KEY'])
TEST_ACCOUNT_ADDRESS = account.address_from_private_key(
    TEST_ACCOUNT_PRIVATE_KEY)

TOKEN1_UNIT_NAME = "TOKEN1"
TOKEN1_ASSET_NAME = "AlgoSwap Token 1 Test Asset"
TOKEN1_AMOUNT = 2**64 - 1
TOKEN1_DECIMALS = 6
TOKEN2_UNIT_NAME = "TOKEN2"
TOKEN2_ASSET_NAME = "AlgoSwap Token 2 Test Asset"
TOKEN2_AMOUNT = 2**64 - 1
TOKEN2_DECIMALS = 6
LIQUIDITY_TOKEN_UNIT_NAME = "T1T2"
LIQUIDITY_TOKEN_ASSET_NAME = "AlgoSwap Token1/Token2"
LIQUIDITY_TOKEN_AMOUNT = 2**64 - 1
LIQUIDITY_TOKEN_DECIMALS = 6


algod_client = algod.AlgodClient(ALGOD_TOKEN, ALGOD_ENDPOINT, headers={
    "x-api-key": ALGOD_TOKEN})
indexer_client = indexer.IndexerClient(INDEXER_TOKEN, INDEXER_ENDPOINT, headers={
    "x-api-key": INDEXER_TOKEN})


def wait_for_transaction(transaction_id):
    suggested_params = algod_client.suggested_params()
    algod_client.status_after_block(suggested_params.first + 4)
    result = indexer_client.search_transactions(txid=transaction_id)
    assert len(result['transactions']) == 1, result
    return result['transactions'][0]


def compile_exchange_validator():
    from contracts import validator

    print("Compiling exchange validator application...")

    validator_approve_teal_code = compileTeal(
        validator.approval_program(), Mode.Application)
    compile_response = algod_client.compile(validator_approve_teal_code)
    validator_approve_code = base64.b64decode(compile_response['result'])
    VALIDATOR_APPROVE_BYTECODE_LEN = len(validator_approve_code)
    VALIDATOR_APPROVE_ADDRESS = compile_response['hash']

    validator_clear_teal_code = compileTeal(
        validator.clear_program(), Mode.Application)
    compile_response = algod_client.compile(validator_clear_teal_code)
    validator_clear_code = base64.b64decode(compile_response['result'])
    VALIDATOR_CLEAR_BYTECODE_LEN = len(validator_clear_code)
    VALIDATOR_CLEAR_ADDRESS = compile_response['hash']

    print(
        f"Exchange Validator | Approval: {VALIDATOR_APPROVE_BYTECODE_LEN}/1024 bytes ({VALIDATOR_APPROVE_ADDRESS}) | Clear: {VALIDATOR_CLEAR_BYTECODE_LEN}/1024 bytes ({VALIDATOR_CLEAR_ADDRESS})")

    with open('./build/validator_approval.teal', 'w') as f:
        f.write(validator_approve_teal_code)
    with open('./build/validator_clear.teal', 'w') as f:
        f.write(validator_clear_teal_code)

    print()

    return validator_approve_code, validator_clear_code


def compile_exchange_manager():
    print("Compiling exchange manager application...")

    manager_approve_teal_code = compileTeal(
        manager.approval_program(), Mode.Application)
    compile_response = algod_client.compile(manager_approve_teal_code)
    manager_approve_code = base64.b64decode(compile_response['result'])
    MANAGER_APPROVE_BYTECODE_LEN = len(manager_approve_code)
    MANAGER_APPROVE_ADDRESS = compile_response['hash']

    manager_clear_teal_code = compileTeal(
        manager.clear_program(), Mode.Application)
    compile_response = algod_client.compile(manager_clear_teal_code)
    manager_clear_code = base64.b64decode(compile_response['result'])
    MANAGER_CLEAR_BYTECODE_LEN = len(manager_clear_code)
    MANAGER_CLEAR_ADDRESS = compile_response['hash']

    print(
        f"Exchange Manager | Approval: {MANAGER_APPROVE_BYTECODE_LEN}/1024 bytes ({MANAGER_APPROVE_ADDRESS}) | Clear: {MANAGER_CLEAR_BYTECODE_LEN}/1024 bytes ({MANAGER_CLEAR_ADDRESS})")

    with open('./build/manager_approval.teal', 'w') as f:
        f.write(manager_approve_teal_code)
    with open('./build/manager_clear.teal', 'w') as f:
        f.write(manager_clear_teal_code)

    print()

    return manager_approve_code, manager_clear_code


def compile_exchange_escrow():
    from contracts import escrow

    print("Compiling exchange escrow logicsig...")
    escrow_logicsig_teal_code = compileTeal(
        escrow.logicsig(), Mode.Application)
    compile_response = algod_client.compile(escrow_logicsig_teal_code)
    escrow_logicsig = compile_response['result']
    escrow_logicsig_bytes = base64.b64decode(escrow_logicsig)
    ESCROW_BYTECODE_LEN = len(escrow_logicsig_bytes)
    ESCROW_ADDRESS = compile_response['hash']
    print(
        f"Exchange Escrow | {ESCROW_BYTECODE_LEN}/1000 bytes ({ESCROW_ADDRESS})")

    with open('./build/escrow.teal', 'w') as f:
        f.write(escrow_logicsig_teal_code)

    with open("./build/escrow_logicsig", "w") as f:
        f.write(escrow_logicsig)

    print(f"Escrow logicsig compiled with address {ESCROW_ADDRESS}")

    print()

    return escrow_logicsig


def deploy_exchange_validator(validator_approve_code, validator_clear_code):
    print("Deploying exchange validator application...")

    create_validator_transaction = transaction.ApplicationCreateTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        on_complete=transaction.OnComplete.NoOpOC,
        approval_program=validator_approve_code,
        clear_program=validator_clear_code,
        global_schema=transaction.StateSchema(num_uints=0, num_byte_slices=1),
        local_schema=None,
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    tx_id = algod_client.send_transaction(create_validator_transaction)
    validator_app_id = wait_for_transaction(tx_id)['created-application-index']
    print(
        f"Exchange Validator deployed with Application ID: {validator_app_id} (Txn ID: https://testnet.algoexplorer.io/tx/{tx_id})"
    )

    print()

    return validator_app_id


def deploy_exchange_manager(manager_approve_code, manager_clear_code):
    print("Deploying exchange manager application...")

    create_manager_transaction = transaction.ApplicationCreateTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        on_complete=transaction.OnComplete.NoOpOC,
        approval_program=manager_approve_code,
        clear_program=manager_clear_code,
        global_schema=transaction.StateSchema(num_uints=0, num_byte_slices=1),
        local_schema=transaction.StateSchema(num_uints=10, num_byte_slices=0),
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)
    tx_id = algod_client.send_transaction(create_manager_transaction)
    manager_app_id = wait_for_transaction(tx_id)['created-application-index']
    print(
        f"Exchange Manager deployed with Application ID: {manager_app_id} (Txn ID: https://testnet.algoexplorer.io/tx/{tx_id})"
    )

    print()

    return manager_app_id


def deploy_token1_token2():
    print(
        f"Deploying tokens {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) and {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME})..."
    )

    txn_1 = transaction.AssetConfigTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        total=TOKEN1_AMOUNT,
        default_frozen=False,
        unit_name=TOKEN1_UNIT_NAME,
        asset_name=TOKEN1_ASSET_NAME,
        manager=DEVELOPER_ACCOUNT_ADDRESS,
        reserve=DEVELOPER_ACCOUNT_ADDRESS,
        freeze=DEVELOPER_ACCOUNT_ADDRESS,
        clawback=DEVELOPER_ACCOUNT_ADDRESS,
        url=f"https://algoswap.io/{TOKEN1_UNIT_NAME}",
        decimals=TOKEN1_DECIMALS
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    txn_2 = transaction.AssetConfigTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        total=TOKEN2_AMOUNT,
        default_frozen=False,
        unit_name=TOKEN2_UNIT_NAME,
        asset_name=TOKEN2_ASSET_NAME,
        manager=DEVELOPER_ACCOUNT_ADDRESS,
        reserve=DEVELOPER_ACCOUNT_ADDRESS,
        freeze=DEVELOPER_ACCOUNT_ADDRESS,
        clawback=DEVELOPER_ACCOUNT_ADDRESS,
        url=f"https://algoswap.io/{TOKEN2_UNIT_NAME}",
        decimals=TOKEN2_DECIMALS
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    tx_id_1 = algod_client.send_transaction(txn_1)
    tx_id_2 = algod_client.send_transaction(txn_2)

    token_1_asset_id = wait_for_transaction(tx_id_1)['created-asset-index']
    token_2_asset_id = wait_for_transaction(tx_id_2)['created-asset-index']

    print(
        f"Deployed {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token_1_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_1}"
    )
    print(
        f"Deployed {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token_2_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_2}"
    )

    print()

    return token_1_asset_id, token_2_asset_id


def deploy_liquidity_pair_token():
    print(
        f"Deploying token {LIQUIDITY_TOKEN_ASSET_NAME} ({LIQUIDITY_TOKEN_UNIT_NAME})..."
    )

    txn = transaction.AssetConfigTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        total=LIQUIDITY_TOKEN_AMOUNT,
        default_frozen=False,
        unit_name=LIQUIDITY_TOKEN_UNIT_NAME,
        asset_name=LIQUIDITY_TOKEN_ASSET_NAME,
        manager=DEVELOPER_ACCOUNT_ADDRESS,
        reserve=DEVELOPER_ACCOUNT_ADDRESS,
        freeze=DEVELOPER_ACCOUNT_ADDRESS,
        clawback=DEVELOPER_ACCOUNT_ADDRESS,
        url=f"https://algoswap.io/{LIQUIDITY_TOKEN_UNIT_NAME}",
        decimals=LIQUIDITY_TOKEN_DECIMALS
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    tx_id = algod_client.send_transaction(txn)

    liquidity_token_asset_id = int(
        wait_for_transaction(tx_id)['created-asset-index'])

    print(
        f"Deployed {LIQUIDITY_TOKEN_ASSET_NAME} ({LIQUIDITY_TOKEN_UNIT_NAME}) with Asset ID: {liquidity_token_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}"
    )

    print()

    return liquidity_token_asset_id


def opt_escrow_into_token(escrow_logicsig, token_idx):
    print(
        f"Opting Escrow into Token with Asset ID: {token_idx}..."
    )
    program = base64.b64decode(escrow_logicsig)

    lsig = transaction.LogicSig(program)

    txn = transaction.AssetTransferTxn(
        sender=lsig.address(),
        sp=algod_client.suggested_params(),
        receiver=lsig.address(),
        amt=0,
        index=token_idx,
    )

    lsig_txn = transaction.LogicSigTransaction(txn, lsig)

    tx_id = algod_client.send_transaction(lsig_txn)

    wait_for_transaction(tx_id)

    print(
        f"Opted Escrow into Token with Asset ID: {token_idx} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}"
    )

    print()


def opt_escrow_into_manager(escrow_logicsig, manager_app_id, liquidity_token_asset_id, token1_asset_id, token2_asset_id):
    print("Opting Escrow into Manager contract...")

    program = base64.b64decode(escrow_logicsig)

    lsig = transaction.LogicSig(program)

    args = [
        liquidity_token_asset_id.to_bytes(8, 'big'),
        token1_asset_id.to_bytes(8, 'big'),
        token2_asset_id.to_bytes(8, 'big')
    ]

    txn = transaction.ApplicationOptInTxn(
        sender=lsig.address(),
        sp=algod_client.suggested_params(),
        index=manager_app_id,
        app_args=args
    )

    lsig_txn = transaction.LogicSigTransaction(txn, lsig)

    tx_id = algod_client.send_transaction(lsig_txn)

    wait_for_transaction(tx_id)

    print(
        f"Opted Escrow into Manager contract successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}"
    )

    print()


def opt_user_into_contract(app_id):
    print(
        f"Opting user into contract with App ID: {app_id}..."
    )

    txn = transaction.ApplicationOptInTxn(
        sender=TEST_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        index=app_id
    ).sign(TEST_ACCOUNT_PRIVATE_KEY)

    tx_id = algod_client.send_transaction(txn)

    wait_for_transaction(tx_id)

    print(
        f"Opted user into contract with App ID: {app_id} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}"
    )

    print()


def opt_user_into_token(asset_id):
    print(
        f"Opting user into token with Asset ID: {asset_id}..."
    )

    txn = transaction.AssetTransferTxn(
        sender=TEST_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        receiver=TEST_ACCOUNT_ADDRESS,
        amt=0,
        index=asset_id
    ).sign(TEST_ACCOUNT_PRIVATE_KEY)

    tx_id = algod_client.send_transaction(txn)

    wait_for_transaction(tx_id)

    print(
        f"Opted user into token with Asset ID: {asset_id} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}"
    )

    print()


def transfer_liquidity_token_to_escrow(liquidity_token_asset_id, escrow_logicsig):
    print(
        f"Transferring {LIQUIDITY_TOKEN_AMOUNT} liquidity token with Asset ID: {liquidity_token_asset_id} to Escrow..."
    )

    program = base64.b64decode(escrow_logicsig)

    lsig = transaction.LogicSig(program)

    txn = transaction.AssetTransferTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        receiver=lsig.address(),
        amt=LIQUIDITY_TOKEN_AMOUNT,
        index=liquidity_token_asset_id
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    tx_id = algod_client.send_transaction(txn)

    wait_for_transaction(tx_id)

    print(
        f"Transferred {LIQUIDITY_TOKEN_AMOUNT} liquidity token with Asset ID: {liquidity_token_asset_id} to Escrow successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}"
    )

    print()


def transfer_token1_token2_to_user(token1_asset_id, token2_asset_id):
    print(
        f"Transferring {int(TOKEN1_AMOUNT/2)} {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token1_asset_id} and {int(TOKEN2_AMOUNT/2)} {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token2_asset_id} to User..."
    )

    txn_1 = transaction.AssetTransferTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        receiver=TEST_ACCOUNT_ADDRESS,
        amt=int(TOKEN1_AMOUNT/2),
        index=token1_asset_id
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    txn_2 = transaction.AssetTransferTxn(
        sender=DEVELOPER_ACCOUNT_ADDRESS,
        sp=algod_client.suggested_params(),
        receiver=TEST_ACCOUNT_ADDRESS,
        amt=int(TOKEN2_AMOUNT/2),
        index=token2_asset_id
    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)

    tx_id_1 = algod_client.send_transaction(txn_1)
    tx_id_2 = algod_client.send_transaction(txn_2)

    wait_for_transaction(tx_id_1)
    wait_for_transaction(tx_id_2)

    print(
        f"Transferred {int(TOKEN1_AMOUNT/2)} {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token1_asset_id} to User successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_1}"
    )

    print(
        f"Transferred {int(TOKEN2_AMOUNT/2)} {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token2_asset_id} to User successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_2}"
    )   

    print()

if __name__ == "__main__":
    print("Starting deployment process...")

    manager_approve_code, manager_clear_code = compile_exchange_manager()

    manager_app_id = deploy_exchange_manager(
         manager_approve_code, manager_clear_code)

    input(f"Update Manager Index in Validator = {manager_app_id}")

    validator_approve_code, validator_clear_code = compile_exchange_validator()

    validator_app_id = deploy_exchange_validator(
        validator_approve_code, validator_clear_code)

    token1_asset_id, token2_asset_id = deploy_token1_token2()

    liquidity_token_asset_id = deploy_liquidity_pair_token()

    params = algod_client.suggested_params()

    print("Please update the Escrow contract with the following:")
    input(f"Manager App ID = {manager_app_id}")
    input(f"Validator App ID = {validator_app_id}")
    input(f"Token 1 Asset ID = {token1_asset_id}")
    input(f"Token 2 Asset ID = {token2_asset_id}")
    input(f"Liquidity Token Asset ID = {liquidity_token_asset_id}")
    input(f"Last Valid Round = {params.last + 100}")

    escrow_logicsig = compile_exchange_escrow()

    input("Please fund the Escrow account with $ALGO to continue")

    opt_escrow_into_token(escrow_logicsig, token1_asset_id)
    opt_escrow_into_token(escrow_logicsig, token2_asset_id)
    opt_escrow_into_token(escrow_logicsig, liquidity_token_asset_id)

    opt_escrow_into_manager(escrow_logicsig, manager_app_id,
                            liquidity_token_asset_id, token1_asset_id, token2_asset_id)

    opt_user_into_contract(validator_app_id)
    opt_user_into_contract(manager_app_id)

    opt_user_into_token(token1_asset_id)
    opt_user_into_token(token2_asset_id)
    opt_user_into_token(liquidity_token_asset_id)

    transfer_liquidity_token_to_escrow(liquidity_token_asset_id, escrow_logicsig)
    transfer_token1_token2_to_user(token1_asset_id, token2_asset_id)

    print("Deployment completed successfully!")


# File: https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/sandbox.py
import algosdk

KMD_ADDRESS = "http://localhost:4002"
KMD_TOKEN = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

KMD_WALLET_NAME = "unencrypted-default-wallet"
KMD_WALLET_PASSWORD = ""


def get_accounts():
    kmd = algosdk.kmd.KMDClient(KMD_TOKEN, KMD_ADDRESS)
    wallets = kmd.list_wallets()

    walletID = None
    for wallet in wallets:
        if wallet["name"] == KMD_WALLET_NAME:
            walletID = wallet["id"]
            break

    if walletID is None:
        raise Exception("Wallet not found: {}".format(KMD_WALLET_NAME))

    walletHandle = kmd.init_wallet_handle(walletID, KMD_WALLET_PASSWORD)

    try:
        addresses = kmd.list_keys(walletHandle)
        privateKeys = [kmd.export_key(walletHandle, KMD_WALLET_PASSWORD, addr) for addr in addresses]
        kmdAccounts = [(addresses[i], privateKeys[i]) for i in range(len(privateKeys))]
    finally:
        kmd.release_wallet_handle(walletHandle)

    return kmdAccounts


# File: https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/utils.py
import base64
from collections import namedtuple
from inspect import get_annotations
from typing import Union
from algosdk import constants
from algosdk.future import transaction
from algosdk.v2client import algod
from smart_asa_asc import SmartASAConfig as PyTealSmartASAConfig


def decode_state(state) -> dict[str, Union[int, bytes]]:
    return {
        # We are assuming that global space `key` are printable.
        # If that's not necessarily true, we can change that.
        base64.b64decode(s["key"]).decode(): base64.b64decode(s["value"]["bytes"])
        if s["value"]["type"] == 1
        else int(s["value"]["uint"])
        for s in state
    }


def get_global_state(
    algod_client: algod.AlgodClient, asc_idx: int
) -> dict[str, Union[bytes, int]]:
    global_state = algod_client.application_info(asc_idx)["params"]["global-state"]
    global_state = decode_state(global_state)
    return global_state


def get_local_state(
    algod_client: algod.AlgodClient, account_address: str, asc_idx: int
) -> dict[str, Union[bytes, int]]:
    local_states = algod_client.account_info(account_address)["apps-local-state"]
    local_state = [s for s in local_states if s["id"] == asc_idx][0].get(
        "key-value", {}
    )
    local_state = decode_state(local_state)
    return local_state


def get_params(
    algod_client: algod.AlgodClient, fee: int = None
) -> transaction.SuggestedParams:
    params = algod_client.suggested_params()
    params.flat_fee = True
    params.fee = fee or constants.MIN_TXN_FEE
    return params


def get_last_round(algod_client: algod.AlgodClient):
    return algod_client.status()["last-round"]


def get_last_timestamp(algod_client: algod.AlgodClient):
    return algod_client.block_info(get_last_round(algod_client))["block"]["ts"]


def assemble_program(algod_client: algod.AlgodClient, source_code: str) -> bytes:
    compile_response = algod_client.compile(source_code)
    return base64.b64decode(compile_response["result"])


SmartASAConfig = namedtuple(
    PyTealSmartASAConfig.__class__.__name__,
    list(get_annotations(PyTealSmartASAConfig)),
)


def normalize_getter_params(getter_params: list) -> SmartASAConfig:
    return SmartASAConfig(*getter_params)


# File: https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py
#
import base64

#
from typing import Optional
from dataclasses import dataclass

#
from algosdk import account, mnemonic, transaction, logic
from algosdk.v2client.algod import AlgodClient
from algosdk.transaction import PaymentTxn, SignedTransaction
from algosdk.transaction import ApplicationCreateTxn, ApplicationCallTxn


#
@dataclass
class AlgoUser:
    pk: str
    address: int
    mnemonic: float

    def __str__(self):
        return "Private Key - {}\nAddress - {}\nMnemonic - {}".format(
                    self.pk,
                    self.address,
                    self.mnemonic
                )


#
class Algorand:
    """
    Algorand object for interacting with algosdk
    """

    # global and local schema parameters
    GLOBAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)
    LOCAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)

    #
    def __init__(self, algo_token: str, algo_address: str) -> None:
        """
        Constructor

        :param algo_token: token for connecting algorand testnet
        :param algo_address: algorand testnet address

        :returns: None
        """
        self.__token = algo_token
        self.__address = algo_address
        self.__headers = {"X-API-Key": self.token}
        self.__client = self.__get_client()
        self.__params = self.client.suggested_params()

    #
    def __get_client(self) -> Optional[AlgodClient]:
        """
        create AlgodClient object from given token and address

        :returns: AlgodClient object
        """
        return AlgodClient(self.token, self.address, self.headers)

    #
    @property
    def headers(self) -> dict:
        """
        Getter for header private field

        :returns: headers field value
        """
        return self.__headers

    #
    @property
    def token(self) -> str:
        """
        Getter for token private field

        :returns: token field value
        """
        return self.__token

    #
    @property
    def address(self) -> str:
        """
        Getter for address private field

        :returns: address field value
        """
        return self.__address

    #
    @property
    def params(self) -> str:
        """
        Getter for params private field

        :returns: params field value
        """
        return self.__params

    #
    @property
    def client(self) -> Optional[AlgodClient]:
        """
        Getter for client private field

        :returns: client field value
        """
        return self.__client

    #
    def get_balance(self, address: str) -> int:
        """
        Get balance of given account

        :params address: address of account

        :returns: amount balance
        """
        return self.client.account_info(address).get("amount")

    #
    def get_transaction_info(self, tx_id: str):
        """
        Get transaction information

        :param tx_id: transaction id

        :returns: transaction information
        """
        return self.client.pending_transaction_info(tx_id)

    #
    def generate_new_account(self) -> dict:
        """
        Generate new account for algorand testnet

        :returns: new generated account key, address and mnemonic
        """
        private_key, address = account.generate_account()
        mnem = mnemonic.from_private_key(private_key)

        return AlgoUser(private_key, address, mnem)

    #
    def get_application_id(self, tx_id: str) -> int:
        """
        Get application id from transaction id

        :param tx_id: transaction id

        :returns: application id
        """
        transaction_info = self.get_transaction_info(tx_id)
        app_id = transaction_info.get("application-index")
        return app_id

    #
    def get_application_address(self, app_id: int) -> str:
        """
        Get application address from id

        :param app_id: id of application

        :returns: address of application
        """
        app_address = logic.get_application_address(app_id)
        return app_address

    #
    def build_payment_transaction(
                self,
                sender: str,
                receiver: str,
                amount: int,
                note: str
            ) -> Optional[PaymentTxn]:
        """
        Build payment transaction from sender to receiver

        :param sender: sender address
        :param receiver: receiver address
        ;param amount: amount which should be transferred
        :param note: note for transaction

        :returns: payment transaction
        """
        txn = transaction.PaymentTxn(
            sender=sender,
            sp=self.params,
            receiver=receiver,
            amt=amount,
            note=note,
        )
        return txn

    #
    def create_application_transaction(
                self,
                sender: str,
                approval_teal: bytes,
                clear_teal: bytes
            ) -> Optional[ApplicationCreateTxn]:
        """
        Create transaction that interacts with the application system

        :param sender: address
        :param approval_teal: transaction smart contract in bytes
        :param clear_teal: clear smart contract in bytes

        :returns: application transaction
        """
        app_create_txn = transaction.ApplicationCreateTxn(
            sender=sender,
            sp=self.params,
            on_complete=transaction.OnComplete.NoOpOC.real,
            approval_program=approval_teal,
            clear_program=clear_teal,
            global_schema=self.GLOBAL_SCHEMA,
            local_schema=self.LOCAL_SCHEMA
        )
        return app_create_txn

    #
    def sign_transaction(
                self,
                sender: str,
                txn: Optional[ApplicationCreateTxn]
            ) -> Optional[SignedTransaction]:
        """
        Sign created transaction

        :param sender: sender private key
        :param txn: transaction which should be signed

        :returns: signed transaction
        """
        signed_txn = txn.sign(sender)
        return signed_txn

    #
    def send_transaction(self, signed_txn: Optional[SignedTransaction]) -> str:
        """
        Send already signed transaction

        :param signed_txn: signed transaction which should be sent

        :returns: transaction id
        """
        tx_id = self.client.send_transaction(signed_txn)
        return tx_id

    #
    def wait_for_confirmation(self, tx_id: str) -> None:
        """
        Block until a pending transaction is confirmed by the network

        :param tx_id: transaction id

        :returns None
        """
        return transaction.wait_for_confirmation(self.client, tx_id, 4)

    #
    def call_application_transaction(
                self,
                sender: str,
                app_id: int,
                app_args: list,
                receiver: str=None,
                asset: int=None
            ) -> Optional[ApplicationCallTxn]:
        """
        Create Application call transaction object

        :param sender: sender address
        :param app_id: application id for which transaction is made
        :param app_args: arguments for application smart contract
        :param receiver: receiver address

        :returns: ApplicationCallTxn objects
        """

        accounts = []
        if receiver:
            accounts.append(receiver)

        assets = []
        if asset:
            assets.append(asset)
        
        app_call_txn = transaction.ApplicationCallTxn(
            sender=sender,
            sp=self.params,
            index=app_id,
            on_complete=transaction.OnComplete.NoOpOC.real,
            app_args=app_args,
            accounts=accounts,
            foreign_assets=assets
        )
        return app_call_txn

    #
    def call_application_transaction_foreign_asset(
                self,
                sender: str,
                app_id: int,
                app_args: list,
                asset_id: str=None
            ) -> Optional[ApplicationCallTxn]:
        """
        Create Application call transaction object

        :param sender: sender address
        :param app_id: application id for which transaction is made
        :param app_args: arguments for application smart contract
        :param receiver: receiver address

        :returns: ApplicationCallTxn objects
        """

        app_call_txn = transaction.ApplicationCallTxn(
            sender=sender.address,
            sp=self.params,
            index=app_id,
            on_complete=transaction.OnComplete.NoOpOC.real,
            app_args=app_args,
            foreign_assets=[asset_id]
        )
        return app_call_txn
    #
    def create_application_no_op_transaction(self, sender, app_id, app_args, receiver=None):
        accounts = []
        if receiver:
            accounts.append(receiver.address)
        
        txn = transaction.ApplicationNoOpTxn(
                sender=sender.address,
                sp=self.params,
                index=app_id,
                app_args=app_args,
                accounts=accounts
        )

        return txn

    #
    def create_asset(self, creator):
        txn = transaction.AssetConfigTxn(
                sender=creator.address,
                sp=self.params,
                total=1000000,
                default_frozen=False,
                unit_name="LSCOIN",
                asset_name="LS Coin",
                manager=creator.address,
                reserve=creator.address,
                freeze=creator.address,
                clawback=creator.address,
                decimals=0
        )
        signed_txn = self.sign_transaction(creator.pk, txn)
        tx_id = self.send_transaction(signed_txn)
        self.wait_for_confirmation(tx_id)
        response = self.client.pending_transaction_info(tx_id)
        return response['asset-index']

    #
    def opt_in_to_asset(self, sender, asset_id):
        txn = transaction.AssetTransferTxn(
                sender=sender.address,
                sp=self.params,
                receiver=sender.address,
                amt=0,
                index=asset_id
            )
        signed_txn = self.sign_transaction(sender.pk, txn)
        tx_id = self.send_transaction(signed_txn)
        self.wait_for_confirmation(tx_id)


    
    #
    def get_application_global_state(self, app_id: int) -> dict:
        """
        Get application global state info

        :param app_id: application id

        :returns: info about application global state
        """
        app_info = self.client.application_info(app_id)
        global_state = app_info['params']['global-state']
        state = {}
        for item in global_state:
            key = base64.b64decode(item['key']).decode('utf-8')
            value = item['value']
            state[key] = value
        return state


# File: https://github.com/khoilr/blockchain-consensus/blob/57eeab4287a05b511b370e2e7258b96687f1f6e8/Algorand.py
import hashlib
import math
import time
import random
from typing import List

from ecdsa import SECP256k1, SigningKey, VerifyingKey

from transaction import Transaction


class Block:
    def __init__(
        self,
        txns: List[Transaction],
        previous_hash: str,
        vrf_proof,
        verify_key: VerifyingKey,
    ):
        self.txns = txns
        self.previous_hash = previous_hash
        self.timestamp = int(time.time())
        self.vrf_proof = vrf_proof
        self.verify_key = verify_key
        self.hash = self.calculate_hash()

    def calculate_hash(self) -> str:
        block_data = f"{self.txns}{self.previous_hash}{self.timestamp}{self.vrf_proof}{self.verify_key}"
        return hashlib.sha256(block_data.encode()).hexdigest()

    def is_valid(self, previous_hash: str):
        return (
            self.hash == self.calculate_hash() and self.previous_hash == previous_hash
        )

    def __repr__(self):
        return f"Block (timestamp={self.timestamp}, hash={self.hash[:8]}, previous_hash={self.previous_hash[:8]}, num_txns={len(self.txns)})"


class Blockchain:
    def __init__(self):
        self.chain: List[Block] = []

        self.create_genesis_block()

    def create_genesis_block(self) -> None:
        genesis_block = Block([], "0", "0", "0")
        self.chain.append(genesis_block)

    def add_block(self, block: Block) -> None:
        if block.is_valid(self.get_last_block().hash):
            self.chain.append(block)

    def get_last_block(self) -> Block:
        return self.chain[-1]

    def get_new_block_index(self) -> int:
        return len(self.chain)

    def is_valid(self) -> bool:
        return all(
            self.chain[i].is_valid(
                target=self.target_from_difficulty(),
                previous_hash=self.chain[i - 1].hash,
            )
            for i in range(1, len(self.chain))
        )


class Account:
    def __init__(self, stake):
        self.signing_key = SigningKey.generate(curve=SECP256k1)
        self.verify_key = self.signing_key.verifying_key
        self.stake = stake
        self.total_rewards = 0

    def generate_key_pair(self):
        return self.signing_key.to_string().hex(), self.verify_key.to_string().hex()

    def prove(self, message):
        # Hash the message
        message_hash = hashlib.sha256(message).digest()

        # Sign the hash
        signature = self.signing_key.sign(message_hash)

        return signature.hex(), self.verify_key

    def verify(self, message: bytes, signature, verify_key):
        verify_key = VerifyingKey.from_string(
            bytes.fromhex(verify_key.to_string().hex()), curve=SECP256k1
        )
        message_hash = hashlib.sha256(message).digest()
        try:
            return verify_key.verify(bytes.fromhex(signature), message_hash)
        except Exception:
            return False

    def __repr__(self):
        return f"Account(verify_key={self.verify_key.to_string().hex()})"


class Algorand(Blockchain):
    def __init__(
        self,
        accounts: List[Account],
        initial_supply: float,
        inflation_rate: float,
    ):
        super().__init__()

        self.accounts = accounts
        self.total_supply = initial_supply
        self.inflation_rate = inflation_rate
        self.current_round = 0
        self.base_reward = (self.total_supply * self.inflation_rate) / (
            365 * 24 * 60
        )  # Per minute

        # Calculate thresholds after committee and proposers sizes are defined
        self.proposer_threshold = 20 / len(accounts)
        self.committee_threshold = self.committee_size / len(accounts)

    @property
    def total_stake(self):
        return sum(account.stake for account in self.accounts)

    @property
    def committee_size(self):
        return max(math.isqrt(len(self.accounts)), 100)

    @property
    def proposers_size(self):
        return max(math.isqrt(len(self.accounts)), 10)

    def select_accounts(
        self,
        seed: bytes,
        threshold: float,
        is_select_proposers: bool,
    ) -> List[Account]:
        weights = [account.stake for account in self.accounts]
        total_weight = sum(weights)

        # Normalize weights
        normalized_weights = [w / total_weight for w in weights]

        # Use VRF to determine eligibility
        eligible_accounts = []
        for account, weight in zip(self.accounts, normalized_weights):
            signature, verify_key = account.prove(seed)
            vrf_output = int(signature, 16)
            if vrf_output / (2**256) < weight * threshold:
                eligible_accounts.append(account)

        # If not enough eligible accounts, add more based on stake weight
        size = self.proposers_size if is_select_proposers else self.committee_size
        if len(eligible_accounts) < size:
            additional_accounts = random.choices(
                self.accounts,
                weights=weights,
                k=size - len(eligible_accounts),
            )
            eligible_accounts.extend(additional_accounts)

        # If more than needed, randomly select the required number
        if len(eligible_accounts) > size:
            eligible_accounts = random.sample(eligible_accounts, size)

        return eligible_accounts

    def propose_block(
        self,
        proposer: Account,
        txns: List[Transaction],
    ) -> Block:
        previous_hash = self.get_last_block().hash
        vrf_proof, verify_key = proposer.prove(previous_hash.encode())
        return Block(txns, previous_hash, vrf_proof, verify_key)

    def validate_block(
        self, block: Block, proposer: Account, previous_block: Block
    ) -> bool:
        if block.previous_hash != previous_block.hash:
            return False
        if not proposer.verify(
            block.previous_hash.encode(),
            block.vrf_proof,
            block.verify_key,
        ):
            return False

        return True

    def byzantine_agreement(
        self,
        proposed_blocks: List[Block],
        committee: List[Account],
    ) -> Block:
        if not proposed_blocks:
            return None

        total_stake = sum(member.stake for member in committee)
        threshold = total_stake * 2 / 3

        # Step 1: Soft Vote
        votes = {block.hash: 0 for block in proposed_blocks}

        for member in committee:
            chosen_block = max(
                proposed_blocks,
                key=lambda b: hash(b.hash + str(member.stake)),
            )
            votes[chosen_block.hash] += member.stake

        winner = max(votes, key=votes.get)
        winner_stake = 0

        for member in committee:
            propose = random.choices([True, False], weights=[0.8, 0.2], k=1)[0]
            if propose:
                winner_stake += member.stake

        if winner_stake > threshold:
            return next(block for block in proposed_blocks if block.hash == winner)

        return None

    def distribute_rewards(self, block: Block, committee: List[Account]):
        total_reward = self.base_reward
        proposer_reward = total_reward * 0.8  # 80% to proposer
        committee_reward = total_reward * 0.2  # 20% split among committee

        proposer = next(
            account
            for account in self.accounts
            if account.verify_key == block.verify_key
        )
        proposer.stake += proposer_reward
        proposer.total_rewards += proposer_reward

        for member in committee:
            reward = committee_reward / len(committee)
            member.stake += reward
            member.total_rewards += reward

        self.total_supply += total_reward

    def mine_block(self, transactions: List[Transaction]) -> Block:
        seed = hashlib.sha256(
            f"{self.get_last_block().hash}{self.current_round}".encode()
        ).digest()

        proposers = self.select_accounts(
            seed + b"proposer", self.proposer_threshold, True
        )
        committee = self.select_accounts(
            seed + b"committee", self.committee_threshold, False
        )

        proposed_blocks = []
        for proposer in proposers:
            block = self.propose_block(proposer, transactions)
            if self.validate_block(block, proposer, self.get_last_block()):
                proposed_blocks.append(block)

        self.current_round += 1

        winner = self.byzantine_agreement(proposed_blocks, committee)

        if winner:
            self.add_block(winner)
            self.distribute_rewards(winner, committee)
            return winner

        return None

    def simulate_51_percent_attack(self, attacker: Account):
        print("Simulating 51% attack...")
        attacker_stake = attacker.stake
        honest_stake = self.total_stake - attacker_stake

        if attacker_stake > honest_stake:
            print(
                f"Attacker has {attacker_stake / self.total_stake:.2%} of the total stake."
            )

            proposer_successes = 0
            committee_controls = 0
            rounds = 1000

            for _ in range(rounds):
                seed = hashlib.sha256(str(random.random()).encode()).digest()
                proposers = self.select_accounts(
                    seed + b"proposer",
                    self.proposer_threshold,
                    True,
                )
                committee = self.select_accounts(
                    seed + b"committee",
                    self.committee_threshold,
                    False,
                )

                if attacker in proposers:
                    proposer_successes += 1

                attacker_committee_stake = sum(
                    member.stake for member in committee if member == attacker
                )
                if (
                    attacker_committee_stake
                    > sum(member.stake for member in committee) * 2 / 3
                ):
                    committee_controls += 1

            print(f"Probability of being a proposer: {proposer_successes / rounds:.2%}")
            print(
                f"Probability of controlling committee: {committee_controls / rounds:.2%}"
            )
            print(
                "Even with majority stake, the attacker cannot consistently control the protocol."
            )
        else:
            print("Attacker doesn't have enough stake for a 51% attack.")

        return False

    def simulate_nothing_at_stake(self, attacker: Account):
        print("Simulating Nothing-at-Stake attack...")

        seed = hashlib.sha256(str(random.random()).encode()).digest()
        proposers = self.select_accounts(
            seed + b"proposer",
            self.proposer_threshold,
            True,
        )
        committee = self.select_accounts(
            seed + b"committee",
            self.committee_threshold,
            False,
        )

        if attacker in proposers:
            block1 = self.propose_block(attacker, [Transaction("main", "chain", 1)])
            block2 = self.propose_block(attacker, [Transaction("fork", "chain", 1)])

            winner = self.byzantine_agreement([block1, block2], committee)

            print("In Algorand:")
            print(
                "1. Only one block can be finalized per round through Byzantine agreement."
            )
            print("2. Proposing multiple blocks doesn't increase chances of reward.")
            print(
                f"3. Result: {'Two blocks proposed, but only one finalized' if winner else 'No block finalized due to conflicting proposals'}"
            )
        else:
            print("Attacker was not selected as a proposer in this round.")

        return False

    def simulate_long_range_attack(self, attacker: Account):
        print("Simulating Long-Range attack...")
        fork_point = max(0, len(self.chain) - 100)  # Try to fork from 1000 blocks ago
        honest_chain = self.chain[:]
        attacker_chain = self.chain[:fork_point]

        if not attacker_chain:
            print("Not enough blocks in the chain to perform a long-range attack.")
            return False

        for i in range(fork_point, len(honest_chain)):
            seed = hashlib.sha256(f"{attacker_chain[-1].hash}{i}".encode()).digest()
            proposers = self.select_accounts(
                seed + b"proposer",
                self.proposer_threshold,
                True,
            )
            committee = self.select_accounts(
                seed + b"committee",
                self.committee_threshold,
                False,
            )

            if attacker in proposers:
                fake_block = self.propose_block(
                    attacker, [Transaction("fake", "transaction", 1)]
                )
                if self.byzantine_agreement([fake_block], committee):
                    attacker_chain.append(fake_block)
                else:
                    print(f"Failed to reach consensus on attacker's block at round {i}")
                    break
            else:
                print(f"Attacker not selected as proposer for round {i}")
                break

        if len(attacker_chain) > len(honest_chain):
            print("In a longest-chain protocol, this attack might succeed.")

        print("In Algorand:")
        print(
            "1. Blocks are final after Byzantine agreement, preventing reorganization."
        )
        print("2. Attacker can't reconstruct historical committees or proposers.")
        print("3. State proofs provide additional security against long-range attacks.")

        return False

    def simulate_sybil_attack(self, attacker: Account):
        print("Simulating Sybil attack...")
        original_stake = attacker.stake
        sybil_accounts = [Account(original_stake / 10) for _ in range(10)]

        def measure_influence(accounts):
            proposer_selections = 0
            committee_selections = 0
            rounds = 1000

            for _ in range(rounds):
                seed = hashlib.sha256(str(random.random()).encode()).digest()
                proposers = self.select_accounts(
                    seed + b"proposer",
                    self.proposer_threshold,
                    True,
                )
                committee = self.select_accounts(
                    seed + b"committee",
                    self.committee_threshold,
                    False,
                )

                proposer_selections += sum(1 for acc in accounts if acc in proposers)
                committee_selections += sum(1 for acc in accounts if acc in committee)

            return proposer_selections / rounds, committee_selections / rounds

        original_proposer_influence, original_committee_influence = measure_influence(
            [attacker]
        )
        sybil_proposer_influence, sybil_committee_influence = measure_influence(
            sybil_accounts
        )

        print(f"Original proposer influence: {original_proposer_influence:.2%}")
        print(f"Sybil proposer influence: {sybil_proposer_influence:.2%}")
        print(f"Original committee influence: {original_committee_influence:.2%}")
        print(f"Sybil committee influence: {sybil_committee_influence:.2%}")
        print("In Algorand:")
        print("1. Influence is directly proportional to stake, not number of accounts.")
        print(
            "2. Splitting stake across multiple accounts doesn't increase overall influence."
        )

        return False

    def simulate_attacks(self):
        attacker = max(self.accounts, key=lambda a: a.stake)
        attacks = [
            self.simulate_51_percent_attack,
            self.simulate_nothing_at_stake,
            self.simulate_long_range_attack,
            self.simulate_sybil_attack,
        ]
        attack = random.choice(attacks)
        attack(attacker)
        print()

    def validate_chain(self) -> bool:
        # Start from the second block (index 1) since the genesis block has no previous hash
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]

            # Check if the current block's previous hash matches the hash of the previous block
            if current_block.previous_hash != previous_block.hash:
                print(f"Invalid previous hash in block {i}")
                return False

            # Validate the block's integrity
            proposer = next(
                (
                    account
                    for account in self.accounts
                    if account.verify_key == current_block.verify_key
                ),
                None,
            )
            if not proposer:
                print(f"Proposer not found for block {i}")
                return False

            if not self.validate_block(current_block, proposer, previous_block):
                print(f"Block {i} failed validation")
                return False

        print("Blockchain is valid")
        return True


def main():
    accounts = [Account(random.uniform(100, 10000)) for _ in range(100)]
    algorand = Algorand(accounts, initial_supply=1000000, inflation_rate=0.05)

    # Mine 100 blocks
    for i in range(100):
        transactions = [
            Transaction(
                f"account_{i}",
                f"account_{(i+1)%100}",
                random.uniform(1, 100),
                random.uniform(1, 100),
            )
            for i in range(5)
        ]
        block = algorand.mine_block(transactions)
        # print(block)
        # if i % 10 == 0:
        #     algorand.simulate_attacks()

    algorand.validate_chain()
    print(algorand)


if __name__ == "__main__":
    main()


# File: https://github.com/zalkikar/AlgoRand_Covid/blob/fe6a060440ec515bfdee2caf35286312d55d833a/py_algorand.py
#!/usr/bin/env python
# coding: utf-8

import algosdk
import math
import time

class Algorand_IReportScrape():
    
    def __init__(self, api_key):
        self.purestake_api_key = api_key
        self.connectMainnet()
        self.client_check()
        
        # For retrieving the real covid data from mainnet
        self.address = "COVIDR5MYE757XMDCFOCS5BXFF4SKD5RTOF4RTA67F47YTJSBR5U7TKBNU"
        self.fromRound = 5646000
        self.maxTxnPerCall = 500 # max transactions in a batch
        self.batchSize = 512 #Read the transactions from the blockchain in 512-block installations
        self.params = self.algod_client.suggested_params()
        self.lastRound = self.params['lastRound']
        #self.lastRound = self.fromRound + 20*self.batchSize # for testing
        
        print("\n total rounds:",self.lastRound - self.fromRound)
        
        self.txns = []
        self.batch_limit = math.ceil((self.lastRound - self.fromRound)/self.maxTxnPerCall)
        
        tot_rounds_div = math.floor((self.lastRound - self.fromRound)/self.batchSize)
        marker_dict = dict(zip([math.floor(tot_rounds_div*(per/10))*self.batchSize + self.fromRound for per in list(range(1,10))],
                               [per/10 for per in list(range(1,10))]))
        
        rnd = self.fromRound
        while rnd < self.lastRound:
            toRnd = rnd + self.batchSize
            if toRnd in marker_dict.keys():
                print("{}% complete".format(marker_dict[toRnd]*100))
            if toRnd > self.lastRound:
                toRnd = self.lastRound
            self.txns.extend(self.getTransactionBatch(rnd,toRnd)) # Fetch transactions for these rounds 
            rnd += self.batchSize
            time.sleep(0.1)

        print("found {} transactions".format(len(self.txns)))
                             
    def connectMainnet(self):
        algod_address_mainnet = "https://mainnet-algorand.api.purestake.io/ps1"
        port = ""
        token = {
            'X-API-key' : self.purestake_api_key,
        }
        # Initialize the algod client
        self.algod_client = algosdk.algod.AlgodClient(port, algod_address_mainnet, token) 
    
    def client_check(self):
        try:
            status = self.algod_client.status()
        except Exception as e:
            print("Failed to get algod status: {}".format(e))

        if status:
            print("algod last round: {}".format(status.get("lastRound")))
            print("algod time since last round: {}".format(status.get("timeSinceLastRound")))
            print("algod catchup: {}".format(status.get("catchupTime")))
            print("algod latest version: {}".format(status.get("lastConsensusVersion")))

        # Retrieve latest block information                                                                                                                                               
        last_round = self.algod_client.status().get("lastRound")
        print("####################")
        block = self.algod_client.block_info(last_round)
        print(block)
                             
    def getTransactionBatch(self,fromRnd,lastRnd):
        if (fromRnd > lastRnd):# sanity check
            return []
        txs = self.algod_client.transactions_by_address(self.address,fromRnd,lastRnd,self.maxTxnPerCall) 
        # make an API call to get the transactions - 500 at a time

        #  A recursive function for getting a batch of transactions, to overcome
        # the limitation of maxTxnPerCall transaction per call to the API
        # If we got all the transactions, just return them
        if ((fromRnd == lastRnd) | (len(txs['transactions']) < self.maxTxnPerCall)):
            return txs['transactions']

            # FIXME: If a single block contains more than maxTxnPerCall
            # transactions for the target address, the code above will return
            # only maxTxnPerCall of them.
            # This is an unlikely case, and not easy to handle. The only way to
            # handle it is to call algod.block(round#), then go over all the
            # transactions in this block and take only the ones corresponding
            # to the target address.

        else: # recursive call to get them in two smaller chunks
            midRnd = math.floor((fromRnd+toRnd) / 2)
            txns1 = getTransactionBatch(fromRnd, midRnd)
            txns2 = getTransactionBatch(midRnd+1, toRnd)
            # return the concatenation of the two chunks
            return txns1.concat(txns2)
                             
    def get_txns(self):
        return self.txns

# File: https://github.com/gitcoinco/web/blob/7c66485f75dbe5ca072892862ff6c9754baf889a/app/grants/utils.py
# -*- coding: utf-8 -*-
"""Define the Grant utilities.

Copyright (C) 2021 Gitcoin Core

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

"""
import json
import logging
import math
import os
import re
import urllib.request
from datetime import datetime
from decimal import Decimal
from random import randint, seed
from secrets import token_hex

from django.utils import timezone

import numpy as np
import pandas as pd
from app.settings import BASE_URL, MEDIA_URL, NOTION_API_KEY, NOTION_SYBIL_DB
from app.utils import notion_write
from avatar.utils import convert_img
from economy.utils import ConversionRateNotFoundError, convert_amount
from gas.utils import eth_usd_conv_rate
from grants.sync.algorand import sync_algorand_payout
from grants.sync.binance import sync_binance_payout
from grants.sync.celo import sync_celo_payout
from grants.sync.cosmos import sync_cosmos_payout
from grants.sync.harmony import sync_harmony_payout
from grants.sync.polkadot import sync_polkadot_payout
from grants.sync.rsk import sync_rsk_payout
from grants.sync.zcash import sync_zcash_payout
from grants.sync.zil import sync_zil_payout
from perftools.models import StaticJsonEnv
from PIL import Image, ImageDraw, ImageOps
from townsquare.models import SquelchProfile

logger = logging.getLogger(__name__)

block_codes = ('', '', '', '', '', '', '', '', '', '')
emoji_codes = ('', '', '', '', '', '', '', '', '', '')


tenant_payout_mapper = {
    'ZCASH': sync_zcash_payout,
    'CELO': sync_celo_payout,
    'ZIL': sync_zil_payout,
    'HARMONY': sync_harmony_payout,
    'POLKADOT': sync_polkadot_payout,
    'BINANCE': sync_binance_payout,
    'KUSAMA': sync_polkadot_payout,
    'RSK': sync_rsk_payout,
    'ALGORAND': sync_algorand_payout,
    'COSMOS': sync_cosmos_payout
}

def get_clr_rounds_metadata():
    '''
        Fetches default CLR round metadata for stats/marketing flows.
        This is configured when multiple rounds are running
    '''
    try:
        CLR_ROUND_DATA = StaticJsonEnv.objects.get(key='CLR_ROUND').data

        clr_round = CLR_ROUND_DATA['round_num']
        start_date = CLR_ROUND_DATA['round_start']
        end_date = CLR_ROUND_DATA['round_end']
        show_round_banner = json.loads(CLR_ROUND_DATA['show_round_banner'])
        claim_start_date = CLR_ROUND_DATA.get('claim_start_date')
        claim_end_date = CLR_ROUND_DATA.get('claim_end_date')
        banner_round_name = CLR_ROUND_DATA.get('banner_round_name')

        # timezones are in UTC (format example: 2021-06-16:15.00.00)
        round_start_date = datetime.strptime(start_date, '%Y-%m-%d:%H.%M.%S')
        round_end_date = datetime.strptime(end_date, '%Y-%m-%d:%H.%M.%S')

        now = datetime.now()

        if claim_start_date and claim_end_date:
            claim_start_date = datetime.strptime(claim_start_date, '%Y-%m-%d:%H.%M.%S')
            claim_end_date = datetime.strptime(claim_end_date, '%Y-%m-%d:%H.%M.%S')

        if round_start_date > now:
            round_status = 'upcoming'
        elif round_start_date <= now <= round_end_date:
            round_status = 'active'
        elif claim_start_date and claim_end_date and claim_start_date <= now <= claim_end_date:
            round_status = 'claim'
        else:
            round_status = 'done'

    except:
        # setting defaults
        clr_round=1
        round_start_date = timezone.now()
        round_end_date = timezone.now() + timezone.timedelta(days=14)
        show_round_banner = False
        claim_start_date = None
        claim_end_date = None
        round_status = 'done'
        banner_round_name = ''

    return {
        'clr_round': clr_round,
        'round_start_date': round_start_date,
        'round_end_date': round_end_date,
        'show_round_banner': show_round_banner,
        'claim_start_date': claim_start_date,
        'claim_end_date': claim_end_date,
        'round_status': round_status,
        'banner_round_name': banner_round_name
    }


def get_upload_filename(instance, filename):
    salt = token_hex(16)
    file_path = os.path.basename(filename)
    return f"grants/{getattr(instance, '_path', '')}/{salt}/{file_path}"


def is_grant_team_member(grant, profile):
    """Checks to see if profile is a grant team member

    Args:
        grant (grants.models.Grant): The grant in question.
        profile (dashboard.models.Profile): The current user's profile.

    """
    if not profile:
        return False
    is_team_member = False
    if grant.admin_profile == profile:
        is_team_member = True
    else:
        for team_member in grant.team_members.all():
            if team_member.id == profile.id:
                is_team_member = True
                break
    return is_team_member


def amount_in_wei(tokenAddress, amount):
    from dashboard.tokens import addr_to_token
    token = addr_to_token(tokenAddress)
    decimals = token['decimals'] if token else 18
    return float(amount) * 10**decimals


def get_converted_amount(amount, token_symbol):
    try:
        if token_symbol == "ETH" or token_symbol == "WETH":
            return Decimal(float(amount) * float(eth_usd_conv_rate()))
        else:
            value_token_to_eth = Decimal(convert_amount(
                amount,
                token_symbol,
                "ETH")
            )

        value_eth_to_usdt = Decimal(eth_usd_conv_rate())
        value_usdt = value_token_to_eth * value_eth_to_usdt
        return value_usdt

    except ConversionRateNotFoundError as e:
        try:
            return Decimal(convert_amount(
                amount,
                token_symbol,
                "USDT"))
        except ConversionRateNotFoundError as no_conversion_e:
            logger.info(no_conversion_e)
            return None


def get_user_code(user_id, grant, coding_set=block_codes, length=6):
    seed(user_id ** grant.id)
    coding_id = [coding_set[randint(0, 9)] for _ in range(length)]

    return ''.join(coding_id)


def generate_collection_thumbnail(collection, width, heigth):
    grants = collection.grants.all()
    profile = collection.profile
    return generate_img_thumbnail_helper(grants, profile, width, heigth)


def generate_img_thumbnail_helper(grants, profile, width, heigth):
    MARGIN = int(width / 30)
    MID_MARGIN = int(width / 90)
    BG = (111, 63, 245)
    DISPLAY_GRANTS_LIMIT = 4
    PROFILE_WIDTH = PROFILE_HEIGHT = int(width / 3.5)
    GRANT_WIDTH = int(width / 2) - MARGIN - MID_MARGIN
    GRANT_HEIGHT = int(heigth / 2) - MARGIN - MID_MARGIN
    IMAGE_BOX = (width, heigth)
    LOGO_SIZE_DIFF = int(GRANT_WIDTH / 5)
    HALF_LOGO_SIZE_DIFF = int(LOGO_SIZE_DIFF / 2)
    PROFILE_BOX = (PROFILE_WIDTH - LOGO_SIZE_DIFF, PROFILE_HEIGHT - LOGO_SIZE_DIFF)
    GRANT_BOX = (GRANT_WIDTH, GRANT_HEIGHT)
    media_url = '' if 'media' not in MEDIA_URL else BASE_URL[:-1]

    logos = []
    for grant in grants:
        if grant.logo:
            if len(logos) > DISPLAY_GRANTS_LIMIT:
                break
            grant_url = f'{media_url}{grant.logo.url}'
            print(f'Trying to get: ${grant_url}')
            fd = urllib.request.urlopen(grant_url)
            logos.append(fd)
        else:
            static_file = f'assets/v2/images/grants/logos/{grant.id % 3}.png'
            logos.append(static_file)

    for logo in range(len(logos), 4):
        logos.append(None)

    thumbail = Image.new('RGBA', IMAGE_BOX, color=BG)
    avatar_url = f'{media_url}{profile.avatar_url}'
    fd = urllib.request.urlopen(avatar_url)

    # Make rounder profile avatar img
    mask = Image.new('L', PROFILE_BOX, 0)
    draw = ImageDraw.Draw(mask)
    draw.ellipse((0, 0) + PROFILE_BOX, fill=255)
    profile_thumbnail = Image.open(fd)

    profile_thumbnail.thumbnail(PROFILE_BOX, Image.ANTIALIAS)
    profile_circle = ImageOps.fit(profile_thumbnail, mask.size, centering=(0.5, 0.5))

    try:
        applied_mask = profile_circle.copy()
        applied_mask.putalpha(mask)
        profile_circle.paste(applied_mask, (0, 0), profile_circle)
    except ValueError:
        profile_circle.putalpha(mask)


    CORNERS = [
        [MARGIN, MARGIN],  # Top left grant
        [width - GRANT_WIDTH - MARGIN, MARGIN],  # Top right grant
        [MARGIN, heigth - GRANT_HEIGHT - MARGIN],  # bottom left grant
        [width - GRANT_WIDTH - MARGIN, heigth - GRANT_HEIGHT - MARGIN]  # bottom right grant
    ]

    for index in range(4):
        if logos[index] is None:
            grant_bg = Image.new('RGBA', GRANT_BOX, color='white')
            thumbail.paste(grant_bg, CORNERS[index], grant_bg)
            continue

        if type(logos[index]) is not str and re.match(r'.*\.svg', logos[index].url):
            grant_img = convert_img(logos[index])
            grant_thumbail = Image.open(grant_img)
        else:
            try:
                grant_thumbail = Image.open(logos[index])
            except ValueError:
                grant_thumbail = Image.open(logos[index]).convert("RGBA")

        grant_thumbail.thumbnail(GRANT_BOX, Image.ANTIALIAS)

        grant_bg = Image.new('RGBA', GRANT_BOX, color='white')

        try:
            grant_bg.paste(grant_thumbail, (int(GRANT_WIDTH / 2 - grant_thumbail.size[0] / 2),
                                            int(GRANT_HEIGHT / 2 - grant_thumbail.size[1] / 2)), grant_thumbail)
        except ValueError:
            grant_bg.paste(grant_thumbail, (int(GRANT_WIDTH / 2 - grant_thumbail.size[0] / 2),
                                            int(GRANT_HEIGHT / 2 - grant_thumbail.size[1] / 2)))

        thumbail.paste(grant_bg, CORNERS[index], grant_bg)

    draw_on_thumbnail = ImageDraw.Draw(thumbail)
    draw_on_thumbnail.ellipse([
        (int(width / 2 - PROFILE_WIDTH / 2), int(heigth / 2 - PROFILE_HEIGHT / 2)),
        (int(width / 2 + PROFILE_WIDTH / 2), int(heigth / 2 + PROFILE_HEIGHT / 2))
    ], fill="#6F3FF5")

    try:
        thumbail.paste(profile_circle, (int(width / 2 - PROFILE_WIDTH / 2) + HALF_LOGO_SIZE_DIFF, int(heigth / 2 - PROFILE_HEIGHT / 2) + HALF_LOGO_SIZE_DIFF),
                       profile_circle)
    except ValueError:
        thumbail.paste(profile_circle, (int(width / 2 - PROFILE_WIDTH / 2) + HALF_LOGO_SIZE_DIFF, int(heigth / 2 - PROFILE_HEIGHT / 2) + HALF_LOGO_SIZE_DIFF))

    return thumbail


def sync_payout(contribution):
    if not contribution:
        return None

    subscription = contribution.subscription

    if not subscription:
        return None

    tenant_payout_mapper[subscription.tenant](contribution)


def save_grant_to_notion(grant):
    """Post an insert to notions sybil-db table"""
    # check for notion credentials before attempting insert
    if NOTION_SYBIL_DB and NOTION_API_KEY:
        # fully qualified url
        fullUrl = BASE_URL.rstrip('/') + grant.url
        grant_tags = []
        for tag in grant.tags_requested.all():
            grant_tags.append(str(tag))

        # write to NOTION_SYBIL_DB following the defined schema (returns dict of new object)
        return notion_write(NOTION_SYBIL_DB, {
            "Platform Status":{
                "id": "qwNU",
                "type": "select",
                "select":
                {
                    "id": "f38a5236-d1d7-4e63-ada0-e52a4e56d06f",
                    "name": "NEEDS REVIEW",
                    "color": "default"
                }
            },
            "Grant Name": {
                "id": "title",
                "type": "title",
                "title": [{
                    "type": "text",
                    "text": {
                        "content": fullUrl,
                        "link": {
                            "url": fullUrl
                        }
                    },
                    "plain_text": fullUrl,
                    "href": fullUrl
                }]
            },
             "Requested Rounds": {
                "id": "qBXH",
                "type": "rich_text",
                "rich_text": [
                    {
                        "type": "text",
                        "text": {
                            "content": ", ".join(grant_tags),
                            "link": None
                        },
                        "annotations": {
                            "bold": False,
                            "italic": False,
                            "strikethrough": False,
                            "underline": False,
                            "code": False,
                            "color": "default"
                        },
                        "plain_text": ", ".join(grant_tags),
                        "href": None
                    }
                ]
            },
            "Eligibility Tag Reasoning": {
                "id": "Q]?]",
                "type": "rich_text",
                "rich_text": [
                    {
                        "type": "text",
                        "text": {
                            "content": grant.tag_eligibility_reason,
                            "link": None
                        },
                        "annotations": {
                            "bold": False,
                            "italic": False,
                            "strikethrough": False,
                            "underline": False,
                            "code": False,
                            "color": "default"
                        },
                        "plain_text": grant.tag_eligibility_reason,
                        "href": None
                    }
                ]
            }
        })


def toggle_user_sybil(sybil_users, non_sybil_users):
    '''util function which marks users as sybil/not'''

    from dashboard.models import Profile

    squelched_profiles = SquelchProfile.objects.all()
    if sybil_users:
        # iterate through users which need to be packed as sybil
        for user in sybil_users:
            try:
                # get user profile. note
                profile = Profile.objects.filter(handle=user.get('handle')).first()
                if profile:
                    label = user.get('label')
                    comment = user.get('comment')

                    if not comment or comment and isNaN(comment):
                        comment = 'added by bsci'

                    # check if user has entry in SquelchProfile
                    if (
                        not squelched_profiles.filter(profile=profile).first() and
                        label and comment
                    ):
                        # mark user as sybil
                        SquelchProfile.objects.create(
                            profile=profile,
                            label=label,
                            comments=comment
                        )
                else:
                    print(f"error: profile not found for {user.get('handle')} as sybil.")
            except Exception as e:
                print(f"error: unable to mark user {user.get('handle')} as sybil. {e}")

    if non_sybil_users:
        # exclude squelches added by manual
        squelched_profiles = squelched_profiles.exclude(label='Manual')
        # iterate and remove sybil from user
        for user in non_sybil_users:
            try:
                profile = Profile.objects.filter(handle=user.get('handle')).first()
                squelched_profiles.filter(profile=profile).delete()
            except Exception as e:
                print(f"error: unable to mark {user.get('handle')} as non sybil. {e}")


def bsci_script(csv: str) -> tuple:
    """
    Generate records of sybil / non-sybil users based
    on the CSV output as provided by BSci detection pipeline.
    """

    # Assumptions
    RENAME_MAP = {'notes': 'comment'}
    ML_THRESHOLD = 0.8
    EVAL_THRESHOLD = 0.8
    HEURISTIC_THRESHOLD = 0.5

def bsci_script(csv: str) -> tuple:
    """
    Generate records of sybil / non-sybil users based
    on the CSV output as provided by BSci detection pipeline.
    """

    # Assumptions
    RENAME_MAP = {'notes': 'comment'}
    ML_THRESHOLD = 0.8
    EVAL_THRESHOLD = 0.8
    HEURISTIC_THRESHOLD = 0.5

    # Read CSV

    try:
        df = (pd.read_csv(csv)
                .assign(is_sybil=None)
                .assign(label=None)
                .rename(columns=RENAME_MAP))

        # Get label domains
        rows_with_evaluation = ~pd.isnull(df.evaluation_score)
        rows_with_heuristic = ~pd.isnull(df.heuristic_score)
        rows_with_prediction = ~pd.isnull(df.prediction_score)

        labels_by_evaluation = rows_with_evaluation
        labels_by_heuristic = (rows_with_heuristic & (rows_with_heuristic
                                                    ^ labels_by_evaluation))
        labels_by_prediction = (rows_with_prediction & (rows_with_prediction
                                                        ^ (labels_by_heuristic |
                                                        labels_by_evaluation)))

        # Assign final `is_sybil` markings according to a priorization criteria
        df.loc[labels_by_evaluation, 'is_sybil'] = df[labels_by_evaluation].evaluation_score > EVAL_THRESHOLD
        df.loc[labels_by_evaluation, 'label'] = "Human Evaluation"

        df.loc[labels_by_heuristic, 'is_sybil'] = df[labels_by_heuristic].heuristic_score > HEURISTIC_THRESHOLD
        df.loc[labels_by_heuristic, 'label'] = "Heuristics"

        df.loc[labels_by_prediction, 'is_sybil'] = df[labels_by_prediction].prediction_score > ML_THRESHOLD
        df.loc[labels_by_prediction, 'label'] = "ML Prediction"

        # Generate dict records
        sybil_records = df.query('is_sybil == True').to_dict('records')
        non_sybil_records = df.query('is_sybil == False').to_dict('records')

        # Output
        return (sybil_records, non_sybil_records)
    except Exception as e:
        logger.error(f'error: bsci_sybil_script - {e}')
        return None


def isNaN(string):
    return string != string

def is_valid_eip_1271_signature(web3, address, hash, signature) -> bool:
    from grants.abi.eip_1271_abi import EIP_1271_ABI
    try:
        eip_1271_contract = web3.eth.contract(address=address, abi=EIP_1271_ABI)
        retval = eip_1271_contract.functions.isValidSignature(hash, signature).call()
        return web3.toInt(retval) == 0x1626ba7e
    except Exception as e:
        return False


# File: https://github.com/VincenzoImp/utils/blob/b797a1d6b71e212e430df3554bf94f9e67cd206d/parser_utils.py
# deprecated

import re
import numpy as np
import pandas as pd

# use only:
# get_links
# clear_html
# get_emails
# get_addresses 
# get_url_info
# get_url_df_info

tlds = ["aaa", "aarp", "abarth", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "ac", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ad", "ads", "adult", "ae", "aeg", "aero", "aetna", "af", "afl", "africa", "ag", "agakhan", "agency", "ai", "aig", "airbus", "airforce", "airtel", "akdn", "al", "alfaromeo", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "am", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "ao", "aol", "apartments", "app", "apple", "aq", "aquarelle", "ar", "arab", "aramco", "archi", "army", "arpa", "art", "arte", "as", "asda", "asia", "associates", "at", "athleta", "attorney", "au", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "avianca", "aw", "aws", "ax", "axa", "az", "azure", "ba", "baby", "baidu", "banamex", "bananarepublic", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bb", "bbc", "bbt", "bbva", "bcg", "bcn", "bd", "be", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bf", "bg", "bh", "bharti", "bi", "bible", "bid", "bike", "bing", "bingo", "bio", "biz", "bj", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bm", "bms", "bmw", "bn", "bnpparibas", "bo", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "br", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "bs", "bt", "build", "builders", "business", "buy", "buzz", "bv", "bw", "by", "bz", "bzh", "ca", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "cat", "catering", "catholic", "cba", "cbn", "cbre", "cbs", "cc", "cd", "center", "ceo", "cern", "cf", "cfa", "cfd", "cg", "ch", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "ci", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "cityeats", "ck", "cl", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "cm", "cn", "co", "coach", "codes", "coffee", "college", "cologne", "com", "comcast", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cookingchannel", "cool", "coop", "corsica", "country", "coupon", "coupons", "courses", "cpa", "cr", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cu", "cuisinella", "cv", "cw", "cx", "cy", "cymru", "cyou", "cz", "dabur", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "de", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dj", "dk", "dm", "dnp", "do", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "dz", "earth", "eat", "ec", "eco", "edeka", "edu", "education", "ee", "eg", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "er", "ericsson", "erni", "es", "esq", "estate", "et", "etisalat", "eu", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fi", "fiat", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "fj", "fk", "flickr", "flights", "flir", "florist", "flowers", "fly", "fm", "fo", "foo", "food", "foodnetwork", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "fr", "free", "fresenius", "frl", "frogans", "frontdoor", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "ga", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gb", "gbiz", "gd", "gdn", "ge", "gea", "gent", "genting", "george", "gf", "gg", "ggee", "gh", "gi", "gift", "gifts", "gives", "giving", "gl", "glass", "gle", "global", "globo", "gm", "gmail", "gmbh", "gmo", "gmx", "gn", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "gov", "gp", "gq", "gr", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gs", "gt", "gu", "guardian", "gucci", "guge", "guide", "guitars", "guru", "gw", "gy", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hgtv", "hiphop", "hisamitsu", "hitachi", "hiv", "hk", "hkt", "hm", "hn", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hoteles", "hotels", "hotmail", "house", "how", "hr", "hsbc", "ht", "hu", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "id", "ie", "ieee", "ifm", "ikano", "il", "im", "imamat", "imdb", "immo", "immobilien", "in", "inc", "industries", "infiniti", "info", "ing", "ink", "institute", "insurance", "insure", "int", "international", "intuit", "investments", "io", "ipiranga", "iq", "ir", "irish", "is", "ismaili", "ist", "istanbul", "it", "itau", "itv", "jaguar", "java", "jcb", "je", "jeep", "jetzt", "jewelry", "jio", "jll", "jm", "jmp", "jnj", "jo", "jobs", "joburg", "jot", "joy", "jp", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "ke", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kg", "kh", "ki", "kia", "kids", "kim", "kinder", "kindle", "kitchen", "kiwi", "km", "kn", "koeln", "komatsu", "kosher", "kp", "kpmg", "kpn", "kr", "krd", "kred", "kuokgroup", "kw", "ky", "kyoto", "kz", "la", "lacaixa", "lamborghini", "lamer", "lancaster", "lancia", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lb", "lc", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "li", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "lk", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "lr", "ls", "lt", "ltd", "ltda", "lu", "lundbeck", "luxe", "luxury", "lv", "ly", "ma", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "maserati", "mattel", "mba", "mc", "mckinsey", "md", "me", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merckmsd", "mg", "mh", "miami", "microsoft", "mil", "mini", "mint", "mit", "mitsubishi", "mk", "ml", "mlb", "mls", "mm", "mma", "mn", "mo", "mobi", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "mp", "mq", "mr", "ms", "msd", "mt", "mtn", "mtr", "mu", "museum", "music", "mutual", "mv", "mw", "mx", "my", "mz", "nan", "nab", "nagoya", "name", "natura", "navy", "nba", "nc", "ne", "nec", "net", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nf", "nfl", "ng", "ngo", "nhk", "ni", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nl", "no", "nokia", "northwesternmutual", "norton", "now", "nowruz", "nowtv", "np", "nr", "nra", "nrw", "ntt", "nu", "nyc", "nz", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "oldnavy", "ollo", "om", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "org", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "pa", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "passagens", "pay", "pccw", "pe", "pet", "pf", "pfizer", "pg", "ph", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "pk", "pl", "place", "play", "playstation", "plumbing", "plus", "pm", "pn", "pnc", "pohl", "poker", "politie", "porn", "post", "pr", "pramerica", "praxi", "press", "prime", "pro", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "ps", "pt", "pub", "pw", "pwc", "py", "qa", "qpon", "quebec", "quest", "racing", "radio", "re", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "ro", "rocher", "rocks", "rodeo", "rogers", "room", "rs", "rsvp", "ru", "rugby", "ruhr", "run", "rw", "rwe", "ryukyu", "sa", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sb", "sbi", "sbs", "sc", "sca", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "sd", "se", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "sg", "sh", "shangrila", "sharp", "shaw", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "showtime", "si", "silk", "sina", "singles", "site", "sj", "sk", "ski", "skin", "sky", "skype", "sl", "sling", "sm", "smart", "smile", "sn", "sncf", "so", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "sr", "srl", "ss", "st", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "su", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "sv", "swatch", "swiss", "sx", "sy", "sydney", "systems", "sz", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tc", "tci", "td", "tdk", "team", "tech", "technology", "tel", "temasek", "tennis", "teva", "tf", "tg", "th", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tiffany", "tips", "tires", "tirol", "tj", "tjmaxx", "tjx", "tk", "tkmaxx", "tl", "tm", "tmall", "tn", "to", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "tr", "trade", "trading", "training", "travel", "travelchannel", "travelers", "travelersinsurance", "trust", "trv", "tt", "tube", "tui", "tunes", "tushu", "tv", "tvs", "tw", "tz", "ua", "ubank", "ubs", "ug", "uk", "unicom", "university", "uno", "uol", "ups", "us", "uy", "uz", "va", "vacations", "vana", "vanguard", "vc", "ve", "vegas", "ventures", "verisign", "versicherung", "vet", "vg", "vi", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vn", "vodka", "volkswagen", "volvo", "vote", "voting", "voto", "voyage", "vu", "vuelos", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "wf", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "ws", "wtc", "wtf", "xbox", "xerox", "xfinity", "xihuan", "xin", "xn--11b4c3d", "xn--1ck2e1b", "xn--1qqw23a", "xn--2scrj9c", "xn--30rr7y", "xn--3bst00m", "xn--3ds443g", "xn--3e0b707e", "xn--3hcrj9c", "xn--3pxu8k", "xn--42c2d9a", "xn--45br5cyl", "xn--45brj9c", "xn--45q11c", "xn--4dbrk0ce", "xn--4gbrim", "xn--54b7fta0cc", "xn--55qw42g", "xn--55qx5d", "xn--5su34j936bgsg", "xn--5tzm5g", "xn--6frz82g", "xn--6qq986b3xl", "xn--80adxhks", "xn--80ao21a", "xn--80aqecdr1a", "xn--80asehdb", "xn--80aswg", "xn--8y0a063a", "xn--90a3ac", "xn--90ae", "xn--90ais", "xn--9dbq2a", "xn--9et52u", "xn--9krt00a", "xn--b4w605ferd", "xn--bck1b9a5dre4c", "xn--c1avg", "xn--c2br7g", "xn--cck2b3b", "xn--cckwcxetd", "xn--cg4bki", "xn--clchc0ea0b2g2a9gcd", "xn--czr694b", "xn--czrs0t", "xn--czru2d", "xn--d1acj3b", "xn--d1alf", "xn--e1a4c", "xn--eckvdtc9d", "xn--efvy88h", "xn--fct429k", "xn--fhbei", "xn--fiq228c5hs", "xn--fiq64b", "xn--fiqs8s", "xn--fiqz9s", "xn--fjq720a", "xn--flw351e", "xn--fpcrj9c3d", "xn--fzc2c9e2c", "xn--fzys8d69uvgm", "xn--g2xx48c", "xn--gckr3f0f", "xn--gecrj9c", "xn--gk3at1e", "xn--h2breg3eve", "xn--h2brj9c", "xn--h2brj9c8c", "xn--hxt814e", "xn--i1b6b1a6a2e", "xn--imr513n", "xn--io0a7i", "xn--j1aef", "xn--j1amh", "xn--j6w193g", "xn--jlq480n2rg", "xn--jvr189m", "xn--kcrx77d1x4a", "xn--kprw13d", "xn--kpry57d", "xn--kput3i", "xn--l1acc", "xn--lgbbat1ad8j", "xn--mgb9awbf", "xn--mgba3a3ejt", "xn--mgba3a4f16a", "xn--mgba7c0bbn0a", "xn--mgbaakc7dvf", "xn--mgbaam7a8h", "xn--mgbab2bd", "xn--mgbah1a3hjkrd", "xn--mgbai9azgqp6j", "xn--mgbayh7gpa", "xn--mgbbh1a", "xn--mgbbh1a71e", "xn--mgbc0a9azcg", "xn--mgbca7dzdo", "xn--mgbcpq6gpa1a", "xn--mgberp4a5d4ar", "xn--mgbgu82a", "xn--mgbi4ecexp", "xn--mgbpl2fh", "xn--mgbt3dhd", "xn--mgbtx2b", "xn--mgbx4cd0ab", "xn--mix891f", "xn--mk1bu44c", "xn--mxtq1m", "xn--ngbc5azd", "xn--ngbe9e0a", "xn--ngbrx", "xn--node", "xn--nqv7f", "xn--nqv7fs00ema", "xn--nyqy26a", "xn--o3cw4h", "xn--ogbpf8fl", "xn--otu796d", "xn--p1acf", "xn--p1ai", "xn--pgbs0dh", "xn--pssy2u", "xn--q7ce6a", "xn--q9jyb4c", "xn--qcka1pmc", "xn--qxa6a", "xn--qxam", "xn--rhqv96g", "xn--rovu88b", "xn--rvc1e0am3e", "xn--s9brj9c", "xn--ses554g", "xn--t60b56a", "xn--tckwe", "xn--tiq49xqyj", "xn--unup4y", "xn--vermgensberater-ctb", "xn--vermgensberatung-pwb", "xn--vhquv", "xn--vuq861b", "xn--w4r85el8fhu5dnra", "xn--w4rs40l", "xn--wgbh1c", "xn--wgbl6a", "xn--xhq521b", "xn--xkc2al3hye2a", "xn--xkc2dl3a5ee0h", "xn--y9a3aq", "xn--yfro4i67o", "xn--ygbi2ammx", "xn--zfr164b", "xxx", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "ye", "yodobashi", "yoga", "yokohama", "you", "youtube", "yt", "yun", "za", "zappos", "zara", "zero", "zip", "zm", "zone", "zuerich", "zw", "onion"]

def remove_hastag(url):
    # Remove 'https://' or 'http://'
    head = ''
    if url.startswith('https://'):
        head = 'https://'
        url = url[8:]
    elif url.startswith('http://'):
        head = 'http://'
        url = url[7:]
    index = url.rfind('/')
    if index != -1:
        index2 = url.rfind('#')
        if index2 > index:
            url = url[:index2]
    return head + url

def get_extension(url, extensions):
    # Remove 'https://' or 'http://'
    if url.startswith('https://'):
        url = url[8:]
    elif url.startswith('http://'):
        url = url[7:]
    index = url.rfind('/')
    extension = ''
    if index != -1:
        index2 = url.rfind('.')
        if index2 > index:
            extension = url[index2+1:].lower()
            for ext in extensions:
                if extension.startswith(ext):
                    return ext
    return np.nan

def remove_not_isalnum(url):
    while len(url) > 0 and not url[-1].isalnum():
        url = url[:-1]
    while len(url) > 0 and not url[0].isalnum():
        url = url[1:]
    return url
def is_tld(url):
    # Remove 'https://' or 'http://'
    if url.startswith('https://'):
        url = url[8:]
    elif url.startswith('http://'):
        url = url[7:]
    index = url.find('/')
    if index != -1:
        url = url[:index]
    if '@' in url:
        return False
    index = url.rfind('.')
    if index != -1:
        url = url[index+1:]
        if url.lower() in tlds:
            return True
    return False
def remove_head(url):
    # Remove 'https://' or 'http://'
    if url.startswith('https://'):
        url = url[8:]
    elif url.startswith('http://'):
        url = url[7:]
    # remove 'www.'
    if url.startswith('www.'):
        url = url[4:]
    return url

def is_still_valid(url):
    # se  vuoto ritorna False
    if url == '':
        return False
    # se non ha un punto ritorna False
    if '.' not in url:
        return False
    # se ha due punti consecutivi ritorna False
    if '..' in url:
        return False
    return True

def get_links(text):
    # text = 'You can view more details at https://uibakery.io, or just ping via email. You can view more details at uibakery.io or just ping via email.'
    urls = []
    # Extract URL from a string
    url_extract_pattern = "https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)"
    urls += re.findall(url_extract_pattern, text)
    for url in urls:
        text = text.replace(url, ' ')
    url_extract_pattern = "[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)"
    urls += re.findall(url_extract_pattern, text)
    urls_cleaned = []
    for url in urls:
        if is_tld(url):
            url = remove_not_isalnum(url)
            if is_still_valid(url):
                urls_cleaned.append(url)
    return urls_cleaned
    









































def clear_html(html_string):
    def clear_tag(html_string, tag):
        if html_string.find(f'<{tag}') == -1 or html_string.find(f'</{tag}>') == -1:
            return html_string
        start = html_string.find(f'<{tag}')
        end = start + html_string[start:].find(f'</{tag}>') + len(tag)+3
        html_string = html_string[:start] + ' ' + html_string[end:]
        return html_string
    tags = ['iframe', 'template', 'script', 'style']
    for tag in tags:
        while True:
            new_html_string = clear_tag(html_string, tag)
            if new_html_string == html_string:
                break
            html_string = new_html_string
    html_string = re.sub(r'<[^>]*?>', ' ', html_string)
    html_string = re.sub(r'\s+', ' ', html_string)
    html_string = html_string.strip()
    return html_string































blockchains = [
        'bitcoin',
        'ethereum',
        'litecoin',
        'dogecoin',
        'monero',
        'dash',
        'cardano',
        'cosmos',
        'iota',
        'lisk',
        'polkadot',
        'ripple',
        'stellar',
        'neo',
        'bitcoin-cash',
        'ethereum-classic',
        'binance-smart-chain',
        'binance-beacon-chain',
        'solana',
        'tron',
        'algorand',
        'vechain'
    ]

def bitcoin(address):
    def taproot(address):
        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,89}))$'
        if re.match(schema, address) is None:
            return False
        return True
    def segwit(address):
        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,87}))$'
        if re.match(schema, address) is None:
            return False
        return True
    def script(address):
        schema = '^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$'
        if re.match(schema, address) is None:
            return False
        return True
    def legacy(address):
        schema = '^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$'
        if re.match(schema, address) is None:
            return False
        return True
    if taproot(address):
        return True
    if segwit(address):
        return True
    if script(address):
        return True
    if legacy(address):
        return True
    return False

def ethereum(address):
    schema = '^((0x)([0-9a-fA-F]{40}))$'
    if re.match(schema, address) is None:
        return False
    return True

def litecoin(address):
    schema = '^([LM3]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}||ltc1[a-z0-9]{39,59})$'
    if re.match(schema, address) is None:
        return False
    return True

def dogecoin(address):
    schema = '^D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}'
    schema2 = 'D[a-zA-Z0-9_.-]{33}'
    if re.match(schema, address) is None and re.match(schema2, address) is None:
        return False
    return True

def monero(address):
    schema = '[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}'
    if re.match(schema, address) is None:
        return False
    return True

def dash(address):
    schema = 'X[1-9A-HJ-NP-Za-km-z]{33}'
    if re.match(schema, address) is None:
        return False
    return True  

def cardano(address):
    schema = 'addr1[a-z0-9]+'
    if re.match(schema, address) is None:
        return False
    return True

def cosmos(address):
    schema = 'cosmos[a-zA-Z0-9_.-]{10,}'
    if re.match(schema, address) is None:
        return False
    return True

def iota(address):
    schema = 'iota[a-z0-9]{10,}'
    if re.match(schema, address) is None:
        return False
    return True

def lisk(address):
    schema = '[0-9]{19}L'
    if re.match(schema, address) is None:
        return False
    return True

def nem(address):
    schema = '[N][A-Za-z0-9-]{37,52}'
    if re.match(schema, address) is None:
        return False
    return True

def neo(address):
    schema = 'A[0-9a-zA-Z]{33}'
    if re.match(schema, address) is None:
        return False
    return True

def polkadot(address):
    schema = '1[0-9a-zA-Z]{47}'
    if re.match(schema, address) is None:
        return False
    return True

def ripple(address):
    schema = '^([r])([1-9A-HJ-NP-Za-km-z]{24,34})$'
    if re.match(schema, address) is None:
        return False
    return True

def stellar(address):
    schema = 'G[0-9A-Z]{40,60}'
    if re.match(schema, address) is None:
        return False
    return True

def ethereum_classic(address):
    return ethereum(address)

def binance_smart_chain(address):
    return ethereum(address)

def binance_beacon_chain(address):
    schema = '^((bnb1)[0-9a-z]{38})$'
    if re.match(schema, address) is None:
        return False
    return True

def bitcoin_cash(address):
    legacy = '[13][a-km-zA-HJ-NP-Z1-9]{33}'
    cashaddr = '((bitcoincash):)?(q|p)[a-z0-9]{41}'
    if re.match(legacy, address) is None and re.match(cashaddr, address) is None:
        return False
    return True

def solana(address):
    schema = '^[1-9A-HJ-NP-Za-km-z]{32,44}$'
    if re.match(schema, address) is None:
        return False
    return True

def tron(address):
    schema = '^((T)[a-zA-Z0-9]{33})$'
    if re.match(schema, address) is None:
        return False
    return True

def algorand(address):
    schema = '^[A-Z2-7]{58}$'
    if re.match(schema, address) is None:
        return False
    return True

def vechain(address):
    return ethereum(address)

def get_addresses(text):
    foo = {
        'bitcoin': bitcoin,
        'ethereum': ethereum,
        'litecoin': litecoin,
        'dogecoin': dogecoin,
        'monero': monero,
        'dash': dash,
        'cardano': cardano,
        'cosmos': cosmos,
        'iota': iota,
        'lisk': lisk,
        'polkadot': polkadot,
        'ripple': ripple,
        'stellar': stellar,
        'neo': neo,
        'bitcoin-cash': bitcoin_cash,
        'ethereum-classic': ethereum_classic,
        'binance-smart-chain': binance_smart_chain,
        'binance-beacon-chain': binance_beacon_chain,
        'solana': solana,
        'tron': tron,
        'algorand': algorand,
        'vechain': vechain,
    }
    crypto = {key : [] for key in foo.keys()}
    text = re.sub(r'\W', ' ', text)
    text = re.sub(r'\s+', ' ', text)
    text = text.strip()
    for address in text.split():
        for key in foo.keys():
            if foo[key](address):
                crypto[key].append(address)
    for key in crypto.keys():
        crypto[key] = list(set(crypto[key]))
    for key in crypto.copy():
        if crypto[key] == []:
            del crypto[key]
    return crypto





























def email(address):
    # remove all no alphanumeric char from the beginning and the end
    address = re.sub(r'^[^a-zA-Z0-9]*', '', address)
    address = re.sub(r'[^a-zA-Z0-9]*$', '', address)
    schema = "^[\w!#$%&'*+/=?`{|}~^-]+(?:\.[\w!#$%&'*+/=?`{|}~^-]+)*@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}$"
    if re.match(schema, address.upper()) is None:
        return None
    return address

def get_emails(text):
    emails = []
    text = re.sub(r'\s+', ' ', text)
    text = text.strip()
    for string in text.split():
        address = email(string)
        if address is not None:
            emails.append(address)
    return emails



















def foo1(x):
    if x.startswith('http://www.'):
        return x[11:]
    if x.startswith('https://www.'):
        return x[12:]
    if x.startswith('http://'):
        return x[7:]
    if x.startswith('https://'):
        return x[8:]
    return x

def foo2(x):
    return x.split('/')[0].lower()

def foo3(x):
    return x.split('.')[-1].lower()

def foo4(x):
    return '.'.join(x.split('.')[:-1]).lower()

def foo5(x):
    x = x.split('/')
    if len(x) > 1:
        y = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]
        x = '/'.join(x[1:-1])+'/'+y
        return x.strip('/')
    return np.nan

def foo6(x):
    x = x.split('/')
    if len(x) > 1:
        x = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]
        x = x.split('.')
        if len(x) > 1:
            return x[-1].lower()
    return np.nan

def get_url_info(url):
    url_df = pd.DataFrame({'url': [url]})
    url_df = get_url_df_info(url_df)
    info = {
        'apex': url_df['apex'][0],
        'domain': url_df['domain'][0],
        'tld': url_df['tld'][0],
        'path': url_df['path'][0],
        'extention': url_df['extention'][0],
        'normalized_url': url_df['normalized_url'][0],
        'normalized_url_lower': url_df['normalized_url_lower'][0],
    }
    return info 

def get_url_df_info(df):
    df['apex'] = df['url'].apply(lambda x: foo2(foo1(x)))
    df['domain'] = df['url'].apply(lambda x: foo4(foo2(foo1(x))))
    df['tld'] = df['url'].apply(lambda x: foo3(foo2(foo1(x))))
    df['path'] = df['url'].apply(lambda x: foo5(foo1(x)))
    df['extention'] = df['url'].apply(lambda x: foo6(foo1(x)))
    df['normalized_url'] = df['apex'] + '/' + df['path']
    df['normalized_url'] = df['normalized_url'].fillna(df['apex'])
    df['normalized_url_lower'] = df['normalized_url'].str.lower()
    return df

# File: https://github.com/Argonaut5000/algorand-arc19-python-example/blob/be35e0c5b48b98a74c7ae70e32531502d6a5e37d/algorand_utils.py
from itsdangerous import json


import json

"""
Striaght ripped from https://github.com/algorand/docs Algorand Dev Documentation

Thank you for the util functions!
"""

#   Utility function used to print asset holding for account and assetid
def print_asset_holding(algodclient, account, assetid):
    # note: if you have an indexer instance available it is easier to just use this
    # response = myindexer.accounts(asset_id = assetid)
    # then loop thru the accounts returned and match the account you are looking for
    account_info = algodclient.account_info(account)
    idx = 0
    for my_account_info in account_info['assets']:
        scrutinized_asset = account_info['assets'][idx]
        idx = idx + 1        
        if (scrutinized_asset['asset-id'] == assetid):
            print("Asset ID: {}".format(scrutinized_asset['asset-id']))
            print(json.dumps(scrutinized_asset, indent=4))
            break

# utility for waiting on a transaction confirmation
def wait_for_confirmation( algod_client, txid, timeout=2000):
    start_round = algod_client.status()["last-round"] + 1
    current_round = start_round

    while current_round < start_round + timeout:
        try:
            pending_txn = algod_client.pending_transaction_info(txid)
        except Exception:
            return 
        if pending_txn.get("confirmed-round", 0) > 0:
            return pending_txn
        elif pending_txn["pool-error"]:  
            raise Exception(
                'pool error: {}'.format(pending_txn["pool-error"]))
        algod_client.status_after_block(current_round)                   
        current_round += 1
    raise Exception(
        'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))


# File: https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py
#!/usr/bin/env python3

import setuptools

with open("README.md", "r") as fh:
    long_description = fh.read()

setuptools.setup(
    name="pyteal",
    version="0.27.0",
    author="Algorand",
    author_email="pypiservice@algorand.com",
    description="Algorand Smart Contracts in Python",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/algorand/pyteal",
    packages=setuptools.find_packages(
        include=(
            "feature_gates",
            "pyteal",
            "pyteal.*",
        )
    ),
    install_requires=[
        # when changing this list, also update docs/requirements.txt
        "docstring-parser==0.14.1",
        "executing==2.0.1",
        "py-algorand-sdk>=2.0.0,<3.0.0",
        "semantic-version>=2.9.0,<3.0.0",
        "tabulate>=0.9.0,<0.10.0",
    ],
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    package_data={"pyteal": ["*.pyi", "py.typed"]},
    python_requires=">=3.10",
)


# File: https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/examples/exodus.py
"""
Example of keys derivation for ed25519 or nist256p1 based coins like Exodus wallet.

Basically, Exodus always uses the secp256k1 curve to derive the BIP44 path, even for coins that are not based on secp256k1.
Then, for coins based on other curves (e.g. Algorand, Solana, Stellar, Neo ...), it uses the last derived private key as a master key to compute the public key and address.
It's not the only wallet doing this (Atomic Wallet does the same), because in this way the developers don't have to implement other derivation schemes beside secp256k1.
"""

from bip_utils import Bip32Slip10Secp256k1, Bip39SeedGenerator, Bip44, Bip44Coins, Bip44ConfGetter


# Mnemonic
mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
# Generate seed from mnemonic
seed_bytes = Bip39SeedGenerator(mnemonic).Generate()

# Example with Solana (ed25519-based coin) and Neo (nist256p1-based coin)
for coin_type in (Bip44Coins.SOLANA, Bip44Coins.NEO):
    # Get coin index from configuration
    coin_idx = Bip44ConfGetter.GetConfig(coin_type).CoinIndex()

    # Derive the standard BIP44 path using secp256k1
    bip32_ctx = Bip32Slip10Secp256k1.FromSeed(seed_bytes).DerivePath(f"m/44'/{coin_idx}'/0'/0/0")
    priv_key_bytes = bip32_ctx.PrivateKey().Raw().ToBytes()

    # Use the last private key as a master key, we can use Bip44 to simplify the address computation
    bip44_ctx = Bip44.FromPrivateKey(priv_key_bytes, coin_type)
    # Same address of Exodus
    print(f"Address for {coin_type}: {bip44_ctx.PublicKey().ToAddress()}")


# File: https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py
#Choice Coin Governance Rewards Code.
#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%
from algosdk import account, encoding, mnemonic,algod
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn
from algosdk.future.transaction import AssetFreezeTxn
from algosdk.v2client import algod
from algorand_demo import choice_trade
import json
import urllib3
choice_id  = 42771692

voter_1_address = 
voter_1_mnemonic = 
voter_1_key = mnemonic.to_private_key(voter_1_mnemonic)


def choice_trade(sender, key, receiver, amount, index,comment):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)
    #Defines an inital transaction for choice Coin
    signature = transaction.sign(key)
    #Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    return True, final



def fetch_addresses():
	http = urllib3.PoolManager()
	main = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')
	json_list = json.loads(main.data.decode('utf-8'))
	with open('data.json', 'w', encoding='utf-8') as f:
		json.dump(json_list, f, ensure_ascii=False, indent=4)
	with open('data.json') as json_file:
		data = json.load(json_file)
		transaction_data = data['transactions']

	# now we will open a file for writing
		data_file = open('file.csv', 'w')

	# create the csv writer object
		csv_writer = csv.writer(data_file)

	# Counter variable used for writing
	# headers to the CSV file
		count = 0

		for transaction in transaction_data:
		    if count == 0:

		        # Writing headers of CSV file
		        header = transaction.keys()
		        csv_writer.writerow(header)
		        count += 1

		    # Writing data of CSV file
		    csv_writer.writerow(transaction.values())

		data_file.close()

def give_rewards():
	with open('data.json', 'r') as json_file:
	    # pass the file object to reader() to get the reader object
					data = json.load(json_file)
					transaction_data = data['transactions']
					for transaction in transaction_data:
						amount = transaction["asset-transfer-transaction"]["amount"]
						amount = int(amount)
						amount = amount + amount * 0.12 #Rewards rate hardcoded
						address = transaction['sender']
						id = transaction['id']
						choice_trade(voter_1_address,voter_1_key,address,amount,choice_id,"Rewards!" + id)
fetch_addresses()
give_rewards()


# File: https://github.com/N3koSempai/searching_algorand/blob/adb01b6981504f6a9df47966cec5b30348cbaca1/search-algorand.py

from methods import online

import threading

import re
import conn
import con_postg
import report



class Coinbot():

    def __init__(self, select_coin, select_db):
        """set the initial variable"""
        #initialize the database
        if select_db == 'postgresql':
            self.db = con_postg.DB()
        else:
            self.db = conn.DB()
        self.db.start()
        self.report = report.Report()
        self.online = online.Online_method()
        if select_coin == "Algorand":
            from generators import algorand
            self.crypto = algorand.Algobot()





    def manager(self, iter, method):
        """The main method managed the iteration ,call other methods and save the result in the BD calling a Bd module"""
        #result = self.check_method_online()

        # vaiable for statistics
        temp_match = 0
        temp_nf = 0
        temp_error = 0
        temp_critical_error = 0
        #how much iterations

        if method == 'online':
            for i in range(0,iter):
                
                #make call to the api online
                keys = self.crypto.generate_keypair()
                if keys[0] == False:
                    print('critical error')
                    exit()

                result = self.online.check_method_online(keys)
                
                
                # the answer is ok
                if result[0] == 'ok':

                    #the answer have amount or assets > 0
                    print(result[1]['acuracy'])
                    if result[1]['acuracy'] == 'good':
                        self.db.added_match(200, result[1]['acuracy'], result[1]['direction'][0],result[1]['direction'][1],result[1]['amount'],result[1]['assets'])

                    elif result[1]['acuracy'] == 'bad':
                        self.db.added_match(200, result[1]['acuracy'], result[1]['direction'][0],result[1]['direction'][1])
                    temp_match = temp_match + 1
                elif result[0] == 'error_not_handler':
                    try:
                        self.db.added_error(result[1], result[2])
                    except Exception as err:
                        self.db.added_error('999', 'internal error when try to save error not handler: {miss}'.format(miss = err) )
                    temp_error = temp_error + 1
                elif result[0] == 'error':
                    if result[1] == 'not_content':
                        print('Critical error, not content found in the response of the api online \n Are you connected to internet?')
                        print('\n status code: ', result[2])
                        temp_critical_error = temp_critical_error + 1
                        #remove this
                        self.db.added_error(900, result[2])
                        
                    elif result[1] == 'Not Found':
                        #normal error when the account is new
                        #100 is for new address
                        # not make nothing for now
                        temp_nf = temp_nf + 1
                        # 
                        self.db.added_error(900, result[2])
                    
                    elif result[1] == 'undeterminate for now':
                        #900 for unidentified error

                        # !!Atention!! . THIS CONDITIONAL WORK WITH ERROR. MAKE THE SAME OF 'NOT FOUND' COINDITIONAL
                        

                        # disable for make less petition to the database. now dont save the not found results, only stdistics save
                        #print(self.db.added_error(900, result[2]['message']))
                        
                        temp_nf = temp_nf + 1


                    # Area for insert new logs
                    # determine if is the first 100 request (stadistics is save after 100 request)
                if i == 100:

                    self.db.added_std(False, temp_match,temp_nf,temp_error,temp_critical_error)
                    self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)

                    #more that 100 need update the session , not create a new session
                elif i % 100 == 0 and i > 100:

                    print(self.db.added_std(True, temp_match,temp_nf,temp_error,temp_critical_error))
                    self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)


            #send stadistics to the database when the loop is finished and iteration < 100
            if iter < 100:
                self.db.added_std(False, temp_match,temp_nf,temp_error,temp_critical_error)
                self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)

            elif iter > 100 and (iter - 1) % 100 != 0:
                self.db.added_std(True, temp_match,temp_nf,temp_error,temp_critical_error)
                self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)
            





if __name__ == "__main__":

    # options for get results in database or
    options = []
    print('Select your action \n 1. search \n 2. get report \n 3. get match \n 4. get_error')
    x = int(input('write: '))
    if x == 1:
        options.append(1)
    elif x == 2:
        options.append(2)

    elif x == 3:
        options.append(3)

    elif x == 4:
        options.append(4)
    else:
        print('error')
        exit()

    if options[0] == 1:
        print('Write the number of your objetive blockchain \n 1. Algorand ')
        x = int(input('number: '))
        if x == 1:
            options.append('Algorand')
        else:
            print('error')
            exit()

        print('Write the number of your database \n 1. postgresql \n 2. sqlite3')
        x = int(input('number: '))
        if x == 1:
            options.append('postgresql')
        elif x == 2:
            options.append('sqlite')
        else:
            print('error')
            exit()

        print('Write the number of your method \n 1. Online')
        x = int(input('number: '))
        if x == 1:
            options.append('online')
        else:
            print('error')
            exit()

        print("set the iter number")
        try:
            itern = int(input("max iter :  "))
        except:
            print("write only integer numbers")

        Coin = Coinbot(options[1],options[2])
        print(options)
        Coin.manager(itern, options[3])
        exit()


    Coin = Coinbot('Algorand','postgresql')


    if options[0] == 2:
        print(Coin.db.getter_report())
        exit()
    elif options[0] == 3:
        print(Coin.db.getter_match())
        exit()
    elif options[0] == 4:
        print(Coin.db.getter_error())
        exit()



# File: https://github.com/major/fedora-rpm-specs/blob/28cd4e4325ce70550cb235b8c2e28beefbf09fe5/specs/python-py-algorand-sdk.spec
%global pypi_name py-algorand-sdk
Name:           python-%{pypi_name}
Version:        2.8.0
Release:        1%{?dist}
Summary:        Algorand Python SDK
License:        MIT

URL:            https://github.com/algorand/py-algorand-sdk
Source0:        https://github.com/algorand/py-algorand-sdk/archive/v%{version}/py-algorand-sdk-%{version}.tar.gz
Source1:        https://raw.githubusercontent.com/algorand/py-algorand-sdk/develop/LICENSE

BuildArch:      noarch

BuildRequires:  python3-devel
BuildRequires:  python3-setuptools
BuildRequires:  python3-pynacl
BuildRequires:  python3-pycryptodomex
BuildRequires:  python3-msgpack


%description
A python library for interacting with the Algorand network.

%package -n python3-%{pypi_name}
Summary:        %{summary}

%description -n python3-%{pypi_name}
A python library for interacting with the Algorand network.

%prep
%setup -q -n %{pypi_name}-%{version}


%build
%py3_build

cp %{SOURCE1} .

%install
%py3_install

%files -n python3-%{pypi_name}
%license LICENSE
%doc README.md
%{python3_sitelib}/algosdk
%{python3_sitelib}/py_algorand_sdk-%{version}-py%{python3_version}.egg-info

%changelog
* Fri Feb 14 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.8.0-1
- 2.8.0

* Sat Jan 18 2025 Fedora Release Engineering <releng@fedoraproject.org> - 2.7.0-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_42_Mass_Rebuild

* Wed Jan 15 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.7.0-1
- 2.7.0

* Fri Jul 19 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.6.1-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_41_Mass_Rebuild

* Wed Jun 12 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.1-1
- 2.6.1

* Sat Jun 08 2024 Python Maint <python-maint@redhat.com> - 2.6.0-2
- Rebuilt for Python 3.13

* Wed Jun 05 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.0-1
- 2.6.0

* Fri Jan 26 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-3
- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild

* Mon Jan 22 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild

* Wed Sep 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.5.0-1
- 2.5.0

* Thu Aug 17 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.4.0-1
- 2.4.0

* Fri Jul 21 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.3.0-3
- Rebuilt for https://fedoraproject.org/wiki/Fedora_39_Mass_Rebuild

* Thu Jun 15 2023 Python Maint <python-maint@redhat.com> - 2.3.0-2
- Rebuilt for Python 3.12

* Wed Jun 14 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.3.0-1
- 2.3.0

* Mon May 08 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.2.0-1
- 2.2.0

* Thu Mar 23 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.2-1
- 2.1.2

* Mon Mar 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.1-1
- 2.1.1

* Wed Mar 15 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.0-1
- 2.1.0

* Fri Mar 03 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-3
- migrated to SPDX license

* Fri Jan 20 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.0.0-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_38_Mass_Rebuild

* Wed Jan 04 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-1
- 2.0.0

* Mon Dec 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.2-1
- 1.20.2

* Thu Nov 10 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.1-1
- 1.20.1

* Wed Nov 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.0-1
- 1.20.0

* Wed Oct 12 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.19.0-1
- 1.19.0

* Mon Sep 19 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.18.0-1
- 1.18.0

* Thu Aug 18 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.1-1
- 1.16.1

* Mon Jul 25 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.0-1
- 1.16.0

* Fri Jul 22 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.15.0-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_37_Mass_Rebuild

* Wed Jul 06 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.15.0-1
- 1.15.0

* Mon Jun 13 2022 Python Maint <python-maint@redhat.com> - 1.13.1-2
- Rebuilt for Python 3.11

* Thu May 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.1-1
- 1.13.1

* Mon May 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.0-1
- 1.13.0

* Thu Apr 21 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.12.0-1
- 1.12.0

* Fri Jan 21 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.8.0-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_36_Mass_Rebuild

* Wed Oct 06 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.8.0-1
- 1.8.0

* Wed Aug 04 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.7.0-1
- 1.7.0

* Fri Jul 23 2021 Fedora Release Engineering <releng@fedoraproject.org> - 1.6.0-2
- Rebuilt for https://fedoraproject.org/wiki/Fedora_35_Mass_Rebuild

* Thu Jun 24 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.6.0-1
- 1.6.0

* Fri Jun 04 2021 Python Maint <python-maint@redhat.com> - 1.5.0-2
- Rebuilt for Python 3.10

* Thu Apr 22 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.5.0-1
- 1.5.0

* Tue Mar 09 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.4.1-1
- Initial package.



# File: https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py
#!/usr/bin/env python3

import setuptools

with open("README.md", "r") as fh:
    long_description = fh.read()

setuptools.setup(
    name="pyteal",
    version="0.27.0",
    author="Algorand",
    author_email="pypiservice@algorand.com",
    description="Algorand Smart Contracts in Python",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/algorand/pyteal",
    packages=setuptools.find_packages(
        include=(
            "feature_gates",
            "pyteal",
            "pyteal.*",
        )
    ),
    install_requires=[
        # when changing this list, also update docs/requirements.txt
        "docstring-parser==0.14.1",
        "executing==2.0.1",
        "py-algorand-sdk>=2.0.0,<3.0.0",
        "semantic-version>=2.9.0,<3.0.0",
        "tabulate>=0.9.0,<0.10.0",
    ],
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    package_data={"pyteal": ["*.pyi", "py.typed"]},
    python_requires=">=3.10",
)


# File: https://github.com/algorandfoundation/docs/blob/85a8af923b2377a6037652372caad238f7f26803/scripts/import_examples.py
#!/usr/bin/env python3

import os
import textwrap
from dataclasses import dataclass

SKIP_DIRS = [".venv", "__pycache__", "node_modules"]


@dataclass
class ExampleSource:
    """Represents a source for examples"""

    #: url to the github repo
    github_url: str
    #: branch name where examples can be found
    git_branch: str
    #: where to find the local repo
    local_dir: str
    #: where to find the example files
    example_dir: str
    #: full name of language
    language_name: str
    #: what to look for as a prefix in source examples
    src_comment_flag: str
    #: what file extensions to consider
    file_extension: str
    #: name for example source
    name: str

    def doc_comment_flag(self) -> str:
        return f"<!-- ==={self.name}_"

    def clone_url(self) -> str:
        return f"{self.github_url}.git"

    def file_url(self, file_name: str) -> str:
        if file_name.startswith(self.example_path()):
            file_name = file_name[len(self.example_path()) + 1 :]

        return (
            f"{self.github_url}/blob/{self.git_branch}/{self.example_dir}/{file_name}"
        )

    def example_path(self) -> str:
        return f"{self.local_dir}/{self.example_dir}"


@dataclass
class Example:
    """Represents a tagged example in source file"""

    path: str
    line_start: int
    lines: list[str]
    matches: int


@dataclass
class DocExampleMatch:
    """Represents a match between source and docs"""

    name: str
    apply_tabs: bool
    line_start: int
    line_stop: int

    @staticmethod
    def empty() -> "DocExampleMatch":
        return DocExampleMatch("", False, 0, 0)


# Example Name => source lines
SDKExamples = dict[str, Example]

sources: list[ExampleSource] = [
    ExampleSource(
        github_url="https://github.com/algorand/py-algorand-sdk",
        git_branch="examples",
        local_dir="../../py-algorand-sdk",
        example_dir="examples",
        language_name="python",
        src_comment_flag="# example: ",
        name="PYSDK",
        file_extension=".py",
    ),
    ExampleSource(
        github_url="https://github.com/algorand/js-algorand-sdk",
        git_branch="examples",
        local_dir="../../js-algorand-sdk",
        example_dir="examples",
        language_name="javascript",
        src_comment_flag="// example: ",
        name="JSSDK",
        file_extension=".ts",
    ),
    ExampleSource(
        github_url="https://github.com/algorand/go-algorand-sdk",
        git_branch="examples",
        local_dir="../../go/src/github.com/algorand/go-algorand-sdk",
        example_dir="examples",
        language_name="go",
        src_comment_flag="\t// example: ",
        name="GOSDK",
        file_extension=".go",
    ),
    ExampleSource(
        github_url="https://github.com/algorand/java-algorand-sdk",
        git_branch="examples",
        local_dir="../../java-algorand-sdk",
        example_dir="examples",
        language_name="java",
        src_comment_flag="// example: ",
        name="JAVASDK",
        file_extension=".java",
    ),
    ExampleSource(
        github_url="https://github.com/algorand-devrel/algorand-teal-examples",
        git_branch="examples",
        local_dir="../../algorand-teal-examples",
        example_dir="examples",
        language_name="teal",
        src_comment_flag="// example: ",
        name="TEAL",
        file_extension=".teal",
    ),
    ExampleSource(
        github_url="https://github.com/barnjamin/pyteal",
        git_branch="examples",
        local_dir="../../pyteal",
        example_dir="examples",
        language_name="python",
        src_comment_flag="# example: ",
        name="PYTEAL",
        file_extension=".py",
    ),
    ExampleSource(
        github_url="https://github.com/algorand-devrel/beaker",
        git_branch="examples",
        local_dir="../../beaker",
        example_dir="examples",
        language_name="python",
        src_comment_flag="# example: ",
        name="BEAKER",
        file_extension=".py",
    ),
]


def find_examples_in_sdk(dir: str, prefix: str, lang: str, ext: str) -> SDKExamples:
    directory = os.listdir(dir)

    name_to_src: SDKExamples = {}
    for fname in directory:
        if fname in SKIP_DIRS:
            continue

        path = os.path.join(dir, fname)
        if not os.path.isfile(path):
            name_to_src |= find_examples_in_sdk(path, prefix, lang, ext)
        elif os.path.splitext(path)[-1] == ext:
            local_example: list[str] = []
            with open(path, "r") as f:
                content = f.read()
                if prefix not in content:
                    continue

                lines = content.splitlines()
                for lno, line in enumerate(lines):
                    if prefix in line:
                        name = line.strip(prefix)
                        formatted_example = textwrap.dedent(
                            "\n".join(local_example)
                        ).split("\n")
                        name_to_src[name] = Example(
                            path=path,
                            line_start=lno - len(local_example),
                            lines=formatted_example,
                            matches=0,
                        )
                        local_example = []
                    else:
                        local_example.append(line)

    return name_to_src


def replace_matches_in_docs(
    dir: str, prefix: str, examples: SDKExamples, src: ExampleSource
):
    """recursively search in directory for string prefix"""
    directory = os.listdir(dir)
    for fname in directory:
        path = os.path.join(dir, fname)
        if not os.path.isfile(path):
            # recurse through directories
            replace_matches_in_docs(path, prefix, examples, src)
            continue
        elif path[-2:] != "md":
            continue

        page_lines: list[str] = []
        matches: list[DocExampleMatch] = []
        current_match = DocExampleMatch.empty()

        with open(path, "r") as f:
            content = f.read()
            if prefix not in content:
                continue

            page_lines = content.splitlines()
            for lno, line in enumerate(page_lines):
                if prefix not in line:
                    continue

                # First time finding this one
                if current_match.name == "":
                    # Its in the tabbed multilanguage section
                    if "===" in page_lines[lno - 1]:
                        current_match.apply_tabs = True

                    current_match.name = line.strip()[len(prefix) :].strip("= ->_")
                    current_match.line_start = lno + 1
                # Second time finding it, add it to matches and wipe current
                else:
                    current_match.line_stop = lno
                    matches.append(current_match)
                    current_match = DocExampleMatch.empty()

        if len(matches) == 0:
            continue

        # Need to track the offset here so we dont write to the
        # wrong spot in the doc file if the example is longer or shorter
        # than the current set of lines in the docs
        offset = 0
        for match in matches:

            if match.name not in examples:
                print(
                    f"Missing {match.name} in {prefix.strip(' -<!=_')} "
                    f"examples (in {path}:{match.line_start})"
                )
                continue

            src_example = examples[match.name]

            example_link = (
                src.file_url(src_example.path)
                + f"#L{src_example.line_start}-"
                + f"L{src_example.line_start + len(src_example.lines)}"
            )

            example_lines = [
                "```" + src.language_name,
                *src_example.lines,
                "```",
                f"[Snippet Source]({example_link})",
            ]

            if match.apply_tabs:
                example_lines = ["\t" + l for l in example_lines]

            page_lines[
                match.line_start + offset : match.line_stop + offset
            ] = example_lines

            offset += len(example_lines) - (match.line_stop - match.line_start)

            examples[match.name].matches += 1

        with open(path, "w") as f:
            f.write("\n".join(page_lines))

    return examples


def ensure_source(src: ExampleSource):
    import git

    if not os.path.isdir(src.local_dir):
        git.Repo.clone_from(src.clone_url(), src.local_dir, branch=src.git_branch)
    else:
        repo = git.Repo(src.local_dir)
        repo.git.checkout(src.git_branch)


if __name__ == "__main__":

    names = [src.name for src in sources]

    import argparse

    parser = argparse.ArgumentParser(description="Gather examples from source repos")
    parser.add_argument(
        "--src",
        metavar="name",
        type=str,
        nargs="*",
        choices=names,
        help="source names to pull (default: all)",
    )

    args = parser.parse_args()
    choices = args.src
    if choices is None:
        choices = names

    for src in sources:
        if src.name not in choices:
            continue

        ensure_source(src)

        sdk_examples = find_examples_in_sdk(
            src.example_path(),
            src.src_comment_flag,
            src.language_name,
            src.file_extension,
        )

        replace_matches_in_docs("../docs", src.doc_comment_flag(), sdk_examples, src)

        for name, example in sdk_examples.items():
            if example.matches == 0:
                print(
                    f"Missing {name} for {src.language_name} in docs "
                    f"(in: {example.path}:{example.line_start})"
                )


# File: https://github.com/demining/CryptoDeepTools/blob/206484942dbcf4b9996fa5bcc14181138c557697/17BTCRecoverCryptoGuide/utilities/algorand_recovery.py
# A really basic Algorand seed recovery script used in an assisted recovery. (May be incorporated to BTCRecover at some time)
# Usage: Clone the py-algorand-sdk and place this file in the folder. Edit the test_seed_cut to match your seed.
# Example below uses a seed with two words missing.

from algosdk import mnemonic

test_seed = ("dumb essay favorite judge punch hood anger under "
             "talk earn anxiety follow scheme sea future response "
             "asset drum size concert sand loan cupboard above bread")

test_seed_cut = ("dumb essay favorite judge punch hood anger under "
            "talk earn anxiety follow scheme sea future response "
            "asset drum size concert sand loan cupboard")


test_address = "LZW5ASZP2DQQGM77EFFUGXUF4DUQPUJEOC5HSQ2TOXKQZQM5H6M2OGK6QY"


if __name__ == "__main__":
    word_list = mnemonic.wordlist.word_list_raw().split("\n")
    word_list2 = mnemonic.wordlist.word_list_raw().split("\n")
    print("Partial Seed: " + test_seed_cut)
    print("Searching for: " + test_address)
    for word in word_list:
        for word2 in word_list2:
            try:
                if(mnemonic.to_public_key(test_seed_cut + " " + word + " " + word2) == test_address):
                    print("Found At:")
                    print(test_seed_cut + " " + word + " " + word2)
                    print()
                    exit()
            except:
                pass


# File: https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/bip_utils/algorand/mnemonic/algorand_mnemonic_encoder.py
# Copyright (c) 2021 Emanuele Bellocchia
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

"""
Module for Algorand mnemonic encoding.
Reference: https://github.com/algorand/py-algorand-sdk
"""

# Imports
from typing import List

from bip_utils.algorand.mnemonic.algorand_entropy_generator import AlgorandEntropyGenerator
from bip_utils.algorand.mnemonic.algorand_mnemonic import AlgorandLanguages, AlgorandMnemonic
from bip_utils.algorand.mnemonic.algorand_mnemonic_utils import AlgorandMnemonicUtils
from bip_utils.bip.bip39.bip39_mnemonic_utils import Bip39WordsListGetter
from bip_utils.utils.mnemonic import Mnemonic, MnemonicEncoderBase


class AlgorandMnemonicEncoder(MnemonicEncoderBase):
    """
    Algorand mnemonic encoder class.
    It encodes bytes to the mnemonic phrase.
    """

    def __init__(self,
                 lang: AlgorandLanguages = AlgorandLanguages.ENGLISH) -> None:
        """
        Construct class.

        Args:
            lang (AlgorandLanguages, optional): Language (default: English)

        Raises:
            TypeError: If the language is not a AlgorandLanguages enum
            ValueError: If loaded words list is not valid
        """
        if not isinstance(lang, AlgorandLanguages):
            raise TypeError("Language is not an enumerative of AlgorandLanguages")
        super().__init__(lang.value, Bip39WordsListGetter)

    def Encode(self,
               entropy_bytes: bytes) -> Mnemonic:
        """
        Encode bytes to mnemonic phrase.

        Args:
            entropy_bytes (bytes): Entropy bytes

        Returns:
            Mnemonic object: Encoded mnemonic

        Raises:
            ValueError: If bytes length is not valid
        """

        # Check entropy length
        entropy_byte_len = len(entropy_bytes)
        if not AlgorandEntropyGenerator.IsValidEntropyByteLen(entropy_byte_len):
            raise ValueError(f"Entropy byte length ({entropy_byte_len}) is not valid")

        # Compute checksum word
        chksum_word_idx = AlgorandMnemonicUtils.ComputeChecksumWordIndex(entropy_bytes)
        # Convert entropy bytes to a list of word indexes
        word_indexes = AlgorandMnemonicUtils.ConvertBits(entropy_bytes, 8, 11)
        # Cannot be None by converting bytes from 8-bit to 11-bit
        assert word_indexes is not None
        # Get mnemonic
        return AlgorandMnemonic.FromList(self.__IndexesToWords(word_indexes + [chksum_word_idx]))

    def __IndexesToWords(self,
                         indexes: List[int]) -> List[str]:
        """
        Get a list of words from a list of indexes.

        Args:
            indexes (list[int]): List of indexes

        Returns:
            list[str]: List of words
        """
        return [self.m_words_list.GetWordAtIdx(idx) for idx in indexes]


# File: https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/algod.py
import json
import logging
import os
from base64 import b64encode
from pathlib import Path
from pprint import PrettyPrinter
from typing import Any, Dict, Final, Iterable, List, Optional, cast

import msgpack
from algosdk import encoding
from algosdk.atomic_transaction_composer import (
    ABI_RETURN_HASH,
    ABIResult,
    AtomicTransactionComposer,
    AtomicTransactionComposerStatus,
    AtomicTransactionResponse,
    abi,
    base64,
    error,
    transaction,
)
from algosdk.error import AlgodHTTPError
from algosdk.future.transaction import PaymentTxn, Transaction
from algosdk.v2client import algod
from pyk.kore.syntax import Pattern

from kavm import constants
from kavm.adaptors.algod_account import KAVMAccount
from kavm.adaptors.algod_transaction import KAVMTransaction
from kavm.kavm import KAVM
from kavm.scenario import KAVMScenario, _sort_dict

_LOGGER: Final = logging.getLogger(__name__)


def msgpack_decode_txn_list(enc: bytes) -> List[Transaction]:
    """
    Decode a msgpack encoded object from a string.
    Args:
        enc (str): string to be decoded
    Returns:
        []Transaction, []SignedTransaction, []Multisig, []Bid, or []SignedBid:\
            decoded object

    Note: This is the missing list decoder from py-algorand-sdk
    """
    unpacker = msgpack.Unpacker()
    unpacker.feed(enc)
    deserialized = []
    while unpacker.tell() < len(enc):
        decoded = encoding.future_msgpack_decode(unpacker.unpack())
        deserialized.append(decoded)
    return deserialized


class KAVMClient(algod.AlgodClient):
    """
    Mock class for algod. Forwards all requests to KAVM

    Instead of establishing a connection with algod:
    * initialize KAVM,
    * pretend it is algod.
    """

    def __init__(
        self,
        faucet_address: str,
        algod_token: Optional[str] = None,
        algod_address: Optional[str] = None,
        log_level: Optional[int] = None,
    ) -> None:
        super().__init__(algod_token, algod_address)
        self.pretty_printer = PrettyPrinter(width=41, compact=True)

        # self._apps = AppCellMap()
        self._committed_txns: Dict[str, Dict[str, Any]] = {}
        self._faucet_address = faucet_address
        self._accounts: Dict[str, KAVMAccount] = {
            self._faucet_address: KAVMAccount(address=faucet_address, amount=constants.FAUCET_ALGO_SUPPLY)
        }
        self._decompiled_teal_dir_path = Path('./.decompiled-teal').resolve()
        self._decompiled_teal_dir_path.mkdir(exist_ok=True)

        self._app_creators: Dict[int, str] = {}
        # Initialize KAVM, fetching the K definition dir from the environment
        definition_dir = os.environ.get('KAVM_DEFINITION_DIR')
        if definition_dir is not None:
            self.kavm = KAVM(definition_dir=Path(definition_dir))
            self.kavm.definition
        else:
            _LOGGER.critical('Cannot initialize KAVM: KAVM_DEFINITION_DIR env variable is not set')
            exit(1)

    def set_log_level(self, log_level: Any) -> None:
        """
        Set log level for algod requests
        """
        _LOGGER.setLevel(log_level)

    def algod_request(
        self,
        method: str,
        requrl: str,
        params: Optional[List[str]] = None,
        data: Optional[bytes] = None,
        headers: Optional[List[str]] = None,
        response_format: str = 'Json',
    ) -> Dict[str, Any]:
        """
        Log requests made to algod, but execute local actions instead

        Need to override this method, and the more specific methods using it can remain the same.
        """

        if method == 'GET':
            return self._handle_get_requests(requrl)
        elif method == 'POST':
            return self._handle_post_requests(requrl, data)
        else:
            raise NotImplementedError(f'{method} {requrl}')

    def _handle_get_requests(self, requrl: str) -> Dict[str, Any]:
        """
        Handle GET requests to algod with KAVM
        """
        _, endpoint, *params = requrl.split('/')

        if endpoint == 'transactions':
            if params[0] == 'params':
                return {
                    'consensus-version': 31,
                    'fee': 1000,
                    'genesis-id': 'pyteal-eval',
                    'genesis-hash': 'pyteal-evalpyteal-evalpyteal-evalpyteal-eval',
                    'last-round': 1,
                    'min-fee': 1000,
                }
            elif params[0] == 'pending':
                if len(params) >= 2:
                    try:
                        return self._committed_txns[params[1]]
                    # hack to temporarily make py-algorand-sdk happy:
                    # if the txn id is not found, return the last committed txn
                    except KeyError:
                        (_, txn) = sorted(self._committed_txns.items())[-1]
                        return txn
                else:
                    raise NotImplementedError(f'Endpoint not implemented: {requrl}')
            else:
                raise NotImplementedError(f'Endpoint not implemented: {requrl}')
        elif endpoint == 'accounts':
            if len(params) == 1:
                address = params[0]
                try:
                    return self._accounts[address].dictify()
                except KeyError:
                    _LOGGER.warning(
                        f'Account {address} is unknown to KAVM. Returing an account with the requested address and 0 balance to the client'
                    )
                    return KAVMAccount(address=address, amount=0).dictify()
            else:
                raise NotImplementedError(f'Endpoint not implemented: {requrl}')

        elif endpoint == 'applications':
            app_id = int(params[0])
            try:
                creator_address = self._app_creators[app_id]
            except KeyError as e:
                raise ValueError(f'Cannot find creator of app {app_id}') from e
            try:
                result = list(filter(lambda app: app['id'] == app_id, self._accounts[creator_address].created_apps))
                return result[0]
            except (KeyError, IndexError) as e:
                raise ValueError(
                    f'Cannot find app with id {app_id} in account {self._accounts[creator_address]}'
                ) from e
        elif endpoint == 'status':
            return {
                'catchup-time': 0,
                'last-round': 1000000000000000,
                'last-version': 'kavm',
                'next-version': 'kavm',
                'next-version-round': 0,
                'next-version-supported': True,
                'stopped-at-unsupported-round': True,
                'time-since-last-round': 0,
                'last-catchpoint': 'kavm',
                'catchpoint': 'kavm',
                'catchpoint-total-accounts': 0,
                'catchpoint-processed-accounts': 0,
                'catchpoint-verified-accounts': 0,
                'catchpoint-total-blocks': 0,
                'catchpoint-acquired-blocks': 0,
            }
        else:
            _LOGGER.debug(requrl.split('/'))
            raise NotImplementedError(f'Endpoint not implemented: {requrl}')

    def _pending_transaction_info(self, txid: int) -> Dict[str, Any]:
        """
        Fetch info about a pending transaction from KAVM

        Fow now, we return any transction as confirmed

        returns:
            PendingTransactionResponse https://github.com/algorand/go-algorand/tree/master/daemon/algod/api/algod.oas2.json#L2600

        """
        return {'confirmed-round': 1}

    def _handle_post_requests(self, requrl: str, data: Optional[bytes]) -> Dict[str, Any]:
        """
        Handle POST requests to algod with KAVM
        """
        # handle transaction group submission
        if requrl == '/transactions':
            assert data is not None, 'attempt to submit an empty transaction group!'
            # decode signed transactions from binary into py-algorand-sdk objects
            txns = [t.transaction for t in msgpack_decode_txn_list(data)]
            txn_msg = self.pretty_printer.pformat(txns)
            f'POST {requrl} {txn_msg}'
            # log decoded transaction as submitted

            return self._eval_transactions(txns)

            # _LOGGER.debug(proc_result.stdout)
            # assert False

            # return self.kavm.eval_transactions(kavm_txns, known_addresses)
        elif requrl == '/teal/compile':
            assert data is not None, 'attempt to compile an empty TEAL program!'
            # we do not actually compile the program since KAVM needs the source code
            return {'result': b64encode(data)}
        else:
            raise NotImplementedError(f'Endpoint not implemented: {requrl}')

    def intermediate_k_state(self) -> Pattern:
        # Construct a json scenario with no transactions and execute just the setup-network stage
        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=[])
        final_state, kavm_stderr = self.kavm.run_avm_json(
            scenario=scenario, existing_decompiled_teal_dir=self._decompiled_teal_dir_path, check=False, output="pretty"
        )
        return final_state

    def _eval_transactions(self, txns: List[Transaction]) -> Dict[str, str]:
        """
        Evaluate a transaction group
        Parameters
        ----------
        txns
            List[Transaction]

        Construct a simulation scenario, serialize it into JSON and submit to KAVM.
        Parse KAVM's resulting configuration and update the account state in KAVMClient.
        """

        # we'll need too keep track of all addresses the transactions mention to
        # make KAVM aware of the new ones, so we preprocess the transactions
        # to dicover new addresses and initialize them with 0 balance
        for txn in txns:
            if not txn.sender in self._accounts.keys():
                self._accounts[txn.sender] = KAVMAccount(address=txn.sender, amount=0)
            if hasattr(txn, 'receiver'):
                txn = cast(PaymentTxn, txn)
                if not txn.receiver in self._accounts.keys():
                    self._accounts[txn.receiver] = KAVMAccount(address=txn.receiver, amount=0)

        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=txns)
        self._last_scenario = scenario

        try:
            final_state, kavm_stderr = self.kavm.run_avm_json(
                scenario=scenario,
                existing_decompiled_teal_dir=self._decompiled_teal_dir_path,
            )
        except RuntimeError as e:
            _LOGGER.critical(
                f'Transaction group evaluation failed, last generated scenario was: {json.dumps(scenario.dictify(), indent=4)}'
            )
            raise AlgodHTTPError(
                msg='KAVM has failed, rerun witn --log-level=ERROR to see the executed JSON scenario'
            ) from e

        try:
            # on succeful execution, the final state will be serialized and prineted to stderr
            state_dump = json.loads(kavm_stderr)
            assert type(state_dump) is dict
        except json.decoder.JSONDecodeError as e:
            _LOGGER.critical(f'Failed to parse the final state JSON: {e}')
            raise AlgodHTTPError(msg='KAVM has failed, see logs for reasons') from e

        _LOGGER.debug(f'Successfully parsed final state JSON: {json.dumps(state_dump, indent=4)}')
        # substitute the tracked accounts by KAVM's state
        self._accounts = {}
        for acc_dict in KAVMScenario.sanitize_accounts(state_dump['accounts']):
            acc_dict_translated = {KAVMAccount.inverted_attribute_map[k]: v for k, v in acc_dict.items()}
            self._accounts[acc_dict_translated['address']] = KAVMAccount(**acc_dict_translated)
            # update app creators
            for addr, acc in self._accounts.items():
                for app in acc.created_apps:
                    self._app_creators[app['id']] = addr
        # merge confirmed transactions with the ones received from KAVM
        for txn in state_dump['transactions']:
            self._committed_txns[txn['id']] = txn['params']
        return {'txId': state_dump['transactions'][0]['id']}

    def _construct_scenario(self, accounts: Iterable[KAVMAccount], transactions: Iterable[Transaction]) -> KAVMScenario:
        """Construct a JSON simulation scenario to run on KAVM"""
        scenario = KAVMScenario.from_json(
            scenario_json_str=json.dumps(
                {
                    "stages": [
                        {"stage-type": "setup-network", "data": {"accounts": [acc.dictify() for acc in accounts]}},
                        {
                            "stage-type": "submit-transactions",
                            "data": {
                                "transactions": [
                                    KAVMTransaction.sanitize_byte_fields(_sort_dict(txn.dictify()))
                                    for txn in transactions
                                ]
                            },
                            "expected-returncode": 0,
                        },
                    ]
                }
            ),
            teal_sources_dir=self._decompiled_teal_dir_path,
        )
        return scenario


class KAVMAtomicTransactionComposer(AtomicTransactionComposer):
    """
    This class overrides the 'execute' method of the base AtomicTransactionComposer class
    by only introducing two lines of code which override the transactions IDs with
    sequential integers (converted to strings). This is a requirement of KAVM's K implementation.
    However, if a vanilla 'AlgodClient' is passed as 'clinet', the default transctions ids will be used
    to maintain compatibility with go-algorand.
    """

    def execute(self, client: algod.AlgodClient, wait_rounds: int) -> "AtomicTransactionResponse":
        """
        Send the transaction group to the network and wait until it's committed
        to a block. An error will be thrown if submission or execution fails.
        The composer's status must be SUBMITTED or lower before calling this method,
        since execution is only allowed once. If submission is successful,
        this composer's status will update to SUBMITTED.
        If the execution is also successful, this composer's status will update to COMMITTED.
        Note: a group can only be submitted again if it fails.
        Args:
            client (AlgodClient): Algod V2 client
            wait_rounds (int): maximum number of rounds to wait for transaction confirmation
        Returns:
            AtomicTransactionResponse: Object with confirmed round for this transaction,
                a list of txIDs of the submitted transactions, and an array of
                results for each method call transaction in this group. If a
                method has no return value (void), then the method results array
                will contain None for that method's return value.
        """
        if self.status > AtomicTransactionComposerStatus.SUBMITTED:  # type: ignore
            raise error.AtomicTransactionComposerError(
                "AtomicTransactionComposerStatus must be submitted or lower to execute a group"
            )

        self.submit(client)
        self.status = AtomicTransactionComposerStatus.SUBMITTED

        # HACK: override the real transaction ids with sequential integers if running with KAVM
        # leave them as is otherwise
        if isinstance(client, KAVMClient):
            self.tx_ids = [str(idx) for idx, _ in enumerate(self.txn_list)]

        resp = transaction.wait_for_confirmation(client, self.tx_ids[0], wait_rounds)

        self.status = AtomicTransactionComposerStatus.COMMITTED

        confirmed_round = resp["confirmed-round"]
        method_results = []

        for i, tx_id in enumerate(self.tx_ids):
            raw_value = None
            return_value = None
            decode_error = None
            tx_info = None

            if i not in self.method_dict:
                continue

            # Parse log for ABI method return value
            try:
                tx_info = client.pending_transaction_info(tx_id)
                if self.method_dict[i].returns.type == abi.Returns.VOID:
                    method_results.append(
                        ABIResult(
                            tx_id=tx_id,
                            raw_value=raw_value,
                            return_value=return_value,
                            decode_error=decode_error,
                            tx_info=tx_info,
                            method=self.method_dict[i],
                        )
                    )
                    continue

                logs = tx_info["logs"] if "logs" in tx_info else []

                # Look for the last returned value in the log
                if not logs:
                    raise error.AtomicTransactionComposerError("app call transaction did not log a return value")
                result = logs[-1]
                # Check that the first four bytes is the hash of "return"
                result_bytes = base64.b64decode(result)
                if len(result_bytes) < 4 or result_bytes[:4] != ABI_RETURN_HASH:
                    raise error.AtomicTransactionComposerError("app call transaction did not log a return value")
                raw_value = result_bytes[4:]
                return_value = self.method_dict[i].returns.type.decode(raw_value)
            except Exception as e:
                decode_error = e
                raise

            abi_result = ABIResult(
                tx_id=tx_id,
                raw_value=raw_value,
                return_value=return_value,
                decode_error=decode_error,
                tx_info=tx_info,
                method=self.method_dict[i],
            )
            method_results.append(abi_result)

        return AtomicTransactionResponse(
            confirmed_round=confirmed_round,
            tx_ids=self.tx_ids,
            results=method_results,
        )


# File: https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/setup.py
import setuptools


with open("README.md", "r") as f:
    long_description = f.read()

setuptools.setup(
    name="tinyman-py-sdk",
    description="Tinyman Python SDK",
    author="Tinyman",
    author_email="hello@tinyman.org",
    version="2.1.1",
    long_description=long_description,
    long_description_content_type="text/markdown",
    license="MIT",
    project_urls={
        "Source": "https://github.com/tinyman/tinyman-py-sdk",
    },
    install_requires=["py-algorand-sdk >= 1.10.0", "requests >= 2.0.0"],
    packages=setuptools.find_packages(),
    python_requires=">=3.8",
    package_data={
        "tinyman.v1": ["asc.json"],
        "tinyman.v2": ["amm_approval.map.json", "swap_router_approval.map.json"],
    },
    include_package_data=True,
)


# File: https://github.com/ChoiceCoin/Voting_DApp/blob/1cd5d81c8c6c96fdb542e399e184abe1512a2045/rewards/rewards.py
# Choice Coin Governance Rewards Code.

from algosdk import account, encoding, mnemonic,algod
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn
from algosdk.future.transaction import AssetFreezeTxn
from algosdk.v2client import algod
import json
import urllib3

choice_id  = 297995609
voter_1_address = ""
voter_1_mnemonic = ""
voter_1_key = mnemonic.to_private_key(voter_1_mnemonic)

algod_client = algod.AlgodClient(
    algod_token="",
    algod_address="https://api.algoexplorer.io",
    # see https://github.com/algorand/py-algorand-sdk/issues/169
    headers={"User-Agent": "DoYouLoveMe?"}

def choice_trade(sender, key, receiver, amount, index,comment):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)
    #Defines an inital transaction for choice Coin
    signature = transaction.sign(key)
    #Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    return True, final

def fetch_addresses():
	http = urllib3.PoolManager()
	main = http.request('GET','')
	json_list = json.loads(main.data.decode('utf-8'))
	with open('data.json', 'w', encoding='utf-8') as f:
		json.dump(json_list, f, ensure_ascii=False, indent=4)
	with open('data.json') as json_file:
		data = json.load(json_file)
		transaction_data = data['transactions']
		data_file = open('file.csv', 'w')
		csv_writer = csv.writer(data_file)
		count = 0
		for transaction in transaction_data:
		    if count == 0:
		        header = transaction.keys()
		        csv_writer.writerow(header)
		        count += 1
		    csv_writer.writerow(transaction.values())

		data_file.close()

def give_rewards():
	with open('data.json', 'r') as json_file:
		data = json.load(json_file)
		transaction_data = data['transactions']
		for transaction in transaction_data:
			amount = transaction["asset-transfer-transaction"]["amount"]
			amount = int(amount)
			amount = amount + amount * 0.186 #Edit to match percentage
			address = transaction['sender']
			id = transaction['id']
			choice_trade(voter_1_address,voter_1_key,address,amount,choice_id,"Rewards!" + id)
fetch_addresses()
give_rewards()


# File: https://github.com/algorand/indexer/blob/f64303b6b373ac30d57577f056e3dad8e956a009/misc/liveindextest.py
#!/usr/bin/env python3
#
# usage:
#  python3 misc/liveindextest.py
#
# Requires go-algorand to be checked out on GOPATH.
# Requires local postgresql and `createdb` `dropdb` standard utils.
# `goal` etc should be built on PATH
# `algorand-indexer` can be installed on PATH or at its development location from `make` or `go build` at cmd/algorand-indexer/algorand-indexer
# pip install py-algorand-sdk
#
# The Test:
# Create a local private Algorand network
# Create a temporary postgres database for indexer
# Run indexer following the primary algod
# Submit a txn using py-algorand-sdk
# Checks that indexer reports that txn by searching for it by txid.
#
# Runs in about 30 seconds on my macbook

import atexit
import base64
import glob
import logging
import os
import random
import shutil
import subprocess
import sys
import tempfile
import threading
import time

import algosdk
import algosdk.v2client

from e2e_common.util import xrun, atexitrun, find_indexer, ensure_test_db

logger = logging.getLogger(__name__)


def find_go_algorand():
    gopath = os.getenv("GOPATH")
    for path in gopath.split(":"):
        goa = os.path.join(path, "src", "github.com", "algorand", "go-algorand")
        if os.path.isdir(goa):
            return goa
    return None


already_stopped = False
already_deleted = False


def goal_network_stop(netdir, normal_cleanup=False):
    global already_stopped, already_deleted
    if already_stopped or already_deleted:
        return

    logger.info("stop network in %s", netdir)
    try:
        xrun(["goal", "network", "stop", "-r", netdir], timeout=10)
    except Exception as e:
        logger.error("error stopping network", exc_info=True)
        if normal_cleanup:
            raise e
    already_stopped = True


def openkmd(algodata):
    kmdnetpath = sorted(glob.glob(os.path.join(algodata, "kmd-*", "kmd.net")))[-1]
    kmdnet = open(kmdnetpath, "rt").read().strip()
    kmdtokenpath = sorted(glob.glob(os.path.join(algodata, "kmd-*", "kmd.token")))[-1]
    kmdtoken = open(kmdtokenpath, "rt").read().strip()
    kmd = algosdk.kmd.KMDClient(kmdtoken, "http://" + kmdnet)
    return kmd


def openalgod(algodata):
    algodnetpath = os.path.join(algodata, "algod.net")
    algodnet = open(algodnetpath, "rt").read().strip()
    algodtokenpath = os.path.join(algodata, "algod.token")
    algodtoken = open(algodtokenpath, "rt").read().strip()
    algod = algosdk.algod.AlgodClient(algodtoken, "http://" + algodnet)
    return algod


class RunContext:
    def __init__(self, env):
        self.env = env
        self.kmd = None
        self.algod = None
        self.lock = threading.Lock()
        self.pubw = None
        self.maxpubaddr = None

    def connect(self):
        with self.lock:
            self._connect()
            return self.algod, self.kmd

    def _connect(self):
        if self.algod and self.kmd:
            return
        # should run from inside self.lock
        xrun(["goal", "kmd", "start", "-t", "200"], env=self.env, timeout=5)
        algodata = self.env["ALGORAND_DATA"]
        self.kmd = openkmd(algodata)
        self.algod = openalgod(algodata)

    def get_pub_wallet(self):
        with self.lock:
            self._connect()
            if not (self.pubw and self.maxpubaddr):
                # find private test node public wallet and its richest account
                wallets = self.kmd.list_wallets()
                pubwid = None
                for xw in wallets:
                    if xw["name"] == "unencrypted-default-wallet":
                        pubwid = xw["id"]
                pubw = self.kmd.init_wallet_handle(pubwid, "")
                pubaddrs = self.kmd.list_keys(pubw)
                pubbalances = []
                maxamount = 0
                maxpubaddr = None
                for pa in pubaddrs:
                    pai = self.algod.account_info(pa)
                    if pai["amount"] > maxamount:
                        maxamount = pai["amount"]
                        maxpubaddr = pai["address"]
                self.pubw = pubw
                self.maxpubaddr = maxpubaddr
            return self.pubw, self.maxpubaddr

    def do_txn(self):
        pubw, maxpubaddr = self.get_pub_wallet()
        algod, kmd = self.connect()

        # create a wallet with an addr to send to
        walletname = base64.b16encode(os.urandom(16)).decode()
        winfo = kmd.create_wallet(walletname, "")
        handle = kmd.init_wallet_handle(winfo["id"], "")
        addr = kmd.generate_key(handle)

        # send one million Algos to the test wallet's account
        params = algod.suggested_params()
        round = params["lastRound"]
        txn = algosdk.transaction.PaymentTxn(
            sender=maxpubaddr,
            fee=params["minFee"],
            first=round,
            last=round + 100,
            gh=params["genesishashb64"],
            receiver=addr,
            amt=1000000000000,
            flat_fee=True,
        )
        stxn = kmd.sign_transaction(pubw, "", txn)
        txid = algod.send_transaction(stxn)
        for i in range(50):
            txinfo = algod.pending_transaction_info(txid)
            if txinfo.get("round"):
                break
            time.sleep(0.1)
        return txid, txinfo


def main():
    start = time.time()
    import argparse

    ap = argparse.ArgumentParser()
    ap.add_argument("--go-algorand", help="path to go-algorand checkout")
    ap.add_argument(
        "--keep-temps",
        default=False,
        action="store_true",
        help="if set, keep all the test files",
    )
    ap.add_argument(
        "--indexer-bin",
        default=None,
        help="path to algorand-indexer binary, otherwise search PATH",
    )
    ap.add_argument(
        "--indexer-port",
        default=None,
        type=int,
        help="port to run indexer on. defaults to random in [4000,30000]",
    )
    ap.add_argument(
        "--connection-string",
        help="Use this connection string instead of attempting to manage a local database.",
    )
    ap.add_argument("--verbose", default=False, action="store_true")
    args = ap.parse_args()
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    indexer_bin = find_indexer(args.indexer_bin)
    goalgorand = args.go_algorand or find_go_algorand()

    # env for child processes
    env = dict(os.environ)

    tempdir = os.getenv("TEMPDIR")
    if not tempdir:
        tempdir = tempfile.mkdtemp()
        env["TEMPDIR"] = tempdir
        logger.info("created TEMPDIR %r", tempdir)
        if not args.keep_temps:
            # If we created a tmpdir and we're not keeping it, clean it up.
            # If an outer process specified $TEMPDIR, let them clean it up.
            atexit.register(shutil.rmtree, tempdir, onerror=logger.error)
        else:
            atexit.register(
                print, "keeping temps. to clean up:\nrm -rf {}".format(tempdir)
            )

    netdir = os.path.join(tempdir, "net")
    env["NETDIR"] = netdir

    template = os.path.join(
        goalgorand, "test/testdata/nettemplates/TwoNodes50EachFuture.json"
    )
    xrun(
        ["goal", "network", "create", "-r", netdir, "-n", "tbd", "-t", template],
        timeout=30,
    )
    xrun(["goal", "network", "start", "-r", netdir], timeout=30)
    atexit.register(goal_network_stop, netdir)

    algodata = os.path.join(netdir, "Node")
    env["ALGORAND_DATA"] = algodata

    psqlstring = ensure_test_db(args.connection_string, args.keep_temps)
    primary = os.path.join(netdir, "Primary")
    aiport = args.indexer_port or random.randint(4000, 30000)
    indexer_token = "security-theater"
    indexerp = subprocess.Popen(
        [
            indexer_bin,
            "daemon",
            "--algod",
            primary,
            "--postgres",
            psqlstring,
            "--dev-mode",
            "--server",
            ":{}".format(aiport),
            "--token",
            indexer_token,
        ]
    )
    atexit.register(indexerp.kill)

    rc = RunContext(env)
    txid, txinfo = rc.do_txn()
    logger.debug("submitted txid %s, %r", txid, txinfo)

    indexer = algosdk.v2client.indexer.IndexerClient(
        indexer_token, "http://localhost:{}".format(aiport)
    )
    ok = False
    retcode = 1
    for i in range(30):
        result = indexer.search_transactions(txid=txid)
        logger.debug("seacrh_transactions: %r", result)
        they = result.get("transactions")
        if they and they[0].get("confirmed-round"):
            logger.info("OK: Got txn")
            ok = True
            retcode = 0
            break
        time.sleep(1.0)

    dt = time.time() - start
    ok = (ok and "OK") or "FAIL"
    sys.stdout.write("indexer live test {} ({:.1f}s)\n".format(ok, dt))
    return retcode


if __name__ == "__main__":
    sys.exit(main())


# File: https://github.com/peterkrull/algorand_vanity_farm/blob/16dcbc387892798e1522d3dda39118f990f51ad4/vanity_browse.py
# vanity_browser.py - lets you browse through the addresses found with vanity_farmer.py
#
# Depends on py-algorand-sdk which can be installed with:
#
# pip3 install py-algorand-sdk
#
# If you don't have pip3 you can install it with:
#
# apt install python3-pip

import json
import algosdk

def program():
    open_file()
    present_names()
    user_input = present_publics()
    present_privates(user_input)

def open_file():
    global file_data
    file_data = ""
    try:
        file_data = json.load(open("vanity_addresses",'r'))
    except FileNotFoundError as e:
        print("No 'vanity_addresses' file found, exiting.")
        exit()

def present_names():
    print("The following vanity addresses were generated.")
    print("Type the name of a vanity to view the addresses.")
    print("")
    names = []
    for vanity in file_data:
        names.append(vanity)
    for i in range(len(names)):
        length = []
        try:
            length.append(len(file_data[names[i]]["A"]))
        except KeyError:
            pass
        try:
            length.append(len(file_data[names[i]]["E"]))
        except KeyError:
            pass
        try:
            length.append(len(file_data[names[i]]["B"]))
        except KeyError:
            pass

        sum_is = 0
        for g in range(len(length)):
            sum_is += length[g]
        print("Found :",names[i],sum_is,"times")

def present_publics():
    user_input = input().upper()
    names = []
    print("")
    if user_input not in file_data:
        print("The vanity '",user_input,"' was not an option. Exiting.",sep="")
        exit() 
    for vanity in file_data:
        names.append(vanity)
        if user_input == vanity:
            try:
                temp = file_data[vanity]["A"]
                print("\nVanity addresses with '"+vanity+"' anywhere.")
                for i in range(len(temp)):
                    print("A"+str(i)+":",temp[str(i)]["public key"])
            except KeyError:
                pass

            try:
                temp = file_data[vanity]["E"]
                print("\nVanity addresses with '"+vanity+"' at the end.")
                for i in range(len(temp)):
                    print("E"+str(i)+":",temp[str(i)]["public key"])
            except KeyError:
                pass

            try:
                temp = file_data[vanity]["B"]
                print("\nVanity addresses with '"+vanity+"' at the beginning.")
                for i in range(len(temp)):
                    print("B"+str(i)+":",temp[str(i)]["public key"])
            except KeyError:
                pass
            
    return user_input

def present_privates(vanity):
    print("\nPlease type the letter and number in front your wanted address.")
    user_input = input()
    try:
        key = file_data[vanity][str(user_input[0]).upper()][str(user_input[1:])]["private key"]
        print("\nThe private mnemonic will now be shown. Make sure noone is watching")
        print("Press the enter key to continue")
        user_input_2 = input()
        if user_input_2 != None:
            print("--------------------------------------------------------------")
            print(algosdk.mnemonic.from_private_key(key))
            print("\n",key,sep="")
            print("--------------------------------------------------------------")
            print("\nREMEMBER! Keep these safe and private. Anyone with your keys can spend your money.")
            print("It is advised to write the mnemonic on a piece of paper and hide it somewhere safe.")
            print("")
            print("Press the enter key to exit program.")
        user_input_2 = input()
        if user_input_2 != None:
            pass
            
    except KeyError as e:
        print("The input {} was not an option. Exiting.".format(e))
    except IndexError as e:
         print("No valid input was given. Exiting.")

program()

# File: https://github.com/AustP/arc72/blob/7e67dd5486a1dd98ffc20b9f1063da7cd9869a1a/arc72.py
from pathlib import Path

from Crypto.Hash import SHA512
from pyteal import *
from pyteal.ast.expr import Expr
from pyteal.ir import TealSimpleBlock

version = "v0.5.0"

################################################################################
# Constants
################################################################################


HI4GE = Addr("HI4GEV4ZU32TGWUPKC5FKNCK6DZOLX2RRX4BVB3QG6WUHQ2UAS4GM3CN5U")
LAUNCH = Addr("LAUNCHPHD5NWWTDNVHOCFORJRFQYSY7UJWRF6A35LYMIDG4QHSHLGTMIEY")

BOOL_FALSE = Bytes("base16", "0x00")
BOOL_TRUE = Bytes("base16", "0x80")

BYTES_ONE = Bytes("base16", "0x01")
BYTES_ZERO = Bytes("base16", "0x00")

EVENT_APPROVAL = "arc72_Approval(address,address,uint256)"
EVENT_APPROVAL_FOR_ALL = "arc72_ApprovalForAll(address,address,bool)"
EVENT_MINT = "highforge_Mint(address,uint256,uint64,uint64,uint64)"
EVENT_REVEAL = "highforge_Reveal(uint256,byte[256])"
EVENT_TRANSFER = "arc72_Transfer(address,address,uint256)"
EVENT_UPDATE_URI = "highforge_UpdateURI(uint256,byte[256])"

INTERFACE_ARC72_CORE = Bytes("base16", "0x53f02a40")
INTERFACE_ARC72_ENUMERATION = Bytes("base16", "0xa57d4679")
INTERFACE_ARC72_MANAGEMENT = Bytes("base16", "0xb9c6f696")
INTERFACE_ARC72_METADATA = Bytes("base16", "0xc3c1fc00")
INTERFACE_MASK = Bytes("base16", "0xffffffff")
INTERFACE_SUPPORTS_INTERFACE = Bytes("base16", "0x4e22a3ba")

PREFIX_RETURN = Bytes("base16", "0x151f7c75")

LENGTH_ADDRESS = Int(32)
LENGTH_BALANCE_BOX = Int(32)
LENGTH_BOOL = Int(1)
LENGTH_INDEX_BOX = Int(32)
LENGTH_METADATA_URI = Int(256)
LENGTH_NFT_BOX = Int(320)
LENGTH_UINT256 = Int(32)
LENGTH_UINT64 = Int(8)
LENGTH_UINT8 = Int(1)

MIN_BALANCE_APPROVAL_BOX = Int(2500 + (((2 * 32) + 1) * 400))
MIN_BALANCE_INDEX_BOX = Int(2500 + (((1 + 32) + 32) * 400))
MIN_BALANCE_NFT_BOX = Int(2500 + (((1 + 32) + 320) * 400))
MIN_BALANCE_BALANCE_BOX = Int(2500 + (((1 + 32) + 32) * 400))

LAUNCH_FEES = Global.min_txn_fee()

################################################################################
# Helper Functions
################################################################################


class ABI_Method:
    def __init__(self, abi, handler):
        self._abi = abi
        self._handler = handler

        self._signature = (
            abi["name"]
            + "("
            + ",".join([arg["type"] for arg in abi["args"]])
            + ")"
            + abi["returns"]["type"]
        )
        self.selector = abi_method(self._signature)

        print(abi["name"], self.selector)

    def handler(self):
        args = {}
        commands = []

        length_map = {
            "account": LENGTH_UINT8,
            "address": LENGTH_ADDRESS,
            "asset": LENGTH_UINT8,
            "bool": LENGTH_BOOL,
            "byte[4]": Int(4),
            "byte[256]": Int(256),
            "uint256": LENGTH_UINT256,
            "uint64": LENGTH_UINT64,
        }

        for i, arg in enumerate(self._abi["args"]):
            args[arg["name"]] = ScratchVar(
                TealType.uint64 if arg["type"] == "asset" else TealType.bytes
            )

            commands.append(
                Assert(Len(Txn.application_args[i + 1]) == length_map[arg["type"]])
            )
            commands.append(
                args[arg["name"]].store(
                    Txn.accounts[Btoi(Txn.application_args[i + 1])]
                    if arg["type"] == "account"
                    else (
                        Txn.assets[Btoi(Txn.application_args[i + 1])]
                        if arg["type"] == "asset"
                        else Txn.application_args[i + 1]
                    )
                )
            )

        return Seq(
            *commands,
            self._handler(args),
        )


class EmptyExpr(Expr):
    def __str__(self):
        return ""

    def __teal__(self, _):
        start = TealSimpleBlock([])
        end = start
        return start, end

    def has_return(self):
        return False

    def type_of(self):
        return TealType.none


class NFT(EmptyExpr):
    # NFT Box Structure
    # owner - 32 bytes
    # operator - 32 bytes
    # metadata_uri - 256 bytes
    box_length = LENGTH_NFT_BOX

    field_indices = {
        "owner": Int(0),
        "operator": Int(32),
        "metadata_uri": Int(64),
    }

    field_lengths = {
        "owner": LENGTH_ADDRESS,
        "operator": LENGTH_ADDRESS,
        "metadata_uri": LENGTH_METADATA_URI,
    }

    def __init__(self, token_id):
        self.box_name = Concat(Bytes("n"), token_id)
        self.token_id = token_id

    def _emit(self, event, bytes):
        return abi_event(event, bytes)

    def approve(self, operator):
        return Seq(
            self.set("operator", operator),
            self.emit_approval(self.get("owner"), operator),
        )

    def burn(self):
        owner = ScratchVar(TealType.bytes)

        return Seq(
            owner.store(self.get("owner")),
            self.transfer(owner.load(), Global.zero_address()),
            Assert(App.box_delete(self.box_name)),
            send_algo(MIN_BALANCE_NFT_BOX, owner.load()),
        )

    def create(self, owner):
        return Seq(
            # create the NFT
            Assert(Not(self.exists())),
            Assert(App.box_create(self.box_name, self.box_length)),
            self.transfer(Global.zero_address(), owner),
        )

    def emit_approval(self, owner, approved):
        return self._emit(EVENT_APPROVAL, Concat(owner, approved, self.token_id))

    def emit_transfer(self, from_, to):
        return self._emit(
            EVENT_TRANSFER,
            Concat(
                from_,
                to,
                self.token_id,
            ),
        )

    def exists(self):
        return Seq(length := App.box_length(self.box_name), length.hasValue())

    def get(self, key):
        return App.box_extract(
            self.box_name, self.field_indices[key], self.field_lengths[key]
        )

    def is_revealed(self):
        return self.get("metadata_uri") != BytesZero(LENGTH_METADATA_URI)

    def set(self, key, value):
        return Seq(
            Assert(Len(value) == self.field_lengths[key]),
            App.box_replace(self.box_name, self.field_indices[key], value),
        )

    def transfer(self, from_, to):
        return Seq(
            self.set("owner", to),
            self.set("operator", Global.zero_address()),
            If(
                from_ != Global.zero_address(),
                Seq(
                    contents := App.box_get(Concat(Bytes("b"), from_)),
                    Assert(contents.hasValue()),
                    App.box_put(
                        Concat(Bytes("b"), from_),
                        Btou256(BytesMinus(contents.value(), BYTES_ONE)),
                    ),
                ),
            ),
            Seq(
                contents := App.box_get(Concat(Bytes("b"), to)),
                App.box_put(
                    Concat(Bytes("b"), to),
                    Btou256(
                        BytesAdd(
                            If(contents.hasValue(), contents.value(), BYTES_ZERO),
                            BYTES_ONE,
                        )
                    ),
                ),
            ),
            self.emit_transfer(from_, to),
        )


def Btou256(bytes):
    return Concat(BytesZero(LENGTH_UINT256 - Len(bytes)), bytes)


def Itou256(int):
    return Concat(BytesZero(LENGTH_UINT256 - LENGTH_UINT64), Itob(int))


def U256toi(bytes):
    return Btoi(Extract(bytes, LENGTH_UINT256 - LENGTH_UINT64, LENGTH_UINT64))


def abi_event(signature, bytes):
    return Log(Concat(abi_method(signature), bytes))


def abi_method(signature):
    hash = SHA512.new(truncate="256")
    hash.update(signature.encode("utf-8"))
    selector = hash.hexdigest()[0:8]
    return Bytes("base16", "0x" + selector)


def abi_return(bytes=None):
    return (
        Seq(
            Log(Concat(PREFIX_RETURN, bytes)),
            Approve(),
        )
        if bytes is not None
        else Approve()
    )


def assert_is_creator():
    return Assert(Txn.sender() == Global.creator_address())


def assert_is_launch():
    return Assert(Txn.sender() == LAUNCH)


@Subroutine(TealType.none)
def assert_mint_funding(index):
    return Assert(
        is_algo_txn(
            index,
            MIN_BALANCE_NFT_BOX  # for NFT storage
            + MIN_BALANCE_INDEX_BOX  # for NFT lookup by index
            + LAUNCH_FEES,  # to pay for LAUNCH's txn fees
            Global.current_application_address(),
        )
    )


@Subroutine(TealType.none)
def build_send_asset(assetID, amount, receiver):
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.SetField(TxnField.xfer_asset, assetID),
        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),
        InnerTxnBuilder.SetField(TxnField.asset_receiver, receiver),
    )


def closeout_algo(receiver):
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.SetField(TxnField.amount, Int(0)),
        InnerTxnBuilder.SetField(TxnField.close_remainder_to, receiver),
        InnerTxnBuilder.SetField(TxnField.receiver, receiver),
        InnerTxnBuilder.Submit(),
    )


@Subroutine(TealType.none)
def closeout_asset_to_creator(assetID):
    assetCreator = AssetParam.creator(assetID)

    return Seq(
        assetCreator,
        build_send_asset(assetID, Int(0), assetCreator.value()),
        InnerTxnBuilder.SetField(TxnField.asset_close_to, assetCreator.value()),
        InnerTxnBuilder.Submit(),
    )


def closeout_asset(assetID, receiver):
    return Seq(
        build_send_asset(assetID, Int(0), receiver),
        InnerTxnBuilder.SetField(TxnField.asset_close_to, receiver),
        InnerTxnBuilder.Submit(),
    )


def create_asset(assetName, unitName, total, assetURL, hash, manager, reserve):
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetConfig),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.SetField(TxnField.config_asset_total, total),
        InnerTxnBuilder.SetField(TxnField.config_asset_decimals, Int(0)),
        InnerTxnBuilder.SetField(TxnField.config_asset_name, assetName),
        InnerTxnBuilder.SetField(
            TxnField.config_asset_unit_name,
            unitName,
        ),
        InnerTxnBuilder.SetField(TxnField.config_asset_url, assetURL),
        InnerTxnBuilder.SetField(TxnField.config_asset_metadata_hash, hash),
        InnerTxnBuilder.SetField(TxnField.config_asset_manager, manager),
        InnerTxnBuilder.SetField(TxnField.config_asset_reserve, reserve),
        InnerTxnBuilder.Submit(),
    )


def distribute_payments(assetID, total):
    artistAmount = ScratchVar(TealType.uint64)
    charityAmount = ScratchVar(TealType.uint64)
    launchpadAmount = ScratchVar(TealType.uint64)

    return Seq(
        # figure out how much charity gets
        charityAmount.store(
            If(
                And(
                    App.globalGet(Bytes("charityAddress"))
                    != Global.current_application_address(),
                    App.globalGet(Bytes("charityPoints")) > Int(0),
                ),
                get_cut(total, App.globalGet(Bytes("charityPoints"))),
                Int(0),
            )
        ),
        # figure out how much the launchpad gets
        launchpadAmount.store(get_cut(total, App.globalGet(Bytes("launchpadFee")))),
        artistAmount.store(total - launchpadAmount.load()),
        If(
            assetID == Int(0),
            Seq(
                # only payout to charity if it doesn't cause any errors
                If(
                    And(
                        charityAmount.load(),
                        artistAmount.load() >= charityAmount.load(),
                        Or(
                            charityAmount.load() >= Global.min_balance(),
                            Balance(App.globalGet(Bytes("charityAddress")))
                            >= Global.min_balance(),
                        ),
                    ),
                    Seq(
                        artistAmount.store(artistAmount.load() - charityAmount.load()),
                        send_algo(
                            charityAmount.load(), App.globalGet(Bytes("charityAddress"))
                        ),
                    ),
                ),
                send_algo(artistAmount.load(), Global.creator_address()),
                send_algo(launchpadAmount.load(), HI4GE),
            ),
            Seq(
                # only payout to charity if it doesn't cause any errors
                If(
                    And(
                        charityAmount.load(),
                        artistAmount.load() >= charityAmount.load(),
                        Seq(
                            opted_in := AssetHolding.balance(
                                App.globalGet(Bytes("charityAddress")),
                                assetID,
                            ),
                            opted_in.hasValue(),
                        ),
                    ),
                    Seq(
                        artistAmount.store(artistAmount.load() - charityAmount.load()),
                        send_asset(
                            assetID,
                            charityAmount.load(),
                            App.globalGet(Bytes("charityAddress")),
                        ),
                    ),
                ),
                send_asset(
                    assetID,
                    artistAmount.load(),
                    Global.creator_address(),
                ),
                send_asset(assetID, launchpadAmount.load(), HI4GE),
            ),
        ),
    )


@Subroutine(TealType.uint64)
def get_cut(total, points):
    return Btoi(BytesDiv(BytesMul(Itob(total), Itob(points)), Itob(Int(10000))))


@Subroutine(TealType.uint64)
def is_algo_txn(index, amount, receiver):
    return And(
        Gtxn[index].type_enum() == TxnType.Payment,
        Gtxn[index].close_remainder_to() == Global.zero_address(),
        Gtxn[index].rekey_to() == Global.zero_address(),
        Gtxn[index].amount() == amount,
        Gtxn[index].receiver() == receiver,
    )


@Subroutine(TealType.uint64)
def is_asset_txn(index, assetID, amount, receiver):
    return And(
        Gtxn[index].type_enum() == TxnType.AssetTransfer,
        Gtxn[index].asset_close_to() == Global.zero_address(),
        Gtxn[index].rekey_to() == Global.zero_address(),
        Gtxn[index].xfer_asset() == assetID,
        Gtxn[index].asset_amount() == amount,
        Gtxn[index].asset_receiver() == receiver,
    )


def is_noop_txn(index, appID, method):
    return And(
        Gtxn[index].type_enum() == TxnType.ApplicationCall,
        Gtxn[index].rekey_to() == Global.zero_address(),
        Gtxn[index].application_id() == appID,
        Gtxn[index].on_completion() == OnComplete.NoOp,
        Gtxn[index].application_args[0] == method,
    )


@Subroutine(TealType.bytes)
def nibble_to_ascii(nibble):
    return Extract(
        Itob(If(nibble < Int(10), Int(48) + nibble, Int(87) + nibble)), Int(7), Int(1)
    )


def optin_asset(assetID):
    return Seq(
        build_send_asset(assetID, Int(0), Global.current_application_address()),
        InnerTxnBuilder.Submit(),
    )


@Subroutine(TealType.none)
def send_algo(amount, receiver):
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.SetField(TxnField.amount, amount),
        InnerTxnBuilder.SetField(TxnField.receiver, receiver),
        InnerTxnBuilder.Submit(),
    )


@Subroutine(TealType.none)
def send_algo_cover_fee(amount, receiver):
    return If(
        And(
            amount > Global.min_txn_fee(),
            Balance(receiver) + amount - Global.min_txn_fee() >= Global.min_balance(),
        ),
        Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),
            InnerTxnBuilder.SetField(TxnField.amount, amount - Global.min_txn_fee()),
            InnerTxnBuilder.SetField(TxnField.fee, Global.min_txn_fee()),
            InnerTxnBuilder.SetField(TxnField.receiver, receiver),
            InnerTxnBuilder.Submit(),
        ),
    )


def send_asset(assetID, amount, receiver):
    return Seq(build_send_asset(assetID, amount, receiver), InnerTxnBuilder.Submit())


def sha_to_token_id(sha256):
    byte = ScratchVar(TealType.uint64)
    i = ScratchVar(TealType.uint64)
    value = ScratchVar(TealType.bytes)

    # todo:
    # for each byte,
    # mod it by 10
    # convert that to ascii
    # should be 32 bytes long
    return Seq(
        value.store(Bytes("")),
        i.store(Int(0)),
        While(i.load() < Int(16)).Do(
            Seq(
                byte.store(GetByte(sha256, i.load())),
                value.store(
                    Concat(
                        value.load(),
                        nibble_to_ascii(byte.load() / Int(16)),
                        nibble_to_ascii(byte.load() & Int(15)),
                    )
                ),
                i.store(i.load() + Int(1)),
            )
        ),
        value.load(),
    )


################################################################################
# NoOp Branches
################################################################################


def on_claim_algo():
    claimableAlgo = Balance(Global.current_application_address()) - MinBalance(
        Global.current_application_address()
    )

    return Seq(
        assert_is_creator(),
        send_algo(claimableAlgo, Global.creator_address()),
        Approve(),
    )


def on_claim_asset(assetID):
    amount = AssetHolding.balance(Global.current_application_address(), assetID)

    return Seq(
        assert_is_creator(),
        amount,
        send_asset(
            assetID,
            amount.value(),
            Global.creator_address(),
        ),
        Approve(),
    )


def on_claim_wl_alt():
    return on_claim_asset(App.globalGet(Bytes("wlAltID")))


def on_claim_wl_token():
    return on_claim_asset(App.globalGet(Bytes("wlTokenID")))


def on_disable_whitelist():
    return Seq(
        assert_is_creator(),
        If(
            App.globalGet(Bytes("wlAltID")),
            closeout_asset_to_creator(App.globalGet(Bytes("wlAltID"))),
        ),
        App.globalPut(Bytes("wlLaunchStart"), Int(0)),
        App.globalPut(Bytes("wlTokenID"), Int(0)),
        App.globalPut(Bytes("wlPrice"), Int(0)),
        App.globalPut(Bytes("wlAltID"), Int(0)),
        App.globalPut(Bytes("wlAltPrice"), Int(0)),
        Approve(),
    )


def on_enable_whitelist():
    hash = ScratchVar(TealType.bytes)
    i = ScratchVar(TealType.uint64)
    name = ScratchVar(TealType.bytes)

    return Seq(
        assert_is_creator(),
        Assert(Btoi(Txn.application_args[1]) < App.globalGet(Bytes("launchStart"))),
        App.globalPut(Bytes("wlLaunchStart"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("wlPrice"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("wlAltID"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("wlAltPrice"), Btoi(Txn.application_args[4])),
        App.globalPut(Bytes("wlMax"), Btoi(Txn.application_args[5])),
        hash.store(Sha256(Itob(Global.current_application_id()))),
        name.store(Bytes("High Forge EA Token: 12345678901")),
        For(i.store(Int(0)), i.load() < Int(11), i.store(i.load() + Int(1))).Do(
            name.store(
                SetByte(
                    name.load(),
                    i.load() + Int(21),
                    (GetByte(hash.load(), i.load()) % Int(26)) + Int(65),
                ),
            )
        ),
        create_asset(
            name.load(),
            Bytes("EARLY"),
            App.globalGet(Bytes("maxSupply")) * Int(10),
            Bytes("https://highforge.io"),
            Global.zero_address(),
            Global.current_application_address(),
            Global.current_application_address(),
        ),
        App.globalPut(Bytes("wlTokenID"), InnerTxn.created_asset_id()),
        If(
            App.globalGet(Bytes("wlAltID")),
            optin_asset(App.globalGet(Bytes("wlAltID"))),
        ),
        Approve(),
    )


def on_set_charity():
    return Seq(
        assert_is_creator(),
        App.globalPut(Bytes("charityAddress"), Txn.application_args[1]),
        App.globalPut(Bytes("charityPoints"), Btoi(Txn.application_args[2])),
        Approve(),
    )


def on_set_launch_dates():
    return Seq(
        assert_is_creator(),
        App.globalPut(Bytes("launchStart"), Btoi(Txn.application_args[1])),
        If(
            Txn.application_args.length() == Int(3),
            Seq(
                Assert(App.globalGet(Bytes("wlTokenID"))),
                Assert(Btoi(Txn.application_args[2]) < Btoi(Txn.application_args[1])),
                App.globalPut(Bytes("wlLaunchStart"), Btoi(Txn.application_args[2])),
            ),
        ),
        Approve(),
    )


def on_set_launch_details():
    return Seq(
        assert_is_creator(),
        App.globalPut(Bytes("price"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("maxSupply"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("launchStart"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("launchEnd"), Int(0)),  # for now, don't allow end date
        # App.globalPut(Bytes("launchEnd"), Btoi(Txn.application_args[4])),
        Approve(),
    )


def on_set_launch_paused():
    return Seq(
        assert_is_creator(),
        App.globalPut(Bytes("launchPaused"), Btoi(Txn.application_args[1])),
        Approve(),
    )


def on_set_launchpad_fee():
    return Seq(
        assert_is_launch(),
        App.globalPut(Bytes("launchpadFee"), Btoi(Txn.application_args[1])),
        Approve(),
    )


def approveHandler(args):
    return Seq(
        nft := NFT(args["tokenId"].load()),
        Assert(nft.exists()),
        Assert(Txn.sender() == nft.get("owner")),
        nft.approve(args["approved"].load()),
        abi_return(),
    )


approve = ABI_Method(
    {
        "name": "arc72_approve",
        "desc": "Approve a controller for a single NFT",
        "readonly": False,
        "args": [
            {
                "type": "address",
                "name": "approved",
                "desc": "Approved controller address",
            },
            {"type": "uint256", "name": "tokenId", "desc": "The ID of the NFT"},
        ],
        "returns": {"type": "void"},
    },
    approveHandler,
)


def balanceOfHandler(args):
    return Seq(
        contents := App.box_get(Concat(Bytes("b"), args["owner"].load())),
        abi_return(
            If(contents.hasValue(), contents.value(), BytesZero(LENGTH_UINT256))
        ),
    )


balanceOf = ABI_Method(
    {
        "name": "arc72_balanceOf",
        "desc": "Returns the number of NFTs owned by an address",
        "readonly": True,
        "args": [
            {"type": "address", "name": "owner"},
        ],
        "returns": {"type": "uint256"},
    },
    balanceOfHandler,
)


def burnHandler(args):
    return Seq(
        nft := NFT(args["tokenId"].load()),
        Assert(nft.exists()),
        Assert(Txn.sender() == nft.get("owner")),
        nft.burn(),
        abi_return(),
    )


burn = ABI_Method(
    {
        "name": "burn",
        "desc": "Burns the specified NFT",
        "readonly": False,
        "args": [
            {"type": "uint256", "name": "tokenId", "desc": "The ID of the NFT"},
        ],
        "returns": {"type": "void"},
    },
    burnHandler,
)


def getApprovedHandler(args):
    return Seq(
        nft := NFT(args["tokenId"].load()),
        Assert(nft.exists()),
        abi_return(nft.get("operator")),
    )


getApproved = ABI_Method(
    {
        "name": "arc72_getApproved",
        "desc": "Get the current approved address for a single NFT",
        "readonly": True,
        "args": [
            {"type": "uint256", "name": "tokenId", "desc": "The ID of the NFT"},
        ],
        "returns": {"type": "address", "desc": "address of approved user or zero"},
    },
    getApprovedHandler,
)


def isApprovedForAllHandler(args):
    return Seq(
        isOperator := App.box_length(
            Concat(args["owner"].load(), args["operator"].load())
        ),
        abi_return(Itob(isOperator.hasValue())),
    )


isApprovedForAll = ABI_Method(
    {
        "name": "arc72_isApprovedForAll",
        "desc": "Query if an address is an authorized operator for another address",
        "readonly": True,
        "args": [
            {"type": "address", "name": "owner"},
            {"type": "address", "name": "operator"},
        ],
        "returns": {
            "type": "bool",
            "desc": "whether operator is authorized for all NFTs of owner",
        },
    },
    isApprovedForAllHandler,
)


def mintHandler(args):
    assetID = ScratchVar(TealType.uint64)
    paidAmount = ScratchVar(TealType.uint64)
    receiptBox = ScratchVar(TealType.bytes)
    receiptContent = ScratchVar(TealType.bytes)

    return Seq(
        # make sure the max supply has not been reached
        Assert(App.globalGet(Bytes("totalMinted")) < App.globalGet(Bytes("maxSupply"))),
        If(
            # if creator is calling, ignore price, period, and paused status
            Txn.sender() == Global.creator_address(),
            Seq(
                assetID.store(Int(0)),
                paidAmount.store(Int(0)),
                assert_mint_funding(Txn.group_index() - Int(1)),
            ),
            Seq(
                # make sure the launch is not paused
                Assert(App.globalGet(Bytes("launchPaused")) == Int(0)),
                # make sure the mint is not over. launchEnd == 0 means it never ends
                Assert(
                    Or(
                        App.globalGet(Bytes("launchEnd")) == Int(0),
                        Global.latest_timestamp() < App.globalGet(Bytes("launchEnd")),
                    )
                ),
                If(
                    # if the time is after the launch start, it's a normal mint
                    Global.latest_timestamp() >= App.globalGet(Bytes("launchStart")),
                    Seq(
                        # make sure they pay the mint price
                        If(
                            is_algo_txn(
                                Txn.group_index() - Int(1),
                                App.globalGet(Bytes("price")),
                                Global.current_application_address(),
                            ),
                            Seq(
                                assetID.store(Int(0)),
                                paidAmount.store(App.globalGet(Bytes("price"))),
                            ),
                            Reject(),
                        ),
                        assert_mint_funding(Txn.group_index() - Int(2)),
                    ),
                    Seq(
                        # make sure whitelist is enabled
                        Assert(App.globalGet(Bytes("wlTokenID"))),
                        # make sure we are in the whitelist window
                        Assert(
                            Global.latest_timestamp()
                            >= App.globalGet(Bytes("wlLaunchStart"))
                        ),
                        # make sure white list is not maxed out
                        Assert(
                            Or(
                                # wlMax == 0 means no limit
                                App.globalGet(Bytes("wlMax")) == Int(0),
                                App.globalGet(Bytes("wlMinted"))
                                < App.globalGet(Bytes("wlMax")),
                            )
                        ),
                        # make sure they pay the whitelist token
                        Assert(
                            is_asset_txn(
                                Txn.group_index() - Int(2),
                                App.globalGet(Bytes("wlTokenID")),
                                Int(1),
                                Global.current_application_address(),
                            )
                        ),
                        # make sure they pay the mint price
                        If(
                            is_algo_txn(
                                Txn.group_index() - Int(1),
                                App.globalGet(Bytes("wlPrice")),
                                Global.current_application_address(),
                            ),
                            Seq(
                                assetID.store(Int(0)),
                                paidAmount.store(App.globalGet(Bytes("wlPrice"))),
                            ),
                            If(
                                And(
                                    App.globalGet(Bytes("wlAltID")),
                                    is_asset_txn(
                                        Txn.group_index() - Int(1),
                                        App.globalGet(Bytes("wlAltID")),
                                        App.globalGet(Bytes("wlAltPrice")),
                                        Global.current_application_address(),
                                    ),
                                ),
                                Seq(
                                    assetID.store(App.globalGet(Bytes("wlAltID"))),
                                    paidAmount.store(
                                        App.globalGet(Bytes("wlAltPrice"))
                                    ),
                                ),
                                Reject(),
                            ),
                        ),
                        assert_mint_funding(Txn.group_index() - Int(3)),
                        App.globalPut(
                            Bytes("wlMinted"), App.globalGet(Bytes("wlMinted")) + Int(1)
                        ),
                    ),
                ),
            ),
        ),
        # send out everyone's cuts
        distribute_payments(assetID.load(), paidAmount.load()),
        # send algo to cover the revealing of the NFT
        send_algo(LAUNCH_FEES, LAUNCH),
        # create the receipt box and make sure it doesn't already exist
        receiptBox.store(Concat(Bytes("r"), args["tempTokenId"].load())),
        length := App.box_length(receiptBox.load()),
        Assert(Not(length.hasValue())),
        # we make the receipt box the same size as an NFT box
        # that way the user covers the min-balance cost
        # and during the reveal we can just replace the receipt box with the NFT box
        Assert(App.box_create(receiptBox.load(), LENGTH_NFT_BOX)),
        Assert(
            App.box_create(
                Concat(Bytes("t"), args["tempTokenId"].load()), LENGTH_INDEX_BOX
            )
        ),
        receiptContent.store(
            Concat(
                Txn.sender(),
                Itou256(App.globalGet(Bytes("nextMintID"))),
                Itob(assetID.load()),
                Itob(paidAmount.load()),
                Itob(Global.latest_timestamp()),
            )
        ),
        App.box_replace(
            receiptBox.load(),
            Int(0),
            receiptContent.load(),
        ),
        # emit the mint event
        abi_event(EVENT_MINT, receiptContent.load()),
        # update variables for next mint
        App.globalPut(Bytes("nextMintID"), App.globalGet(Bytes("nextMintID")) + Int(1)),
        App.globalPut(
            Bytes("totalMinted"), App.globalGet(Bytes("totalMinted")) + Int(1)
        ),
        abi_return(Itou256(App.globalGet(Bytes("nextMintID")) - Int(1))),
    )


mint = ABI_Method(
    {
        "name": "highforge_mint",
        "desc": "Attempts to mint an NFT for the user",
        "readonly": False,
        "args": [
            {
                "type": "uint256",
                "name": "tempTokenId",
                "desc": "A unique temporary token ID for the NFT",
            },
        ],
        "returns": {
            "type": "uint256",
            "desc": "tokenId - The ID of the NFT that was minted",
        },
    },
    mintHandler,
)


def ownerOfHandler(args):
    nft = NFT(args["tokenId"].load())

    return abi_return(
        If(
            nft.exists(),
            nft.get("owner"),
            Global.zero_address(),
        )
    )


ownerOf = ABI_Method(
    {
        "name": "arc72_ownerOf",
        "desc": "Returns the address of the current owner of the NFT with the given tokenId",
        "readonly": True,
        "args": [
            {"type": "uint256", "name": "tokenId", "desc": "The ID of the NFT"},
        ],
        "returns": {"type": "address", "desc": "The current owner of the NFT."},
    },
    ownerOfHandler,
)


def revealHandler(args):
    receiptBox = ScratchVar(TealType.bytes)
    sender = ScratchVar(TealType.bytes)
    tokenId = ScratchVar(TealType.bytes)
    collectionIndex = ScratchVar(TealType.bytes)

    return Seq(
        assert_is_launch(),
        # load the receipt
        receiptBox.store(Concat(Bytes("r"), args["tempTokenId"].load())),
        length := App.box_length(receiptBox.load()),
        Assert(length.hasValue()),
        sender.store(App.box_extract(receiptBox.load(), Int(0), LENGTH_ADDRESS)),
        tokenId.store(
            App.box_extract(receiptBox.load(), LENGTH_ADDRESS, LENGTH_UINT256)
        ),
        # verify against the receipt
        Assert(args["tokenId"].load() == tokenId.load()),
        # delete the receipt box
        Assert(App.box_delete(receiptBox.load())),
        Assert(App.box_delete(Concat(Bytes("t"), args["tempTokenId"].load()))),
        # create the NFT
        nft := NFT(args["tokenId"].load()),
        nft.create(sender.load()),
        nft.set("metadata_uri", args["tokenURI"].load()),
        # create the index lookup box
        collectionIndex.store(
            Itou256(U256toi(args["tokenId"].load()) - Int(1)),
        ),
        length := App.box_length(Concat(Bytes("i"), collectionIndex.load())),
        Assert(Not(length.hasValue())),
        App.box_put(Concat(Bytes("i"), collectionIndex.load()), args["tokenId"].load()),
        # emit event and return
        abi_event(
            EVENT_REVEAL, Concat(args["tokenId"].load(), args["tokenURI"].load())
        ),
        abi_return(),
    )


reveal = ABI_Method(
    {
        "name": "highforge_reveal",
        "desc": "Reveals the NFT",
        "readonly": False,
        "args": [
            {
                "type": "uint256",
                "name": "tempTokenId",
                "desc": "The temporary token ID",
            },
            {
                "type": "uint256",
                "name": "tokenId",
                "desc": "The actual token ID",
            },
            {
                "type": "byte[256]",
                "name": "tokenURI",
                "desc": "The metadata URI for the token",
            },
        ],
        "returns": {"type": "void"},
    },
    revealHandler,
)


def setApprovalForAllHandler(args):
    return Seq(
        If(
            args["approved"].load() == BOOL_TRUE,
            Assert(
                App.box_create(Concat(Txn.sender(), args["operator"].load()), Int(1))
            ),
            If(
                args["approved"].load() == BOOL_FALSE,
                Assert(App.box_delete(Concat(Txn.sender(), args["operator"].load()))),
                Reject(),
            ),
        ),
        abi_event(
            EVENT_APPROVAL_FOR_ALL,
            Concat(
                Txn.sender(),
                args["operator"].load(),
                args["approved"].load(),
            ),
        ),
        abi_return(),
    )


setApprovalForAll = ABI_Method(
    {
        "name": "arc72_setApprovalForAll",
        "desc": "Approve an operator for all NFTs for a user",
        "readonly": False,
        "args": [
            {
                "type": "address",
                "name": "operator",
                "desc": "Approved operator address",
            },
            {
                "type": "bool",
                "name": "approved",
                "desc": "true to give approval, false to revoke",
            },
        ],
        "returns": {"type": "void"},
    },
    setApprovalForAllHandler,
)


def setupBalanceHandler(args):
    return Seq(
        Assert(
            is_algo_txn(
                Txn.group_index() - Int(1),
                MIN_BALANCE_BALANCE_BOX,
                Global.current_application_address(),
            )
        ),
        length := App.box_length(Concat(Bytes("b"), Txn.sender())),
        If(
            length.hasValue(),
            send_algo_cover_fee(
                MIN_BALANCE_BALANCE_BOX,
                Gtxn[Txn.group_index() - Int(1)].sender(),
            ),
            Assert(
                App.box_create(Concat(Bytes("b"), Txn.sender()), LENGTH_BALANCE_BOX)
            ),
        ),
        abi_return(),
    )


setupBalance = ABI_Method(
    {
        "name": "highforge_setupBalance",
        "desc": "Makes sure that the balance box for the sender is set up",
        "readonly": False,
        "args": [],
        "returns": {"type": "void"},
    },
    setupBalanceHandler,
)


def supportsInterfaceHandler(args):
    return Seq(
        If(
            args["interfaceID"].load() == INTERFACE_SUPPORTS_INTERFACE,
            abi_return(BOOL_TRUE),
        ),
        If(args["interfaceID"].load() == INTERFACE_MASK, abi_return(BOOL_FALSE)),
        If(args["interfaceID"].load() == INTERFACE_ARC72_CORE, abi_return(BOOL_TRUE)),
        If(
            args["interfaceID"].load() == INTERFACE_ARC72_ENUMERATION,
            abi_return(BOOL_TRUE),
        ),
        If(
            args["interfaceID"].load() == INTERFACE_ARC72_MANAGEMENT,
            abi_return(BOOL_TRUE),
        ),
        If(
            args["interfaceID"].load() == INTERFACE_ARC72_METADATA,
            abi_return(BOOL_TRUE),
        ),
        abi_return(BOOL_FALSE),
    )


supportsInterface = ABI_Method(
    {
        "name": "supportsInterface",
        "desc": "Detects support for an interface specified by selector.",
        "readonly": True,
        "args": [
            {
                "type": "byte[4]",
                "name": "interfaceID",
                "desc": "The selector of the interface to detect.",
            },
        ],
        "returns": {
            "type": "bool",
            "desc": "Whether the contract supports the interface.",
        },
    },
    supportsInterfaceHandler,
)


def tokenByIndexHandler(args):
    return Seq(
        Assert(U256toi(args["index"].load()) < App.globalGet(Bytes("totalMinted"))),
        contents := App.box_get(Concat(Bytes("i"), args["index"].load())),
        Assert(contents.hasValue()),
        abi_return(contents.value()),
    )


tokenByIndex = ABI_Method(
    {
        "name": "arc72_tokenByIndex",
        "desc": "Returns the token ID of the token with the given index among all NFTs defined by the contract",
        "readonly": True,
        "args": [
            {"type": "uint256", "name": "index"},
        ],
        "returns": {"type": "uint256"},
    },
    tokenByIndexHandler,
)


def tokenURIHandler(args):
    return Seq(
        nft := NFT(args["tokenId"].load()),
        Assert(nft.exists()),
        abi_return(nft.get("metadata_uri")),
    )


tokenURI = ABI_Method(
    {
        "name": "arc72_tokenURI",
        "desc": "Returns a URI pointing to the NFT metadata",
        "readonly": True,
        "args": [
            {"type": "uint256", "name": "tokenId", "desc": "The ID of the NFT"},
        ],
        "returns": {"type": "byte[256]", "desc": "URI to token metadata."},
    },
    tokenURIHandler,
)


def totalSupplyHandler(_):
    return abi_return(Itou256(App.globalGet(Bytes("totalMinted"))))


totalSupply = ABI_Method(
    {
        "name": "arc72_totalSupply",
        "desc": "Returns the number of NFTs currently defined by this contract",
        "readonly": True,
        "args": [],
        "returns": {"type": "uint256"},
    },
    totalSupplyHandler,
)


def transferFromHandler(args):
    owner = ScratchVar(TealType.bytes)

    return Seq(
        nft := NFT(args["tokenId"].load()),
        owner.store(nft.get("owner")),
        isOperator := App.box_length(Concat(owner.load(), Txn.sender())),
        Assert(args["from"].load() == owner.load()),
        Assert(
            Or(
                Txn.sender() == nft.get("operator"),
                Txn.sender() == owner.load(),
                isOperator.hasValue(),
            )
        ),
        # we allow an optional txn before this one that covers the min balance
        # cost for the balance box. if it already exists, we will refund it
        If(
            Txn.group_index() > Int(0),
            If(
                is_algo_txn(
                    Txn.group_index() - Int(1),
                    MIN_BALANCE_BALANCE_BOX,
                    Global.current_application_address(),
                ),
                Seq(
                    length := App.box_length(Concat(Bytes("b"), args["to"].load())),
                    If(
                        length.hasValue(),
                        send_algo_cover_fee(
                            MIN_BALANCE_BALANCE_BOX,
                            Gtxn[Txn.group_index() - Int(1)].sender(),
                        ),
                    ),
                ),
            ),
        ),
        nft.transfer(owner.load(), args["to"].load()),
        abi_return(),
    )


transferFrom = ABI_Method(
    {
        "name": "arc72_transferFrom",
        "desc": "Transfers ownership of an NFT",
        "readonly": False,
        "args": [
            {"type": "address", "name": "from"},
            {"type": "address", "name": "to"},
            {"type": "uint256", "name": "tokenId"},
        ],
        "returns": {"type": "void"},
    },
    transferFromHandler,
)


def updateTokenURIHandler(args):
    return Seq(
        assert_is_creator(),
        nft := NFT(args["tokenId"].load()),
        Assert(nft.exists()),
        Assert(nft.is_revealed()),
        nft.set("metadata_uri", args["tokenURI"].load()),
        abi_event(
            EVENT_UPDATE_URI,
            Concat(
                args["tokenId"].load(),
                args["tokenURI"].load(),
            ),
        ),
        abi_return(),
    )


updateTokenURI = ABI_Method(
    {
        "name": "highforge_updateTokenURI",
        "desc": "Allows the creator to update the token URI for a token",
        "readonly": False,
        "args": [
            {"type": "uint256", "name": "tokenId", "desc": "The ID of the NFT"},
            {
                "type": "byte[256]",
                "name": "tokenURI",
                "desc": "The metadata URI for the token",
            },
        ],
        "returns": {"type": "void"},
    },
    updateTokenURIHandler,
)


################################################################################
# OnComplete Branches
################################################################################


def on_creation():
    return Seq(
        App.globalPut(Bytes("price"), Int(0)),
        # launch will be available when time >= launchStart
        # it will go until maxSupply is reached OR time > launchEnd
        App.globalPut(Bytes("maxSupply"), Int(0)),
        # (wl)launchStart and launchEnd are given in seconds since epoch
        App.globalPut(Bytes("launchStart"), Int(0)),
        App.globalPut(Bytes("launchEnd"), Int(0)),
        App.globalPut(Bytes("launchPaused"), Int(0)),
        # whitelist will start when time > wlLaunchStart
        # whitelist will end when time >= launchStart
        App.globalPut(Bytes("wlLaunchStart"), Int(0)),
        App.globalPut(Bytes("wlTokenID"), Int(0)),
        App.globalPut(Bytes("wlPrice"), Int(0)),
        App.globalPut(Bytes("wlAltID"), Int(0)),
        App.globalPut(Bytes("wlAltPrice"), Int(0)),
        App.globalPut(Bytes("wlMax"), Int(0)),
        App.globalPut(Bytes("wlMinted"), Int(0)),
        # launchpad fee is in basis points (defaults to 2.5%)
        App.globalPut(Bytes("launchpadFee"), Int(250)),
        App.globalPut(Bytes("nextMintID"), Int(1)),
        App.globalPut(Bytes("totalMinted"), Int(0)),
        App.globalPut(Bytes("charityAddress"), Global.current_application_address()),
        App.globalPut(Bytes("charityPoints"), Int(0)),
        Approve(),
    )


def on_closeout():
    return Reject()


def on_delete():
    return Seq(
        assert_is_creator(),
        Assert(App.globalGet(Bytes("totalMinted")) == Int(0)),
        If(
            App.globalGet(Bytes("wlAltID")),
            closeout_asset_to_creator(App.globalGet(Bytes("wlAltID"))),
        ),
        closeout_algo(Global.creator_address()),
        Approve(),
    )


def on_noop():
    return Cond(
        [Txn.application_args[0] == Bytes("claimAlgo"), on_claim_algo()],
        [Txn.application_args[0] == Bytes("claimWLAlt"), on_claim_wl_alt()],
        [Txn.application_args[0] == Bytes("claimWLToken"), on_claim_wl_token()],
        [Txn.application_args[0] == Bytes("disableWL"), on_disable_whitelist()],
        [Txn.application_args[0] == Bytes("enableWL"), on_enable_whitelist()],
        [Txn.application_args[0] == Bytes("setCharity"), on_set_charity()],
        [Txn.application_args[0] == Bytes("setLaunchDates"), on_set_launch_dates()],
        [Txn.application_args[0] == Bytes("setLaunchDetails"), on_set_launch_details()],
        [Txn.application_args[0] == Bytes("setLaunchPaused"), on_set_launch_paused()],
        [Txn.application_args[0] == Bytes("setLaunchpadFee"), on_set_launchpad_fee()],
        [Txn.application_args[0] == approve.selector, approve.handler()],
        [Txn.application_args[0] == balanceOf.selector, balanceOf.handler()],
        [Txn.application_args[0] == burn.selector, burn.handler()],
        [Txn.application_args[0] == getApproved.selector, getApproved.handler()],
        [
            Txn.application_args[0] == isApprovedForAll.selector,
            isApprovedForAll.handler(),
        ],
        [Txn.application_args[0] == mint.selector, mint.handler()],
        [Txn.application_args[0] == ownerOf.selector, ownerOf.handler()],
        [Txn.application_args[0] == reveal.selector, reveal.handler()],
        [
            Txn.application_args[0] == setApprovalForAll.selector,
            setApprovalForAll.handler(),
        ],
        [Txn.application_args[0] == setupBalance.selector, setupBalance.handler()],
        [
            Txn.application_args[0] == supportsInterface.selector,
            supportsInterface.handler(),
        ],
        [Txn.application_args[0] == tokenByIndex.selector, tokenByIndex.handler()],
        [Txn.application_args[0] == tokenURI.selector, tokenURI.handler()],
        [Txn.application_args[0] == totalSupply.selector, totalSupply.handler()],
        [Txn.application_args[0] == transferFrom.selector, transferFrom.handler()],
    )


def on_optin():
    return Reject()


def on_update():
    return Seq(assert_is_launch(), Approve())


################################################################################
# Program Construction
################################################################################


def approval_program():
    program = Seq(
        Assert(Txn.rekey_to() == Global.zero_address()),
        Cond(
            [Txn.application_id() == Int(0), on_creation()],
            [Txn.on_completion() == OnComplete.CloseOut, on_closeout()],
            [Txn.on_completion() == OnComplete.DeleteApplication, on_delete()],
            [Txn.on_completion() == OnComplete.NoOp, on_noop()],
            [Txn.on_completion() == OnComplete.OptIn, on_optin()],
            [Txn.on_completion() == OnComplete.UpdateApplication, on_update()],
        ),
    )

    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)


def clear_program():
    program = on_closeout()
    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)


p = Path(__file__).parent.absolute()
(p / f"arc72/{version}").mkdir(exist_ok=True)


with open(f"arc72/{version}/approval.teal", "w") as f:
    f.write(approval_program())

with open(f"arc72/{version}/clear.teal", "w") as f:
    f.write(clear_program())


import base64, hashlib, subprocess

subprocess.run(
    [
        "goal",
        "clerk",
        "compile",
        f"arc72/{version}/approval.teal",
        "-o",
        f"arc72/{version}/approval.bin",
    ]
)
subprocess.run(
    [
        "goal",
        "clerk",
        "compile",
        f"arc72/{version}/clear.teal",
        "-o",
        f"arc72/{version}/clear.bin",
    ]
)

with open(f"arc72/{version}/approval.bin", "rb") as f:
    contents = f.read()
    print("approvalHash", base64.b64encode(hashlib.sha256(contents).digest()).decode())
    with open(f"arc72/{version}/approval.b64", "w") as f:
        f.write(base64.b64encode(contents).decode())

with open(f"arc72/{version}/clear.bin", "rb") as f:
    contents = f.read()
    print("clearHash", base64.b64encode(hashlib.sha256(contents).digest()).decode())
    with open(f"arc72/{version}/clear.b64", "w") as f:
        f.write(base64.b64encode(contents).decode())

print("")
print("Copy approval.b64 and clear.b64 to algoseas-libs!!!")


# File: https://github.com/cloud-travelx/workshop-labitconf-22/blob/4d4ddddeaafd6d59947202b7199f6684714d54a9/assets/nfticket/NFTicketManager.py
from typing import Final

import beaker as bkr
from pyteal import *


class NFTicketManager(bkr.Application):
    protocol: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(
        stack_type=TealType.bytes,
        static=True,
        descr="Protocol fee account",
    )

    protocol_fee: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(
        stack_type=TealType.uint64,
        default=Int(10),  # 1%
        descr="Protocol Fee Percentage",
    )

    supplier: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(
        stack_type=TealType.bytes,
        descr="Supplier account",
        static=True
    )

    supplier_share: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(
        stack_type=TealType.uint64,
        default=Int(1),
        descr="Share of supplier on resale"
    )

    @bkr.create
    def create(self, protocol: abi.Account, supplier: abi.Account):
        return Seq(
            self.initialize_application_state(),
            self.protocol.set(Txn.accounts[1]),
            self.supplier.set(Txn.accounts[2])
        )

    @bkr.external(authorize=bkr.Authorize.only(protocol))
    def set_up_asset(self, asset: abi.Asset):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: asset.asset_id(),
                TxnField.asset_receiver: self.address,
                TxnField.asset_amount: Int(0),
                TxnField.fee: Int(0)
            }),
            InnerTxnBuilder.Submit(),
        )

    @bkr.external(authorize=bkr.Authorize.only(protocol))
    def set_up_fee(self, supplier_share: abi.Uint64, protocol: abi.Uint64):
        return Seq(
            self.supplier_share.set(supplier_share.get()),
            self.protocol_fee.set(protocol.get())
        )

    @bkr.external(authorize=bkr.Authorize.only(supplier))
    def mint(self, name: abi.String, meta_url: abi.String, meta_hash: abi.String, *, output: abi.Uint64):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_total: Int(1),
                TxnField.config_asset_decimals: Int(0),
                TxnField.config_asset_name: Concat(Bytes("NFTicket"), name.get()),
                TxnField.config_asset_unit_name: Bytes("NFTicket"),
                TxnField.config_asset_url: meta_url.get(),
                TxnField.config_asset_metadata_hash: meta_hash.get(),
                TxnField.config_asset_default_frozen: Int(1),
                TxnField.config_asset_reserve: Global.current_application_address(),
                TxnField.config_asset_manager: Global.current_application_address(),
                TxnField.config_asset_clawback: Global.current_application_address(),
                TxnField.config_asset_freeze: Global.current_application_address(),
                TxnField.fee: Int(0),
            }),
            InnerTxnBuilder.Submit(),

            output.set(Gitxn[0].created_asset_id())
        )

    @bkr.internal(TealType.none)
    def move_asset(self, asset, owner, to):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: asset,
                TxnField.asset_sender: owner,
                TxnField.asset_receiver: to,
                TxnField.asset_amount: Int(1),
                TxnField.fee: Int(0),
            }),
            InnerTxnBuilder.Submit(),
        )

    @bkr.internal(TealType.none)
    def pay_share(self, asset, to, amount):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: asset,
                TxnField.asset_receiver: to,
                TxnField.asset_amount: amount,
                TxnField.fee: Int(0)
            }),
            InnerTxnBuilder.Submit(),
        )

    @bkr.external(authorize=bkr.Authorize.only(supplier))
    def redeem(self, asset: abi.Asset):
        return self.move_asset(asset.asset_id(), self.address, Txn.sender())

    @bkr.external(authorize=bkr.Authorize.only(supplier))
    def withdraw(self, asset: abi.Asset, amount: abi.Uint64, to: abi.Account):
        return self.pay_share(asset.asset_id(), to.address(), amount.get())

    @bkr.external
    def sell(self,
             price: abi.Uint64,
             nfticket: abi.Asset,
             buyer: abi.Account,
             protocol: abi.Account,
             pay_asset: abi.Asset,
             payment: abi.AssetTransferTransaction):
        payment = payment.get()
        return Seq(
            # Payment to contract
            #  (implicit) Payment asset
            Assert(payment.asset_receiver() == self.address),
            Assert(payment.xfer_asset() == pay_asset.asset_id()),

            # Payment amount is sell price
            Assert(payment.asset_amount() >= price.get()),

            # Protocol Fee
            Assert(self.protocol.get() == protocol.address()),
            # (protocol_fee := ScratchVar(TealType.uint64)).store(price.get() * (self.protocol_fee.get() / Int(1000))),
            (protocol_fee := abi.Uint64()).set(price.get() * self.protocol_fee.get() / Int(1000)),
            # Pay to Protocol
            self.pay_share(payment.xfer_asset(), protocol.address(), protocol_fee.get()),

            # Seller profit
            (sell_worth := abi.Uint64()).set(price.get() - protocol_fee.get()),
            (supplier_share := abi.Uint64()).set(sell_worth.get() * self.supplier_share.get() / Int(1000)),
            # Pay to seller
            self.pay_share(payment.xfer_asset(), Txn.sender(), price.get() - supplier_share.get()),

            # Move asset
            #  (implicit check) Seller is owner
            self.move_asset(nfticket.asset_id(), Txn.sender(), buyer.address())
        )


if __name__ == '__main__':
    import sys
    import json
    import collections
    from os import path

    app = NFTicketManager()

    if len(sys.argv) > 1:
        if sys.argv[1] == "--artifacts":
            app.dump(f"{path.dirname(__file__)}/artifacts")
            exit(0)
        if sys.argv[1] == "--spec":
            spec = app.application_spec()


            def cost(declared) -> collections.Counter:
                return collections.Counter(map(lambda e: e["type"], declared.values()))


            print(cost(spec["schema"]["local"]["declared"]))
            print(cost(spec["schema"]["global"]["declared"]))

            sys.exit(0)
        if sys.argv[1] == "--abi":
            with open(__file__.replace(".py", ".abi.json"), "w") as abi_fp:
                json.dump(app.contract.dictify(), abi_fp, indent=2)

    print(app.approval_program)


# File: https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/dao.py
from pathlib import Path

from typing import Literal



from beaker import *

from beaker.lib.storage import BoxMapping

from pyteal import *





class NFTProposal(abi.NamedTuple):

    url: abi.Field[abi.String]

    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]

    name: abi.Field[abi.String]

    unit_name: abi.Field[abi.String]

    reserve: abi.Field[abi.Address]



###############

# DAO Contract

###############



class DAOState:

    # Global Storage

    winning_proposal_votes = GlobalStateValue(

        stack_type=TealType.uint64, default=Int(0)

    )



    winning_proposal = GlobalStateValue(stack_type=TealType.bytes, default=Bytes(""))



    # Box Storage

    has_voted = BoxMapping(key_type=abi.Address, value_type=abi.Bool)

    

    proposals = BoxMapping(

        key_type=abi.Tuple2[abi.Address, abi.Uint64],

        value_type=NFTProposal,

        prefix=Bytes("p-"),

    )



    votes = BoxMapping(

        key_type=abi.Tuple2[abi.Address, abi.Uint64],

        value_type=abi.Uint64,

        prefix=Bytes("v-"),

    )



dao = Application("DAO", state=DAOState)





@dao.create(bare=True)

def create() -> Expr:

    return dao.initialize_global_state()





@dao.external

def add_proposal(

    proposal: NFTProposal, proposal_id: abi.Uint64, mbr_payment: abi.PaymentTransaction

) -> Expr:

    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])

    addr = abi.Address()



    return Seq(

        # Assert MBR payment is going to the contract

        Assert(mbr_payment.get().receiver() == Global.current_application_address()),

        # Get current MBR before adding proposal

        pre_mbr := AccountParam.minBalance(Global.current_application_address()),

        # Set proposal key

        addr.set(Txn.sender()),

        proposal_key.set(addr, proposal_id),

        # Check if the proposal already exists

        Assert(dao.state.proposals[proposal_key].exists() == Int(0)),

        # Not using .get() here because desc is already a abi.String

        dao.state.proposals[proposal_key].set(proposal),

        # Verify payment covers MBR difference

        current_mbr := AccountParam.minBalance(Global.current_application_address()),

        Assert(mbr_payment.get().amount() >= current_mbr.value() - pre_mbr.value()),

    )





@dao.external

def vote(proposer: abi.Address, proposal_id: abi.Uint64) -> Expr:

    total_votes = abi.Uint64()

    current_votes = abi.Uint64()

    true_value = abi.Bool()

    zero_val = abi.Uint64()

    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])



    return Seq(

        zero_val.set(Int(0)),

        proposal_key.set(proposer, proposal_id),

        # Make sure we haven't voted yet

        Assert(dao.state.has_voted[Txn.sender()].exists() == Int(0)),

        # Get current vote count

        If(dao.state.votes[proposal_key].exists() == Int(0)).Then(

            dao.state.votes[proposal_key].set(zero_val)

        ),

        dao.state.votes[proposal_key].store_into(current_votes),

        # Increment and save total vote count

        total_votes.set(current_votes.get() + Int(1)),

        dao.state.votes[proposal_key].set(total_votes),

        # Check if this proposal is now winning

        If(total_votes.get() > dao.state.winning_proposal_votes.get()).Then(

            dao.state.winning_proposal_votes.set(total_votes.get()),

            dao.state.winning_proposal.set(proposal_key.encode()),

        ),

        # Set has_voted to true

        true_value.set(value=True),

        dao.state.has_voted[Txn.sender()].set(true_value),

    )





@dao.external

def mint(minter_app: abi.Application, *, output: abi.Uint64) -> Expr:

    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])

    proposal = NFTProposal()



    return Seq(

        # Get the winning proposal key

        proposal_key.decode(dao.state.winning_proposal.get()),

        # Get the winning proposal

        dao.state.proposals[proposal_key].store_into(proposal),

        # Call NFT minter

        InnerTxnBuilder.ExecuteMethodCall(

            app_id=Tmpl.Int("TMPL_MINTER_APP"),

            method_signature=f"mint_nft({NFTProposal().type_spec()})uint64",

            args=[proposal],

        ),

        # Return created asset

        output.set(Btoi(Suffix(InnerTxn.last_log(), Int(4)))),

    )





#####################

# NFT Minter Contract

#####################



minter = Application("Minter")





@minter.external

def mint_nft(proposal: NFTProposal, *, output: abi.Uint64) -> Expr:

    name = abi.String()

    unit_name = abi.String()

    reserve = abi.Address()

    url = abi.String()

    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])

    abi.make(abi.Tuple2[abi.Address, abi.Uint64])



    return Seq(

        # Get properties from proposal and mint NFT

        proposal.name.store_into(name),

        proposal.unit_name.store_into(unit_name),

        proposal.reserve.store_into(reserve),

        proposal.url.store_into(url),

        proposal.metadata_hash.store_into(metadata_hash),

        InnerTxnBuilder.Execute(

            {

                TxnField.type_enum: TxnType.AssetConfig,

                TxnField.config_asset_name: name.get(),

                TxnField.config_asset_unit_name: unit_name.get(),

                TxnField.config_asset_reserve: reserve.get(),

                TxnField.config_asset_url: url.get(),

                TxnField.config_asset_metadata_hash: metadata_hash.encode(),

                TxnField.config_asset_total: Int(1),

                TxnField.fee: Int(0),

            }

        ),

        # Return created asset

        output.set(InnerTxn.created_asset_id()),

    )





if __name__ == "__main__":

    dao.build().export(Path(__file__).resolve().parent / f"./artifacts/{dao.name}")

    minter.build().export(

        Path(__file__).resolve().parent / f"./artifacts/{minter.name}"

    )

# File: https://github.com/Sam2much96/algorand_python_Scripts/blob/8c9356be983ffb4b3d0f3221d33eaf4a7d118b6a/contracts/escrow/Box_storage_escrow_3.py
#!/usr/bin/env python3
# *************************************************
# godot3-Dystopia-game by INhumanity_arts
# Released under MIT License
# *************************************************
# Box Storage Escrow Smart Contract
#
# An ARC 4 Abi Smart Contract
# THe Entire SmartContract Logic in one File.
# 
# Features:
# (1) Box Storage
# (2) Withdrawals
# (3) Deposit
# (4) NFT minting

# To Do:
# (1) Onchain Method Call 
# (2) Box Storage isn't yet supported in Algonaut Rust Crate, rewrite to use Global Storage

from pyteal import *
from beaker import *

import base64
import hashlib
from base64 import b64encode, b64decode

from typing import Final

#from beaker.lib.storage import Mapping


#beaker documentation : https://algorand-devrel.github.io/beaker/html/application_client.html


from algosdk.v2client import algod
from algosdk import mnemonic
from beaker.client.application_client import ApplicationClient
from beaker.client.logic_error import LogicException
from beaker.consts import Algos

from beaker.lib.storage import Mapping

import json
from simple_smart_contract import create_app, compile_program, call_app, delete_app, pay, call_app_method, pay_construct, get_application_address, update_app

from algosdk.future import transaction
from algosdk.abi import Contract

from algosdk.encoding import decode_address , encode_address

# For running Teal inspector
import subprocess

# Arc 4 Smart Contract

class BoxEscrow(Application):

    #uses nonce https://www.investopedia.com/terms/n/nonce.asp
    hashed_secret: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.bytes,
        descr="A scratch for saving secret nonce to application state",
    )
    
    #store transaction details to  boxes
    
 
    
    #Bare app calls https://pyteal.readthedocs.io/en/stable/abi.html?highlight=registrable%20methods#registering-bare-app-calls
    @Subroutine(TealType.none)  
    def assert_sender_is_creator() -> Expr:
        return Seq(
            If(Txn.sender() == Global.creator_address())
            .Then (

                # If box Storage Exists, delete them
                Pop(App.box_delete(Bytes("BoxA"))),
                Pop(App.box_delete(Bytes("BoxB"))),
                Pop(App.box_delete(Bytes("BoxC")))    


                )

            )



    # move any balance that the user has into the "lost" amount when they close out or clear state
    transfer_balance_to_lost = App.globalPut(
        Bytes("lost"),
        App.globalGet(Bytes("lost")) + App.localGet(Txn.sender(), Bytes("balance")),
    )


    
                
                
                
    """
    Docs:
        https://pyteal.readthedocs.io/en/stable/abi.html?highlight=call_config#registering-methods
 
    """
    
    my_router = Router(
    name="AlgoBank",
    bare_calls=BareCallActions(
        # approve a creation no-op call 
        #no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),
        no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),
        # approve opt-in calls during normal usage, and during creation as a convenience for the creator
        opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL),
        # move any balance that the user has into the "lost" amount when they close out or clear state
        close_out=OnCompleteAction(
            action=transfer_balance_to_lost, call_config=CallConfig.CALL
        ),
        clear_state=OnCompleteAction(
            action=transfer_balance_to_lost, call_config=CallConfig.CALL
        ),
        # only the creator can update or delete the app
        update_application=OnCompleteAction(
            action=assert_sender_is_creator, call_config=CallConfig.CALL
        ),
        delete_application=OnCompleteAction(
            action=assert_sender_is_creator, call_config=CallConfig.CALL
            ),
        ),
    )

    @my_router.method(no_op=CallConfig.CALL, opt_in=CallConfig.CALL)
    def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
        """This method receives a payment from an account opted into this app and records it as a deposit.

        The caller may opt into this app during this call.

        Args:
            payment: A payment transaction containing the amount of Algos the user wishes to deposit.
                The receiver of this transaction must be this app's escrow account.
            sender: An account that is opted into this app (or will opt in during this method call).
                The deposited funds will be recorded in this account's local state. This account must
                be the same as the sender of the `payment` transaction.
        """
        return Seq(
            Assert(payment.get().sender() == sender.address()),
            Assert(payment.get().receiver() == Global.current_application_address()),


        #Global Storage
        App.globalPut(Bytes("Depositors"), sender.address()),
                

        # Disabling Box Storage Until it's implemented in Algonaut

        # write to box `A` with new value
        # Deposit Address
        #Pop(App.box_create(Bytes("BoxA"), Int(10))),
        #App.box_put(Bytes("BoxA"), sender.address())

        )


    @my_router.method
    def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
        """Lookup the balance of a user held by this app.

        Args:
            user: The user whose balance you wish to look up. This user must be opted into this app.

        Returns:
            The balance corresponding to the given user, in microAlgos.
        """


        return output.set(App.localGet(user.address(), Bytes("balance")))


    @my_router.method
    def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
        """Withdraw an amount of Algos held by this app.

        The sender of this method call will be the source of the Algos, and the destination will be
        the `recipient` argument.

        The Algos will be transferred to the recipient using an inner transaction whose fee is set
        to 0, meaning the caller's transaction must include a surplus fee to cover the inner
        transaction.

        Args:
            amount: The amount of Algos requested to be withdraw, in microAlgos. This method will fail
                if this amount exceeds the amount of Algos held by this app for the method call sender.
            recipient: An account who will receive the withdrawn Algos. This may or may not be the same
                as the method call sender.
        """
        return Seq(

            If(Txn.sender() != Global.creator_address()) 

            .Then( 

                InnerTxnBuilder.Begin(),
                InnerTxnBuilder.SetFields(
                    {
                        TxnField.type_enum: TxnType.Payment,
                        TxnField.receiver: recipient.address(),
                        TxnField.amount: amount.get(),
                        TxnField.fee: Int(0),
                    }
                ),
                InnerTxnBuilder.Submit(),

                #Global Storage
                App.globalPut(Bytes("Withdrwl"), amount.get()),
                
                App.globalPut(Bytes("Receipient"), recipient.address()),
                
                
                # Disabling Box Storages until it'simplemented in Algonaut

                # write to box `B` with new value "Withdrawal Amount"
                # converted from an Integer to a Byte
                # App.box_put(Bytes("BoxB"), Itob(amount.get())),
                
                # write to box `C` with new value "Withdrawal To Address"
                #App.box_put(Bytes("BoxC"), recipient.address())
                )
            .ElseIf( Txn.sender() == Global.creator_address())
            .Then(Approve())
        )


    
    #    """
    #    Triggers an Abi method call via smartcontracts


    #    Args:
    #        Abi Arguments to this method via BareApp calls

    #    Docs: https://pyteal.readthedocs.io/en/stable/api.html?highlight=MethodCall#pyteal.InnerTxnBuilder.MethodCall

    #    """




    @my_router.method
    def mint(recipient : abi.Account, payment: abi.PaymentTransaction) -> Expr:
        """Mints an Asset Token To a Recipient Wallet Address
            the caller's transaction must include a surplus fee to cover the inner
            transaction

        Args:
            recipient: An account who will receive the withdrawn Algos. This may or may not be the same 
            as the method call sender.

        Docs: https://pyteal.readthedocs.io/en/stable/api.html#pyteal.TxnExpr

        """

        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_total: Int(1),
                TxnField.config_asset_decimals: Int(1),
                TxnField.config_asset_unit_name: Bytes("PUNK 001"),
                TxnField.config_asset_name: Bytes("CryptoPunk"),
                TxnField.config_asset_url: Bytes("ipfs://QmXYApu5uDsfQHMx149LWJy3x5XRssUeiPzvqPJyLV2ABx"), #CryptoPunk Asset CID
                TxnField.config_asset_manager: Global.current_application_address(),
                TxnField.config_asset_reserve: Global.current_application_address(),
                TxnField.config_asset_freeze: Global.current_application_address(),
                TxnField.config_asset_clawback: Global.current_application_address(),
            }),
            InnerTxnBuilder.Submit(),

            #Bug for Testing debug state

            #InnerTxnBuilder.Begin(),
            #InnerTxnBuilder.SetFields({
            #    TxnField.type_enum: TxnType.AssetTransfer,
            #   TxnField.asset_receiver: recipient.address(),
            #    TxnField.asset_amount: Int(1),
            #    TxnField.xfer_asset: Txn.assets[0], # Must be in the assets array sent as part of the application call
            #}),
            #InnerTxnBuilder.Submit(),

        )



    approval_program, clear_state_program, contract = my_router.compile_program(
        version=8, optimize=OptimizeOptions(scratch_slots=True)
    )





    """
    Write Out the Approval and Clear Programs. 
    Dump the Contract's method to a .json file.

    """

    with open("algobank_approval.teal", "w") as f:
        f.write(approval_program)

    with open("algobank_clear_state.teal", "w") as f:
        f.write(clear_state_program)
        
    with open("algobank.json", "w") as f:
        f.write(json.dumps(contract.dictify(), indent=4))









    

# Sha 265 Hashes a String
def sha256b64(s: str) -> str:
    return base64.b64encode(hashlib.sha256(str(s).encode("utf-8")).digest()).decode("utf-8")

#Configured to Testnet
#
#
def create_algorand_node_and_acct(command: str):
    
    # test-net
    algod_address = "https://node.testnet.algoexplorerapi.io"
    algod_token = ""
    algod_client = algod.AlgodClient(algod_token, algod_address)



    _params = algod_client.suggested_params()

    __mnemonic : str = "tank game arrive train bring taxi tackle popular bacon gasp tell pigeon error step leaf zone suit chest next swim luggage oblige opinion about execute"

    __mnemonic_2 : str = "degree feature waste gospel screen near subject boost wreck proof caution hen adapt fiber fault level blind entry also embark oval board bunker absorb garage"

    __mnemonic_3 : str = "scrub garment fashion column property obscure agree mobile maple stage pass boat snow diary canyon lesson under curtain impact earn calm maximum song ability together"


    #For Sandbox
    #client = sandbox.get_algod_client()

    #accts = sandbox.get_accounts()

    accts = {}
    accts[1] = {}
    accts[1]['pk'] = mnemonic.to_public_key(__mnemonic) #saves the new account's address
    accts[1]['sk'] = mnemonic.to_private_key(__mnemonic) #saves the new account's mnemonic
    
    mnemonic_obj_a1 = mnemonic.to_private_key(__mnemonic)
    mnemonic_obj_a2 = mnemonic.to_public_key(__mnemonic)
    
    #acct = accts.pop()

    print('Algod Client Status: ',algod_client.status())

    print (accts[1])

    #other accounts
    accts[2] = {}
    accts[2]['pk'] = mnemonic.to_public_key(__mnemonic_2)
    accts[2]['sk'] = mnemonic.to_private_key(__mnemonic_2)

    accts[3] = {}
    accts[3]['pk'] = mnemonic.to_public_key(__mnemonic_3)
    accts[3]['sk'] = mnemonic.to_private_key(__mnemonic_3)



    mnemonic_obj_b1 = mnemonic.to_private_key(__mnemonic_2)
    mnemonic_obj_b2 = mnemonic.to_public_key(__mnemonic_2)
    


    # Create an Application client containing both an algod client and my app
    
    app_client = algod.AlgodClient(algod_token, algod_address,headers={'User-Agent': 'DoYouLoveMe?'})

    

    _app_id : int = 157718578  

    escrow_address =get_application_address(_app_id)

    pc :int = 79

    print('Algod Client Status: ',algod_client.status())

    command = input("Enter command  [deploy,pay,withdraw,deposit,mint,fetch, fetch2, balance, delete, update ,debug ]  ")
    
    "*****************Perform Transactions Operations**********************"

    match command:
        case "deploy":

            



            "Deploy Smart Contract"
            deploy(_params, accts[1]['sk'],algod_client, 2500)
        case "delete":
    
            "Delete Smart Contract"
            delete_app(algod_client, accts[1]['sk'], _app_id)
        case "pay" :
        
            

            "Pay to Account"
            pay(algod_client, accts[1]['sk'], escrow_address, 1101101)

        case "withdraw":
    
            
            call_app_method(app_client,accts[3]['sk'],_app_id, 2500,get_method("withdraw"), 10_000,accts[3]['pk'] )

        case "deposit":

        

            print ("depositing 101100 MicroAlgos to Escrow Address ", escrow_address)

            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)

            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method("deposit"), txn ,accts[2]['pk'] )
        case "update":


            update_(app_client, _app_id, _params,accts[1]['sk'])


        case "mint":

            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)            
            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method("mint"), accts[2]['pk'] ,txn )
            

        case "fetch" :
            
            #Prints Withdrawal & Deposit Information from box storage as Raw Bytes
            

            print("Withdrawal Amounts: ",app_client.application_box_by_name(_app_id,bytes("BoxB".encode('utf-8', 'strict'))))

            print("Withdrawal recipients: ",app_client.application_box_by_name(_app_id,bytes("BoxC".encode('utf-8', 'strict'))))
  
            print("Depositors Address: ", app_client.application_box_by_name(_app_id,bytes("BoxA".encode('utf-8', 'strict'))))

        case "fetch2" :
            #Prints Withdrawal & Deposit Information from box storage Decoded to Int and String
            #Documentation: https://developer.algorand.org/docs/get-details/encoding/
            
            result2 = app_client.application_box_by_name(_app_id,bytes("BoxC".encode('utf-8', 'strict')))
            q =encode_address(base64.b64decode(result2["value"]))
            print ("Withdrawal recipients: ",q)


            result3 = app_client.application_box_by_name(_app_id,bytes("BoxA".encode('utf-8', 'strict')))
            g =encode_address(base64.b64decode(result3["value"]))
            print ("Depositors Addresses: ",g)



            result =app_client.application_box_by_name(_app_id,bytes("BoxB".encode('utf-8', 'strict')))
            
            p = int.from_bytes(base64.b64decode(result["value"]), byteorder="big")
            print("Withdrawal Amount: ",p)

            

        case "balance":

            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method("balance"),accts[2]['pk'] )

        case "debug":
            pc =input ("enter program counter")
            # Using system() method  and Teal Inspector to
            # execute shell commands
            subprocess.Popen('tealinspector --network testnet --application_id {} --program_counter {}'.format(_app_id, pc), shell=True)

        case other:
            print ("No Match Found, Please Pass a Valid command to this Method in ln 309")


# Utility function to get the Method object for a given method name
def get_method(name: str) :
    with open("algobank.json") as f:
        js = f.read()
    c = Contract.from_json(js)
    for m in c.methods:
        if m.name == name:
            print ("M: ",m.name)
            return m
    raise Exception("No method with the name {}".format(name))


def update_(algod_client, app_id, params, private_key):

    #Docs: https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/transaction.html?highlight=ApplicationUpdateTxn#algosdk.transaction.ApplicationUpdateTxn


    # Read the compiled approvl & clear programs Teal files 
    
    """
   
    """

    with open("algobank_approval.teal", "r") as f:
        approval_program = f.read()

    with open("algobank_clear_state.teal", "r") as f:
        clear_state_program= f.read()
   

    # compile program to binary
    approval_program_compiled = compile_program(algod_client, approval_program)

    # compile program to binary
    clear_state_program_compiled = compile_program(algod_client, clear_state_program)

    update_app(algod_client, app_id, params ,private_key, approval_program_compiled,clear_state_program_compiled)



def deploy(_params, mnemonic_ ,algod_client, fee):

    _params.flat_fee = True
    _params.fee = fee


    # declare application state storage (immutable)
    local_ints = 0
    local_bytes = 0
    global_ints = 1
    global_bytes = 1
    global_schema = transaction.StateSchema(global_ints, global_bytes)
    local_schema = transaction.StateSchema(local_ints, local_bytes)


    # Read the compiled approvl & clear programs Teal files 
    
    """
   
    """

    with open("algobank_approval.teal", "r") as f:
        approval_program = f.read()

    with open("algobank_clear_state.teal", "r") as f:
        clear_state_program= f.read()
   


    



    response = algod_client.compile(approval_program)
    print ("Raw Response =",response )
    print("Response Result = ",response['result'])
    print("Response Hash = ",response['hash'])


    # compile program to binary
    approval_program_compiled = compile_program(algod_client, approval_program)

    # compile program to binary
    clear_state_program_compiled = compile_program(algod_client, clear_state_program)


    app_id = create_app(algod_client,_params ,mnemonic_, approval_program_compiled, clear_state_program_compiled, global_schema, local_schema)

    # Create the applicatiion on chain, set the app id for the app client & store app secret
    print(f"Created App with id: {app_id} ")


"""
THE MAIN METHOD
"""

if __name__ == "__main__":
    
    #Builds the progam and deploys
    ca = BoxEscrow()
    

    # Application State Machine
    create_algorand_node_and_acct("")
    



# File: https://github.com/Sotatek-NguyenNguyen/gs-sc-algo/blob/04452faf44e9472fd718b9a50c13a5c4b83a564a/contract/nftContracts.py
from pyteal import *


def approval_program():
    # Global
    asset_name = Bytes("asset_name")

    # @Subroutine(TealType.uint64)
    # def executeAssetCreationTxn(txn_index: TealType.uint64) -> TxnExpr:
    #     """
    #     returns the ID of the generated asset or fails
    #     """
    #     call_parameters = Gtxn[txn_index].application_args
    #     asset_total = Btoi(call_parameters[3])
    #     decimals = Btoi(call_parameters[4])
    #     return Seq([
    #         InnerTxnBuilder.Begin(),
    #         InnerTxnBuilder.SetFields({
    #             TxnField.type_enum: TxnType.AssetConfig,
    #             # TxnField.config_asset_name: call_parameters[1],
    #             # TxnField.config_asset_unit_name: call_parameters[2],
    #             # TxnField.config_asset_total: asset_total,
    #             # TxnField.config_asset_decimals: decimals,
    #             # TxnField.config_asset_url: call_parameters[5],

    #             # TxnField.config_asset_default_frozen: Int(1),
    #             # TxnField.config_asset_metadata_hash: call_parameters[0],

    #             TxnField.config_asset_manager: Global.current_application_address(),
    #             TxnField.config_asset_reserve: Global.current_application_address(),
    #             TxnField.config_asset_freeze: Global.current_application_address(),
    #             TxnField.config_asset_clawback: Global.current_application_address(),
    #         }),
    #         InnerTxnBuilder.Submit(),
    #         Log(Itob(InnerTxn.created_asset_id())),
    #         # InnerTxn.created_asset_id()
    #     ])

    @Subroutine(TealType.none)
    def executeAssetCreationTxn() -> TxnExpr:
        return Seq([
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields({
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_name: App.globalGet(asset_name),
                TxnField.config_asset_unit_name: Txn.application_args[1],
                TxnField.config_asset_total: Int(1),
                TxnField.config_asset_decimals: Int(0),
                TxnField.config_asset_url: Txn.application_args[2],

                TxnField.config_asset_manager: Global.current_application_address(),
                TxnField.config_asset_reserve: Global.current_application_address(),
                TxnField.config_asset_freeze: Global.current_application_address(),
                TxnField.config_asset_clawback: Global.current_application_address(),
            }),
            InnerTxnBuilder.Submit(),
            Log(Itob(InnerTxn.created_asset_id())),
        ])

    @Subroutine(TealType.none)
    def executeAssetTransferTxn() -> TxnExpr:
        return Seq([
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: Txn.assets[0],
                    TxnField.asset_receiver: Txn.accounts[1],
                    # TxnField.asset_close_to:Txn.accounts[1],
                    TxnField.asset_amount: Int(1),
                }
            ),
            InnerTxnBuilder.Submit(),
        ])

    @Subroutine(TealType.none)
    def executeAssetDestroyTxn() -> TxnExpr:
        return Seq([
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.type_enum: TxnType.AssetConfig,
                    # TxnField.xfer_asset: Txn.assets[0],
                    TxnField.config_asset: Txn.assets[0]

                }
            ),
            InnerTxnBuilder.Submit(),
        ])

    on_create = Seq(
        App.globalPut(asset_name, Txn.application_args[0]),
        Approve(),
    )
    on_mint = Seq(
        executeAssetCreationTxn(),
        Approve(),
    )
    on_withdraw = Seq(
        executeAssetTransferTxn(),
        Approve(),
    )
    on_deposit = Seq(
        executeAssetDestroyTxn(),
        Approve(),
    )

    on_call_method = Txn.application_args[0]
    on_call = Cond(
        [on_call_method == Bytes("mint"), on_mint],
        [on_call_method == Bytes("withdraw"), on_withdraw],
        [on_call_method == Bytes("deposit"), on_deposit],

    )

    program = Cond(
        [Txn.application_id() == Int(0), on_create],
        [Txn.on_completion() == OnComplete.NoOp, on_call],
        [
            Or(
                Txn.on_completion() == OnComplete.OptIn,
                Txn.on_completion() == OnComplete.CloseOut,
                Txn.on_completion() == OnComplete.UpdateApplication,
            ),
            Reject(),
        ],
    )

    return program


def clear_state_program():
    return Approve()


with open("teal/nft/auction_approval.teal", "w") as f:
    compiled = compileTeal(
        approval_program(), mode=Mode.Application, version=5)
    f.write(compiled)

with open("teal/nft/auction_clear_state.teal", "w") as f:
    compiled = compileTeal(clear_state_program(),
                           mode=Mode.Application, version=5)
    f.write(compiled)


# File: https://github.com/CupStakes/cupstakes-smart-contracts/blob/2155155985eb525f111458e0c237b0aaed642c39/draw/sc.py
from pyteal import *
from assets import ticket_price, burn_ticket_price, storage_app_id, oracle_app_id, rewards_pool_address, super_admin_address

# Of the above:
# - immutable:
#   - rewards_pool_address: hardcoded
#   - storage_app_id: hardcoded
# - mutable / just initial values, stored in global storage:
#   - ticket_price
#   - burn_ticket_price
#   - oracle_app_id

storage_app_id_int = Int(storage_app_id)

max_randomness_range = 1000

# Define Byte sequences used
# Numbers and special symbols
bytes_empty = Bytes('')
bytes_151f7c75 = Bytes('base16', '151f7c75') # successful return from ABI call header

# global storage lookup keys
# kill switch: leave only "collect" action available
kill_switch_key = Bytes('kill')
# free draw NFT ID + implicit availability 
free_draw_nft_id_key = Bytes('free_draw_nft')
# ticket price in mAlgo
ticket_key = Bytes('ticket')
burn_ticket_key = Bytes('burn_ticket')
# oracle app id
oracle_app_id_key = Bytes('oracle_app_id')
# sum or all odds of team NFTs. MUST BE POWER OF TWO
max_odds_key = Bytes('max_odds')
# randomness oracle maximum range
max_randomness_range_key = Bytes('max_randomness_range')

# local (user) storage lookup keys
# NFT slots, available to collect
slot1_key = Bytes("slot1")
slot2_key = Bytes("slot2")
slot3_key = Bytes("slot3")
# queued draw action. valid after round
draw_round_key = Bytes("draw_round")
# queued draw action. amount to draw
draw_amount_key = Bytes("draw_amount")
draw_amount_paid_key = Bytes("draw_amount_paid")

# Log and misc
bytes_rand = Bytes('rand')
bytes_ret = Bytes('ret')
bytes_default = Bytes('default')
bytes_rand_mapped = Bytes("Rand mapped")

# extra_fields{} for zero fees
zero_fee_extra_fields={}
zero_fee_extra_fields[TxnField.fee]=Int(0)

# error strings end up in algod error messages <3
err_contract_killed = "CONTRACT KILLED"
err_validation = "VALIDATION FAIL"
err_payment_incorrect = "PAYMENT FAIL"
err_payment_amount_invalid = "PAYMENT AMT FAIL"
err_wait_for_randomness = "WAIT FOR RANDOMNESS"
err_oracle_invalid = "ORACLE INVALID"
err_randomness_fail = "RANDOMNESS FAIL"
err_drawing_failed = "DRAWING FAILED"
err_drawing_disabled = "DRAWING DISABLED"
err_slot_not_empty = "MUST COLLECT"
err_no_free_slot = "NO FREE SLOT"
err_no_slots_full = "NO NFTs IN SLOTS"
err_unauthorized = "UNAUTH"
err_draw_queued = "ERR DRAW QUEUED ALREADY"
err_no_draw_queued = "ERR NO DRAW QUEUED"
err_randomness_expired = "ERR RANDOMNESS EXPIRED"
err_randomness_not_expired = "ERR RANDOMNESS NOT EXPIRED"
err_no_burn_available = "ERR BURN NOT AVAILABLE"
err_invalid_slot = "ERR INVALID SLOT"
err_no_burn_hacking = "ERR NO BURN HACKING"

opup = OpUp(OpUpMode.Explicit, storage_app_id_int)

# my greatest invention
# assert that fails with an error string attached
# Example error message: logic eval error: assert failed pc=2330. Details: pc=2330, opcodes=pushbytes 0x45525220445241572051554555454420414c5245414459 // "ERR DRAW QUEUED ALREADY"
def custom_assert(cond, str):
    return If(Not(cond)).Then(Assert(Bytes('') == Bytes(str)))

# same as above, but inversed - skips a Not()
# not sure if it saves opcode costs
def fail_if(cond, str):
    return If(cond).Then(Assert(Bytes('') == Bytes(str)))

# as above but without condition
def fail(str):
    return Assert(bytes_empty == Bytes(str))

# helper function to get the draw amount of a user
# called with 0 for txn sender (draw/freedraw) or 1 (first Txn.accounts entry) for executing the draw 
def user_draw_amount(acctIdx):
    return App.localGet(acctIdx, draw_amount_key)

# return whether draw_round randomness has expired for user $acct
# called with 1 (first Txn.accounts entry) for executing the draw or refund
def randomness_expired(addrIdx):
    return Global.round() > App.globalGet(max_randomness_range_key) + App.localGet(addrIdx, draw_round_key)

# reset user draw state to initial (no draw)
# called with 0 when opting in or 1 (first Txn.accounts entry) for executing the draw 
def reset_user_draw_state(addrIdx):
    return Seq(
        App.localPut(addrIdx, draw_amount_key, Int(0)),
        App.localPut(addrIdx, draw_amount_paid_key, Int(0)),
        App.localPut(addrIdx, draw_round_key, Int(0))
    )

# Set up default values upon creation; convenience operation, all of these are updatable
handle_creation = Seq(
    App.globalPut(kill_switch_key, Int(0)), # kill-switch when 1 - only allow collecting and emptying NFTs
    App.globalPut(free_draw_nft_id_key, Int(0)), # free draw NFT ID
    App.globalPut(ticket_key, Int(ticket_price)), # ticket price in mAlgo
    App.globalPut(burn_ticket_key, Int(burn_ticket_price)), # burn ticket price in mAlgo
    App.globalPut(max_odds_key, Int(1048576)), # max odds for modulo op. MUST BE POWER OF TWO
    App.globalPut(oracle_app_id_key, Int(oracle_app_id)), # randomness oracle app id - mutable in case of permanent beacon failure
    App.globalPut(max_randomness_range_key, Int(max_randomness_range)), # range after which to refund ticket price
    Approve()
)

# User opting in: Set up 3 local storage slots representing drawn NFT ID load slots,
# and the "draw queue" entries: amount of draws and round to draw at
handle_optin = Seq(
    App.localPut(Int(0), slot1_key, Int(0)),
    App.localPut(Int(0), slot2_key, Int(0)),
    App.localPut(Int(0), slot3_key, Int(0)),
    reset_user_draw_state(Int(0)),
)

# Collect available NFTs
# Assumes we have "infinite" NFTs available - will mint 10M per for CupStakes
@Subroutine(TealType.none)
def sub_collect():
    return Seq(
        # check that at least some NFT slots are full
        custom_assert(Or(
            App.localGet(Int(0), slot1_key) != Int(0),
            App.localGet(Int(0), slot2_key) != Int(0),
            App.localGet(Int(0), slot3_key) != Int(0)
        ), err_no_slots_full),
        If(App.localGet(Int(0), slot1_key) != Int(0)).Then(Seq(
            # send slot 1
            InnerTxnBuilder.Execute({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: App.localGet(Int(0), slot1_key),
                TxnField.asset_receiver: Txn.sender(),
                TxnField.asset_amount: Int(1),
                TxnField.fee: Int(0)
            }),
            # clear slot 1
            App.localPut(Int(0), slot1_key, Int(0))
        )),
        If(App.localGet(Int(0), slot2_key) != Int(0)).Then(Seq(
            # send slot 2
            InnerTxnBuilder.Execute({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: App.localGet(Int(0), slot2_key),
                TxnField.asset_receiver: Txn.sender(),
                TxnField.asset_amount: Int(1),
                TxnField.fee: Int(0)
            }),
            # clear slot 2
            App.localPut(Int(0), slot2_key, Int(0))
        )),
        If(App.localGet(Int(0), slot3_key) != Int(0)).Then(Seq(
            # send slot 3
            InnerTxnBuilder.Execute({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: App.localGet(Int(0), slot3_key),
                TxnField.asset_receiver: Txn.sender(),
                TxnField.asset_amount: Int(1),
                TxnField.fee: Int(0)
            }),
            # clear slot 3
            App.localPut(Int(0), slot3_key, Int(0))
        )),
    )

# validate that the contract is not killswitched
@Subroutine(TealType.none)
def not_killed():
    return custom_assert(App.globalGet(kill_switch_key) == Int(0), err_contract_killed)

# validate caller is the super_admin_address
@Subroutine(TealType.none)
def super_admin_only():
    return fail_if(Gtxn[0].sender() != Addr(super_admin_address), err_unauthorized)

# validate called is admin/creator
@Subroutine(TealType.none)
def admin_only():
    return fail_if(Gtxn[0].sender() != Global.creator_address(), err_unauthorized)

# Handles deleting the contract
# Will send all ALGO And remaining NFTs to the rewards wallet
handle_delete_app = Seq(
    admin_only(),
    InnerTxnBuilder.Execute({
        TxnField.type_enum: TxnType.Payment,
        TxnField.close_remainder_to: Global.creator_address(),
        TxnField.fee: Int(0),
    })
)

# handle user's app close-out and clear-out
# If we have NFTs available in slots and user requests close-out
# we opt into them in the group txn if necessary
# so here we send them
# and then delete local state (likely not needed)
# close-out may fail if not opted in, clear-out will not
handle_close_out = Seq(
    If(Or(
        App.localGet(Int(0), slot1_key) != Int(0),
        App.localGet(Int(0), slot2_key) != Int(0),
        App.localGet(Int(0), slot3_key) != Int(0)
    )).Then(
        sub_collect()
    ),
    App.localDel(Int(0), slot1_key),
    App.localDel(Int(0), slot2_key),
    App.localDel(Int(0), slot3_key),
)

# Main router class
router = Router(
    # Name of the contract
    "draw",
    # What to do for each on-complete type when no arguments are passed (bare call)
    BareCallActions(
        # On create only, just approve
        no_op=OnCompleteAction.create_only(handle_creation),
        # Always let creator update/delete but only by the creator of this contract
        update_application=OnCompleteAction.call_only(super_admin_only), # super admin = 2/2 multisig:nullun+D13
        delete_application=OnCompleteAction.call_only(handle_delete_app), # admin = D13
        opt_in=OnCompleteAction.always(handle_optin), # user opt-in - set up user local state
        close_out=OnCompleteAction.call_only(handle_close_out), # send stored NFTs before closing out state (will fail if user is not opted in)
        clear_state=OnCompleteAction.call_only(handle_close_out) # attempt to send NFTs before clearing state (won't fail)
    ),
)

# admin method to close out all held NFTs to creator address
# intentionally allowed when contract is killed
@router.method
def closeout_nft():
    i = ScratchVar(TealType.uint64)
    return Seq(
        # creator is calling us or fail
        admin_only(),
        # iterate all foreign assets in Txn, close out
        For(i.store(Int(0)), i.load() < Txn.assets.length(),  i.store(i.load() + Int(1))).Do(Seq(
            # close out remaining NFT balances to creator address
            InnerTxnBuilder.Execute({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: Txn.assets[i.load()],
                TxnField.asset_close_to: Global.creator_address(),
            })
        ))
    )

# admin method to opt contract in to NFTs
# opts in to all txn's foreign assets
@router.method
def optin():
    i = ScratchVar(TealType.uint64)
    return Seq(
        # creator is calling us or fail
        admin_only(),
        # disabled when contract is killed
        not_killed(),
        # iterate all foreign assets in Txn, opt in
        For(i.store(Int(0)), i.load() < Txn.assets.length(),  i.store(i.load() + Int(1))).Do(
            # send opt-in to NFT txn
            InnerTxnBuilder.Execute({
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: Txn.assets[i.load()],
                TxnField.asset_receiver: Global.current_application_address(),
            })
        )
    )

# admin method to change global state (8x)
@router.method
def update_state_int(key1: abi.DynamicBytes, val1: abi.Uint64,
                     key2: abi.DynamicBytes, val2: abi.Uint64,
                     key3: abi.DynamicBytes, val3: abi.Uint64,
                     key4: abi.DynamicBytes, val4: abi.Uint64,
                     key5: abi.DynamicBytes, val5: abi.Uint64,
                     key6: abi.DynamicBytes, val6: abi.Uint64,
                     key7: abi.DynamicBytes, val7: abi.Uint64,
                     key8: abi.DynamicBytes, val8: abi.Uint64):
    return Seq(
        # only admin/creator can call update global state
        admin_only(),
        # disabled when contract is killed
        not_killed(),
        If(key1.get() != bytes_empty).Then(App.globalPut(key1.get(), val1.get())),
        If(key2.get() != bytes_empty).Then(App.globalPut(key2.get(), val2.get())),
        If(key3.get() != bytes_empty).Then(App.globalPut(key3.get(), val3.get())),
        If(key4.get() != bytes_empty).Then(App.globalPut(key4.get(), val4.get())),
        If(key5.get() != bytes_empty).Then(App.globalPut(key5.get(), val5.get())),
        If(key6.get() != bytes_empty).Then(App.globalPut(key6.get(), val6.get())),
        If(key7.get() != bytes_empty).Then(App.globalPut(key7.get(), val7.get())),
        If(key8.get() != bytes_empty).Then(App.globalPut(key8.get(), val8.get())),
    )

# mint "free draw" nft that is accepted in lieu of ticket by free_draw entry point
# admin only; admin must pay the ticket price into the rewards pool
@router.method
def get_free_draw_nft(num: abi.Uint64):
    return Seq(
        # only creator can make free_draw nfts
        admin_only(),
        # disabled when contract is killed
        not_killed(),
        # drawing enabled check. is this pointless?
        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),
        # first group txn type == algo payment
        fail_if(Gtxn[0].type_enum() != TxnType.Payment, err_payment_incorrect),
        # multisig rewards should receive the funds
        fail_if(Gtxn[0].receiver() != Addr(rewards_pool_address), err_payment_incorrect),
        # validate enough paid
        fail_if(Gtxn[0].amount() != num.get() * App.globalGet(ticket_key), err_payment_amount_invalid),
        # send NFT 
        InnerTxnBuilder.Execute({
            TxnField.type_enum: TxnType.AssetTransfer,
            TxnField.xfer_asset: App.globalGet(free_draw_nft_id_key),
            # hardcoded to creator address
            TxnField.asset_receiver: Global.creator_address(),
            TxnField.asset_amount: num.get(),
            # user pays fees
            TxnField.fee: Int(0)
        })
    )

# function to validate ALGO payments for 1/3 draws or 1/2/3 burns
# fails is drawing is disabled (ticket price == 0)
# ticket_key will be 'ticket' or 'burn_ticket'
@Subroutine(TealType.none)
def validate_payment(multiplier, ticket_key):
    return Seq(
        # multiplier is 1 or 3
        # validate first payment: (algo) payment type
        fail_if(Gtxn[0].type_enum() != TxnType.Payment, err_payment_incorrect),
        # validate first payment: multiplier times ticket price
        fail_if(Gtxn[0].amount() != multiplier * App.globalGet(ticket_key), err_payment_amount_invalid),
        # receiver must be rewards pool address
        fail_if(Gtxn[0].receiver() != Addr(rewards_pool_address), err_payment_incorrect),
    )

# function to validate Free Draw NFT payments for 1x Free Draw
# fails is drawing is disabled (ticket price == 0)
@Subroutine(TealType.none)
def validate_free_draw_payment(multiplier):
    return Seq(
        # drawing enabled check. redundant as we check in queue_draw but we deployed it like this, so :)
        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),
        # validate free draw payment with free draw nft
        fail_if(Gtxn[0].type_enum() != TxnType.AssetTransfer, err_payment_incorrect),
        # multiplier will be = 1
        fail_if(Gtxn[0].asset_amount() != multiplier, err_payment_amount_invalid),
        # free draw NFTs should be sent to the application address
        fail_if(Gtxn[0].asset_receiver() != Global.current_application_address(), err_payment_incorrect),
        # confirm NFT ID matches
        fail_if(Gtxn[0].xfer_asset() != App.globalGet(free_draw_nft_id_key), err_payment_incorrect)
    )

# get random bytes from randomness oracle for $acct, round $rand_count - $cur
# going before $rand_count is safe because rounds [$seed-7 -> $seed] are seeded by $seed round
# returns random 32 byte / 256 bit sequence
# account here is BYTES, not index like in other calls
@Subroutine(TealType.bytes)
def get_random_bytes(acct, rand_round, cur):
    res = abi.DynamicBytes()
    return Seq(
        # call the randomness contract
        # passing round-$i (i in 0,1,2) and user address as user_bytes
        # for multiple calls we prefer to call 3x for transparency w/ end users
        InnerTxnBuilder.ExecuteMethodCall(
            app_id=App.globalGet(oracle_app_id_key),
            method_signature="get(uint64,byte[])byte[]", # using get instead of must_get intentionally, handling zero byte return further down when randomness isn't ready (pretty error message)
            args=[Itob(Minus(rand_round, cur)), acct],
            extra_fields=zero_fee_extra_fields, # user pays fees
        ),
        # last_log is the encoded ABI return value
        # It must begin with hex 151f7c75
        fail_if(Len(InnerTxn.last_log()) < Int(6), err_oracle_invalid),
        fail_if(Substring(InnerTxn.last_log(), Int(0), Int(4)) != bytes_151f7c75, err_randomness_fail),
        # decode the ABI return value into res scratch slot
        abi.DynamicBytes.decode(res, Substring(InnerTxn.last_log(), Int(4), Len(InnerTxn.last_log()))),
        # check that it isn't zero (eg when randomness was not ready yet)
        fail_if(res.get() == bytes_empty, err_randomness_fail),
        Log(bytes_rand),
        Log(res.get()),
        Return(res.get())
    )

# helper to get int value from storage contract's global storage
@Subroutine(TealType.uint64)
def get_ext_storage(keynum):
    extvalue = App.globalGetEx(storage_app_id_int, Itob(keynum))
    return Seq(
        extvalue, # must include this or pyteal compilation fails
        Return(extvalue.value())
    )

# pick next round as a draw target
# if we are at round mod 8 == 0 it is safe to use current round
# as the randomness seed is based on this current block's signature
# so it can't be known yet
# otherwise choose the next multiple of 8
@Subroutine(TealType.uint64)
def get_next_rand_round():
    return Return(Cond( # I don't know why this isn't an If() statement. Don't ask. Still, effectively the same.
        [Mod(Global.round(), Int(8)) == Int(0), Global.round()],
        [Int(1), Add(Global.round(), Minus(Int(8), Mod(Global.round(), Int(8))))],
    ))

# map a 256 bit random value into one of the NFTs according to their rarity
# team NFT IDs and odds are stored like so:
# 1: TEAM_1_NFT_ID
# 2: TEAM_1_ODDS
# 3: TEAM_2_NFT_ID
# 4: TEAM_2_ODDS + TEAM_1_ODDS
# ...
# 63: TEAM_32_NFT_ID
# 64: SUM(TEAM_ODDS) ~ aka max_odds **MUST BE POWER OF 2 for mapping from 256 bits to be uniform**
# We get a 256 bit random value and do modulo SUM(TEAM_ODDS) (stored in global storage max_odds_key)
# this goes into rand_val and is in [0, max_odds)
# then iterate for(i=2; i<=64; i+=2)
# first nft odds value which is larger than $rand_val is the NFT to return
# the ID is one index before the currently iterated idx
@Subroutine(TealType.uint64)
def get_random_nft_id(acct, rnd, iter):
    i = ScratchVar(TealType.uint64)
    rand_val = ScratchVar(TealType.uint64)
    return Seq(
        # random(256bit) modulo (max_odds) -> to_integer() -> $rand_val
        rand_val.store(Btoi(
            BytesMod( # BytesMod is expensive - could have sliced a few bytes off the rnd tail, Btoi and do int mod so save op costs
                get_random_bytes(acct, rnd, iter), # 256 bit
                Itob(App.globalGet(max_odds_key)) # Must be power of 2
            )
        )),
        Log(bytes_rand_mapped), # debug/log label & mapped rand value
        Log(Itob(rand_val.load())),
        # for all possible NFT values
        For(i.store(Int(2)),
            Le(i.load(), Int(64)),
            i.store(Add(i.load(), Int(2)))
        ).Do(Seq(
            # described in function header doc
            If (get_ext_storage(i.load()) > rand_val.load()).Then(Seq(
                # switch to using i as results storage
                # ID to return is one before the odds that just won
                i.store(get_ext_storage(Minus(i.load(), Int(1)))),
                # assert that the value is not zero
                fail_if(i.load() == Int(0), err_drawing_failed), # Needed?
                Return(i.load())
            ))
        )),
        # failsafe
        fail_if(Int(1), err_drawing_failed),
        # never reached, but pyteal like this
        Return(Int(1))
    )

# translate int(1,2,3) -> slot1_key slot2_key slot3_key or fail the program  
# used by burn entry points to map slot idx to slot name
@Subroutine(TealType.bytes)
def slot_int_to_key(slot_int):
    return Cond(
        [slot_int == Int(1), slot1_key],
        [slot_int == Int(2), slot2_key],
        [slot_int == Int(3), slot3_key],
        [Int(1), Seq(fail(err_invalid_slot), bytes_empty)] # The seq, bytes dance is to satisfy pyteal
    )

# utility to get the first available free NFT slot in user storage
# empty bytes is all slots filled
@Subroutine(TealType.bytes)
def get_free_slot_for(addrIdx):
    return Cond(
        [App.localGet(addrIdx, slot1_key) == Int(0), slot1_key],
        [App.localGet(addrIdx, slot2_key) == Int(0), slot2_key],
        [App.localGet(addrIdx, slot3_key) == Int(0), slot3_key],
        [Int(1), bytes_empty]
    )

# validate (num) 1 or 3 free slots are available in user storage
# used before a draw is queued
@Subroutine(TealType.none)
def validate_free_slots(num, acctIdx):
    return Cond(
        # validating 1 slot available: is there is any free slot we're good
        [num == Int(1), fail_if(get_free_slot_for(acctIdx) == bytes_empty, err_no_free_slot)], # NO FREE SLOT
        # validating all slots are available
        [Int(1), custom_assert(And(
            App.localGet(acctIdx, slot1_key) == Int(0),
            App.localGet(acctIdx, slot2_key) == Int(0),
            App.localGet(acctIdx, slot3_key) == Int(0)
        ), err_slot_not_empty)] # "MUST_COLLECT"
    )

# internal method to queue a draw action into user local storage
@Subroutine(TealType.uint64)
def queue_draw(num, paid_num, ticket_key):
    return Seq(
        # drawing is enabled
        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),
        # already a draw in queue? fail
        fail_if(user_draw_amount(Int(0)) != Int(0), err_draw_queued),
        # save amount of draws in key
        App.localPut(Int(0), draw_amount_key, num),
        # save amount paid for refund in case of randomness expiry
        App.localPut(Int(0), draw_amount_paid_key, App.globalGet(ticket_key) * paid_num),
        # get next safe randomness round and save it in key
        App.localPut(Int(0), draw_round_key, get_next_rand_round()),
        # return the round so the user knows how long to wait (+2 in practice for the VRF oracle to be seeded by off-chain service)
        Return(App.localGet(Gtxn[0].sender(), draw_round_key))
    );


# DRAW/BURN_DRAW/FREE_DRAW methods
# these all return the randomness round commitment

# entry point to queue a 1x draw paying with a free draw NFT
@router.method
def free_draw(*, output: abi.Uint64):
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # validate 1x Free Draw NFTs sent or fail
        validate_free_draw_payment(Int(1)),
        # validate there are 1x free NFT slots in user storage or fail
        validate_free_slots(Int(1), Int(0)),
        # add a 1x draw "queue" to user storage and return the round
        # paid == 0 - no refunds for free drawers, sorry
        output.set(queue_draw(Int(1), Int(0), ticket_key))
    )

# entry point to queue a 1x draw paying with ALGO
@router.method
def draw(*, output: abi.Uint64):
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # validate 1x ALGO payments are sent or fail
        validate_payment(Int(1), ticket_key),
        # validate there is 1x free slot available to draw into, or fail
        validate_free_slots(Int(1), Int(0)),
        # add a 1x draw "queue" to user storage and return the round
        output.set(queue_draw(Int(1), Int(1), ticket_key))
    )

# entry point to queue a 3x draw paying with ALGO
@router.method
def draw3(*, output: abi.Uint64):
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # validate 3x ALGO ticket price is sent or fail
        validate_payment(Int(3), ticket_key),
        # validate there are 3x free NFT slots in user storage or fail
        validate_free_slots(Int(3), Gtxn[0].sender()),
        # add a 3x draw "queue" to user storage and return the round
        output.set(queue_draw(Int(3), Int(3), ticket_key))
    )

@router.method
def burn_draw(slot: abi.Uint64, *, output: abi.Uint64):
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # validate passed slot is burnable
        fail_if(App.localGet(Int(0), slot_int_to_key(slot.get())) == Int(0), err_no_burn_available),
        # "burn" NFT - zero out slot$n
        App.localPut(Int(0), slot_int_to_key(slot.get()), Int(0)),
        # validate burn payment sent
        validate_payment(Int(1), burn_ticket_key),
        # skip validate free slot, we just created one
        # add a 1x draw "queue" to user storage and return the round
        output.set(queue_draw(Int(1), Int(1), burn_ticket_key))
    )

@router.method
def burn_draw2(slot1: abi.Uint64, slot2: abi.Uint64, *, output: abi.Uint64):
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # validate passed slots are burnable
        fail_if(slot1.get() == slot2.get(), err_no_burn_hacking), # if sneaky user tries to burn the same slot twice, amuse them with an error message
        fail_if(App.localGet(Int(0), slot_int_to_key(slot1.get())) == Int(0), err_no_burn_available),
        fail_if(App.localGet(Int(0), slot_int_to_key(slot2.get())) == Int(0), err_no_burn_available),
        # "burn" NFTs - zero out slots
        App.localPut(Int(0), slot_int_to_key(slot1.get()), Int(0)),
        App.localPut(Int(0), slot_int_to_key(slot2.get()), Int(0)),
        # validate burn payment sent
        validate_payment(Int(2), burn_ticket_key),
        # skip validate free slot, we just created two
        # add a 1x draw "queue" to user storage and return the round
        output.set(queue_draw(Int(2), Int(2), burn_ticket_key))
    )

@router.method
def burn_draw3(*, output: abi.Uint64):
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # validate 3 NFTs are in user storage to burn
        custom_assert(get_free_slot_for(Int(0)) == bytes_empty, err_no_burn_available),
        # validate 3x ALGO ticket price is sent or fail
        validate_payment(Int(3), burn_ticket_key),
        App.localPut(Int(0), slot_int_to_key(Int(1)), Int(0)),
        App.localPut(Int(0), slot_int_to_key(Int(2)), Int(0)),
        App.localPut(Int(0), slot_int_to_key(Int(3)), Int(0)),
        # add a 3x draw "queue" to user storage and return the round
        output.set(queue_draw(Int(3), Int(3), burn_ticket_key))
    )

# does the actual drawing
# meant to be called by (our) backend to make the UX nicer but isn't restricted as such
# we have exposed a fallback to end users in the frontend if our redundant backends fail
# note we are using "1" as the account index - meaning first foreign account
@router.method
def exec_draw():
    i = ScratchVar(TealType.uint64) # draw number iterator
    return Seq(
        # disabled when contract is killed
        not_killed(),
        # Otherwise do store(txn.accounts.last())
        # if no draw queued, fail
        fail_if(Eq(user_draw_amount(Int(1)), Int(0)), err_no_draw_queued),
        # if round is not past yet, fail
        fail_if(Lt(Global.round(), App.localGet(Int(1), draw_round_key)), err_wait_for_randomness),
        fail_if(randomness_expired(Int(1)), err_randomness_expired),
        # auto-inner TXN to storage app to increase budget - triggers when 3x draw
        opup.ensure_budget(Int(450) * user_draw_amount(Int(1))),
        # for i=0; i<user.draw_amount; i++
        For(i.store(Int(0)), Lt(i.load(), user_draw_amount(Int(1))), i.store(Add(i.load(), Int(1)))).Do(Seq(
            App.localPut(
                Int(1),
                # get free NFT slot for user
                get_free_slot_for(Int(1)),
                # save a random NFT ID
                get_random_nft_id(
                    Txn.accounts[Int(1)],
                    App.localGet(Int(1), draw_round_key), # agreed upon round
                    i.load() # draw number in [0, 1, 2]
                 )
            )
        )),
        # reset queued draw user storage keys
        reset_user_draw_state(Int(1))
    )

# collect all available NFTs from user storage slots
# intentionally left enabled when contract is killed
@router.method
def collect():
    return sub_collect()

# refund in case randomness has expired
# this should never happen, but has to be factored in anyhow
# free draw users are SOL
# paying users get their money back & a digital apology
# intentionally left available when contract is killed
@router.method
def refund(*, output: abi.Uint64):
    amount = ScratchVar(TealType.uint64) # draw amount to refund
    addr = ScratchVar(TealType.bytes) # address to refund
    return Seq(
        # Otherwise do store(txn.accounts.last())
        # if no draw queued, fail
        addr.store(Txn.accounts[Int(1)]),
        fail_if(user_draw_amount(Int(1)) == Int(0), err_no_draw_queued),
        # if round is not past yet, fail
        custom_assert(randomness_expired(Int(1)), err_randomness_not_expired),
        amount.store(App.localGet(Int(1), draw_amount_paid_key)),
        # for i=0; i<user.draw_amount; i++
        # reset queued draw user storage keys
        reset_user_draw_state(Int(1)),
        InnerTxnBuilder.Execute({
            TxnField.type_enum: TxnType.Payment,
            TxnField.receiver: Txn.sender(),
            TxnField.amount: amount.load(),
            TxnField.fee: Int(0),
        }),
        output.set(amount.load()),
    )

def get_contracts():
    return router.compile_program(version=6)


# File: https://github.com/summitbajaj/AlDonate/blob/1a0fd9ad0b0a036508c40a10d2432f0213f17f61/donate.py
import base64
from typing import Tuple
from algosdk import mnemonic, transaction, account
from algosdk.v2client import algod
from pyteal import *

print("  ")
print("  ")

txn_history = {}


def donation_escrow(benefactor):

    # Getting AppID
    # AppID = AppParamObject
    # Getting Minimum Allowed Fee
    Fee = Global.min_txn_fee()

    program = And(
        Global.group_size() == Int(1),
        Txn.rekey_to() == Global.zero_address(),
        Txn.fee() <= Fee,
        Or(
            And(
                Txn.type_enum() == TxnType.Payment,
                Txn.receiver() == Addr(benefactor),
            ),
            And(
                Txn.type_enum() == TxnType.AssetConfig,
                Txn.config_asset_total() == Int(1),
                Txn.config_asset_unit_name() == Bytes("AlD")
                # ensure nft is the logo of the charity
                # Txn.config_asset_url()
            ),
            And(
                Txn.type_enum() == TxnType.AssetTransfer,

            ),
            And(
                Txn.type_enum() == TxnType.AssetFreeze,
            )
        )
    )

    return compileTeal(program, Mode.Signature, version=5)


# user declared account mnemonics
benefactor_mnemonic = "mom lottery uniform olive visa occur garlic artefact minimum reward custom legend suit stock install leg doctor favorite retreat cart all exact camp able cute"
sender_mnemonic = "shoe onion turkey shallow belt drop owner merit eager reflect radio gravity stone eyebrow busy dolphin verb bonus load unit engage young decrease ability fame"


# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config
algod_address = "http://localhost:4001"
algod_token = "a" * 64

# helper function to compile program source


def compile_smart_signature(
    client: algod.AlgodClient, source_code: str
) -> Tuple[str, str]:
    compile_response = client.compile(source_code)
    return compile_response["result"], compile_response["hash"]


def payment_transaction(
    creator_mnemonic: str, amt: int, rcv: str, algod_client: algod.AlgodClient
) -> dict:
    creator_pk = mnemonic.to_private_key(creator_mnemonic)
    creator_address = account.address_from_private_key(creator_pk)

    params = algod_client.suggested_params()
    unsigned_txn = transaction.PaymentTxn(creator_address, params, rcv, amt)
    signed = unsigned_txn.sign(creator_pk)

    txid = algod_client.send_transaction(signed)
    pmtx = transaction.wait_for_confirmation(algod_client, txid, 5)
    return txid, pmtx["txn"]["txn"]


# for minting nft
def mint_nft(encoded_program: str, algod_client: algod.AlgodClient):
    sp = algod_client.suggested_params()
    # Create an lsig object using the compiled, b64 encoded program
    program = base64.b64decode(encoded_program)
    lsig = transaction.LogicSigAccount(program)

    # define NFT asset parameters
    txn = transaction.AssetConfigTxn(
        sender=lsig.address(),
        sp=sp,
        default_frozen=False,
        unit_name="AlD",
        asset_name="AlDonate NFT",
        manager=lsig.address(),
        reserve=lsig.address(),
        freeze=lsig.address(),
        clawback=lsig.address(),
        url="https://tinyurl.com/mt3yzhz4",
        total=1,
        decimals=0,
    )

    # sign the transaction using the logic signature
    stxn = transaction.LogicSigTransaction(txn, lsig)

    # send the transaction to the network
    tx_id = algod_client.send_transaction(stxn)
    print("")
    print(f"Minting Transaction ID: {tx_id}")
    print("")
    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 5)

    return pmtx

# perform opt in transaction for minted NFT


def opt_in_nft(
    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str
):
    sp = algod_client.suggested_params()
    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)
    receiver_address = account.address_from_private_key(receiver_pk)
    optin_txn = transaction.AssetOptInTxn(
        sender=receiver_address, sp=sp, index=asset_id
    )
    signed_optin_txn = optin_txn.sign(receiver_pk)
    txid = algod_client.send_transaction(signed_optin_txn)
    print("")
    print(f"Opting in your wallet to receive NFT: {txid}")

    # Wait for the transaction to be confirmed
    results = transaction.wait_for_confirmation(algod_client, txid, 4)
    print(f"Result confirmed in round: {results['confirmed-round']}")
    print("")


def transfer_nft_to_donor(
        encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str, id, txn):
    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)
    receiver_address = account.address_from_private_key(receiver_pk)
    opt_in_nft(encoded_program, asset_id, algod_client, receiver_mnemonic)

    # Create an lsig object using the compiled, b64 encoded program
    program = base64.b64decode(encoded_program)
    lsig = transaction.LogicSigAccount(program)
    note = f"Transaction: {id}, Amount: {txn['amt']}, Fee: {txn['fee']}".encode(
    )
    # Transfer the newly created NFT from escrow to donor
    txn = transaction.AssetTransferTxn(
        sender=lsig.address(),
        sp=algod_client.suggested_params(),
        receiver=receiver_address,
        amt=1,
        index=asset_id,
        note=note
    )
    stxn = transaction.LogicSigTransaction(txn, lsig)
    txid = algod_client.send_transaction(stxn)

    print(f"Sent asset transfer transaction with txid: {txid}")
    # Wait for the transaction to be confirmed
    results = transaction.wait_for_confirmation(algod_client, txid, 4)
    print(f"Result confirmed in round: {results['confirmed-round']}")


def freeze_donor_nft(
    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str
):
    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)
    receiver_address = account.address_from_private_key(receiver_pk)

    # Create an lsig object using the compiled, b64 encoded program
    program = base64.b64decode(encoded_program)
    lsig = transaction.LogicSigAccount(program)

    # Create freeze transaction to freeze the asset in acct2 balance
    freeze_txn = transaction.AssetFreezeTxn(
        sender=lsig.address(),
        sp=algod_client.suggested_params(),
        target=receiver_address,
        index=asset_id,
        new_freeze_state=True,
    )

    stxn = transaction.LogicSigTransaction(freeze_txn, lsig)
    txid = algod_client.send_transaction(stxn)
    results = transaction.wait_for_confirmation(algod_client, txid, 4)
    print("")
    print(f"Sent freeze transaction with txid: {txid}")
    print(f"Result confirmed in round: {results['confirmed-round']}")
    print("")
    print("Congrats! NFT has been transferred to you! Note: You will not be able to transfer this asset")


def lsig_payment_txn(
    encoded_program: str, amt: int, rcv: str, algod_client: algod.AlgodClient
):
    # Create an lsig object using the compiled, b64 encoded program
    program = base64.b64decode(encoded_program)
    lsig = transaction.LogicSigAccount(program)

    # Create transaction with the lsig address as the sender
    params = algod_client.suggested_params()
    unsigned_txn = transaction.PaymentTxn(lsig.address(), params, rcv, amt)

    # sign the transaction using the logic
    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)
    tx_id = algod_client.send_transaction(stxn)
    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)
    return pmtx


def main():
    # initialize an algodClient
    algod_client = algod.AlgodClient(algod_token, algod_address)

    # define private keys
    private_key = mnemonic.to_private_key(benefactor_mnemonic)
    # receiver_public_key = account.address_from_private_key(private_key)

    print("")
    print("")
    print("")
    print("Thank you for your donation! Which charity will you like to send the donation to? Key in the number:")
    print("")
    print("")

    choice = 0

    while (choice != 3):

        print("1: NKF  || Onboarded suppliers: - Penny Appeal(Turkey Food Donation), - Ikea Foundation(Turkey Shelters)")
        print("2: WWF  || Onboarded suppliers: - Ghana Stores(Ghana Food Donation)")
        print("3: To exit this application")
        print("4: View your Donations")
        choice = int(input())
        charity = ""

        if choice == 1:
            print("sending donation to NKF")
            charity = "NKF"
            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'

        elif choice == 2:
            print("sending donation to WWF")
            charity = "WWF"
            receiver_public_key = 'XHT4KIAFOP4626AFLA6GMOMST4QO3AO2XADMIJJOACMFEGT5GLA6LOCLWQ'

        elif choice == 3:
            break

        elif choice == 4:
            for charity, transactions_list in txn_history.items():
                print(f"Transactions for {charity}:")
                for txn in transactions_list:
                    print(f"\tTransaction ID: {txn['txn_id']}")
                    print(f"\tAmount Donated: {txn['amount_donated']}")
                    print(f"\tCertificate ID: {txn['certificate_id']}\n")

            continue

        else:
            print("Sending donation to NKF")
            charity = "NKF"
            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'

        print("")
        print("Compiling Donation Smart Signature......")
        print("")
        stateless_program_teal = donation_escrow(receiver_public_key)
        escrow_result, escrow_address = compile_smart_signature(
            algod_client, stateless_program_teal
        )

        print("Program:", escrow_result)
        print("LSig Address: ", escrow_address)
        print("")
        print("Activating Donation Smart Signature......")

        # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator
        amt = 100000
        id, txn = payment_transaction(
            sender_mnemonic, amt, escrow_address, algod_client)

        if charity not in txn_history.keys():
            txn_history[charity] = []

        # Mint NFT using the escrow address
        print("Thank you for your donation, Minting NFT......")
        pmtx = mint_nft(escrow_result, algod_client)
        created_asset = pmtx["asset-index"]

        txn_history[charity].append(
            {"txn_id": id, "amount_donated": amt, "certificate_id": created_asset})

        print("")
        print("Withdrawing from Donation Smart Signature......")
        print(f"NFT Address: {created_asset}")

        # Withdraws 1 ALGO from smart signature using logic signature.
        withdrawal_amt = 10000
        lsig_payment_txn(escrow_result, withdrawal_amt,
                         receiver_public_key, algod_client)

        transfer_nft_to_donor(escrow_result, created_asset,
                              algod_client, sender_mnemonic, id, txn)
        freeze_donor_nft(escrow_result, created_asset,
                         algod_client, sender_mnemonic)


if __name__ == "__main__":
    main()



# File: https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/mint_nfts.py
from pathlib import Path
from typing import Literal
from beaker import *
from pyteal import *


class NFTs(abi.NamedTuple):
    url: abi.Field[abi.String]
    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]
    name: abi.Field[abi.String]
    unitName: abi.Field[abi.String]
    reserve: abi.Field[abi.Address]

    asa = LocalStateValue(stack_type=TealType.uint64, default=Int(0))
    burn_address = LocalStateValue(stack_type= TealType.bytes, default=Bytes("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ"))
    burntId = LocalStateValue(stack_type= TealType.uint64, default=Int(0))


app = Application("MintNFTs", state=NFTs)

@app.create(bare=True)
def create() -> Expr:
    return app.initialize_global_state()


@app.external(authorize= Authorize.only(Global.creator_address()))
def mintNFTs(requestMint: NFTs, *, output: abi.Uint64) -> Expr:
    name = abi.String()
    unitName = abi.String()
    reserve = abi.Address()
    url = abi.String()
    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])

    return Seq(
        requestMint.name.store_into(name),
        requestMint.unitName.store_into(unitName),
        requestMint.reserve.store_into(reserve),
        requestMint.url.store_into(url),
        requestMint.metadata_hash.store_into(metadata_hash),
        InnerTxnBuilder.Execute(
            {
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_name: name.get(),
                TxnField.config_asset_unit_name: unitName.get(),
                TxnField.config_asset_reserve: reserve.get(),
                TxnField.config_asset_url: url.get(),
                TxnField.config_asset_metadata_hash: metadata_hash.encode(),
                TxnField.config_asset_total: Int(1),
                TxnField.fee: Int(0),
            }
        ),
        output.set(InnerTxn.created_asset_id()),
        app.state.asa.set(InnerTxn.created_asset_id())
    )


@app.external(authorize= Authorize.only(Global.creator_address()))
def transferNFTs(assetId: abi.Uint64, receiver: abi.Address) -> Expr:
    assetId= app.state.asa.get()
    receiver= abi.Address()
    return Seq(

        Assert(app.state.asa == assetId),
        Assert(app.state.burntId != assetId),

        InnerTxnBuilder.Execute(
            {
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.asset_receiver: receiver.get(),
                TxnField.xfer_asset: assetId,
                TxnField.asset_amount: Int(1),
            }
    )
)

@app.external(authorize= Authorize.only(Global.creator_address()))
def burn(Id: abi.Uint64) -> Expr:
    burntAddress= app.state.burn_address.get()
    Id= abi.Uint64()
    return Seq(
        Assert(app.state.asa == Id.get()),
        InnerTxnBuilder.Execute(
            {
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.asset_receiver: burntAddress,
                TxnField.xfer_asset: Id.get(),
                TxnField.asset_amount: Int(1),
            }
        ),
        app.state.burntId.set(Id.get())
)


if __name__ == "__main__":
    app.build().export(
        Path(__file__).resolve().parent / f"./artifacts/{app.name}"
    )


# File: https://github.com/sagaranand015/algorand-smart-asa/blob/68eb9b7f07b93c5fd52ddcd29a73633f82e2f520/contracts/emission_control.py
from typing import Final

from pyteal import *
from beaker import *


class EmissionRuleResult(abi.NamedTuple):
    emission: abi.Field[abi.String]
    max: abi.Field[abi.Uint64]
    min: abi.Field[abi.Uint64]


COMPLIANCE_ASA_APP_BINDING = "https://compliance.app/"

UNDERLYING_COMPLIANCE_NFT_DECIMALS = Int(0)
UNDERLYING_COMPLIANCE_NFT_DEFAULT_FROZEN = Int(0)
UNDERLYING_COMPLIANCE_NFT_UNIT_NAME = Bytes("COM-ASA")
UNDERLYING_COMPLIANCE_NFT_NAME = Bytes("COMPLIANCE-ASA")
UNDERLYING_COMPLIANCE_NFT_URL = Bytes(COMPLIANCE_ASA_APP_BINDING)
UNDERLYING_COMPLIANCE_NFT_METADATA_HASH = Bytes("Comliance NFT Metadata")
UNDERLYING_COMPLIANCE_NFT_MANAGER_ADDR = Global.current_application_address()
UNDERLYING_COMPLIANCE_NFT_RESERVE_ADDR = Global.current_application_address()
UNDERLYING_COMPLIANCE_NFT_FREEZE_ADDR = Global.current_application_address()
UNDERLYING_COMPLIANCE_NFT_CLAWBACK_ADDR = Global.current_application_address()


class EmissionControl(Application):
    """
    Emission Control(aka Smart Contract App) for storing business' compliance analysis on chain
    and creating/minting NFTs for businesses based on the rules defined by the regulators.
    """

    regulator: Final[ApplicationStateValue] = ApplicationStateValue(
        TealType.bytes,
        descr="Regulator acting as the owner of the Emission Control",
    )
    emission_parameter: Final[ApplicationStateValue] = ApplicationStateValue(
        TealType.bytes, descr="Emission Parameter to keep track of"
    )
    emission_max: Final[ApplicationStateValue] = ApplicationStateValue(
        TealType.uint64, descr="Max value of the emission control parameter"
    )
    emission_min: Final[ApplicationStateValue] = ApplicationStateValue(
        TealType.uint64, descr="Min value of the emission control parameter"
    )

    @external
    def get_emission_rule(self, *, output: EmissionRuleResult):
        """
        Returns the rules defined by the regulator for the given emission SC
        """
        return Seq(
            (max := abi.Uint64()).set(self.emission_max.get()),
            (min := abi.Uint64()).set(self.emission_min.get()),
            (parameter := abi.String()).set(self.emission_parameter.get()),
            output.set(parameter, max, min),
        )

    @external
    def set_emission_rule(
        self,
        emission_parameter: abi.String,
        emission_max: abi.Uint64,
        emission_min: abi.Uint64,
        *,
        output: abi.Bool,
    ):
        """
        Sets the rules defined by the regulator for the given emission
        """
        return Seq(
            self.emission_parameter.set(emission_parameter.get()),
            self.emission_max.set(emission_max.get()),
            self.emission_min.set(emission_min.get()),
            output.set(True),
        )

    @external
    def is_business_compliant(
        self,
        emission_parameter: abi.String,
        emission_value: abi.Uint64,
        *,
        output: abi.Bool,
    ):
        """
        Returns true/false based on whether the business is compliant to the emissions value or not
        """
        return Seq(
            Assert(
                self.emission_parameter == emission_parameter.get(),
                comment="Emission Parameter given is not correct for the app being used!",
            ),
            Assert(
                emission_value.get() >= self.emission_min,
                comment="Emission value is lesser than min configured",
            ),
            If(emission_value.get() <= self.emission_max)
            .Then(output.set(True))
            .Else(output.set(False)),
        )

    @internal(TealType.uint64)
    def create_compliance_nft_internal(self):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.fee: Int(0),
                    TxnField.type_enum: TxnType.AssetConfig,
                    TxnField.config_asset_total: Int(1),
                    TxnField.config_asset_decimals: UNDERLYING_COMPLIANCE_NFT_DECIMALS,
                    TxnField.config_asset_unit_name: UNDERLYING_COMPLIANCE_NFT_UNIT_NAME,
                    TxnField.config_asset_name: UNDERLYING_COMPLIANCE_NFT_NAME,
                    TxnField.config_asset_url: UNDERLYING_COMPLIANCE_NFT_URL,
                    TxnField.config_asset_manager: UNDERLYING_COMPLIANCE_NFT_MANAGER_ADDR,
                    TxnField.config_asset_reserve: UNDERLYING_COMPLIANCE_NFT_RESERVE_ADDR,
                    TxnField.config_asset_freeze: UNDERLYING_COMPLIANCE_NFT_FREEZE_ADDR,
                    TxnField.config_asset_clawback: UNDERLYING_COMPLIANCE_NFT_CLAWBACK_ADDR,
                }
            ),
            InnerTxnBuilder.Submit(),
            Return(InnerTxn.created_asset_id()),
        )

    @internal(TealType.none)
    def app_opt_into_asset(self, asset_id: Expr):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.fee: Int(0),
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: asset_id,
                    TxnField.asset_amount: Int(0),
                    TxnField.sender: Global.current_application_address(),
                    # TxnField.asset_sender: Global.current_application_address(),
                    TxnField.asset_receiver: Global.current_application_address(),
                }
            ),
            InnerTxnBuilder.Submit(),
        )

    @internal(TealType.none)
    def opt_into_asset_for_business(
        self, business_address: Expr, asset_id: Expr
    ):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.fee: Int(0),
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: asset_id,
                    TxnField.asset_amount: Int(0),
                    TxnField.sender: business_address,
                    # TxnField.asset_sender: Global.current_application_address(),
                    TxnField.asset_receiver: business_address,
                }
            ),
            InnerTxnBuilder.Submit(),
        )

    @internal(TealType.none)
    def transfer_compliance_nft_to_business(
        self, business_address: Expr, asset_id: Expr
    ):
        # TODO: Add the check for business' emission control before actually transferring the token!
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.fee: Int(0),
                    TxnField.type_enum: TxnType.AssetTransfer,
                    TxnField.xfer_asset: asset_id,
                    TxnField.asset_amount: Int(1),
                    TxnField.sender: Global.current_application_address(),
                    # TxnField.asset_sender: Global.current_application_address(),
                    TxnField.asset_receiver: business_address,
                }
            ),
            InnerTxnBuilder.Submit(),
        )

    @external
    def create_compliance_nft(self, *, output: abi.Uint64):
        """
        Creates the compliance NFT for the business via the Algorand SC
        """
        return Seq(
            (asset_id := abi.Uint64()).set(
                self.create_compliance_nft_internal()
            ),
            self.app_opt_into_asset(asset_id.get()),
            output.set(asset_id),
        )

    @external
    def allocate_compliance_nft_to_business(
        self,
        business_address: abi.Address,
        asset_id: abi.Uint64,
        *,
        output: abi.Uint64,
    ):
        """
        Creates the compliance NFT for the business via the Algorand SC
        """
        return Seq(
            self.transfer_compliance_nft_to_business(
                business_address.get(), asset_id.get()
            ),
            output.set(asset_id),
        )

    @external
    def business_opt_into_asset(
        self,
        business_address: abi.Address,
        asset_id: abi.Uint64,
        *,
        output: abi.Uint64,
    ):
        """
        Business Account opting into the Compliance NFT
        """
        return Seq(
            self.opt_into_asset_for_business(
                business_address.get(), asset_id.get()
            ),
            output.set(asset_id),
        )

    @create
    def create(self):
        return self.initialize_application_state()

    @update(authorize=Authorize.only(Global.creator_address()))
    def update(self):
        return Approve()

    @opt_in
    def opt_in(self):
        return Approve()


if __name__ == "__main__":
    EmissionControl().dump("./artifacts")


# File: https://github.com/bytesdruid/Pure-NFT/blob/03143e8f897f930c481ec640d142087d8ed30a4c/asset_contract/asset.py
from pyteal import *

def approval():
    on_creation = Seq(
        [
            # g byteslice - asset name is Bloom Token
            App.globalPut(Bytes("AssetName"), Bytes("Pure NFT")),
            # g byteslice - unit name is BLT
            App.globalPut(Bytes("UnitName"), Bytes("NFP1023")),
            # g int - decimals
            App.globalPut(Bytes("Decimals"), Int(0)),
            # g Int - total supply 
            App.globalPut(Bytes("Total"), Int(1)),
            # g Int - reserve is total amount not sitting in local balance
            App.globalPut(Bytes("GlobalReserve"), Int(1)),
            # approve sequence
            Return(Int(1)),
        ]
    )

    opt_in = Seq([
        # l int - local balance
        App.localPut(Int(0), Bytes("LocalBalance"), Int(0)),
        Return(Int(1))
    ])

    init_admin = Seq([
        # make sure account opting in is the contract creator address
        Assert(Txn.sender() == Global.creator_address()),
        # set the txn sender address to manager
        App.localPut(Int(0), Bytes("Admin"), Int(1)),
        Return(Int(1))
    ])

    is_admin = App.localGet(Int(0), Bytes("Admin"))

    set_admin = Seq(
        [
            Assert(And(is_admin, Txn.application_args.length() == Int(1))),
            App.localPut(Int(1), Bytes("Admin"), Int(1)),
            Return(Int(1)),
        ]
    )

    on_closeout = Seq(
        [
            App.globalPut(
                Bytes("GlobalReserve"),
                App.globalGet(Bytes("GlobalReserve"))
                + App.localGet(Int(0), Bytes("LocalBalance")),
            ),
            Return(Int(1)),
        ]
    )

    mint = Seq(
        [
            Assert(Txn.application_args.length() == Int(2)),
            Assert(Btoi(Txn.application_args[1]) <= App.globalGet(Bytes("GlobalReserve"))),
            App.globalPut(
                Bytes("GlobalReserve"), App.globalGet(Bytes("GlobalReserve")) - Btoi(Txn.application_args[1]),
            ),
            App.localPut(
                Int(0),
                Bytes("LocalBalance"),
                App.localGet(Int(0), Bytes("LocalBalance")) + Btoi(Txn.application_args[1]),
            ),
            Return(is_admin),
        ]
    )

    transfer_amount = Btoi(Txn.application_args[1])    
    transfer = Seq(
        [
            Assert(Txn.application_args.length() == Int(2)),
            Assert(transfer_amount <= App.localGet(Int(0), Bytes("LocalBalance"))),
            App.localPut(
                Int(0),
                Bytes("LocalBalance"),
                App.localGet(Int(0), Bytes("LocalBalance")) - transfer_amount,
            ),
            App.localPut(
                Int(1),                 
                Bytes("LocalBalance"),
                App.localGet(Int(1), Bytes("LocalBalance")) + transfer_amount,
            ),
            Return(Int(1)),
        ]
    )

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, opt_in],
        [Txn.application_args[0] == Bytes("Init_Admin"), init_admin],
        [Txn.application_args[0] == Bytes("Set_Admin"), set_admin],
        [Txn.application_args[0] == Bytes("Mint"), mint],
        [Txn.application_args[0] == Bytes("Transfer"), transfer],
    )

    return program

def clear():
    program = Seq(
        [
            App.globalPut(
                Bytes("GlobalReserve"),
                App.globalGet(Bytes("GlobalReserve"))
                + App.localGet(Int(0), Bytes("LocalBalance")),
            ),
            Return(Int(1)),
        ]
    )

    return program


if __name__ == "__main__":
    with open("approval.teal", "w") as f:
        compiled = compileTeal(approval(), mode=Mode.Application, version=6)
        f.write(compiled)

    with open("clear.teal", "w") as f:
        compiled = compileTeal(clear(), mode=Mode.Application, version=6)
        f.write(compiled)

# File: https://github.com/algorandfoundation/puya/blob/6d27f657ce8fddaedc33e778daa8799546778d1b/stubs/algopy-stubs/_contract.pyi
import abc
import typing

from algopy import UInt64, urange

@typing.final
class StateTotals:
    """
    Options class to manually define the total amount of global and local state contract will use,
    used by [`Contract.__init_subclass__`](#algopy.Contract.__init_subclass__).

    This is not required when all state is assigned to `self.`, but is required if a
    contract dynamically interacts with state via `AppGlobal.get_bytes` etc, or if you want
    to reserve additional state storage for future contract updates, since the Algorand protocol
    doesn't allow increasing them after creation.
    """

    def __init__(
        self,
        *,
        global_uints: int = ...,
        global_bytes: int = ...,
        local_uints: int = ...,
        local_bytes: int = ...,
    ) -> None:
        """Specify the totals for both global and local, and for each type. Any arguments not
        specified default to their automatically calculated values.

        Values are validated against the known totals assigned through `self.`, a warning is
        produced if the total specified is insufficient to accommodate all `self.` state values
        at once.
        """

class Contract(abc.ABC):
    """Base class for an Algorand Smart Contract"""

    def __init_subclass__(
        cls,
        *,
        name: str = ...,
        scratch_slots: urange | tuple[int | urange, ...] | list[int | urange] = ...,
        state_totals: StateTotals = ...,
        avm_version: int = ...,
    ):
        """
        When declaring a Contract subclass, options and configuration are passed in
        the base class list:

        ```python
        class MyContract(algopy.Contract, name="CustomName"):
            ...
        ```

        :param name:
         Will affect the output TEAL file name if there are multiple non-abstract contracts
         in the same file.

         If the contract is a subclass of algopy.ARC4Contract, `name` will also be used as the
         contract name in the ARC-32 application.json, instead of the class name.

        :param scratch_slots:
         Allows you to mark a slot ID or range of slot IDs as "off limits" to Puya.
         These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
         This is particularly useful in combination with `algopy.op.gload_bytes` / `algopy.op.gload_uint64`
         which lets a contract in a group transaction read from the scratch slots of another contract
         that occurs earlier in the transaction group.

         In the case of inheritance, scratch slots reserved become cumulative. It is not an error
         to have overlapping ranges or values either, so if a base class contract reserves slots
         0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived
         contract all slots 0-10 will be marked as reserved.

        :param state_totals:
         Allows defining what values should be used for global and local uint and bytes storage
         values when creating a contract. Used when outputting ARC-32 application.json schemas.

         If let unspecified, the totals will be determined by the compiler based on state
         variables assigned to `self`.

         This setting is not inherited, and only applies to the exact `Contract` it is specified
         on. If a base class does specify this setting, and a derived class does not, a warning
         will be emitted for the derived class. To resolve this warning, `state_totals` must be
         specified. Note that it is valid to not provide any arguments to the `StateTotals`
         constructor, like so `state_totals=StateTotals()`, in which case all values will be
         automatically calculated.
        :param avm_version:
         Determines which AVM version to use, this affects what operations are supported.
         Defaults to value provided supplied on command line (which defaults to current mainnet version)
        """

    @abc.abstractmethod
    def approval_program(self) -> UInt64 | bool:
        """Represents the program called for all transactions
        where `OnCompletion` != `ClearState`"""

    @abc.abstractmethod
    def clear_state_program(self) -> UInt64 | bool:
        """Represents the program called when `OnCompletion` == `ClearState`"""


# File: https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py
#
import base64

#
from typing import Optional
from dataclasses import dataclass

#
from algosdk import account, mnemonic, transaction, logic
from algosdk.v2client.algod import AlgodClient
from algosdk.transaction import PaymentTxn, SignedTransaction
from algosdk.transaction import ApplicationCreateTxn, ApplicationCallTxn


#
@dataclass
class AlgoUser:
    pk: str
    address: int
    mnemonic: float

    def __str__(self):
        return "Private Key - {}\nAddress - {}\nMnemonic - {}".format(
                    self.pk,
                    self.address,
                    self.mnemonic
                )


#
class Algorand:
    """
    Algorand object for interacting with algosdk
    """

    # global and local schema parameters
    GLOBAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)
    LOCAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)

    #
    def __init__(self, algo_token: str, algo_address: str) -> None:
        """
        Constructor

        :param algo_token: token for connecting algorand testnet
        :param algo_address: algorand testnet address

        :returns: None
        """
        self.__token = algo_token
        self.__address = algo_address
        self.__headers = {"X-API-Key": self.token}
        self.__client = self.__get_client()
        self.__params = self.client.suggested_params()

    #
    def __get_client(self) -> Optional[AlgodClient]:
        """
        create AlgodClient object from given token and address

        :returns: AlgodClient object
        """
        return AlgodClient(self.token, self.address, self.headers)

    #
    @property
    def headers(self) -> dict:
        """
        Getter for header private field

        :returns: headers field value
        """
        return self.__headers

    #
    @property
    def token(self) -> str:
        """
        Getter for token private field

        :returns: token field value
        """
        return self.__token

    #
    @property
    def address(self) -> str:
        """
        Getter for address private field

        :returns: address field value
        """
        return self.__address

    #
    @property
    def params(self) -> str:
        """
        Getter for params private field

        :returns: params field value
        """
        return self.__params

    #
    @property
    def client(self) -> Optional[AlgodClient]:
        """
        Getter for client private field

        :returns: client field value
        """
        return self.__client

    #
    def get_balance(self, address: str) -> int:
        """
        Get balance of given account

        :params address: address of account

        :returns: amount balance
        """
        return self.client.account_info(address).get("amount")

    #
    def get_transaction_info(self, tx_id: str):
        """
        Get transaction information

        :param tx_id: transaction id

        :returns: transaction information
        """
        return self.client.pending_transaction_info(tx_id)

    #
    def generate_new_account(self) -> dict:
        """
        Generate new account for algorand testnet

        :returns: new generated account key, address and mnemonic
        """
        private_key, address = account.generate_account()
        mnem = mnemonic.from_private_key(private_key)

        return AlgoUser(private_key, address, mnem)

    #
    def get_application_id(self, tx_id: str) -> int:
        """
        Get application id from transaction id

        :param tx_id: transaction id

        :returns: application id
        """
        transaction_info = self.get_transaction_info(tx_id)
        app_id = transaction_info.get("application-index")
        return app_id

    #
    def get_application_address(self, app_id: int) -> str:
        """
        Get application address from id

        :param app_id: id of application

        :returns: address of application
        """
        app_address = logic.get_application_address(app_id)
        return app_address

    #
    def build_payment_transaction(
                self,
                sender: str,
                receiver: str,
                amount: int,
                note: str
            ) -> Optional[PaymentTxn]:
        """
        Build payment transaction from sender to receiver

        :param sender: sender address
        :param receiver: receiver address
        ;param amount: amount which should be transferred
        :param note: note for transaction

        :returns: payment transaction
        """
        txn = transaction.PaymentTxn(
            sender=sender,
            sp=self.params,
            receiver=receiver,
            amt=amount,
            note=note,
        )
        return txn

    #
    def create_application_transaction(
                self,
                sender: str,
                approval_teal: bytes,
                clear_teal: bytes
            ) -> Optional[ApplicationCreateTxn]:
        """
        Create transaction that interacts with the application system

        :param sender: address
        :param approval_teal: transaction smart contract in bytes
        :param clear_teal: clear smart contract in bytes

        :returns: application transaction
        """
        app_create_txn = transaction.ApplicationCreateTxn(
            sender=sender,
            sp=self.params,
            on_complete=transaction.OnComplete.NoOpOC.real,
            approval_program=approval_teal,
            clear_program=clear_teal,
            global_schema=self.GLOBAL_SCHEMA,
            local_schema=self.LOCAL_SCHEMA
        )
        return app_create_txn

    #
    def sign_transaction(
                self,
                sender: str,
                txn: Optional[ApplicationCreateTxn]
            ) -> Optional[SignedTransaction]:
        """
        Sign created transaction

        :param sender: sender private key
        :param txn: transaction which should be signed

        :returns: signed transaction
        """
        signed_txn = txn.sign(sender)
        return signed_txn

    #
    def send_transaction(self, signed_txn: Optional[SignedTransaction]) -> str:
        """
        Send already signed transaction

        :param signed_txn: signed transaction which should be sent

        :returns: transaction id
        """
        tx_id = self.client.send_transaction(signed_txn)
        return tx_id

    #
    def wait_for_confirmation(self, tx_id: str) -> None:
        """
        Block until a pending transaction is confirmed by the network

        :param tx_id: transaction id

        :returns None
        """
        return transaction.wait_for_confirmation(self.client, tx_id, 4)

    #
    def call_application_transaction(
                self,
                sender: str,
                app_id: int,
                app_args: list,
                receiver: str=None,
                asset: int=None
            ) -> Optional[ApplicationCallTxn]:
        """
        Create Application call transaction object

        :param sender: sender address
        :param app_id: application id for which transaction is made
        :param app_args: arguments for application smart contract
        :param receiver: receiver address

        :returns: ApplicationCallTxn objects
        """

        accounts = []
        if receiver:
            accounts.append(receiver)

        assets = []
        if asset:
            assets.append(asset)
        
        app_call_txn = transaction.ApplicationCallTxn(
            sender=sender,
            sp=self.params,
            index=app_id,
            on_complete=transaction.OnComplete.NoOpOC.real,
            app_args=app_args,
            accounts=accounts,
            foreign_assets=assets
        )
        return app_call_txn

    #
    def call_application_transaction_foreign_asset(
                self,
                sender: str,
                app_id: int,
                app_args: list,
                asset_id: str=None
            ) -> Optional[ApplicationCallTxn]:
        """
        Create Application call transaction object

        :param sender: sender address
        :param app_id: application id for which transaction is made
        :param app_args: arguments for application smart contract
        :param receiver: receiver address

        :returns: ApplicationCallTxn objects
        """

        app_call_txn = transaction.ApplicationCallTxn(
            sender=sender.address,
            sp=self.params,
            index=app_id,
            on_complete=transaction.OnComplete.NoOpOC.real,
            app_args=app_args,
            foreign_assets=[asset_id]
        )
        return app_call_txn
    #
    def create_application_no_op_transaction(self, sender, app_id, app_args, receiver=None):
        accounts = []
        if receiver:
            accounts.append(receiver.address)
        
        txn = transaction.ApplicationNoOpTxn(
                sender=sender.address,
                sp=self.params,
                index=app_id,
                app_args=app_args,
                accounts=accounts
        )

        return txn

    #
    def create_asset(self, creator):
        txn = transaction.AssetConfigTxn(
                sender=creator.address,
                sp=self.params,
                total=1000000,
                default_frozen=False,
                unit_name="LSCOIN",
                asset_name="LS Coin",
                manager=creator.address,
                reserve=creator.address,
                freeze=creator.address,
                clawback=creator.address,
                decimals=0
        )
        signed_txn = self.sign_transaction(creator.pk, txn)
        tx_id = self.send_transaction(signed_txn)
        self.wait_for_confirmation(tx_id)
        response = self.client.pending_transaction_info(tx_id)
        return response['asset-index']

    #
    def opt_in_to_asset(self, sender, asset_id):
        txn = transaction.AssetTransferTxn(
                sender=sender.address,
                sp=self.params,
                receiver=sender.address,
                amt=0,
                index=asset_id
            )
        signed_txn = self.sign_transaction(sender.pk, txn)
        tx_id = self.send_transaction(signed_txn)
        self.wait_for_confirmation(tx_id)


    
    #
    def get_application_global_state(self, app_id: int) -> dict:
        """
        Get application global state info

        :param app_id: application id

        :returns: info about application global state
        """
        app_info = self.client.application_info(app_id)
        global_state = app_info['params']['global-state']
        state = {}
        for item in global_state:
            key = base64.b64decode(item['key']).decode('utf-8')
            value = item['value']
            state[key] = value
        return state


# File: https://github.com/KOSASIH/pi-nexus-autonomous-banking-network/blob/aad37ae96f34f3088f33692b3eaae503e53ee1eb/projects/piguardian/smart_contracts/incident_response_contract.py
from algosdk import constants
from algosdk.encoding import encode_address, is_valid_address
from algosdk.future import transaction

class IncidentResponseContract:
    def __init__(self, creator_address, incident_response_fee):
        self.creator_address = creator_address
        self.incident_response_fee = incident_response_fee

    def create_contract(self):
        # Create a new Algorand transaction
        txn = transaction.PaymentTxn(
            self.creator_address,
            constants.ZERO_ADDRESS,
            self.incident_response_fee,
            "incident response contract"
        )

        # Compile the contract code
        contract_code = self.compile_contract_code()

        # Create a new Algorand smart contract
        contract = transaction.LogicSig(contract_code)

        # Return the contract
        return contract

    def compile_contract_code(self):
        # Compile the contract code using the Algorand SDK
        # This code will be executed on the Algorand blockchain
        # It will handle incident response logic
        contract_code = """
        pragma solidity ^0.6.0;

        contract IncidentResponseContract {
            address private creator;
            uint public incidentResponseFee;

            constructor() public {
                creator = msg.sender;
                incidentResponseFee = 1000000; // 1 Algo
            }

            function respondToIncident(address incidentAddress) public {
                // Check if the incident address is valid
                require(isValidAddress(incidentAddress), "Invalid incident address");

                // Check if the caller is the creator of the contract
                require(msg.sender == creator, "Only the creator can respond to incidents");

                // Respond to the incident
                // This will trigger a payment to the incident address
                // with the incident response fee
                payable(incidentAddress).transfer(incidentResponseFee);
            }

            function isValidAddress(address addr) internal view returns (bool) {
                return addr != address(0);
            }
        }
        """
        return contract_code

    def deploy_contract(self, contract):
        # Deploy the contract to the Algorand blockchain
        # This will create a new smart contract on the blockchain
        # with the incident response logic
        txn_id = transaction.send_transaction(contract)
        return txn_id

    def call_contract(self, contract, incident_address):
        # Call the contract to respond to an incident
        # This will trigger the incident response logic
        # and send the incident response fee to the incident address
        txn_id = transaction.call_contract(contract, incident_address)
        return txn_id


# File: https://github.com/marotipatre/Escrow-Mechanism-on-Algorand/blob/0ed1b564a678a60028558082832e3bec46afdc61/projects/escrow_mechanism/smart_contracts/artifacts/escrow_contract/escrow_client.py
# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": []}, "methods": [{"actions": {"call": [], "create": ["NoOp"]}, "args": [{"type": "uint64", "name": "value"}, {"type": "account", "name": "seller"}, {"type": "account", "name": "buyer"}, {"type": "account", "name": "arbitrator"}, {"type": "uint64", "name": "escrow_duration"}], "name": "create_application", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "name": "payment"}], "name": "deposit_funds", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "release_funds_to_seller", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "refund_funds_to_buyer", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "raise_dispute", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "name": "decision"}], "name": "resolve_dispute", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "expire_escrow", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["DeleteApplication"], "create": []}, "args": [], "name": "delete_application", "returns": {"type": "void"}, "events": [], "readonly": false, "recommendations": {}}], "name": "Escrow", "state": {"keys": {"box": {}, "global": {"seller": {"key": "c2VsbGVy", "keyType": "AVMString", "valueType": "AVMBytes"}, "buyer": {"key": "YnV5ZXI=", "keyType": "AVMString", "valueType": "AVMBytes"}, "arbitrator": {"key": "YXJiaXRyYXRvcg==", "keyType": "AVMString", "valueType": "AVMBytes"}, "amount": {"key": "YW1vdW50", "keyType": "AVMString", "valueType": "AVMUint64"}, "escrow_expiry": {"key": "ZXNjcm93X2V4cGlyeQ==", "keyType": "AVMString", "valueType": "AVMUint64"}, "is_disputed": {"key": "aXNfZGlzcHV0ZWQ=", "keyType": "AVMString", "valueType": "AVMUint64"}, "is_settled": {"key": "aXNfc2V0dGxlZA==", "keyType": "AVMString", "valueType": "AVMUint64"}, "value": {"key": "dmFsdWU=", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 3, "ints": 5}, "local": {"bytes": 0, "ints": 0}}}, "structs": {}, "byteCode": {"approval": "CiADAAHoByYHCmlzX3NldHRsZWQFYnV5ZXIFdmFsdWUGc2VsbGVyCmFyYml0cmF0b3ILaXNfZGlzcHV0ZWQNZXNjcm93X2V4cGlyeTEbQQA/gggEP+TTmgT9xpXCBDHOdZcENMl5yQRDmCZdBJG0UyoEUSH3QQQzs0meNhoAjggAaABSAEYAOgAuABwAEAACIkMxGYEFEkQxGESIAekjQzEZFEQxGESIAcojQzEZFEQxGEQ2GgFXAgCIAWUjQzEZFEQxGESIASQjQzEZFEQxGESIANYjQzEZFEQxGESIAIgjQzEZFEQxGEQxFiMJSTgQIxJEiABOI0MxGRREMRgURDYaARc2GgIXwBw2GgMXwBw2GgQXwBw2GgUXiAACI0OKBQAqi/tnK4v8ZymL/WcnBIv+ZzIHi/8IJwZMZycFImcoImeJigEAMQAiKWVEEkSL/zgHMgoSRIv/OAgiKmVEEkQiKGVEFESJigAAMQBJIillRCInBGVMTgNEEkAACIsAiwESQQAgI0QiKGVEFESxIitlRCIqZUSyCLIHI7IQJLIBsygjZ4kiQv/digAAMQBJIitlRCInBGVMTgNEEkAACIsAiwESQQAgI0QiKGVEFESxIillRCIqZUSyCLIHI7IQJLIBsygjZ4kiQv/digAAMQBJIillRCIrZUxOA0QSQAAIiwCLARJBABQjRCInBWVEFEQiKGVEFEQnBSNniSJC/+mKAQAxACInBGVEEkQiJwVlREQiKGVEFESL/4ARcmVsZWFzZV90b19zZWxsZXISQQAHiP8TKCNniYv/gA9yZWZ1bmRfdG9fYnV5ZXISRIj/OUL/4TIHIicGZUQPRCIoZUQURIj/JIkiKGVERDEAMgkSRIk=", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 4, "patch": 4}}, "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTAwMAogICAgYnl0ZWNibG9jayAiaXNfc2V0dGxlZCIgImJ1eWVyIiAidmFsdWUiICJzZWxsZXIiICJhcmJpdHJhdG9yIiAiaXNfZGlzcHV0ZWQiICJlc2Nyb3dfZXhwaXJ5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2FmdGVyX2lmX2Vsc2VAMTQKICAgIHB1c2hieXRlc3MgMHgzZmU0ZDM5YSAweGZkYzY5NWMyIDB4MzFjZTc1OTcgMHgzNGM5NzljOSAweDQzOTgyNjVkIDB4OTFiNDUzMmEgMHg1MTIxZjc0MSAweDMzYjM0OTllIC8vIG1ldGhvZCAiY3JlYXRlX2FwcGxpY2F0aW9uKHVpbnQ2NCxhY2NvdW50LGFjY291bnQsYWNjb3VudCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVwb3NpdF9mdW5kcyhwYXkpdm9pZCIsIG1ldGhvZCAicmVsZWFzZV9mdW5kc190b19zZWxsZXIoKXZvaWQiLCBtZXRob2QgInJlZnVuZF9mdW5kc190b19idXllcigpdm9pZCIsIG1ldGhvZCAicmFpc2VfZGlzcHV0ZSgpdm9pZCIsIG1ldGhvZCAicmVzb2x2ZV9kaXNwdXRlKHN0cmluZyl2b2lkIiwgbWV0aG9kICJleHBpcmVfZXNjcm93KCl2b2lkIiwgbWV0aG9kICJkZWxldGVfYXBwbGljYXRpb24oKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NyZWF0ZV9hcHBsaWNhdGlvbl9yb3V0ZUAzIG1haW5fZGVwb3NpdF9mdW5kc19yb3V0ZUA0IG1haW5fcmVsZWFzZV9mdW5kc190b19zZWxsZXJfcm91dGVANSBtYWluX3JlZnVuZF9mdW5kc190b19idXllcl9yb3V0ZUA2IG1haW5fcmFpc2VfZGlzcHV0ZV9yb3V0ZUA3IG1haW5fcmVzb2x2ZV9kaXNwdXRlX3JvdXRlQDggbWFpbl9leHBpcmVfZXNjcm93X3JvdXRlQDkgbWFpbl9kZWxldGVfYXBwbGljYXRpb25fcm91dGVAMTAKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NQogICAgLy8gY2xhc3MgRXNjcm93KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9hcHBsaWNhdGlvbl9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTA5LTExMAogICAgLy8gIyBEZWxldGUgdGhlIGFwcGxpY2F0aW9uIChvbmx5IGFmdGVyIHNldHRsZW1lbnQpCiAgICAvLyBAYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJEZWxldGVBcHBsaWNhdGlvbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZXhwaXJlX2VzY3Jvd19yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyAjIFRpbWUtbG9jazogQXV0b21hdGljYWxseSByZWZ1bmQgYnV5ZXIgaWYgZXNjcm93IGV4cGlyZXMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGV4cGlyZV9lc2Nyb3cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVzb2x2ZV9kaXNwdXRlX3JvdXRlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg0CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg0CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgcmVzb2x2ZV9kaXNwdXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3JhaXNlX2Rpc3B1dGVfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzQtNzUKICAgIC8vICMgUmFpc2UgYSBkaXNwdXRlIChjYWxsZWQgYnkgYnV5ZXIgb3Igc2VsbGVyKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmFpc2VfZGlzcHV0ZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9yZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NTgtNTkKICAgIC8vICMgUmVmdW5kIGZ1bmRzIHRvIGJ1eWVyIChjYWxsZWQgYnkgc2VsbGVyIG9yIGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVsZWFzZV9mdW5kc190b19zZWxsZXJfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NDItNDMKICAgIC8vICMgUmVsZWFzZSBmdW5kcyB0byBzZWxsZXIgKGNhbGxlZCBieSBidXllciBvciBhcmJpdHJhdG9yKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmVsZWFzZV9mdW5kc190b19zZWxsZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVwb3NpdF9mdW5kc19yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNC0zNQogICAgLy8gIyBEZXBvc2l0IGZ1bmRzIGludG8gZXNjcm93IChjYWxsZWQgYnkgYnV5ZXIpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNC0zNQogICAgLy8gIyBEZXBvc2l0IGZ1bmRzIGludG8gZXNjcm93IChjYWxsZWQgYnkgYnV5ZXIpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZGVwb3NpdF9mdW5kcwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfYXBwbGljYXRpb25fcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTcKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwgY3JlYXRlPSJyZXF1aXJlIikKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUKICAgIC8vIGNsYXNzIEVzY3JvdyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxNwogICAgLy8gQGFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiTm9PcCJdLCBjcmVhdGU9InJlcXVpcmUiKQogICAgY2FsbHN1YiBjcmVhdGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5jcmVhdGVfYXBwbGljYXRpb24odmFsdWU6IHVpbnQ2NCwgc2VsbGVyOiBieXRlcywgYnV5ZXI6IGJ5dGVzLCBhcmJpdHJhdG9yOiBieXRlcywgZXNjcm93X2R1cmF0aW9uOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZV9hcHBsaWNhdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTctMjUKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwgY3JlYXRlPSJyZXF1aXJlIikKICAgIC8vIGRlZiBjcmVhdGVfYXBwbGljYXRpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWx1ZTogVUludDY0LAogICAgLy8gICAgIHNlbGxlcjogQWNjb3VudCwKICAgIC8vICAgICBidXllcjogQWNjb3VudCwKICAgIC8vICAgICBhcmJpdHJhdG9yOiBBY2NvdW50LAogICAgLy8gICAgIGVzY3Jvd19kdXJhdGlvbjogVUludDY0LCAgIyBEdXJhdGlvbiBpbiBzZWNvbmRzCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA1IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MjYKICAgIC8vIHNlbGYudmFsdWUgPSB2YWx1ZQogICAgYnl0ZWNfMiAvLyAidmFsdWUiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3CiAgICAvLyBzZWxmLnNlbGxlciA9IHNlbGxlcgogICAgYnl0ZWNfMyAvLyAic2VsbGVyIgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToyOAogICAgLy8gc2VsZi5idXllciA9IGJ1eWVyCiAgICBieXRlY18xIC8vICJidXllciIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MjkKICAgIC8vIHNlbGYuYXJiaXRyYXRvciA9IGFyYml0cmF0b3IKICAgIGJ5dGVjIDQgLy8gImFyYml0cmF0b3IiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwCiAgICAvLyBzZWxmLmVzY3Jvd19leHBpcnkgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGVzY3Jvd19kdXJhdGlvbgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBieXRlYyA2IC8vICJlc2Nyb3dfZXhwaXJ5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzEKICAgIC8vIHNlbGYuaXNfZGlzcHV0ZWQgPSBGYWxzZQogICAgYnl0ZWMgNSAvLyAiaXNfZGlzcHV0ZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzIKICAgIC8vIHNlbGYuaXNfc2V0dGxlZCA9IEZhbHNlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5kZXBvc2l0X2Z1bmRzKHBheW1lbnQ6IHVpbnQ2NCkgLT4gdm9pZDoKZGVwb3NpdF9mdW5kczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzQtMzYKICAgIC8vICMgRGVwb3NpdCBmdW5kcyBpbnRvIGVzY3JvdyAoY2FsbGVkIGJ5IGJ1eWVyKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGVwb3NpdF9mdW5kcyhzZWxmLCBwYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbikgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5idXllciwgIk9ubHkgdGhlIGJ1eWVyIGNhbiBkZXBvc2l0IGZ1bmRzIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBidXllciBjYW4gZGVwb3NpdCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozOAogICAgLy8gYXNzZXJ0IHBheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgIlBheW1lbnQgbXVzdCBiZSBzZW50IHRvIHRoZSBlc2Nyb3ciCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byB0aGUgZXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyBhc3NlcnQgcGF5bWVudC5hbW91bnQgPT0gc2VsZi52YWx1ZSwgIlBheW1lbnQgbXVzdCBtYXRjaCB0aGUgYXNzZXQgcHJpY2UiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbHVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbHVlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgbWF0Y2ggdGhlIGFzc2V0IHByaWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcigpIC0+IHZvaWQ6CnJlbGVhc2VfZnVuZHNfdG9fc2VsbGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo0Mi00NAogICAgLy8gIyBSZWxlYXNlIGZ1bmRzIHRvIHNlbGxlciAoY2FsbGVkIGJ5IGJ1eWVyIG9yIGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcihzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciBpbiAoc2VsZi5idXllciwgc2VsZi5hcmJpdHJhdG9yKSwgIk9ubHkgYnV5ZXIgb3IgYXJiaXRyYXRvciBjYW4gcmVsZWFzZSBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gImFyYml0cmF0b3IiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXJiaXRyYXRvciBleGlzdHMKICAgID09CiAgICBibnogcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgPT0KICAgIGJ6IHJlbGVhc2VfZnVuZHNfdG9fc2VsbGVyX2Jvb2xfZmFsc2VAMwoKcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo0NQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuYnV5ZXIsIHNlbGYuYXJiaXRyYXRvciksICJPbmx5IGJ1eWVyIG9yIGFyYml0cmF0b3IgY2FuIHJlbGVhc2UgZnVuZHMiCiAgICBhc3NlcnQgLy8gT25seSBidXllciBvciBhcmJpdHJhdG9yIGNhbiByZWxlYXNlIGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ2CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTUzCiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgLy8gICAgIGFtb3VudD1zZWxmLnZhbHVlLAogICAgLy8gICAgIGZlZT0xXzAwMCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NTAKICAgIC8vIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInNlbGxlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zZWxsZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUxCiAgICAvLyBhbW91bnQ9c2VsZi52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWx1ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWx1ZSBleGlzdHMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTQ5CiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1MgogICAgLy8gZmVlPTFfMDAwLAogICAgaW50Y18yIC8vIDEwMDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTUzCiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgLy8gICAgIGFtb3VudD1zZWxmLnZhbHVlLAogICAgLy8gICAgIGZlZT0xXzAwMCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU1LTU2CiAgICAvLyAjIE1hcmsgYXMgc2V0dGxlZAogICAgLy8gc2VsZi5pc19zZXR0bGVkID0gVHJ1ZQogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpyZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcl9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZWZ1bmRfZnVuZHNfdG9fYnV5ZXIoKSAtPiB2b2lkOgpyZWZ1bmRfZnVuZHNfdG9fYnV5ZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4LTYwCiAgICAvLyAjIFJlZnVuZCBmdW5kcyB0byBidXllciAoY2FsbGVkIGJ5IHNlbGxlciBvciBhcmJpdHJhdG9yKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgcmVmdW5kX2Z1bmRzX3RvX2J1eWVyKHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NjEKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIChzZWxmLnNlbGxlciwgc2VsZi5hcmJpdHJhdG9yKSwgIk9ubHkgc2VsbGVyIG9yIGFyYml0cmF0b3IgY2FuIHJlZnVuZCBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInNlbGxlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zZWxsZXIgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiYXJiaXRyYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAzCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hcmJpdHJhdG9yIGV4aXN0cwogICAgPT0KICAgIGJueiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgPT0KICAgIGJ6IHJlZnVuZF9mdW5kc190b19idXllcl9ib29sX2ZhbHNlQDMKCnJlZnVuZF9mdW5kc190b19idXllcl9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpyZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuc2VsbGVyLCBzZWxmLmFyYml0cmF0b3IpLCAiT25seSBzZWxsZXIgb3IgYXJiaXRyYXRvciBjYW4gcmVmdW5kIGZ1bmRzIgogICAgYXNzZXJ0IC8vIE9ubHkgc2VsbGVyIG9yIGFyYml0cmF0b3IgY2FuIHJlZnVuZCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2MgogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NC02OQogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyBiYWNrIHRvIGJ1eWVyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5idXllciwKICAgIC8vICAgICBhbW91bnQ9c2VsZi52YWx1ZSwKICAgIC8vICAgICBmZWU9MV8wMDAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2CiAgICAvLyByZWNlaXZlcj1zZWxmLmJ1eWVyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NwogICAgLy8gYW1vdW50PXNlbGYudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidmFsdWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsdWUgZXhpc3RzCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NC02NQogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyBiYWNrIHRvIGJ1eWVyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBmZWU9MV8wMDAsCiAgICBpbnRjXzIgLy8gMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NjQtNjkKICAgIC8vICMgVHJhbnNmZXIgZnVuZHMgYmFjayB0byBidXllcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuYnV5ZXIsCiAgICAvLyAgICAgYW1vdW50PXNlbGYudmFsdWUsCiAgICAvLyAgICAgZmVlPTFfMDAwLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzEtNzIKICAgIC8vICMgTWFyayBhcyBzZXR0bGVkCiAgICAvLyBzZWxmLmlzX3NldHRsZWQgPSBUcnVlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJlZnVuZF9mdW5kc190b19idXllcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cucmFpc2VfZGlzcHV0ZSgpIC0+IHZvaWQ6CnJhaXNlX2Rpc3B1dGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyAjIFJhaXNlIGEgZGlzcHV0ZSAoY2FsbGVkIGJ5IGJ1eWVyIG9yIHNlbGxlcikKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIHJhaXNlX2Rpc3B1dGUoc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo3NwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuYnV5ZXIsIHNlbGYuc2VsbGVyKSwgIk9ubHkgYnV5ZXIgb3Igc2VsbGVyIGNhbiByYWlzZSBhIGRpc3B1dGUiCiAgICB0eG4gU2VuZGVyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJidXllciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5idXllciBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJzZWxsZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc2VsbGVyIGV4aXN0cwogICAgPT0KICAgIGJueiByYWlzZV9kaXNwdXRlX2Jvb2xfdHJ1ZUAyCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDEKICAgID09CiAgICBieiByYWlzZV9kaXNwdXRlX2Jvb2xfZmFsc2VAMwoKcmFpc2VfZGlzcHV0ZV9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpyYWlzZV9kaXNwdXRlX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIChzZWxmLmJ1eWVyLCBzZWxmLnNlbGxlciksICJPbmx5IGJ1eWVyIG9yIHNlbGxlciBjYW4gcmFpc2UgYSBkaXNwdXRlIgogICAgYXNzZXJ0IC8vIE9ubHkgYnV5ZXIgb3Igc2VsbGVyIGNhbiByYWlzZSBhIGRpc3B1dGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzgKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5pc19kaXNwdXRlZCwgIkRpc3B1dGUgYWxyZWFkeSByYWlzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiaXNfZGlzcHV0ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfZGlzcHV0ZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gRGlzcHV0ZSBhbHJlYWR5IHJhaXNlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo3OQogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4MQogICAgLy8gc2VsZi5pc19kaXNwdXRlZCA9IFRydWUKICAgIGJ5dGVjIDUgLy8gImlzX2Rpc3B1dGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJhaXNlX2Rpc3B1dGVfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgcmFpc2VfZGlzcHV0ZV9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZXNvbHZlX2Rpc3B1dGUoZGVjaXNpb246IGJ5dGVzKSAtPiB2b2lkOgpyZXNvbHZlX2Rpc3B1dGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg1CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiByZXNvbHZlX2Rpc3B1dGUoc2VsZiwgZGVjaXNpb246IFN0cmluZykgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4NgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5hcmJpdHJhdG9yLCAiT25seSB0aGUgYXJiaXRyYXRvciBjYW4gcmVzb2x2ZSBkaXNwdXRlcyIKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJhcmJpdHJhdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFyYml0cmF0b3IgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIGFyYml0cmF0b3IgY2FuIHJlc29sdmUgZGlzcHV0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6ODcKICAgIC8vIGFzc2VydCBzZWxmLmlzX2Rpc3B1dGVkLCAiTm8gZGlzcHV0ZSB0byByZXNvbHZlIgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImlzX2Rpc3B1dGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2Rpc3B1dGVkIGV4aXN0cwogICAgYXNzZXJ0IC8vIE5vIGRpc3B1dGUgdG8gcmVzb2x2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4OAogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo5MAogICAgLy8gaWYgZGVjaXNpb24gPT0gInJlbGVhc2VfdG9fc2VsbGVyIjoKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGJ5dGVzICJyZWxlYXNlX3RvX3NlbGxlciIKICAgID09CiAgICBieiByZXNvbHZlX2Rpc3B1dGVfZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTEKICAgIC8vIHNlbGYucmVsZWFzZV9mdW5kc190b19zZWxsZXIoKQogICAgY2FsbHN1YiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcgoKcmVzb2x2ZV9kaXNwdXRlX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTctOTgKICAgIC8vICMgTWFyayBhcyBzZXR0bGVkCiAgICAvLyBzZWxmLmlzX3NldHRsZWQgPSBUcnVlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJlc29sdmVfZGlzcHV0ZV9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTIKICAgIC8vIGVsaWYgZGVjaXNpb24gPT0gInJlZnVuZF90b19idXllciI6CiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hieXRlcyAicmVmdW5kX3RvX2J1eWVyIgogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGRlY2lzaW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzCiAgICAvLyBzZWxmLnJlZnVuZF9mdW5kc190b19idXllcigpCiAgICBjYWxsc3ViIHJlZnVuZF9mdW5kc190b19idXllcgogICAgYiByZXNvbHZlX2Rpc3B1dGVfYWZ0ZXJfaWZfZWxzZUA2CgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cuZXhwaXJlX2VzY3JvdygpIC0+IHZvaWQ6CmV4cGlyZV9lc2Nyb3c6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gYXNzZXJ0IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wID49IHNlbGYuZXNjcm93X2V4cGlyeSwgIkVzY3JvdyBoYXMgbm90IGV4cGlyZWQgeWV0IgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImVzY3Jvd19leHBpcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZXNjcm93X2V4cGlyeSBleGlzdHMKICAgID49CiAgICBhc3NlcnQgLy8gRXNjcm93IGhhcyBub3QgZXhwaXJlZCB5ZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTA0CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNi0xMDcKICAgIC8vICMgUmVmdW5kIGJ1eWVyCiAgICAvLyBzZWxmLnJlZnVuZF9mdW5kc190b19idXllcigpCiAgICBjYWxsc3ViIHJlZnVuZF9mdW5kc190b19idXllcgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cuZGVsZXRlX2FwcGxpY2F0aW9uKCkgLT4gdm9pZDoKZGVsZXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxMTIKICAgIC8vIGFzc2VydCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBtdXN0IGJlIHNldHRsZWQgYmVmb3JlIGRlbGV0aW5nIgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX3NldHRsZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfc2V0dGxlZCBleGlzdHMKICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHNldHRsZWQgYmVmb3JlIGRlbGV0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExMwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIk9ubHkgdGhlIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgYXBwbGljYXRpb24iCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSBhcHBsaWNhdGlvbgogICAgcmV0c3ViCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [529], "errorMessage": "Dispute already raised"}, {"pc": [636], "errorMessage": "Escrow has not expired yet"}, {"pc": [621], "errorMessage": "Invalid decision"}, {"pc": [562], "errorMessage": "No dispute to resolve"}, {"pc": [151], "errorMessage": "OnCompletion is not DeleteApplication"}, {"pc": [163, 175, 193, 205, 217, 229, 251], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [391], "errorMessage": "Only buyer or arbitrator can release funds"}, {"pc": [522], "errorMessage": "Only buyer or seller can raise a dispute"}, {"pc": [457], "errorMessage": "Only seller or arbitrator can refund funds"}, {"pc": [556], "errorMessage": "Only the arbitrator can resolve disputes"}, {"pc": [334], "errorMessage": "Only the buyer can deposit funds"}, {"pc": [657], "errorMessage": "Only the creator can delete the application"}, {"pc": [342], "errorMessage": "Payment must be sent to the escrow"}, {"pc": [352], "errorMessage": "Payment must match the asset price"}, {"pc": [358, 397, 463, 535, 568, 642], "errorMessage": "Transaction is already settled"}, {"pc": [651], "errorMessage": "Transaction must be settled before deleting"}, {"pc": [255], "errorMessage": "can only call when creating"}, {"pc": [154, 166, 178, 196, 208, 220, 232], "errorMessage": "can only call when not creating"}, {"pc": [377, 443, 554], "errorMessage": "check self.arbitrator exists"}, {"pc": [332, 369, 468, 501], "errorMessage": "check self.buyer exists"}, {"pc": [634], "errorMessage": "check self.escrow_expiry exists"}, {"pc": [527, 561], "errorMessage": "check self.is_disputed exists"}, {"pc": [356, 395, 461, 533, 566, 640, 650], "errorMessage": "check self.is_settled exists"}, {"pc": [402, 435, 508], "errorMessage": "check self.seller exists"}, {"pc": [350, 406, 472], "errorMessage": "check self.value exists"}, {"pc": [242], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class DepositFundsArgs:
    """Dataclass for deposit_funds arguments"""
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "deposit_funds(pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ResolveDisputeArgs:
    """Dataclass for resolve_dispute arguments"""
    decision: str

    @property
    def abi_method_signature(self) -> str:
        return "resolve_dispute(string)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateApplicationArgs:
    """Dataclass for create_application arguments"""
    value: int
    seller: str | bytes
    buyer: str | bytes
    arbitrator: str | bytes
    escrow_duration: int

    @property
    def abi_method_signature(self) -> str:
        return "create_application(uint64,account,account,account,uint64)void"


class _EscrowDelete:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppDeleteMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_application()void",
        }))


class EscrowParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_EscrowDelete":
        return _EscrowDelete(self.app_client)

    def deposit_funds(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deposit_funds(pay)void",
            "args": method_args,
        }))

    def release_funds_to_seller(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "release_funds_to_seller()void",
        }))

    def refund_funds_to_buyer(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "refund_funds_to_buyer()void",
        }))

    def raise_dispute(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "raise_dispute()void",
        }))

    def resolve_dispute(
        self,
        args: tuple[str] | ResolveDisputeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "resolve_dispute(string)void",
            "args": method_args,
        }))

    def expire_escrow(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "expire_escrow()void",
        }))

    def create_application(
        self,
        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_application(uint64,account,account,account,uint64)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class _EscrowDeleteTransaction:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_application()void",
        }))


class EscrowCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_EscrowDeleteTransaction":
        return _EscrowDeleteTransaction(self.app_client)

    def deposit_funds(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deposit_funds(pay)void",
            "args": method_args,
        }))

    def release_funds_to_seller(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "release_funds_to_seller()void",
        }))

    def refund_funds_to_buyer(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "refund_funds_to_buyer()void",
        }))

    def raise_dispute(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "raise_dispute()void",
        }))

    def resolve_dispute(
        self,
        args: tuple[str] | ResolveDisputeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "resolve_dispute(string)void",
            "args": method_args,
        }))

    def expire_escrow(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "expire_escrow()void",
        }))

    def create_application(
        self,
        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_application(uint64,account,account,account,uint64)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class _EscrowDeleteSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_application()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)


class EscrowSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_EscrowDeleteSend":
        return _EscrowDeleteSend(self.app_client)

    def deposit_funds(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "deposit_funds(pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def release_funds_to_seller(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "release_funds_to_seller()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def refund_funds_to_buyer(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "refund_funds_to_buyer()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def raise_dispute(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "raise_dispute()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def resolve_dispute(
        self,
        args: tuple[str] | ResolveDisputeArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "resolve_dispute(string)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def expire_escrow(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "expire_escrow()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def create_application(
        self,
        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_application(uint64,account,account,account,uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    seller: bytes
    buyer: bytes
    arbitrator: bytes
    amount: int
    escrow_expiry: int
    is_disputed: int
    is_settled: int
    value: int

class EscrowState:
    """Methods to access state for the current Escrow app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def seller(self) -> bytes:
        """Get the current value of the seller key in global_state state"""
        value = self.app_client.state.global_state.get_value("seller")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def buyer(self) -> bytes:
        """Get the current value of the buyer key in global_state state"""
        value = self.app_client.state.global_state.get_value("buyer")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def arbitrator(self) -> bytes:
        """Get the current value of the arbitrator key in global_state state"""
        value = self.app_client.state.global_state.get_value("arbitrator")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

    @property
    def amount(self) -> int:
        """Get the current value of the amount key in global_state state"""
        value = self.app_client.state.global_state.get_value("amount")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def escrow_expiry(self) -> int:
        """Get the current value of the escrow_expiry key in global_state state"""
        value = self.app_client.state.global_state.get_value("escrow_expiry")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def is_disputed(self) -> int:
        """Get the current value of the is_disputed key in global_state state"""
        value = self.app_client.state.global_state.get_value("is_disputed")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def is_settled(self) -> int:
        """Get the current value of the is_settled key in global_state state"""
        value = self.app_client.state.global_state.get_value("is_settled")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def value(self) -> int:
        """Get the current value of the value key in global_state state"""
        value = self.app_client.state.global_state.get_value("value")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class EscrowClient:
    """Client for interacting with Escrow smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = EscrowParams(self.app_client)
        self.create_transaction = EscrowCreateTransactionParams(self.app_client)
        self.send = EscrowSend(self.app_client)
        self.state = EscrowState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "EscrowClient":
        return EscrowClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "EscrowClient":
        return EscrowClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "EscrowClient":
        return EscrowClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "EscrowComposer":
        return EscrowComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["deposit_funds(pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["release_funds_to_seller()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["refund_funds_to_buyer()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["raise_dispute()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["resolve_dispute(string)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["expire_escrow()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_application(uint64,account,account,account,uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["delete_application()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class EscrowMethodCallCreateParams(
    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[
        CreateApplicationArgs,
        str | None,
    ]
):
    """Parameters for creating Escrow contract using ABI"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallCreateParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

@dataclasses.dataclass(frozen=True)
class EscrowMethodCallDeleteParams(
    algokit_utils.BaseAppClientMethodCallParams[
        typing.Any,
        str | None,
    ]
):
    """Parameters for calling Escrow contract using ABI"""
    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

class EscrowFactory(algokit_utils.TypedAppFactoryProtocol[EscrowMethodCallCreateParams, None, EscrowMethodCallDeleteParams]):
    """Factory for deploying and managing EscrowClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = EscrowFactoryParams(self.app_factory)
        self.create_transaction = EscrowFactoryCreateTransaction(self.app_factory)
        self.send = EscrowFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: EscrowMethodCallCreateParams | None = None,
        update_params: None = None,
        delete_params: EscrowMethodCallDeleteParams | None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[EscrowClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return EscrowClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> EscrowClient:
        """Get an app client by creator address and name"""
        return EscrowClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> EscrowClient:
        """Get an app client by app ID"""
        return EscrowClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class EscrowFactoryParams:
    """Parameters for creating transactions for Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = EscrowFactoryCreateParams(app_factory)
        self.update = EscrowFactoryUpdateParams(app_factory)
        self.delete = EscrowFactoryDeleteParams(app_factory)

class EscrowFactoryCreateParams:
    """Parameters for 'create' operations of Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def deposit_funds(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the deposit_funds(pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "deposit_funds(pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def release_funds_to_seller(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the release_funds_to_seller()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "release_funds_to_seller()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def refund_funds_to_buyer(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the refund_funds_to_buyer()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "refund_funds_to_buyer()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def raise_dispute(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the raise_dispute()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "raise_dispute()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def resolve_dispute(
        self,
        args: tuple[str] | ResolveDisputeArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the resolve_dispute(string)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "resolve_dispute(string)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def expire_escrow(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the expire_escrow()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "expire_escrow()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def create_application(
        self,
        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_application(uint64,account,account,account,uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_application(uint64,account,account,account,uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def delete_application(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the delete_application()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "delete_application()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class EscrowFactoryUpdateParams:
    """Parameters for 'update' operations of Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class EscrowFactoryDeleteParams:
    """Parameters for 'delete' operations of Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class EscrowFactoryCreateTransaction:
    """Create transactions for Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = EscrowFactoryCreateTransactionCreate(app_factory)


class EscrowFactoryCreateTransactionCreate:
    """Create new instances of Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class EscrowFactorySend:
    """Send calls to Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = EscrowFactorySendCreate(app_factory)


class EscrowFactorySendCreate:
    """Send create calls to Escrow contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[EscrowClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return EscrowClient(result[0]), result[1]

    def create_application(
        self,
        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> tuple[EscrowClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:
            """Creates and sends a transaction using the create_application(uint64,account,account,account,uint64)void ABI method"""
            params = params or algokit_utils.CommonAppCallCreateParams()
            client, result = self.app_factory.send.create(
                algokit_utils.AppFactoryCreateMethodCallParams(
                    **{
                    **dataclasses.asdict(params),
                    "method": "create_application(uint64,account,account,account,uint64)void",
                    "args": _parse_abi_args(args),
                    }
                ),
                send_params=send_params,
                compilation_params=compilation_params
            )
            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)
    
            return EscrowClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](
                **{
                    **result.__dict__,
                    "app_id": result.app_id,
                    "abi_return": return_value,
                    "transaction": result.transaction,
                    "confirmation": result.confirmation,
                    "group_id": result.group_id,
                    "tx_ids": result.tx_ids,
                    "transactions": result.transactions,
                    "confirmations": result.confirmations,
                    "app_address": result.app_address,
                }
            )


class _EscrowDeleteComposer:
    def __init__(self, composer: "EscrowComposer"):
        self.composer = composer
    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self.composer._composer.add_app_delete_method_call(
            self.composer.client.params.delete.delete_application(
                
                params=params,
                
            )
        )
        self.composer._result_mappers.append(
            lambda v: self.composer.client.decode_return_value(
                "delete_application()void", v
            )
        )
        return self.composer


class EscrowComposer:
    """Composer for creating transaction groups for Escrow contract calls"""

    def __init__(self, client: "EscrowClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    @property
    def delete(self) -> "_EscrowDeleteComposer":
        return _EscrowDeleteComposer(self)

    def deposit_funds(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.deposit_funds(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "deposit_funds(pay)void", v
            )
        )
        return self

    def release_funds_to_seller(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.release_funds_to_seller(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "release_funds_to_seller()void", v
            )
        )
        return self

    def refund_funds_to_buyer(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.refund_funds_to_buyer(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "refund_funds_to_buyer()void", v
            )
        )
        return self

    def raise_dispute(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.raise_dispute(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "raise_dispute()void", v
            )
        )
        return self

    def resolve_dispute(
        self,
        args: tuple[str] | ResolveDisputeArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.resolve_dispute(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "resolve_dispute(string)void", v
            )
        )
        return self

    def expire_escrow(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.expire_escrow(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "expire_escrow()void", v
            )
        )
        return self

    def create_application(
        self,
        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "EscrowComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_application(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_application(uint64,account,account,account,uint64)void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "EscrowComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "EscrowComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)


# File: https://github.com/algorandfoundation/ARCs/blob/2f3df5821265291f49710f58e53324ac4405d0e9/assets/arc-0062/smart_contracts/artifacts/circulating_supply/circulating_supply_client.py
# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ASA ID of the circulating supply", "name": "asset_id"}], "name": "set_asset", "returns": {"type": "void"}, "desc": "Set the ASA ID for the circulating supply - Authorization: ASA Manager Address", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "desc": "Address to assign to the label to", "name": "address"}, {"type": "string", "desc": "Not-circulating label selector", "name": "label"}], "name": "set_not_circulating_address", "returns": {"type": "void"}, "desc": "Set non-circulating supply addresses - Authorization: ASA Manager Address", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ASA ID of the circulating supply", "name": "asset_id"}], "name": "arc62_get_circulating_supply", "returns": {"type": "uint64", "desc": "ASA circulating supply"}, "desc": "Get ASA circulating supply", "events": [], "readonly": true, "recommendations": {}}], "name": "CirculatingSupply", "state": {"keys": {"box": {}, "global": {"asset_id": {"key": "YXNzZXRfaWQ=", "keyType": "AVMString", "valueType": "AVMUint64"}, "not_circulating_label_1": {"key": "YnVybmVk", "keyType": "AVMString", "valueType": "address"}, "not_circulating_label_2": {"key": "bG9ja2Vk", "keyType": "AVMString", "valueType": "address"}, "not_circulating_label_3": {"key": "Z2VuZXJpYw==", "keyType": "AVMString", "valueType": "address"}}, "local": {}}, "maps": {"box": {}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 3, "ints": 1}, "local": {"bytes": 0, "ints": 0}}}, "structs": {}, "byteCode": {"approval": "CiADAAEgJgQIYXNzZXRfaWQGYnVybmVkBmxvY2tlZAdnZW5lcmljMRhAAA8oImcpMgNnKjIDZysyA2cxG0EAXYIDBHCbgKgEC2LHKARcwsU1NhoAjgMAMQAcAAIiQzEZFEQxGEQ2GgEXiACXFoAEFR98dUxQsCNDMRkURDEYRDYaATYaAlcCAIgAPSNDMRkURDEYRDYaAReIAA0jQzEZQP+6MRgURCNDigEAMQCL/3EHRBJBAA4iKGVEQAAHI0Qoi/9niSJC//aKAgAiKGVEMQBLAXEHRBJEi/4VJBJEi/5McABFAUQpKiuL/44DAAsABgABACuL/meJKov+Z4kpi/5niYoBAYAARwIiKWVMSU8CRBUkEkQiKmVMSU8CRBUkEkQiK2VMSU8CRBUkEkQiKGVEi/8SRIv/cQhEMgMSQAAOi/9xCESL/3AARQFAAHgijAKLAzIDEkAAC4sDi/9wAEUBQABWIowAiwQyAxJAAAuLBIv/cABFAUAANCKMAYsFMgMSQAALiwWL/3AARQFAABQii/9xAESLAgmLAAmLAQlMCYwAiYsFi/9wAERC/+OLBIv/cABEjAFC/8OLA4v/cABEjABC/6GL/3EIRIv/cABEjAJC/3w=", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 4, "patch": 0}}, "desc": "ARC-62 Reference Implementation", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMuY2lyY3VsYXRpbmdfc3VwcGx5LmNvbnRyYWN0LkNpcmN1bGF0aW5nU3VwcGx5Ll9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDAgMSAzMgogICAgYnl0ZWNibG9jayAiYXNzZXRfaWQiICJidXJuZWQiICJsb2NrZWQiICJnZW5lcmljIgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyNC0yNQogICAgLy8gIyBHbG9iYWwgU3RhdGUKICAgIC8vIHNlbGYuYXNzZXRfaWQgPSBVSW50NjQoKQogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjcKICAgIC8vIEFkZHJlc3MoKSwga2V5PWNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMQogICAgYnl0ZWNfMSAvLyAiYnVybmVkIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjI2LTI4CiAgICAvLyBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8xID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgQWRkcmVzcygpLCBrZXk9Y2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8xCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozMAogICAgLy8gQWRkcmVzcygpLCBrZXk9Y2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8yCiAgICBieXRlY18yIC8vICJsb2NrZWQiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjktMzEKICAgIC8vIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzIgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzIKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjMzCiAgICAvLyBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzMKICAgIGJ5dGVjXzMgLy8gImdlbmVyaWMiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MzItMzQKICAgIC8vIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzMKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAKICAgIC8vIGNsYXNzIENpcmN1bGF0aW5nU3VwcGx5KEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9iYXJlX3JvdXRpbmdAOAogICAgcHVzaGJ5dGVzcyAweDcwOWI4MGE4IDB4MGI2MmM3MjggMHg1Y2MyYzUzNSAvLyBtZXRob2QgInNldF9hc3NldCh1aW50NjQpdm9pZCIsIG1ldGhvZCAic2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKGFkZHJlc3Msc3RyaW5nKXZvaWQiLCBtZXRob2QgImFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHkodWludDY0KXVpbnQ2NCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fc2V0X2Fzc2V0X3JvdXRlQDUgbWFpbl9zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfcm91dGVANiBtYWluX2FyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfcm91dGVANwoKbWFpbl9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIwCiAgICAvLyBjbGFzcyBDaXJjdWxhdGluZ1N1cHBseShBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5CiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3NldF9hc3NldF9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozNgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAKICAgIC8vIGNsYXNzIENpcmN1bGF0aW5nU3VwcGx5KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjM2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X2Fzc2V0CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JhcmVfcm91dGluZ0A4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMTAKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfYXNzZXQoYXNzZXRfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc2V0X2Fzc2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozNi0zNwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X2Fzc2V0KHNlbGYsIGFzc2V0X2lkOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NDUtNDYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlciBhbmQgbm90IHNlbGYuYXNzZXRfaWQsIGVyci5VTkFVVEhPUklaRUQKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgID09CiAgICBieiBzZXRfYXNzZXRfYm9vbF9mYWxzZUAzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzZXRfaWQgZXhpc3RzCiAgICBibnogc2V0X2Fzc2V0X2Jvb2xfZmFsc2VAMwogICAgaW50Y18xIC8vIDEKCnNldF9hc3NldF9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjQ1LTQ2CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IGFzc2V0Lm1hbmFnZXIgYW5kIG5vdCBzZWxmLmFzc2V0X2lkLCBlcnIuVU5BVVRIT1JJWkVECiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjQ3LTQ4CiAgICAvLyAjIEVmZmVjdHMKICAgIC8vIHNlbGYuYXNzZXRfaWQgPSBhc3NldF9pZAogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnNldF9hc3NldF9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzZXRfYXNzZXRfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3MoYWRkcmVzczogYnl0ZXMsIGxhYmVsOiBieXRlcykgLT4gdm9pZDoKc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo1MC01MQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKHNlbGYsIGFkZHJlc3M6IEFkZHJlc3MsIGxhYmVsOiBTdHJpbmcpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NTkKICAgIC8vIGFzc2V0ID0gQXNzZXQoc2VsZi5hc3NldF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJhc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc3NldF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjAtNjEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlciwgZXJyLlVOQVVUSE9SSVpFRAogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2MgogICAgLy8gYXNzZXJ0IEFjY291bnQoYWRkcmVzcy5ieXRlcykuaXNfb3B0ZWRfaW4oYXNzZXQpLCBlcnIuTk9UX09QVEVEX0lOCiAgICBmcmFtZV9kaWcgLTIKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIEFkZHJlc3MgbGVuZ3RoIGlzIDMyIGJ5dGVzCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTm90IE9wdGVkLUluCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjY1CiAgICAvLyBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMToKICAgIGJ5dGVjXzEgLy8gImJ1cm5lZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjcKICAgIC8vIGNhc2UgY2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8yOgogICAgYnl0ZWNfMiAvLyAibG9ja2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2OQogICAgLy8gY2FzZSBjZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzM6CiAgICBieXRlY18zIC8vICJnZW5lcmljIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2My03MgogICAgLy8gIyBFZmZlY3RzCiAgICAvLyBtYXRjaCBsYWJlbDoKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMToKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMjoKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMi52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMzoKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMy52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIF86CiAgICAvLyAgICAgICAgIGFzc2VydCBGYWxzZSwgZXJyLklOVkFMSURfTEFCRUwKICAgIGZyYW1lX2RpZyAtMQogICAgbWF0Y2ggc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3N3aXRjaF9jYXNlXzBAMSBzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMUAyIHNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8yQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NzIKICAgIC8vIGFzc2VydCBGYWxzZSwgZXJyLklOVkFMSURfTEFCRUwKICAgIGVyciAvLyBJbnZhbGlkIExhYmVsCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMkAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3MAogICAgLy8gc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMy52YWx1ZSA9IGFkZHJlc3MKICAgIGJ5dGVjXzMgLy8gImdlbmVyaWMiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8xQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8yLnZhbHVlID0gYWRkcmVzcwogICAgYnl0ZWNfMiAvLyAibG9ja2VkIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMEAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2NgogICAgLy8gc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZSA9IGFkZHJlc3MKICAgIGJ5dGVjXzEgLy8gImJ1cm5lZCIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXJjdWxhdGluZ19zdXBwbHkuY29udHJhY3QuQ2lyY3VsYXRpbmdTdXBwbHkuYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseShhc3NldF9pZDogdWludDY0KSAtPiB1aW50NjQ6CmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojc0LTc1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseShzZWxmLCBhc3NldF9pZDogVUludDY0KSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBub3RfY2lyY3VsYXRpbmdfMSA9IEFjY291bnQoc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZS5ieXRlcykKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJidXJuZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8xIGV4aXN0cwogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gQWRkcmVzcyBsZW5ndGggaXMgMzIgYnl0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6ODcKICAgIC8vIG5vdF9jaXJjdWxhdGluZ18yID0gQWNjb3VudChzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8yLnZhbHVlLmJ5dGVzKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImxvY2tlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzIgZXhpc3RzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo4OAogICAgLy8gbm90X2NpcmN1bGF0aW5nXzMgPSBBY2NvdW50KHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMudmFsdWUuYnl0ZXMpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiZ2VuZXJpYyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMgZXhpc3RzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo4OS05MAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgYXNzZXRfaWQgPT0gc2VsZi5hc3NldF9pZCwgZXJyLklOVkFMSURfQVNTRVRfSUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJhc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc3NldF9pZCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIEFTQSBJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5NAogICAgLy8gaWYgYXNzZXQucmVzZXJ2ZSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRSZXNlcnZlCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojk0LTk1CiAgICAvLyBpZiBhc3NldC5yZXNlcnZlID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIG9yIG5vdCBhc3NldC5yZXNlcnZlLmlzX29wdGVkX2luKGFzc2V0KQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTUKICAgIC8vIG9yIG5vdCBhc3NldC5yZXNlcnZlLmlzX29wdGVkX2luKGFzc2V0KQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0UmVzZXJ2ZQogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAzCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5MwogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAyCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTAwCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzEuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVANgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDEKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMS5pc19vcHRlZF9pbihhc3NldCkKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDcKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDYKICAgIC8vIGlmIG5vdF9jaXJjdWxhdGluZ18yID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGZyYW1lX2RpZyA0CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjEwNi0xMDcKICAgIC8vIGlmIG5vdF9jaXJjdWxhdGluZ18yID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMi5pc19vcHRlZF9pbihhc3NldCkKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDcKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMi5pc19vcHRlZF9pbihhc3NldCkKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDExCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA1CiAgICAvLyBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDEKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTEyCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMyA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgNQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTItMTEzCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMyA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzMuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTEzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzMuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxNQoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExMQogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X21lcmdlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTcKICAgIC8vIGFzc2V0LnRvdGFsCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRUb3RhbAogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTE4CiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIGZyYW1lX2RpZyAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExNy0xMTkKICAgIC8vIGFzc2V0LnRvdGFsCiAgICAvLyAtIHJlc2VydmVfYmFsYW5jZQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8xCiAgICBmcmFtZV9kaWcgMAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTIwCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gbm90X2NpcmN1bGF0aW5nX2JhbGFuY2VfMQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICBmcmFtZV9kaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTIxCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gbm90X2NpcmN1bGF0aW5nX2JhbGFuY2VfMQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICAvLyAtIG5vdF9jaXJjdWxhdGluZ19iYWxhbmNlXzMKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTE2LTEyMgogICAgLy8gcmV0dXJuICgKICAgIC8vICAgICBhc3NldC50b3RhbAogICAgLy8gICAgIC0gcmVzZXJ2ZV9iYWxhbmNlCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8xCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8zCiAgICAvLyApCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTQKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShub3RfY2lyY3VsYXRpbmdfMykKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTYKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA4CiAgICAvLyBlbHNlIGFzc2V0LmJhbGFuY2Uobm90X2NpcmN1bGF0aW5nXzIpCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGZyYW1lX2J1cnkgMQogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTIKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDIKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShub3RfY2lyY3VsYXRpbmdfMSkKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgZnJhbWVfYnVyeSAwCiAgICBiIGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUA4CgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfZmFsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTYKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShhc3NldC5yZXNlcnZlKQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0UmVzZXJ2ZQogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGZyYW1lX2J1cnkgMgogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANAo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [221, 277, 289, 301], "errorMessage": "Address length is 32 bytes"}, {"pc": [309], "errorMessage": "Invalid ASA ID"}, {"pc": [243], "errorMessage": "Invalid Label"}, {"pc": [229], "errorMessage": "Not Opted-In"}, {"pc": [97, 123, 144], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [190, 215], "errorMessage": "Unauthorized"}, {"pc": [427, 437, 449, 464], "errorMessage": "account opted into asset"}, {"pc": [177, 213, 314, 325, 406, 459], "errorMessage": "asset exists"}, {"pc": [165], "errorMessage": "can only call when creating"}, {"pc": [100, 126, 147], "errorMessage": "can only call when not creating"}, {"pc": [185, 206, 305], "errorMessage": "check self.asset_id exists"}, {"pc": [273], "errorMessage": "check self.not_circulating_label_1 exists"}, {"pc": [285], "errorMessage": "check self.not_circulating_label_2 exists"}, {"pc": [297], "errorMessage": "check self.not_circulating_label_3 exists"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetAssetArgs:
    """Dataclass for set_asset arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "set_asset(uint64)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class SetNotCirculatingAddressArgs:
    """Dataclass for set_not_circulating_address arguments"""
    address: str
    label: str

    @property
    def abi_method_signature(self) -> str:
        return "set_not_circulating_address(address,string)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class Arc62GetCirculatingSupplyArgs:
    """Dataclass for arc62_get_circulating_supply arguments"""
    asset_id: int

    @property
    def abi_method_signature(self) -> str:
        return "arc62_get_circulating_supply(uint64)uint64"


class CirculatingSupplyParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def set_asset(
        self,
        args: tuple[int] | SetAssetArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_asset(uint64)void",
            "args": method_args,
        }))

    def set_not_circulating_address(
        self,
        args: tuple[str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_not_circulating_address(address,string)void",
            "args": method_args,
        }))

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc62_get_circulating_supply(uint64)uint64",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class CirculatingSupplyCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def set_asset(
        self,
        args: tuple[int] | SetAssetArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_asset(uint64)void",
            "args": method_args,
        }))

    def set_not_circulating_address(
        self,
        args: tuple[str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_not_circulating_address(address,string)void",
            "args": method_args,
        }))

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc62_get_circulating_supply(uint64)uint64",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class CirculatingSupplySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def set_asset(
        self,
        args: tuple[int] | SetAssetArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_asset(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def set_not_circulating_address(
        self,
        args: tuple[str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "set_not_circulating_address(address,string)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "arc62_get_circulating_supply(uint64)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    asset_id: int
    not_circulating_label_1: str
    not_circulating_label_2: str
    not_circulating_label_3: str

class CirculatingSupplyState:
    """Methods to access state for the current CirculatingSupply app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def asset_id(self) -> int:
        """Get the current value of the asset_id key in global_state state"""
        value = self.app_client.state.global_state.get_value("asset_id")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def not_circulating_label_1(self) -> str:
        """Get the current value of the not_circulating_label_1 key in global_state state"""
        value = self.app_client.state.global_state.get_value("not_circulating_label_1")
        if isinstance(value, dict) and "address" in self._struct_classes:
            return _init_dataclass(self._struct_classes["address"], value)  # type: ignore
        return typing.cast(str, value)

    @property
    def not_circulating_label_2(self) -> str:
        """Get the current value of the not_circulating_label_2 key in global_state state"""
        value = self.app_client.state.global_state.get_value("not_circulating_label_2")
        if isinstance(value, dict) and "address" in self._struct_classes:
            return _init_dataclass(self._struct_classes["address"], value)  # type: ignore
        return typing.cast(str, value)

    @property
    def not_circulating_label_3(self) -> str:
        """Get the current value of the not_circulating_label_3 key in global_state state"""
        value = self.app_client.state.global_state.get_value("not_circulating_label_3")
        if isinstance(value, dict) and "address" in self._struct_classes:
            return _init_dataclass(self._struct_classes["address"], value)  # type: ignore
        return typing.cast(str, value)

class CirculatingSupplyClient:
    """Client for interacting with CirculatingSupply smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = CirculatingSupplyParams(self.app_client)
        self.create_transaction = CirculatingSupplyCreateTransactionParams(self.app_client)
        self.send = CirculatingSupplySend(self.app_client)
        self.state = CirculatingSupplyState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "CirculatingSupplyClient":
        return CirculatingSupplyClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CirculatingSupplyClient":
        return CirculatingSupplyClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "CirculatingSupplyClient":
        return CirculatingSupplyClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "CirculatingSupplyComposer":
        return CirculatingSupplyComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["set_asset(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["set_not_circulating_address(address,string)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["arc62_get_circulating_supply(uint64)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class CirculatingSupplyBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating CirculatingSupply contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class CirculatingSupplyFactory(algokit_utils.TypedAppFactoryProtocol[CirculatingSupplyBareCallCreateParams, None, None]):
    """Factory for deploying and managing CirculatingSupplyClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = CirculatingSupplyFactoryParams(self.app_factory)
        self.create_transaction = CirculatingSupplyFactoryCreateTransaction(self.app_factory)
        self.send = CirculatingSupplyFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: CirculatingSupplyBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[CirculatingSupplyClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return CirculatingSupplyClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CirculatingSupplyClient:
        """Get an app client by creator address and name"""
        return CirculatingSupplyClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> CirculatingSupplyClient:
        """Get an app client by app ID"""
        return CirculatingSupplyClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class CirculatingSupplyFactoryParams:
    """Parameters for creating transactions for CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CirculatingSupplyFactoryCreateParams(app_factory)
        self.update = CirculatingSupplyFactoryUpdateParams(app_factory)
        self.delete = CirculatingSupplyFactoryDeleteParams(app_factory)

class CirculatingSupplyFactoryCreateParams:
    """Parameters for 'create' operations of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def set_asset(
        self,
        args: tuple[int] | SetAssetArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the set_asset(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "set_asset(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def set_not_circulating_address(
        self,
        args: tuple[str, str] | SetNotCirculatingAddressArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the set_not_circulating_address(address,string)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "set_not_circulating_address(address,string)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the arc62_get_circulating_supply(uint64)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "arc62_get_circulating_supply(uint64)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class CirculatingSupplyFactoryUpdateParams:
    """Parameters for 'update' operations of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class CirculatingSupplyFactoryDeleteParams:
    """Parameters for 'delete' operations of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class CirculatingSupplyFactoryCreateTransaction:
    """Create transactions for CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CirculatingSupplyFactoryCreateTransactionCreate(app_factory)


class CirculatingSupplyFactoryCreateTransactionCreate:
    """Create new instances of CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class CirculatingSupplyFactorySend:
    """Send calls to CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = CirculatingSupplyFactorySendCreate(app_factory)


class CirculatingSupplyFactorySendCreate:
    """Send create calls to CirculatingSupply contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[CirculatingSupplyClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return CirculatingSupplyClient(result[0]), result[1]


class CirculatingSupplyComposer:
    """Composer for creating transaction groups for CirculatingSupply contract calls"""

    def __init__(self, client: "CirculatingSupplyClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def set_asset(
        self,
        args: tuple[int] | SetAssetArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.set_asset(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "set_asset(uint64)void", v
            )
        )
        return self

    def set_not_circulating_address(
        self,
        args: tuple[str, str] | SetNotCirculatingAddressArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.set_not_circulating_address(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "set_not_circulating_address(address,string)void", v
            )
        )
        return self

    def arc62_get_circulating_supply(
        self,
        args: tuple[int] | Arc62GetCirculatingSupplyArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_app_call_method_call(
            self.client.params.arc62_get_circulating_supply(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "arc62_get_circulating_supply(uint64)uint64", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "CirculatingSupplyComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "CirculatingSupplyComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)


# File: https://github.com/Keshabkjha/LotteryContract/blob/964bd66aa545308c496198cd32b56e5a2907fd61/smart_contracts/artifacts/lottery/lottery_client.py
# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": []}, "methods": [{"actions": {"call": [], "create": ["NoOp"]}, "args": [{"type": "uint64", "name": "entry_fee"}], "name": "create_application", "returns": {"type": "void"}, "desc": "Initialize the lottery contract with an entry fee.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "pay", "name": "payment_txn"}], "name": "enter_lottery", "returns": {"type": "void"}, "desc": "Allow users to enter the lottery by sending the entry fee.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "pick_winner", "returns": {"type": "void"}, "desc": "Allows the contract creator to randomly pick a winner.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["DeleteApplication"], "create": []}, "args": [], "name": "delete_application", "returns": {"type": "void"}, "desc": "Allows the creator to delete the application.", "events": [], "readonly": false, "recommendations": {}}], "name": "Lottery", "state": {"keys": {"box": {}, "global": {"entry_fee": {"key": "ZW50cnlfZmVl", "keyType": "AVMString", "valueType": "AVMUint64"}, "total_entries": {"key": "dG90YWxfZW50cmllcw==", "keyType": "AVMString", "valueType": "AVMUint64"}, "creator_address": {"key": "Y3JlYXRvcl9hZGRyZXNz", "keyType": "AVMString", "valueType": "AVMBytes"}}, "local": {}}, "maps": {"box": {}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 1, "ints": 2}, "local": {"bytes": 0, "ints": 0}}}, "structs": {}, "byteCode": {"approval": "CiADAAHoByYDD2NyZWF0b3JfYWRkcmVzcw10b3RhbF9lbnRyaWVzCWVudHJ5X2ZlZTEbQQAjggQEoDuB0gSH6knXBL4L3r8EM7NJnjYaAI4EADIAHAAQAAIiQzEZgQUSRDEYRIgAlyNDMRkURDEYRIgAVyNDMRkURDEYRDEWIwlJOBAjEkSIACIjQzEZFEQxGBRENhoBF4gAAiNDigEAKov/ZygyCWcpImeJigEAi/84BzIKEkSL/zgIIiplRBJEIillRCMIKUxniTEAIihlRBJEIillREQyBjIEIillRE8CTBhMGDgAsTIKcwBEgcCEPQmyCLIHI7IQJLIBs4kxACIoZUQSRLEiKGVEIihlRLIJIrIIsgcjshAksgGziQ==", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 4, "patch": 1}}, "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTAwMAogICAgYnl0ZWNibG9jayAiY3JlYXRvcl9hZGRyZXNzIiAidG90YWxfZW50cmllcyIgImVudHJ5X2ZlZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjEyLTEzCiAgICAvLyAjIFdlIHdhbnQgdGhlIG1ldGhvZHMgaW4gb3VyIGNvbnRyYWN0IHRvIGZvbGxvdyB0aGUgQVJDNCBzdGFuZGFyZAogICAgLy8gY2xhc3MgTG90dGVyeShBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYWZ0ZXJfaWZfZWxzZUAxMAogICAgcHVzaGJ5dGVzcyAweGEwM2I4MWQyIDB4ODdlYTQ5ZDcgMHhiZTBiZGViZiAweDMzYjM0OTllIC8vIG1ldGhvZCAiY3JlYXRlX2FwcGxpY2F0aW9uKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJlbnRlcl9sb3R0ZXJ5KHBheSl2b2lkIiwgbWV0aG9kICJwaWNrX3dpbm5lcigpdm9pZCIsIG1ldGhvZCAiZGVsZXRlX2FwcGxpY2F0aW9uKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9jcmVhdGVfYXBwbGljYXRpb25fcm91dGVAMyBtYWluX2VudGVyX2xvdHRlcnlfcm91dGVANCBtYWluX3BpY2tfd2lubmVyX3JvdXRlQDUgbWFpbl9kZWxldGVfYXBwbGljYXRpb25fcm91dGVANgoKbWFpbl9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MTItMTMKICAgIC8vICMgV2Ugd2FudCB0aGUgbWV0aG9kcyBpbiBvdXIgY29udHJhY3QgdG8gZm9sbG93IHRoZSBBUkM0IHN0YW5kYXJkCiAgICAvLyBjbGFzcyBMb3R0ZXJ5KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9hcHBsaWNhdGlvbl9yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6ODItODQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgKICAgIC8vICAgICBhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXQogICAgLy8gKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcGlja193aW5uZXJfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjUyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBwaWNrX3dpbm5lcgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9lbnRlcl9sb3R0ZXJ5X3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjEyLTEzCiAgICAvLyAjIFdlIHdhbnQgdGhlIG1ldGhvZHMgaW4gb3VyIGNvbnRyYWN0IHRvIGZvbGxvdyB0aGUgQVJDNCBzdGFuZGFyZAogICAgLy8gY2xhc3MgTG90dGVyeShBUkM0Q29udHJhY3QpOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGVudGVyX2xvdHRlcnkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2FwcGxpY2F0aW9uX3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weToyMy0yNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKAogICAgLy8gICAgIGFsbG93X2FjdGlvbnM9WyJOb09wIl0sCiAgICAvLyAgICAgY3JlYXRlPSJyZXF1aXJlIiwKICAgIC8vICkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weToxMi0xMwogICAgLy8gIyBXZSB3YW50IHRoZSBtZXRob2RzIGluIG91ciBjb250cmFjdCB0byBmb2xsb3cgdGhlIEFSQzQgc3RhbmRhcmQKICAgIC8vIGNsYXNzIExvdHRlcnkoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjIzLTI2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoCiAgICAvLyAgICAgYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwKICAgIC8vICAgICBjcmVhdGU9InJlcXVpcmUiLAogICAgLy8gKQogICAgY2FsbHN1YiBjcmVhdGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMubG90dGVyeS5jb250cmFjdC5Mb3R0ZXJ5LmNyZWF0ZV9hcHBsaWNhdGlvbihlbnRyeV9mZWU6IHVpbnQ2NCkgLT4gdm9pZDoKY3JlYXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MjMtMzAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgKICAgIC8vICAgICBhbGxvd19hY3Rpb25zPVsiTm9PcCJdLAogICAgLy8gICAgIGNyZWF0ZT0icmVxdWlyZSIsCiAgICAvLyApCiAgICAvLyBkZWYgY3JlYXRlX2FwcGxpY2F0aW9uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZW50cnlfZmVlOiBVSW50NjQsICAjIFRoZSBlbnRyeSBmZWUgcmVxdWlyZWQgdG8gcGFydGljaXBhdGUgaW4gdGhlIGxvdHRlcnkKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MzQtMzUKICAgIC8vICMgSW5pdGlhbGl6ZSB0aGUgZW50cnkgZmVlIGFuZCBjcmVhdG9yIGFkZHJlc3MgaW4gdGhlIGNvbnRyYWN0J3Mgc3RhdGUKICAgIC8vIHNlbGYuZW50cnlfZmVlID0gZW50cnlfZmVlCiAgICBieXRlY18yIC8vICJlbnRyeV9mZWUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozNgogICAgLy8gc2VsZi5jcmVhdG9yX2FkZHJlc3MgPSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzCiAgICBieXRlY18wIC8vICJjcmVhdG9yX2FkZHJlc3MiCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozNwogICAgLy8gc2VsZi50b3RhbF9lbnRyaWVzID0gVUludDY0KDApICAjIEluaXRpYWxpemUgdGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIHRvIDAKICAgIGJ5dGVjXzEgLy8gInRvdGFsX2VudHJpZXMiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5sb3R0ZXJ5LmNvbnRyYWN0LkxvdHRlcnkuZW50ZXJfbG90dGVyeShwYXltZW50X3R4bjogdWludDY0KSAtPiB2b2lkOgplbnRlcl9sb3R0ZXJ5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MzktNDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIGVudGVyX2xvdHRlcnkoc2VsZiwgcGF5bWVudF90eG46IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo0NC00NQogICAgLy8gIyBFbnN1cmUgdGhhdCB0aGUgcGF5bWVudCBpcyBzZW50IHRvIHRoZSBhcHBsaWNhdGlvbiBhZGRyZXNzCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4ucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjQ3LTQ4CiAgICAvLyAjICMgRW5zdXJlIHRoYXQgdGhlIHBheW1lbnQgYW1vdW50KG1pY3JvYWxnbykgaXMgZXF1YWwgdG8gdGhlIGVudHJ5IGZlZQogICAgLy8gYXNzZXJ0IHBheW1lbnRfdHhuLmFtb3VudCA9PSBzZWxmLmVudHJ5X2ZlZQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJlbnRyeV9mZWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZW50cnlfZmVlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NTAKICAgIC8vIHNlbGYudG90YWxfZW50cmllcyArPSBVSW50NjQoMSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJ0b3RhbF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2VudHJpZXMgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWNfMSAvLyAidG90YWxfZW50cmllcyIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubG90dGVyeS5jb250cmFjdC5Mb3R0ZXJ5LnBpY2tfd2lubmVyKCkgLT4gdm9pZDoKcGlja193aW5uZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo1Ny01OAogICAgLy8gIyAjIEVuc3VyZSB0aGF0IG9ubHkgdGhlIGNyZWF0b3IgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJjcmVhdG9yX2FkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY3JlYXRvcl9hZGRyZXNzIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NjAtNjEKICAgIC8vICMgRW5zdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwYXJ0aWNpcGFudAogICAgLy8gYXNzZXJ0IHNlbGYudG90YWxfZW50cmllcyA+IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInRvdGFsX2VudHJpZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudG90YWxfZW50cmllcyBleGlzdHMKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NjMtNjQKICAgIC8vICMgU2ltcGxlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB1c2luZyByb3VuZCBhbmQgaW5kZXgKICAgIC8vIHJvdW5kX251bWJlciA9IEdsb2JhbC5yb3VuZAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo2NQogICAgLy8gZ3JvdXBfc2l6ZSA9IEdsb2JhbC5ncm91cF9zaXplCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo2Ny02OAogICAgLy8gIyBDYWxjdWxhdGUgcHNldWRvLXJhbmRvbSBpbmRleCBiYXNlZCBvbiByb3VuZCBudW1iZXIgYW5kIGdyb3VwIHNpemUKICAgIC8vIHJhbmRvbV9udW1iZXIgPSByb3VuZF9udW1iZXIgJSBzZWxmLnRvdGFsX2VudHJpZXMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJ0b3RhbF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2VudHJpZXMgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjcwLTcxCiAgICAvLyAjIEdldCB0aGUgd2lubmVyJ3MgYWRkcmVzcyBmcm9tIHRoZSB0cmFuc2FjdGlvbiBhdCB0aGUgY2FsY3VsYXRlZCBpbmRleAogICAgLy8gd2lubmVyX2luZGV4ID0gcmFuZG9tX251bWJlciAlIGdyb3VwX3NpemUKICAgIHN3YXAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjcyCiAgICAvLyB3aW5uZXJfYWRkcmVzcyA9IGd0eG4uVHJhbnNhY3Rpb24od2lubmVyX2luZGV4KS5zZW5kZXIKICAgIGd0eG5zIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzQtODAKICAgIC8vICMgaXR4bi5mZWUoVUludDY0KDEwMDApKQogICAgLy8gIyBUcmFuc2ZlciBhbGwgQUxHT3MgY29sbGVjdGVkIHRvIHRoZSB3aW5uZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlIC0gVUludDY0KDEwMF8wMF8wMCksICMgMSBBbGdvID0gMTAwMDAwMCBtaWNyb2FsZ29zCiAgICAvLyAgICAgcmVjZWl2ZXI9d2lubmVyX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzcKICAgIC8vIGFtb3VudD1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBVSW50NjQoMTAwXzAwXzAwKSwgIyAxIEFsZ28gPSAxMDAwMDAwIG1pY3JvYWxnb3MKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgcHVzaGludCAxMDAwMDAwIC8vIDEwMDAwMDAKICAgIC0KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gIyBpdHhuLmZlZShVSW50NjQoMTAwMCkpCiAgICAvLyAjIFRyYW5zZmVyIGFsbCBBTEdPcyBjb2xsZWN0ZWQgdG8gdGhlIHdpbm5lcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzkKICAgIC8vIGZlZT1VSW50NjQoMTAwMCkKICAgIGludGNfMiAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzQtODAKICAgIC8vICMgaXR4bi5mZWUoVUludDY0KDEwMDApKQogICAgLy8gIyBUcmFuc2ZlciBhbGwgQUxHT3MgY29sbGVjdGVkIHRvIHRoZSB3aW5uZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlIC0gVUludDY0KDEwMF8wMF8wMCksICMgMSBBbGdvID0gMTAwMDAwMCBtaWNyb2FsZ29zCiAgICAvLyAgICAgcmVjZWl2ZXI9d2lubmVyX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5sb3R0ZXJ5LmNvbnRyYWN0LkxvdHRlcnkuZGVsZXRlX2FwcGxpY2F0aW9uKCkgLT4gdm9pZDoKZGVsZXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6ODktOTAKICAgIC8vICMgT25seSBhbGxvdyB0aGUgY3JlYXRvciB0byBkZWxldGUgdGhlIGFwcGxpY2F0aW9uCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBzZWxmLmNyZWF0b3JfYWRkcmVzcwogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImNyZWF0b3JfYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jcmVhdG9yX2FkZHJlc3MgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5Mi05OAogICAgLy8gIyBTZW5kIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0byB0aGUgY3JlYXRvcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gICAgIGNsb3NlX3JlbWFpbmRlcl90bz1zZWxmLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBmZWU9VUludDY0KDEwMDApCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5NAogICAgLy8gcmVjZWl2ZXI9c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiY3JlYXRvcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNyZWF0b3JfYWRkcmVzcyBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5Ojk2CiAgICAvLyBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiY3JlYXRvcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNyZWF0b3JfYWRkcmVzcyBleGlzdHMKICAgIGl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTUKICAgIC8vIGFtb3VudD0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5Mi05MwogICAgLy8gIyBTZW5kIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0byB0aGUgY3JlYXRvcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTcKICAgIC8vIGZlZT1VSW50NjQoMTAwMCkKICAgIGludGNfMiAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTItOTgKICAgIC8vICMgU2VuZCB0aGUgcmVtYWluaW5nIGJhbGFuY2UgdG8gdGhlIGNyZWF0b3IKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1Ygo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [96], "errorMessage": "OnCompletion is not DeleteApplication"}, {"pc": [108, 120, 142], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [236], "errorMessage": "account funded"}, {"pc": [146], "errorMessage": "can only call when creating"}, {"pc": [99, 111, 123], "errorMessage": "can only call when not creating"}, {"pc": [207, 259, 266, 270], "errorMessage": "check self.creator_address exists"}, {"pc": [189], "errorMessage": "check self.entry_fee exists"}, {"pc": [195, 213, 222], "errorMessage": "check self.total_entries exists"}, {"pc": [133], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class EnterLotteryArgs:
    """Dataclass for enter_lottery arguments"""
    payment_txn: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "enter_lottery(pay)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateApplicationArgs:
    """Dataclass for create_application arguments"""
    entry_fee: int

    @property
    def abi_method_signature(self) -> str:
        return "create_application(uint64)void"


class _LotteryDelete:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppDeleteMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_application()void",
        }))


class LotteryParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_LotteryDelete":
        return _LotteryDelete(self.app_client)

    def enter_lottery(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "enter_lottery(pay)void",
            "args": method_args,
        }))

    def pick_winner(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "pick_winner()void",
        }))

    def create_application(
        self,
        args: tuple[int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_application(uint64)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class _LotteryDeleteTransaction:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_application()void",
        }))


class LotteryCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_LotteryDeleteTransaction":
        return _LotteryDeleteTransaction(self.app_client)

    def enter_lottery(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "enter_lottery(pay)void",
            "args": method_args,
        }))

    def pick_winner(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "pick_winner()void",
        }))

    def create_application(
        self,
        args: tuple[int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_application(uint64)void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class _LotteryDeleteSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "delete_application()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)


class LotterySend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def delete(self) -> "_LotteryDeleteSend":
        return _LotteryDeleteSend(self.app_client)

    def enter_lottery(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "enter_lottery(pay)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def pick_winner(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "pick_winner()void",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def create_application(
        self,
        args: tuple[int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_application(uint64)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    entry_fee: int
    total_entries: int
    creator_address: bytes

class LotteryState:
    """Methods to access state for the current Lottery app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def entry_fee(self) -> int:
        """Get the current value of the entry_fee key in global_state state"""
        value = self.app_client.state.global_state.get_value("entry_fee")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def total_entries(self) -> int:
        """Get the current value of the total_entries key in global_state state"""
        value = self.app_client.state.global_state.get_value("total_entries")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def creator_address(self) -> bytes:
        """Get the current value of the creator_address key in global_state state"""
        value = self.app_client.state.global_state.get_value("creator_address")
        if isinstance(value, dict) and "AVMBytes" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMBytes"], value)  # type: ignore
        return typing.cast(bytes, value)

class LotteryClient:
    """Client for interacting with Lottery smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = LotteryParams(self.app_client)
        self.create_transaction = LotteryCreateTransactionParams(self.app_client)
        self.send = LotterySend(self.app_client)
        self.state = LotteryState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "LotteryClient":
        return LotteryClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "LotteryClient":
        return LotteryClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "LotteryClient":
        return LotteryClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "LotteryComposer":
        return LotteryComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["enter_lottery(pay)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["pick_winner()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_application(uint64)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["delete_application()void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class LotteryMethodCallCreateParams(
    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[
        CreateApplicationArgs,
        str | None,
    ]
):
    """Parameters for creating Lottery contract using ABI"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallCreateParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

@dataclasses.dataclass(frozen=True)
class LotteryMethodCallDeleteParams(
    algokit_utils.BaseAppClientMethodCallParams[
        typing.Any,
        str | None,
    ]
):
    """Parameters for calling Lottery contract using ABI"""
    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None
    method: str | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:
        method_args = _parse_abi_args(self.args)
        return algokit_utils.AppClientMethodCallParams(
            **{
                **self.__dict__,
                "method": self.method or getattr(self.args, "abi_method_signature", None),
                "args": method_args,
            }
        )

class LotteryFactory(algokit_utils.TypedAppFactoryProtocol[LotteryMethodCallCreateParams, None, LotteryMethodCallDeleteParams]):
    """Factory for deploying and managing LotteryClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = LotteryFactoryParams(self.app_factory)
        self.create_transaction = LotteryFactoryCreateTransaction(self.app_factory)
        self.send = LotteryFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: LotteryMethodCallCreateParams | None = None,
        update_params: None = None,
        delete_params: LotteryMethodCallDeleteParams | None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[LotteryClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return LotteryClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> LotteryClient:
        """Get an app client by creator address and name"""
        return LotteryClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> LotteryClient:
        """Get an app client by app ID"""
        return LotteryClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class LotteryFactoryParams:
    """Parameters for creating transactions for Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = LotteryFactoryCreateParams(app_factory)
        self.update = LotteryFactoryUpdateParams(app_factory)
        self.delete = LotteryFactoryDeleteParams(app_factory)

class LotteryFactoryCreateParams:
    """Parameters for 'create' operations of Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def enter_lottery(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the enter_lottery(pay)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "enter_lottery(pay)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def pick_winner(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the pick_winner()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "pick_winner()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def create_application(
        self,
        args: tuple[int] | CreateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_application(uint64)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_application(uint64)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def delete_application(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the delete_application()void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "delete_application()void",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

class LotteryFactoryUpdateParams:
    """Parameters for 'update' operations of Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class LotteryFactoryDeleteParams:
    """Parameters for 'delete' operations of Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class LotteryFactoryCreateTransaction:
    """Create transactions for Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = LotteryFactoryCreateTransactionCreate(app_factory)


class LotteryFactoryCreateTransactionCreate:
    """Create new instances of Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class LotteryFactorySend:
    """Send calls to Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = LotteryFactorySendCreate(app_factory)


class LotteryFactorySendCreate:
    """Send create calls to Lottery contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[LotteryClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return LotteryClient(result[0]), result[1]

    def create_application(
        self,
        args: tuple[int] | CreateApplicationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> tuple[LotteryClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:
            """Creates and sends a transaction using the create_application(uint64)void ABI method"""
            params = params or algokit_utils.CommonAppCallCreateParams()
            client, result = self.app_factory.send.create(
                algokit_utils.AppFactoryCreateMethodCallParams(
                    **{
                    **dataclasses.asdict(params),
                    "method": "create_application(uint64)void",
                    "args": _parse_abi_args(args),
                    }
                ),
                send_params=send_params,
                compilation_params=compilation_params
            )
            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)
    
            return LotteryClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](
                **{
                    **result.__dict__,
                    "app_id": result.app_id,
                    "abi_return": return_value,
                    "transaction": result.transaction,
                    "confirmation": result.confirmation,
                    "group_id": result.group_id,
                    "tx_ids": result.tx_ids,
                    "transactions": result.transactions,
                    "confirmations": result.confirmations,
                    "app_address": result.app_address,
                }
            )


class _LotteryDeleteComposer:
    def __init__(self, composer: "LotteryComposer"):
        self.composer = composer
    def delete_application(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "LotteryComposer":
        self.composer._composer.add_app_delete_method_call(
            self.composer.client.params.delete.delete_application(
                
                params=params,
                
            )
        )
        self.composer._result_mappers.append(
            lambda v: self.composer.client.decode_return_value(
                "delete_application()void", v
            )
        )
        return self.composer


class LotteryComposer:
    """Composer for creating transaction groups for Lottery contract calls"""

    def __init__(self, client: "LotteryClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    @property
    def delete(self) -> "_LotteryDeleteComposer":
        return _LotteryDeleteComposer(self)

    def enter_lottery(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "LotteryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.enter_lottery(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "enter_lottery(pay)void", v
            )
        )
        return self

    def pick_winner(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "LotteryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.pick_winner(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "pick_winner()void", v
            )
        )
        return self

    def create_application(
        self,
        args: tuple[int] | CreateApplicationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "LotteryComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_application(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_application(uint64)void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "LotteryComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "LotteryComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)


# File: https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/smart_asa_asc.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Smart ASA PyTEAL reference implementation based on ARC-20
"""

__author__ = "Cosimo Bassi, Stefano De Angelis"
__email__ = "<cosimo.bassi@algorand.com>, <stefano.deangelis@algorand.com>"

from pyteal import (
    And,
    App,
    Approve,
    Assert,
    AssetHolding,
    AssetParam,
    BareCallActions,
    Bytes,
    CallConfig,
    Concat,
    Expr,
    Extract,
    Global,
    Gtxn,
    If,
    InnerTxn,
    InnerTxnBuilder,
    Int,
    Len,
    Mode,
    Not,
    OnCompleteAction,
    OptimizeOptions,
    Or,
    Reject,
    Return,
    Router,
    Seq,
    Subroutine,
    Suffix,
    TealType,
    Txn,
    TxnField,
    TxnType,
    abi,
    compileTeal,
)
from algosdk.future.transaction import StateSchema
from algosdk.constants import key_len_bytes


# / --- CONSTANTS
TEAL_VERSION = 7

# Descriptive field for the binding of Smart ASA App ID into the Underlying ASA url.
SMART_ASA_APP_BINDING = "smart-asa-app-id:"

# NOTE: The following costs could change over time with protocol upgrades.
OPTIN_COST = 100_000
UINTS_COST = 28_500
BYTES_COST = 50_000


def static_attrs(cls):
    return [k for k in cls.__dict__ if not k.startswith("__")]


# / --- SMART ASA ASC
# / --- --- ERRORS
class Error:
    address_length = "Invalid Address length (must be 32 bytes)"
    missing_smart_asa_id = "Smart ASA ID does not exist"
    invalid_smart_asa_id = "Invalid Smart ASA ID"
    not_creator_addr = "Caller not authorized (must be: App Creator Address)"
    not_manager_addr = "Caller not authorized (must be: Manager Address)"
    not_reserve_addr = "Caller not authorized (must be: Reserve Address)"
    not_freeze_addr = "Caller not authorized (must be: Freeze Address)"
    not_clawback_addr = "Caller not authorized (must be: Clawback Address)"
    asset_frozen = "Smart ASA is frozen"
    sender_frozen = "Sender is frozen"
    receiver_frozen = "Receiver is frozen"


# / --- --- GLOBAL STATE
class GlobalInts:
    total = Bytes("total")
    decimals = Bytes("decimals")
    default_frozen = Bytes("default_frozen")
    smart_asa_id = Bytes("smart_asa_id")
    frozen = Bytes("frozen")


class GlobalBytes:
    unit_name = Bytes("unit_name")
    name = Bytes("name")
    url = Bytes("url")
    metadata_hash = Bytes("metadata_hash")
    manager_addr = Bytes("manager_addr")
    reserve_addr = Bytes("reserve_addr")
    freeze_addr = Bytes("freeze_addr")
    clawback_addr = Bytes("clawback_addr")


class GlobalState(GlobalInts, GlobalBytes):
    @staticmethod
    def num_uints():
        return len(static_attrs(GlobalInts))

    @staticmethod
    def num_bytes():
        return len(static_attrs(GlobalBytes))

    @classmethod
    def schema(cls):
        return StateSchema(
            num_uints=cls.num_uints(),
            num_byte_slices=cls.num_bytes(),
        )


class SmartASAConfig(abi.NamedTuple):
    total: abi.Field[abi.Uint64]
    decimals: abi.Field[abi.Uint32]
    default_frozen: abi.Field[abi.Bool]
    unit_name: abi.Field[abi.String]
    name: abi.Field[abi.String]
    url: abi.Field[abi.String]
    metadata_hash: abi.Field[abi.DynamicArray[abi.Byte]]
    manager_addr: abi.Field[abi.Address]
    reserve_addr: abi.Field[abi.Address]
    freeze_addr: abi.Field[abi.Address]
    clawback_addr: abi.Field[abi.Address]


# / --- --- LOCAL STATE
# NOTE: Local State is needed only if the Smart ASA has `account_frozen`.
# Local State is not needed in case Smart ASA has just "global" `asset_freeze`.
class LocalInts:
    smart_asa_id = Bytes("smart_asa_id")
    frozen = Bytes("frozen")


class LocalBytes:
    ...


class LocalState(LocalInts, LocalBytes):
    @staticmethod
    def num_uints():
        return len(static_attrs(LocalInts))

    @staticmethod
    def num_bytes():
        return len(static_attrs(LocalBytes))

    @classmethod
    def schema(cls):
        return StateSchema(
            num_uints=cls.num_uints(),
            num_byte_slices=cls.num_bytes(),
        )


# / --- --- SUBROUTINES
@Subroutine(TealType.none)
def init_global_state() -> Expr:
    return Seq(
        App.globalPut(GlobalState.smart_asa_id, Int(0)),
        App.globalPut(GlobalState.total, Int(0)),
        App.globalPut(GlobalState.decimals, Int(0)),
        App.globalPut(GlobalState.default_frozen, Int(0)),
        # NOTE: ASA behaves excluding `unit_name` field if not declared:
        App.globalPut(GlobalState.unit_name, Bytes("")),
        # NOTE: ASA behaves excluding `name` field if not declared:
        App.globalPut(GlobalState.name, Bytes("")),
        # NOTE: ASA behaves excluding `url` field if not declared:
        App.globalPut(GlobalState.url, Bytes("")),
        # NOTE: ASA behaves excluding `metadata_hash` field if not declared:
        App.globalPut(GlobalState.metadata_hash, Bytes("")),
        App.globalPut(GlobalState.manager_addr, Global.zero_address()),
        App.globalPut(GlobalState.reserve_addr, Global.zero_address()),
        App.globalPut(GlobalState.freeze_addr, Global.zero_address()),
        App.globalPut(GlobalState.clawback_addr, Global.zero_address()),
        # Special Smart ASA fields
        App.globalPut(GlobalState.frozen, Int(0)),
    )


@Subroutine(TealType.none)
def init_local_state() -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    return Seq(
        App.localPut(Txn.sender(), LocalState.smart_asa_id, smart_asa_id),
        App.localPut(Txn.sender(), LocalState.frozen, Int(0)),
    )


@Subroutine(TealType.bytes)
def digit_to_ascii(i: Expr) -> Expr:
    """digit_to_ascii converts an integer < 10 to the ASCII byte that represents it"""
    return Extract(Bytes("0123456789"), i, Int(1))


@Subroutine(TealType.bytes)
def itoa(i: Expr) -> Expr:
    """itoa converts an integer to the ASCII byte string it represents."""
    return If(
        i == Int(0),
        Bytes("0"),
        Concat(
            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes("")),
            digit_to_ascii(i % Int(10)),
        ),
    )


@Subroutine(TealType.bytes)
def strip_len_prefix(abi_encoded: Expr) -> Expr:
    return Suffix(abi_encoded, Int(abi.Uint16TypeSpec().byte_length_static()))


# / --- --- UNDERLYING ASA CONFIG
UNDERLYING_ASA_TOTAL = Int(2**64 - 1)
UNDERLYING_ASA_DECIMALS = Int(0)
UNDERLYING_ASA_DEFAULT_FROZEN = Int(1)
UNDERLYING_ASA_UNIT_NAME = Bytes("S-ASA")
UNDERLYING_ASA_NAME = Bytes("SMART-ASA")
UNDERLYING_ASA_URL = Concat(
    Bytes(SMART_ASA_APP_BINDING), itoa(Global.current_application_id())
)
UNDERLYING_ASA_METADATA_HASH = Bytes("")
UNDERLYING_ASA_MANAGER_ADDR = Global.current_application_address()
UNDERLYING_ASA_RESERVE_ADDR = Global.current_application_address()
UNDERLYING_ASA_FREEZE_ADDR = Global.current_application_address()
UNDERLYING_ASA_CLAWBACK_ADDR = Global.current_application_address()


@Subroutine(TealType.uint64)
def underlying_asa_create_inner_tx() -> Expr:
    return Seq(
        InnerTxnBuilder.Execute(
            {
                TxnField.fee: Int(0),
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_total: UNDERLYING_ASA_TOTAL,
                TxnField.config_asset_decimals: UNDERLYING_ASA_DECIMALS,
                TxnField.config_asset_default_frozen: UNDERLYING_ASA_DEFAULT_FROZEN,
                TxnField.config_asset_unit_name: UNDERLYING_ASA_UNIT_NAME,
                TxnField.config_asset_name: UNDERLYING_ASA_NAME,
                TxnField.config_asset_url: UNDERLYING_ASA_URL,
                TxnField.config_asset_manager: UNDERLYING_ASA_MANAGER_ADDR,
                TxnField.config_asset_reserve: UNDERLYING_ASA_RESERVE_ADDR,
                TxnField.config_asset_freeze: UNDERLYING_ASA_FREEZE_ADDR,
                TxnField.config_asset_clawback: UNDERLYING_ASA_CLAWBACK_ADDR,
            }
        ),
        Return(InnerTxn.created_asset_id()),
    )


@Subroutine(TealType.none)
def smart_asa_transfer_inner_txn(
    smart_asa_id: Expr,
    asset_amount: Expr,
    asset_sender: Expr,
    asset_receiver: Expr,
) -> Expr:
    return InnerTxnBuilder.Execute(
        {
            TxnField.fee: Int(0),
            TxnField.type_enum: TxnType.AssetTransfer,
            TxnField.xfer_asset: smart_asa_id,
            TxnField.asset_amount: asset_amount,
            TxnField.asset_sender: asset_sender,
            TxnField.asset_receiver: asset_receiver,
        }
    )


@Subroutine(TealType.none)
def smart_asa_destroy_inner_txn(smart_asa_id: Expr) -> Expr:
    return InnerTxnBuilder.Execute(
        {
            TxnField.fee: Int(0),
            TxnField.type_enum: TxnType.AssetConfig,
            TxnField.config_asset: smart_asa_id,
        }
    )


@Subroutine(TealType.none)
def is_valid_address_bytes_length(address: Expr) -> Expr:
    # WARNING: Note this check only ensures proper bytes' length on `address`,
    # but doesn't ensure that those 32 bytes are a _proper_ Algorand address.
    return Assert(Len(address) == Int(key_len_bytes), comment=Error.address_length)


@Subroutine(TealType.uint64)
def circulating_supply(asset_id: Expr):
    smart_asa_reserve = AssetHolding.balance(
        Global.current_application_address(), asset_id
    )
    return Seq(smart_asa_reserve, UNDERLYING_ASA_TOTAL - smart_asa_reserve.value())


@Subroutine(TealType.none)
def getter_preconditions(asset_id: Expr) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == asset_id
    return Seq(
        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),
        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),
    )


# / --- --- ABI
# / --- --- BARE CALLS
@Subroutine(TealType.none)
def asset_app_create() -> Expr:
    return Seq(
        # Preconditions
        # Not mandatory - Smart ASA Application self validate its state.
        Assert(
            Txn.global_num_uints() == Int(GlobalState.num_uints()),
            comment=f"Wrong State Schema - Expexted Global Ints: "
            f"{GlobalState.num_uints()}",
        ),
        Assert(
            Txn.global_num_byte_slices() == Int(GlobalState.num_bytes()),
            comment=f"Wrong State Schema - Expexted Global Bytes: "
            f"{GlobalState.num_bytes()}",
        ),
        Assert(
            Txn.local_num_uints() == Int(LocalState.num_uints()),
            comment=f"Wrong State Schema - Expexted Local Ints: "
            f"{LocalState.num_uints()}",
        ),
        Assert(
            Txn.local_num_byte_slices() == Int(LocalState.num_bytes()),
            comment=f"Wrong State Schema - Expexted Local Bytes: "
            f"{LocalState.num_bytes()}",
        ),
        init_global_state(),
        Approve(),
    )


smart_asa_abi = Router(
    "Smart ASA ref. implementation",
    BareCallActions(
        no_op=OnCompleteAction.create_only(asset_app_create()),
        # Rules governing a Smart ASA are only in place as long as the
        # controlling Smart Contract is not updatable.
        update_application=OnCompleteAction.always(Reject()),
        # Rules governing a Smart ASA are only in place as long as the
        # controlling Smart Contract is not deletable.
        delete_application=OnCompleteAction.always(Reject()),
        clear_state=OnCompleteAction.call_only(Reject()),
    ),
)


# / --- --- METHODS
@smart_asa_abi.method(opt_in=CallConfig.ALL)
def asset_app_optin(
    asset: abi.Asset,
    underlying_asa_optin: abi.AssetTransferTransaction,
) -> Expr:
    """
    Smart ASA atomic opt-in to Smart ASA App and Underlying ASA.

    Args:
        asset: Underlying ASA ID (ref. App Global State: "smart_asa_id").
        underlying_asa_optin: Underlying ASA opt-in transaction.
    """
    # On OptIn the frozen status must be set to `True` if account owns any
    # units of the underlying ASA. This prevents malicious users to circumvent
    # the `default_frozen` status by clearing their Local State. Note that this
    # could be avoided by the use of Boxes once available.
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == asset.asset_id()
    default_frozen = App.globalGet(GlobalState.default_frozen)
    freeze_account = App.localPut(Txn.sender(), LocalState.frozen, Int(1))
    account_balance = AssetHolding().balance(Txn.sender(), asset.asset_id())
    optin_to_underlying_asa = account_balance.hasValue()
    return Seq(
        # Preconditions
        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),
        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),
        Assert(
            underlying_asa_optin.get().type_enum() == TxnType.AssetTransfer,
            comment="Underlying ASA Opt-In Txn: Wrong Txn Type (Expected: Axfer)",
        ),
        Assert(
            underlying_asa_optin.get().xfer_asset() == smart_asa_id,
            comment="Underlying ASA Opt-In Txn: Wrong Asset ID (Expected: Smart ASA ID)",
        ),
        Assert(
            underlying_asa_optin.get().sender() == Txn.sender(),
            comment="Underlying ASA Opt-In Txn: Wrong Sender (Expected: App Caller)",
        ),
        Assert(
            underlying_asa_optin.get().asset_receiver() == Txn.sender(),
            comment="Underlying ASA Opt-In Txn: Wrong Asset Receiver (Expected: App Caller)",
        ),
        Assert(
            underlying_asa_optin.get().asset_amount() == Int(0),
            comment="Underlying ASA Opt-In Txn: Wrong Asset Amount (Expected: 0)",
        ),
        Assert(
            underlying_asa_optin.get().asset_close_to() == Global.zero_address(),
            comment="Underlying ASA Opt-In Txn: Wrong Asset CloseTo (Expected: Zero Address)",
        ),
        account_balance,
        Assert(optin_to_underlying_asa, comment="Missing Opt-In to Underlying ASA"),
        # Effects
        init_local_state(),
        If(Or(default_frozen, account_balance.value() > Int(0))).Then(freeze_account),
        Approve(),
    )


@smart_asa_abi.method
def asset_create(
    total: abi.Uint64,
    decimals: abi.Uint32,
    default_frozen: abi.Bool,
    unit_name: abi.String,
    name: abi.String,
    url: abi.String,
    metadata_hash: abi.DynamicArray[abi.Byte],
    manager_addr: abi.Address,
    reserve_addr: abi.Address,
    freeze_addr: abi.Address,
    clawback_addr: abi.Address,
    *,
    output: abi.Uint64,
) -> Expr:
    """
    Create a Smart ASA (triggers inner creation of an Underlying ASA).

    Args:
        total: The total number of base units of the Smart ASA to create.
        decimals: The number of digits to use after the decimal point when displaying the Smart ASA. If 0, the Smart ASA is not divisible.
        default_frozen: Smart ASA default frozen status (True to freeze holdings by default).
        unit_name: The name of a unit of Smart ASA.
        name: The name of the Smart ASA.
        url: Smart ASA external URL.
        metadata_hash: Smart ASA metadata hash (suggested 32 bytes hash).
        manager_addr: The address of the account that can manage the configuration of the Smart ASA and destroy it.
        reserve_addr: The address of the account that holds the reserve (non-minted) units of the asset and can mint or burn units of Smart ASA.
        freeze_addr: The address of the account that can freeze/unfreeze holdings of this Smart ASA globally or locally (specific accounts). If empty, freezing is not permitted.
        clawback_addr: The address of the account that can clawback holdings of this asset. If empty, clawback is not permitted.

    Returns:
        New Smart ASA ID.
    """

    is_creator = Txn.sender() == Global.creator_address()
    smart_asa_not_created = Not(App.globalGet(GlobalState.smart_asa_id))
    smart_asa_id = underlying_asa_create_inner_tx()

    return Seq(
        # Preconditions
        Assert(is_creator, comment=Error.not_creator_addr),
        Assert(smart_asa_not_created, comment="Smart ASA ID already exists"),
        is_valid_address_bytes_length(manager_addr.get()),
        is_valid_address_bytes_length(reserve_addr.get()),
        is_valid_address_bytes_length(freeze_addr.get()),
        is_valid_address_bytes_length(clawback_addr.get()),
        # Effects
        # Underlying ASA creation
        App.globalPut(GlobalState.smart_asa_id, smart_asa_id),
        # Smart ASA properties
        App.globalPut(GlobalState.total, total.get()),
        App.globalPut(GlobalState.decimals, decimals.get()),
        App.globalPut(GlobalState.default_frozen, default_frozen.get()),
        App.globalPut(GlobalState.unit_name, unit_name.get()),
        App.globalPut(GlobalState.name, name.get()),
        App.globalPut(GlobalState.url, url.get()),
        App.globalPut(
            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())
        ),
        App.globalPut(GlobalState.manager_addr, manager_addr.get()),
        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),
        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),
        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),
        output.set(App.globalGet(GlobalState.smart_asa_id)),
    )


@smart_asa_abi.method
def asset_config(
    config_asset: abi.Asset,
    total: abi.Uint64,
    decimals: abi.Uint32,
    default_frozen: abi.Bool,
    unit_name: abi.String,
    name: abi.String,
    url: abi.String,
    metadata_hash: abi.DynamicArray[abi.Byte],
    manager_addr: abi.Address,
    reserve_addr: abi.Address,
    freeze_addr: abi.Address,
    clawback_addr: abi.Address,
) -> Expr:
    """
    Configure the Smart ASA. Use existing values for unchanged parameters. Setting Smart ASA roles to zero-address is irreversible.

    Args:
        config_asset: Underlying ASA ID to configure (ref. App Global State: "smart_asa_id").
        total: The total number of base units of the Smart ASA to create. It can not be configured to less than its current circulating supply.
        decimals: The number of digits to use after the decimal point when displaying the Smart ASA. If 0, the Smart ASA is not divisible.
        default_frozen: Smart ASA default frozen status (True to freeze holdings by default).
        unit_name: The name of a unit of Smart ASA.
        name: The name of the Smart ASA.
        url: Smart ASA external URL.
        metadata_hash: Smart ASA metadata hash (suggested 32 bytes hash).
        manager_addr: The address of the account that can manage the configuration of the Smart ASA and destroy it.
        reserve_addr: The address of the account that holds the reserve (non-minted) units of the asset and can mint or burn units of Smart ASA.
        freeze_addr: The address of the account that can freeze/unfreeze holdings of this Smart ASA globally or locally (specific accounts). If empty, freezing is not permitted.
        clawback_addr: The address of the account that can clawback holdings of this asset. If empty, clawback is not permitted.
    """

    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    current_manager_addr = App.globalGet(GlobalState.manager_addr)
    current_reserve_addr = App.globalGet(GlobalState.reserve_addr)
    current_freeze_addr = App.globalGet(GlobalState.freeze_addr)
    current_clawback_addr = App.globalGet(GlobalState.clawback_addr)

    is_manager_addr = Txn.sender() == current_manager_addr
    is_correct_smart_asa_id = smart_asa_id == config_asset.asset_id()

    update_reserve_addr = current_reserve_addr != reserve_addr.get()
    update_freeze_addr = current_freeze_addr != freeze_addr.get()
    update_clawback_addr = current_clawback_addr != clawback_addr.get()

    # NOTE: In ref. implementation Smart ASA total can not be configured to
    # less than its current circulating supply.
    is_valid_total = total.get() >= circulating_supply(smart_asa_id)

    return Seq(
        # Preconditions
        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),
        # NOTE: useless in ref. impl since 1 ASA : 1 App
        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),
        is_valid_address_bytes_length(manager_addr.get()),
        is_valid_address_bytes_length(reserve_addr.get()),
        is_valid_address_bytes_length(freeze_addr.get()),
        is_valid_address_bytes_length(clawback_addr.get()),
        Assert(is_manager_addr, comment=Error.not_manager_addr),
        If(update_reserve_addr).Then(
            Assert(
                current_reserve_addr != Global.zero_address(),
                comment="Reserve Address has been deleted",
            )
        ),
        If(update_freeze_addr).Then(
            Assert(
                current_freeze_addr != Global.zero_address(),
                comment="Freeze Address has been deleted",
            )
        ),
        If(update_clawback_addr).Then(
            Assert(
                current_clawback_addr != Global.zero_address(),
                comment="Clawback Address has been deleted",
            )
        ),
        Assert(is_valid_total, comment="Invalid Total (must be >= Circulating Supply)"),
        # Effects
        App.globalPut(GlobalState.total, total.get()),
        App.globalPut(GlobalState.decimals, decimals.get()),
        App.globalPut(GlobalState.default_frozen, default_frozen.get()),
        App.globalPut(GlobalState.unit_name, unit_name.get()),
        App.globalPut(GlobalState.name, name.get()),
        App.globalPut(GlobalState.url, url.get()),
        App.globalPut(
            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())
        ),
        App.globalPut(GlobalState.manager_addr, manager_addr.get()),
        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),
        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),
        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),
    )


@smart_asa_abi.method
def asset_transfer(
    xfer_asset: abi.Asset,
    asset_amount: abi.Uint64,
    asset_sender: abi.Account,
    asset_receiver: abi.Account,
) -> Expr:
    """
    Smart ASA transfers: regular, clawback (Clawback Address), mint or burn (Reserve Address).

    Args:
        xfer_asset: Underlying ASA ID to transfer (ref. App Global State: "smart_asa_id").
        asset_amount: Smart ASA amount to transfer.
        asset_sender: Smart ASA sender, for regular transfer this must be equal to the Smart ASA App caller.
        asset_receiver: The recipient of the Smart ASA transfer.
    """
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    clawback_addr = App.globalGet(GlobalState.clawback_addr)
    is_not_clawback = And(
        Txn.sender() == asset_sender.address(),
        Txn.sender() != clawback_addr,
    )

    # NOTE: Ref. implementation grants _minting_ premission to `reserve_addr`,
    # has restriction no restriction on who is the minting _receiver_.
    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off minting.
    is_minting = And(
        Txn.sender() == App.globalGet(GlobalState.reserve_addr),
        asset_sender.address() == Global.current_application_address(),
    )

    # NOTE: Ref. implementation grants _burning_ premission to `reserve_addr`,
    # has restriction both on burning _sender_ and _receiver_ to prevent
    # _clawback_ throug burning.
    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off burning.
    is_burning = And(
        Txn.sender() == App.globalGet(GlobalState.reserve_addr),
        asset_sender.address() == App.globalGet(GlobalState.reserve_addr),
        asset_receiver.address() == Global.current_application_address(),
    )

    is_clawback = Txn.sender() == clawback_addr
    is_correct_smart_asa_id = smart_asa_id == xfer_asset.asset_id()

    # NOTE: Ref. implementation checks that `smart_asa_id` is correct in Local
    # State since the App could generate a new Smart ASA (if the previous one
    # has been dystroied) requiring users to opt-in again to gain a coherent
    # new `frozen` status.
    is_current_smart_asa_id = And(
        smart_asa_id == App.localGet(asset_sender.address(), LocalState.smart_asa_id),
        smart_asa_id == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),
    )
    asset_frozen = App.globalGet(GlobalState.frozen)
    asset_sender_frozen = App.localGet(asset_sender.address(), LocalState.frozen)
    asset_receiver_frozen = App.localGet(asset_receiver.address(), LocalState.frozen)
    return Seq(
        # Preconditions
        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),
        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),
        is_valid_address_bytes_length(asset_sender.address()),
        is_valid_address_bytes_length(asset_receiver.address()),
        If(is_not_clawback)
        .Then(
            # Asset Regular Transfer Preconditions
            Assert(Not(asset_frozen), comment=Error.asset_frozen),
            Assert(Not(asset_sender_frozen), comment=Error.sender_frozen),
            Assert(Not(asset_receiver_frozen), comment=Error.receiver_frozen),
            Assert(is_current_smart_asa_id, comment=Error.invalid_smart_asa_id),
        )
        .ElseIf(is_minting)
        .Then(
            # Asset Minting Preconditions
            Assert(Not(asset_frozen), comment=Error.asset_frozen),
            Assert(Not(asset_receiver_frozen), comment=Error.receiver_frozen),
            Assert(
                smart_asa_id
                == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),
                comment=Error.invalid_smart_asa_id,
            ),
            # NOTE: Ref. implementation prevents minting more than `total`.
            Assert(
                circulating_supply(smart_asa_id) + asset_amount.get()
                <= App.globalGet(GlobalState.total),
                comment="Over-minting (can not mint more than Total)",
            ),
        )
        .ElseIf(is_burning)
        .Then(
            # Asset Burning Preconditions
            Assert(Not(asset_frozen), comment=Error.asset_frozen),
            Assert(Not(asset_sender_frozen), comment=Error.sender_frozen),
            Assert(
                smart_asa_id
                == App.localGet(asset_sender.address(), LocalState.smart_asa_id),
                comment=Error.invalid_smart_asa_id,
            ),
        )
        .Else(
            # Asset Clawback Preconditions
            Assert(is_clawback, comment=Error.not_clawback_addr),
            # NOTE: `is_current_smart_asa_id` implicitly checks that both
            # `asset_sender` and `asset_receiver` opted-in the Smart ASA
            # App. This ensures that _mint_ and _burn_ can not be
            # executed as _clawback_, since the Smart ASA App can not
            # opt-in to itself.
            Assert(is_current_smart_asa_id, comment=Error.invalid_smart_asa_id),
        ),
        # Effects
        smart_asa_transfer_inner_txn(
            xfer_asset.asset_id(),
            asset_amount.get(),
            asset_sender.address(),
            asset_receiver.address(),
        ),
    )


@smart_asa_abi.method
def asset_freeze(freeze_asset: abi.Asset, asset_frozen: abi.Bool) -> Expr:
    """
    Smart ASA global freeze (all accounts), called by the Freeze Address.

    Args:
        freeze_asset: Underlying ASA ID to freeze/unfreeze (ref. App Global State: "smart_asa_id").
        asset_frozen: Smart ASA ID forzen status.
    """
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()
    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)
    return Seq(
        # Asset Freeze Preconditions
        Assert(
            smart_asa_id,
            comment=Error.missing_smart_asa_id,
        ),
        Assert(
            is_correct_smart_asa_id,
            comment=Error.invalid_smart_asa_id,
        ),
        Assert(
            is_freeze_addr,
            comment=Error.not_freeze_addr,
        ),
        # Effects
        App.globalPut(GlobalState.frozen, asset_frozen.get()),
    )


@smart_asa_abi.method
def account_freeze(
    freeze_asset: abi.Asset,
    freeze_account: abi.Account,
    asset_frozen: abi.Bool,
) -> Expr:
    """
    Smart ASA local freeze (account specific), called by the Freeze Address.

    Args:
        freeze_asset: Underlying ASA ID to freeze/unfreeze (ref. App Global State: "smart_asa_id").
        freeze_account: Account to freeze/unfreeze.
        asset_frozen: Smart ASA ID forzen status.
    """
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()
    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)
    return Seq(
        # Account Freeze Preconditions
        is_valid_address_bytes_length(freeze_account.address()),
        Assert(
            smart_asa_id,
            comment=Error.missing_smart_asa_id,
        ),
        Assert(
            is_correct_smart_asa_id,
            comment=Error.invalid_smart_asa_id,
        ),
        Assert(
            is_freeze_addr,
            comment=Error.not_freeze_addr,
        ),
        # Effects
        App.localPut(freeze_account.address(), LocalState.frozen, asset_frozen.get()),
    )


@smart_asa_abi.method(close_out=CallConfig.ALL)
def asset_app_closeout(
    close_asset: abi.Asset,
    close_to: abi.Account,
) -> Expr:
    """
    Smart ASA atomic close-out of Smart ASA App and Underlying ASA.

    Args:
        close_asset: Underlying ASA ID to close-out (ref. App Global State: "smart_asa_id").
        close_to: Account to send all Smart ASA reminder to. If the asset/account is forzen then this must be set to Smart ASA Creator.
    """
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == close_asset.asset_id()
    current_smart_asa_id = App.localGet(Txn.sender(), LocalState.smart_asa_id)
    is_current_smart_asa_id = current_smart_asa_id == close_asset.asset_id()
    account_balance = AssetHolding().balance(Txn.sender(), close_asset.asset_id())
    asset_creator = AssetParam().creator(close_asset.asset_id())
    asset_frozen = App.globalGet(GlobalState.frozen)
    asset_closer_frozen = App.localGet(Txn.sender(), LocalState.frozen)
    asa_closeout_relative_idx = Txn.group_index() + Int(1)
    return Seq(
        # Preconditions
        # NOTE: Smart ASA existence is not checked by default on close-out
        # since would be impossible to close-out destroyed assets.
        is_valid_address_bytes_length(close_to.address()),
        Assert(
            is_current_smart_asa_id,
            comment=Error.invalid_smart_asa_id,
        ),
        Assert(
            Global.group_size() > asa_closeout_relative_idx,
            comment="Smart ASA CloseOut: Wrong group size (Expected: 2)",
        ),
        Assert(
            Gtxn[asa_closeout_relative_idx].type_enum() == TxnType.AssetTransfer,
            comment="Underlying ASA CloseOut Txn: Wrong Txn type (Expected: Axfer)",
        ),
        Assert(
            Gtxn[asa_closeout_relative_idx].xfer_asset() == close_asset.asset_id(),
            comment="Underlying ASA CloseOut Txn: Wrong ASA ID (Expected: Smart ASA ID)",
        ),
        Assert(
            Gtxn[asa_closeout_relative_idx].sender() == Txn.sender(),
            comment="Underlying ASA CloseOut Txn: Wrong sender (Expected: Smart ASA CloseOut caller)",
        ),
        Assert(
            Gtxn[asa_closeout_relative_idx].asset_amount() == Int(0),
            comment="Underlying ASA CloseOut Txn: Wrong amount (Expected: 0)",
        ),
        Assert(
            Gtxn[asa_closeout_relative_idx].asset_close_to()
            == Global.current_application_address(),
            comment="Underlying ASA CloseOut Txn: Wrong CloseTo address (Expected: Smart ASA App Account)",
        ),
        # Effects
        asset_creator,
        # NOTE: Skip checks if Underlying ASA has been destroyed to avoid
        # users' lock-in.
        If(asset_creator.hasValue()).Then(
            # NOTE: Smart ASA has not been destroyed.
            Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),
            If(Or(asset_frozen, asset_closer_frozen)).Then(
                # NOTE: If Smart ASA is frozen, users can only close-out to
                # Creator
                Assert(
                    close_to.address() == Global.current_application_address(),
                    comment="Wrong CloseTo address: Frozen Smart ASA must be closed-out to creator",
                ),
            ),
            If(close_to.address() != Global.current_application_address()).Then(
                # NOTE: If the target of close-out is not Creator, it MUST be
                # opted-in to the current Smart ASA.
                Assert(
                    smart_asa_id
                    == App.localGet(close_to.address(), LocalState.smart_asa_id),
                    comment=Error.invalid_smart_asa_id,
                )
            ),
            account_balance,
            smart_asa_transfer_inner_txn(
                close_asset.asset_id(),
                account_balance.value(),
                Txn.sender(),
                close_to.address(),
            ),
        ),
        # NOTE: If Smart ASA has been destroyed:
        #   1. The close-to address could be anyone
        #   2. No InnerTxn happens
        Approve(),
    )


@smart_asa_abi.method
def asset_destroy(destroy_asset: abi.Asset) -> Expr:
    """
    Destroy the Underlying ASA, must be called by Manager Address.

    Args:
        destroy_asset: Underlying ASA ID to destroy (ref. App Global State: "smart_asa_id").
    """
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == destroy_asset.asset_id()
    is_manager_addr = Txn.sender() == App.globalGet(GlobalState.manager_addr)
    return Seq(
        # Asset Destroy Preconditions
        Assert(
            smart_asa_id,
            comment=Error.missing_smart_asa_id,
        ),
        Assert(
            is_correct_smart_asa_id,
            comment=Error.invalid_smart_asa_id,
        ),
        Assert(
            is_manager_addr,
            comment=Error.not_manager_addr,
        ),
        # Effects
        smart_asa_destroy_inner_txn(destroy_asset.asset_id()),
        init_global_state(),
    )


# / --- --- GETTERS
@smart_asa_abi.method
def get_asset_is_frozen(freeze_asset: abi.Asset, *, output: abi.Bool) -> Expr:
    """
    Get Smart ASA global frozen status.

    Args:
        freeze_asset: Underlying ASA ID (ref. App Global State: "smart_asa_id").

    Returns:
        Smart ASA global frozen status.
    """
    return Seq(
        # Preconditions
        getter_preconditions(freeze_asset.asset_id()),
        # Effects
        output.set(App.globalGet(GlobalState.frozen)),
    )


@smart_asa_abi.method
def get_account_is_frozen(
    freeze_asset: abi.Asset, freeze_account: abi.Account, *, output: abi.Bool
) -> Expr:
    """
    Get Smart ASA local frozen status (account specific).

    Args:
        freeze_asset: Underlying ASA ID (ref. App Global State: "smart_asa_id").
        freeze_account: Account to check.

    Returns:
        Smart ASA local frozen status (account specific).
    """
    return Seq(
        # Preconditions
        getter_preconditions(freeze_asset.asset_id()),
        is_valid_address_bytes_length(freeze_account.address()),
        # Effects
        output.set(App.localGet(freeze_account.address(), LocalState.frozen)),
    )


@smart_asa_abi.method
def get_circulating_supply(asset: abi.Asset, *, output: abi.Uint64) -> Expr:
    """
    Get Smart ASA circulating supply.

    Args:
        asset: Underlying ASA ID (ref. App Global State: "smart_asa_id").

    Returns:
        Smart ASA circulating supply.
    """
    return Seq(
        # Preconditions
        getter_preconditions(asset.asset_id()),
        # Effects
        output.set(circulating_supply(asset.asset_id())),
    )


@smart_asa_abi.method
def get_optin_min_balance(asset: abi.Asset, *, output: abi.Uint64) -> Expr:
    """
    Get Smart ASA required minimum balance (including Underlying ASA and App Local State).

    Args:
        asset: Underlying ASA ID (ref. App Global State: "smart_asa_id").

    Returns:
        Smart ASA required minimum balance in microALGO.
    """
    min_balance = Int(
        OPTIN_COST
        + UINTS_COST * LocalState.num_uints()
        + BYTES_COST * LocalState.num_bytes()
    )

    return Seq(
        # Preconditions
        getter_preconditions(asset.asset_id()),
        # Effects
        output.set(min_balance),
    )


@smart_asa_abi.method
def get_asset_config(asset: abi.Asset, *, output: SmartASAConfig) -> Expr:
    """
    Get Smart ASA configuration.

    Args:
        asset: Underlying ASA ID (ref. App Global State: "smart_asa_id").

    Returns:
        Smart ASA configuration parameters.
    """
    return Seq(
        # Preconditions
        getter_preconditions(asset.asset_id()),
        # Effects
        (total := abi.Uint64()).set(App.globalGet(GlobalState.total)),
        (decimals := abi.Uint32()).set(App.globalGet(GlobalState.decimals)),
        (default_frozen := abi.Bool()).set(App.globalGet(GlobalState.default_frozen)),
        (unit_name := abi.String()).set(App.globalGet(GlobalState.unit_name)),
        (name := abi.String()).set(App.globalGet(GlobalState.name)),
        (url := abi.String()).set(App.globalGet(GlobalState.url)),
        (metadata_hash_str := abi.String()).set(
            App.globalGet(GlobalState.metadata_hash)
        ),
        (metadata_hash := abi.make(abi.DynamicArray[abi.Byte])).decode(
            metadata_hash_str.encode()
        ),
        (manager_addr := abi.Address()).set(App.globalGet(GlobalState.manager_addr)),
        (reserve_addr := abi.Address()).set(App.globalGet(GlobalState.reserve_addr)),
        (freeze_addr := abi.Address()).set(App.globalGet(GlobalState.freeze_addr)),
        (clawback_addr := abi.Address()).set(App.globalGet(GlobalState.clawback_addr)),
        output.set(
            total,
            decimals,
            default_frozen,
            unit_name,
            name,
            url,
            metadata_hash,
            manager_addr,
            reserve_addr,
            freeze_addr,
            clawback_addr,
        ),
    )


def compile_stateful(program: Expr) -> str:
    return compileTeal(
        program,
        Mode.Application,
        version=TEAL_VERSION,
        assembleConstants=True,
        optimize=OptimizeOptions(scratch_slots=True),
    )


if __name__ == "__main__":
    # Allow quickly testing compilation.
    from smart_asa_test import test_compile

    test_compile(*smart_asa_abi.build_program())


# File: https://github.com/McEazy2700/vericert-backend/blob/52c53f1ee2ae599117a50436675833bfbf614441/veecert_backend/apps/common/smart_contract_client.py
# flake8: noqa
# fmt: off
# mypy: disable-error-code="no-any-return, no-untyped-call, misc, type-arg"
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^1.2.0
import base64
import dataclasses
import decimal
import typing
from abc import ABC, abstractmethod

import algokit_utils
import algosdk
from algosdk.v2client import models
from algosdk.atomic_transaction_composer import (
    AtomicTransactionComposer,
    AtomicTransactionResponse,
    SimulateAtomicTransactionResponse,
    TransactionSigner,
    TransactionWithSigner
)

_APP_SPEC_JSON = r"""{
    "hints": {
        "hello(string)string": {
            "call_config": {
                "no_op": "CALL"
            }
        },
        "create_certificate_nft((string,string,uint64,string,string))uint64": {
            "structs": {
                "args": {
                    "name": "NewCertificateNftArgs",
                    "elements": [
                        [
                            "name",
                            "string"
                        ],
                        [
                            "image_url",
                            "string"
                        ],
                        [
                            "certificate_id",
                            "uint64"
                        ],
                        [
                            "metadata_hash",
                            "string"
                        ],
                        [
                            "unit_name",
                            "string"
                        ]
                    ]
                }
            },
            "call_config": {
                "no_op": "CALL"
            }
        },
        "update()bool": {
            "call_config": {
                "update_application": "CALL"
            }
        },
        "delete()bool": {
            "call_config": {
                "delete_application": "CALL"
            }
        }
    },
    "source": {
        "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmFwcHJvdmFsX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYmFyZV9yb3V0aW5nQDgKICAgIG1ldGhvZCAiaGVsbG8oc3RyaW5nKXN0cmluZyIKICAgIG1ldGhvZCAiY3JlYXRlX2NlcnRpZmljYXRlX25mdCgoc3RyaW5nLHN0cmluZyx1aW50NjQsc3RyaW5nLHN0cmluZykpdWludDY0IgogICAgbWV0aG9kICJ1cGRhdGUoKWJvb2wiCiAgICBtZXRob2QgImRlbGV0ZSgpYm9vbCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5faGVsbG9fcm91dGVAMiBtYWluX2NyZWF0ZV9jZXJ0aWZpY2F0ZV9uZnRfcm91dGVAMyBtYWluX3VwZGF0ZV9yb3V0ZUA0IG1haW5fZGVsZXRlX3JvdXRlQDUKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5faGVsbG9fcm91dGVAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6MTgKICAgIC8vIGNsYXNzIENlcnQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBoZWxsbwogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfY2VydGlmaWNhdGVfbmZ0X3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE4CiAgICAvLyBjbGFzcyBDZXJ0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2NlcnRpZmljYXRlX25mdAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjQ0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIlVwZGF0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBpbnQgVXBkYXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIFVwZGF0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB1cGRhdGUKICAgIGJ5dGUgMHgwMAogICAgaW50IDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGRlbGV0ZQogICAgYnl0ZSAweDAwCiAgICBpbnQgMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0LmNvbnRyYWN0LkNlcnQuaGVsbG8obmFtZTogYnl0ZXMpIC0+IGJ5dGVzOgpoZWxsbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5LTIwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGhlbGxvKHNlbGYsIG5hbWU6IGFyYzQuU3RyaW5nKSAtPiBhcmM0LlN0cmluZzoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6MjEKICAgIC8vIHJldHVybiAiSGVsbG8sICIgKyBuYW1lCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBieXRlICJIZWxsbywgIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnQuY29udHJhY3QuQ2VydC5jcmVhdGVfY2VydGlmaWNhdGVfbmZ0KGFyZ3M6IGJ5dGVzKSAtPiBieXRlczoKY3JlYXRlX2NlcnRpZmljYXRlX25mdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjIzLTI3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9jZXJ0aWZpY2F0ZV9uZnQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBhcmdzOiBOZXdDZXJ0aWZpY2F0ZU5mdEFyZ3MsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyOQogICAgLy8gYXNzZXRfbmFtZT1hcmdzLm5hbWUubmF0aXZlLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDEKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnQgMgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjMxCiAgICAvLyB1bml0X25hbWU9YXJncy51bml0X25hbWUubmF0aXZlLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMTQKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMgogICAgLy8gdXJsPWFyZ3MuaW1hZ2VfdXJsLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMwogICAgLy8gbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM0LTM2CiAgICAvLyBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBkdXBuIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM3CiAgICAvLyBtZXRhZGF0YV9oYXNoPWFyZ3MubWV0YWRhdGFfaGFzaC5uYXRpdmUuYnl0ZXMsCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAxMgogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDEKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnQgMgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyB0eG4uc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNZXRhZGF0YUhhc2gKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0Q2xhd2JhY2sKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRGcmVlemUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VVJMCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyOAogICAgLy8gdHhuID0gaXR4bi5Bc3NldENvbmZpZygKICAgIGludCBhY2ZnCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMAogICAgLy8gZmVlPTEwMDAsCiAgICBpbnQgMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyB0eG4uc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0MAogICAgLy8gYXNzZXQgPSBvcC5JVHhuLmNyZWF0ZWRfYXNzZXRfaWQoKQogICAgaXR4biBDcmVhdGVkQXNzZXRJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDIKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChhc3NldC5pZCkKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0LmNvbnRyYWN0LkNlcnQudXBkYXRlKCkgLT4gdWludDY0Ogp1cGRhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0NC00NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJVcGRhdGVBcHBsaWNhdGlvbiJdKQogICAgLy8gZGVmIHVwZGF0ZShzZWxmKSAtPiBib29sOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0NgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludCAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmRlbGV0ZSgpIC0+IHVpbnQ2NDoKZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDgtNDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiBkZWxldGUoc2VsZikgLT4gYm9vbDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NTAKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCg==",
        "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgaW50IDEKICAgIHJldHVybgo="
    },
    "state": {
        "global": {
            "num_byte_slices": 0,
            "num_uints": 0
        },
        "local": {
            "num_byte_slices": 0,
            "num_uints": 0
        }
    },
    "schema": {
        "global": {
            "declared": {},
            "reserved": {}
        },
        "local": {
            "declared": {},
            "reserved": {}
        }
    },
    "contract": {
        "name": "Cert",
        "methods": [
            {
                "name": "hello",
                "args": [
                    {
                        "type": "string",
                        "name": "name"
                    }
                ],
                "returns": {
                    "type": "string"
                }
            },
            {
                "name": "create_certificate_nft",
                "args": [
                    {
                        "type": "(string,string,uint64,string,string)",
                        "name": "args"
                    }
                ],
                "returns": {
                    "type": "uint64"
                }
            },
            {
                "name": "update",
                "args": [],
                "returns": {
                    "type": "bool"
                }
            },
            {
                "name": "delete",
                "args": [],
                "returns": {
                    "type": "bool"
                }
            }
        ],
        "networks": {}
    },
    "bare_call_config": {
        "no_op": "CREATE"
    }
}"""
APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)
_TReturn = typing.TypeVar("_TReturn")


class _ArgsBase(ABC, typing.Generic[_TReturn]):
    @staticmethod
    @abstractmethod
    def method() -> str:
        ...


_TArgs = typing.TypeVar("_TArgs", bound=_ArgsBase[typing.Any])


@dataclasses.dataclass(kw_only=True)
class _TArgsHolder(typing.Generic[_TArgs]):
    args: _TArgs


@dataclasses.dataclass(kw_only=True)
class Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):
    pass


def _filter_none(value: dict | typing.Any) -> dict | typing.Any:
    if isinstance(value, dict):
        return {k: _filter_none(v) for k, v in value.items() if v is not None}
    return value


def _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:
    if data is None:
        return {}
    if not dataclasses.is_dataclass(data):
        raise TypeError(f"{data} must be a dataclass")
    if convert_all:
        result = dataclasses.asdict(data)
    else:
        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}
    return _filter_none(result)


def _convert_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.TransactionParametersDict:
    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))


def _convert_call_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
) -> algokit_utils.OnCompleteCallParametersDict:
    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))


def _convert_create_transaction_parameters(
    transaction_parameters: algokit_utils.TransactionParameters | None,
    on_complete: algokit_utils.OnCompleteActionName,
) -> algokit_utils.CreateCallParametersDict:
    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))
    on_complete_enum = on_complete.replace("_", " ").title().replace(" ", "") + "OC"
    result["on_complete"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)
    return result


def _convert_deploy_args(
    deploy_args: algokit_utils.DeployCallArgs | None,
) -> algokit_utils.ABICreateCallArgsDict | None:
    if deploy_args is None:
        return None

    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))
    if isinstance(deploy_args, _TArgsHolder):
        deploy_args_dict["args"] = _as_dict(deploy_args.args)
        deploy_args_dict["method"] = deploy_args.args.method()

    return deploy_args_dict


@dataclasses.dataclass(kw_only=True)
class HelloArgs(_ArgsBase[str]):
    name: str

    @staticmethod
    def method() -> str:
        return "hello(string)string"


@dataclasses.dataclass(kw_only=True)
class NewCertificateNftArgs:
    name: str
    image_url: str
    certificate_id: int
    metadata_hash: str
    unit_name: str


@dataclasses.dataclass(kw_only=True)
class CreateCertificateNftArgs(_ArgsBase[int]):
    args: NewCertificateNftArgs

    @staticmethod
    def method() -> str:
        return "create_certificate_nft((string,string,uint64,string,string))uint64"


@dataclasses.dataclass(kw_only=True)
class UpdateArgs(_ArgsBase[bool]):
    @staticmethod
    def method() -> str:
        return "update()bool"


@dataclasses.dataclass(kw_only=True)
class DeleteArgs(_ArgsBase[bool]):
    @staticmethod
    def method() -> str:
        return "delete()bool"


@dataclasses.dataclass(kw_only=True)
class SimulateOptions:
    allow_more_logs: bool = dataclasses.field(default=False)
    allow_empty_signatures: bool = dataclasses.field(default=False)
    extra_opcode_budget: int = dataclasses.field(default=0)
    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)


class Composer:

    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
        self.app_client = app_client
        self.atc = atc

    def build(self) -> AtomicTransactionComposer:
        return self.atc

    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:
        request = models.SimulateRequest(
            allow_more_logs=options.allow_more_logs,
            allow_empty_signatures=options.allow_empty_signatures,
            extra_opcode_budget=options.extra_opcode_budget,
            exec_trace_config=options.exec_trace_config,
            txn_groups=[]
        ) if options else None
        result = self.atc.simulate(self.app_client.algod_client, request)
        return result

    def execute(self) -> AtomicTransactionResponse:
        return self.app_client.execute_atc(self.atc)

    def hello(
        self,
        *,
        name: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `hello(string)string` ABI method
        
        :param str name: The `name` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = HelloArgs(
            name=name,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_certificate_nft(
        self,
        *,
        args: NewCertificateNftArgs,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `create_certificate_nft((string,string,uint64,string,string))uint64` ABI method
        
        :param NewCertificateNftArgs args: The `args` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = CreateCertificateNftArgs(
            args=args,
        )
        self.app_client.compose_call(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def create_bare(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to create an application using the no_op bare method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        self.app_client.compose_create(
            self.atc,
            call_abi_method=False,
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
        )
        return self

    def update_update(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `update()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = UpdateArgs()
        self.app_client.compose_update(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def delete_delete(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> "Composer":
        """Adds a call to `delete()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns Composer: This Composer instance"""

        args = DeleteArgs()
        self.app_client.compose_delete(
            self.atc,
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return self

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> "Composer":
        """Adds a call to the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass"""
    
        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
        return self


class CertClient:
    """A class for interacting with the Cert app providing high productivity and
    strongly typed methods to deploy and call the app"""

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    @typing.overload
    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        ...

    def __init__(
        self,
        algod_client: algosdk.v2client.algod.AlgodClient,
        *,
        creator: str | algokit_utils.Account | None = None,
        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,
        existing_deployments: algokit_utils.AppLookup | None = None,
        app_id: int = 0,
        signer: TransactionSigner | algokit_utils.Account | None = None,
        sender: str | None = None,
        suggested_params: algosdk.transaction.SuggestedParams | None = None,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        app_name: str | None = None,
    ) -> None:
        """
        CertClient can be created with an app_id to interact with an existing application, alternatively
        it can be created with a creator and indexer_client specified to find existing applications by name and creator.
        
        :param AlgodClient algod_client: AlgoSDK algod client
        :param int app_id: The app_id of an existing application, to instead find the application by creator and name
        use the creator and indexer_client parameters
        :param str | Account creator: The address or Account of the app creator to resolve the app_id
        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by
        creator and app name
        :param AppLookup existing_deployments:
        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and
        creator was passed as an Account will use that.
        :param str sender: Address to use as the sender for all transactions, will use the address associated with the
        signer if not specified.
        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should
        *NOT* include the TMPL_ prefix
        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the
        Application Specification
            """

        self.app_spec = APP_SPEC
        
        # calling full __init__ signature, so ignoring mypy warning about overloads
        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]
            algod_client=algod_client,
            app_spec=self.app_spec,
            app_id=app_id,
            creator=creator,
            indexer_client=indexer_client,
            existing_deployments=existing_deployments,
            signer=signer,
            sender=sender,
            suggested_params=suggested_params,
            template_values=template_values,
            app_name=app_name,
        )

    @property
    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
        return self.app_client.algod_client

    @property
    def app_id(self) -> int:
        return self.app_client.app_id

    @app_id.setter
    def app_id(self, value: int) -> None:
        self.app_client.app_id = value

    @property
    def app_address(self) -> str:
        return self.app_client.app_address

    @property
    def sender(self) -> str | None:
        return self.app_client.sender

    @sender.setter
    def sender(self, value: str) -> None:
        self.app_client.sender = value

    @property
    def signer(self) -> TransactionSigner | None:
        return self.app_client.signer

    @signer.setter
    def signer(self, value: TransactionSigner) -> None:
        self.app_client.signer = value

    @property
    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:
        return self.app_client.suggested_params

    @suggested_params.setter
    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:
        self.app_client.suggested_params = value

    def hello(
        self,
        *,
        name: str,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[str]:
        """Calls `hello(string)string` ABI method
        
        :param str name: The `name` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[str]: The result of the transaction"""

        args = HelloArgs(
            name=name,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_certificate_nft(
        self,
        *,
        args: NewCertificateNftArgs,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[int]:
        """Calls `create_certificate_nft((string,string,uint64,string,string))uint64` ABI method
        
        :param NewCertificateNftArgs args: The `args` ABI parameter
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction"""

        args = CreateCertificateNftArgs(
            args=args,
        )
        result = self.app_client.call(
            call_abi_method=args.method(),
            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def create_bare(
        self,
        *,
        on_complete: typing.Literal["no_op"] = "no_op",
        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Creates an application using the no_op bare method
        
        :param typing.Literal[no_op] on_complete: On completion type to use
        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.TransactionResponse: The result of the transaction"""

        result = self.app_client.create(
            call_abi_method=False,
            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),
        )
        return result

    def update_update(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """Calls `update()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction"""

        args = UpdateArgs()
        result = self.app_client.update(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def delete_delete(
        self,
        *,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
    ) -> algokit_utils.ABITransactionResponse[bool]:
        """Calls `delete()bool` ABI method
        
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction"""

        args = DeleteArgs()
        result = self.app_client.delete(
            call_abi_method=args.method(),
            transaction_parameters=_convert_transaction_parameters(transaction_parameters),
            **_as_dict(args, convert_all=True),
        )
        return result

    def clear_state(
        self,
        transaction_parameters: algokit_utils.TransactionParameters | None = None,
        app_args: list[bytes] | None = None,
    ) -> algokit_utils.TransactionResponse:
        """Calls the application with on completion set to ClearState
    
        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
        :param list[bytes] | None app_args: (optional) Application args to pass
        :returns algokit_utils.TransactionResponse: The result of the transaction"""
    
        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)

    def deploy(
        self,
        version: str | None = None,
        *,
        signer: TransactionSigner | None = None,
        sender: str | None = None,
        allow_update: bool | None = None,
        allow_delete: bool | None = None,
        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,
        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,
        template_values: algokit_utils.TemplateValueMapping | None = None,
        create_args: algokit_utils.DeployCallArgs | None = None,
        update_args: Deploy[UpdateArgs],
        delete_args: Deploy[DeleteArgs],
    ) -> algokit_utils.DeployResponse:
        """Deploy an application and update client to reference it.
        
        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator
        account, including deploy-time template placeholder substitutions.
        To understand the architecture decisions behind this functionality please see
        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>
        
        ```{note}
        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to
        'ReplaceApp' the existing app will be deleted and re-created.
        ```
        
        ```{note}
        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')
        the existing app will be deleted and re-created.
        ```
        
        :param str version: version to use when creating or updating app, if None version will be auto incremented
        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app
        , if None uses self.signer
        :param str sender: sender address to use when deploying app, if None uses self.sender
        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app
        can be deleted
        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app
        can be updated
        :param OnUpdate on_update: Determines what action to take if an application update is required
        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements
        has increased beyond the current allocation
        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys
        should *NOT* include the TMPL_ prefix
        :param algokit_utils.DeployCallArgs | None create_args: Arguments used when creating an application
        :param Deploy[UpdateArgs] update_args: Arguments used when updating an application
        :param Deploy[DeleteArgs] delete_args: Arguments used when deleting an application
        :return DeployResponse: details action taken and relevant transactions
        :raises DeploymentError: If the deployment failed"""

        return self.app_client.deploy(
            version,
            signer=signer,
            sender=sender,
            allow_update=allow_update,
            allow_delete=allow_delete,
            on_update=on_update,
            on_schema_break=on_schema_break,
            template_values=template_values,
            create_args=_convert_deploy_args(create_args),
            update_args=_convert_deploy_args(update_args),
            delete_args=_convert_deploy_args(delete_args),
        )

    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
        return Composer(self.app_client, atc or AtomicTransactionComposer())


# File: https://github.com/lexycole/pay-rent-ng/blob/d572a34a39087e5fd775f8eb3bf88b024379dcd3/projects/pay-rent-ng-contracts/smart_contracts/__main__.py
# __main__.py
import logging
import sys
from pathlib import Path
import uvicorn
from dotenv import load_dotenv


from smart_contracts._helpers.api import app
from smart_contracts._helpers.build import build
from smart_contracts._helpers.config import contracts
from smart_contracts._helpers.deploy import deploy

# Uncomment the following lines to enable auto generation of AVM Debugger compliant sourcemap and simulation trace file.
# Learn more about using AlgoKit AVM Debugger to debug your TEAL source codes and inspect various kinds of
# Algorand transactions in atomic groups -> https://github.com/algorandfoundation/algokit-avm-vscode-debugger
from algokit_utils.config import config
config.configure(debug=True, trace_all=True)
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s %(levelname)-10s: %(message)s"
)
logger = logging.getLogger(__name__)
logger.info("Loading .env")
# For manual script execution (bypassing `algokit project deploy`) with a custom .env,
# modify `load_dotenv()` accordingly. For example, `load_dotenv('.env.localnet')`.
load_dotenv()
root_path = Path(__file__).parent


def main(action: str, contract_name: str | None = None) -> None:
    artifact_path = root_path / "artifacts"

    # Filter contracts if a specific contract name is provided
    filtered_contracts = [
        c for c in contracts if contract_name is None or c.name == contract_name
    ]

    match action:
        case "serve":
            logger.info("Starting FastAPI server...")
            
            uvicorn.run("smart_contracts._helpers.api:app", host="127.0.0.1", port=8000,  reload=True)
        case "build":
            for contract in filtered_contracts:
                logger.info(f"Building app at {contract.path}")
                build(artifact_path / contract.name, contract.path)
        case "deploy":
            for contract in filtered_contracts:
                output_dir = artifact_path / contract.name
                app_spec_file_name = next(
                    (
                        file.name
                        for file in output_dir.iterdir()
                        if file.is_file() and file.suffixes == [".arc32", ".json"]
                    ),
                    None,
                )
                if app_spec_file_name is None:
                    raise Exception("Could not deploy app, .arc32.json file not found")
                app_spec_path = output_dir / app_spec_file_name
                if contract.deploy:
                    logger.info(f"Deploying app {contract.name}")
                    deploy(app_spec_path, contract.deploy)
        

        case "all":
            for contract in filtered_contracts:
                logger.info(f"Building app at {contract.path}")
                app_spec_path = build(artifact_path / contract.name, contract.path)
                if contract.deploy:
                    logger.info(f"Deploying {contract.path.name}")
                    deploy(app_spec_path, contract.deploy)


if __name__ == "__main__":
    if len(sys.argv) > 2:
        main(sys.argv[1], sys.argv[2])
    elif len(sys.argv) > 1:
        main(sys.argv[1])
    else:
        main("all")


# File: https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/is_updatable.py
"""Detector for finding execution paths missing UpdateApplication."""

from typing import List, TYPE_CHECKING, Tuple

from tealer.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DetectorType,
)
from tealer.detectors.utils import (
    detect_missing_tx_field_validations_group,
    detect_missing_tx_field_validations_group_complete,
)
from tealer.utils.teal_enums import TealerTransactionType
from tealer.utils.output import ExecutionPaths

if TYPE_CHECKING:
    from tealer.teal.basic_blocks import BasicBlock
    from tealer.utils.output import ListOutput
    from tealer.teal.context.block_transaction_context import BlockTransactionContext
    from tealer.teal.teal import Teal


class IsUpdatable(AbstractDetector):  # pylint: disable=too-few-public-methods
    """Detector to find execution paths missing UpdateApplication check.

    Stateful smart contracts(application) can be updated with the new code
    in algorand. If the application transaction of type UpdateApplication is
    approved by the contract then the application's approval, clear programs
    will be replaced by the ones sent along with the transaction. Contracts
    can check the application transaction type using OnCompletion field.

    This detector tries to find execution paths that approve the application
    transactions("return 1") and doesn't check the OnCompletion field against
    UpdateApplication value. Execution paths that only execute if the application
    transaction is not UpdateApplication are excluded.
    """

    NAME = "is-updatable"
    DESCRIPTION = "Upgradable Applications"
    TYPE = DetectorType.STATEFULL

    IMPACT = DetectorClassification.HIGH
    CONFIDENCE = DetectorClassification.HIGH

    WIKI_URL = "https://github.com/crytic/tealer/wiki/Detector-Documentation#upgradable-application"
    WIKI_TITLE = "Upgradable Application"
    WIKI_DESCRIPTION = (
        "Application can be updated by sending an `UpdateApplication` type application call."
    )
    WIKI_EXPLOIT_SCENARIO = """
```py
@router.method(update_application=CallConfig.CALL)
def update_application() -> Expr:
    return Assert(Txn.sender() == Global.creator_address())
```

Creator updates the application and steals all of its assets.
"""

    WIKI_RECOMMENDATION = """
Do not approve `UpdateApplication` type application calls.
"""

    def detect(self) -> "ListOutput":
        """Detect execution paths with missing UpdateApplication check.

        Returns:
            ExecutionPaths instance containing the list of vulnerable execution
            paths along with name, check, impact, confidence and other detector
            information.
        """

        def checks_field(block_ctx: "BlockTransactionContext") -> bool:
            # return False if Txn Type can be UpdateApplication.
            # return True if Txn Type cannot be UpdateApplication.
            return not TealerTransactionType.ApplUpdateApplication in block_ctx.transaction_types

        # there should be a better to decide which function to call ??
        if self.tealer.output_group:
            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:
            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance
            return list(
                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)
            )

        # paths_without_check: List[List[BasicBlock]] = detect_missing_tx_field_validations(
        #     self.teal, checks_field
        # )

        # return ExecutionPaths(self.teal, self, paths_without_check)
        output: List[
            Tuple["Teal", List[List["BasicBlock"]]]
        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)
        detector_output: "ListOutput" = []
        for contract, vulnerable_paths in output:
            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))

        return detector_output


# File: https://github.com/cusma/pe-de-manga/blob/4b2fde7681ff06232d071a60c7fb9ee83b356d57/pe_de_manga_smart_contract.py
"""
Algorand Smart Contract Pe de Manga: rega, diga ox e receba sua manga NFT! 
"""

from algosdk.future.transaction import StateSchema
from pyteal import (
    And,
    App,
    Approve,
    Assert,
    Bytes,
    Cond,
    Expr,
    Global,
    If,
    InnerTxn,
    InnerTxnBuilder,
    Int,
    Mode,
    OnComplete,
    Reject,
    Seq,
    Txn,
    TxnField,
    TxnType,
    compileTeal,
)

TEAL_VERSION = 5

# SMART CONTRACT STATE SCHEMA
GLOBAL_NA_MANGUEIRA = Bytes("naMangueira")

GLOBAL_STATE = StateSchema(num_uints=1, num_byte_slices=0)
LOCAL_STATE = StateSchema(num_uints=0, num_byte_slices=0)

# SMART CONTRACT METHODS
METHOD_REGA = "rega"
METHOD_COLHE = "ox"


def pe_de_manga_approval() -> Expr:
    return Cond(
        [Txn.application_id() == Int(0), on_app_create()],
        [Txn.on_completion() == OnComplete.NoOp, on_app_call()],
    )


def pe_de_manga_clear() -> Expr:
    return Reject()


def on_app_create() -> Expr:
    precondition = And(
        Txn.global_num_uints() == Int(GLOBAL_STATE.num_uints),
        Txn.global_num_byte_slices() == Int(GLOBAL_STATE.num_byte_slices),
        Txn.local_num_uints() == Int(LOCAL_STATE.num_uints),
        Txn.local_num_byte_slices() == Int(LOCAL_STATE.num_byte_slices),
    )

    return Seq(
        Assert(precondition),
        App.globalPut(GLOBAL_NA_MANGUEIRA, Int(0)),
        Approve()
    )


def on_app_call() -> Expr:
    method_selector = Txn.application_args[0]

    return Seq(
        Assert(Txn.application_args.length() == Int(1)),
        Cond(
            [method_selector == Bytes(METHOD_REGA), rega_pe_de_manga()],
            [method_selector == Bytes(METHOD_COLHE), colhe_manga()],
        ),
        Approve(),
    )


def rega_pe_de_manga() -> Expr:
    mangueira_account = Global.current_application_address()

    nao_tem_manga = App.globalGet(GLOBAL_NA_MANGUEIRA) == Int(0)

    nasce_manga = Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_name: Bytes("MANGA"),
                TxnField.config_asset_unit_name: Bytes(""),
                TxnField.config_asset_url: Bytes(
                    "ipfs://bafkreibojeqclpzpz73gotdzqtondllgkncdzarmpad3i5alcvhodv7ujy#arc3"
                ),
                TxnField.config_asset_metadata_hash: Bytes(
                    "LkkgJb8vz/ZnTHmE3NGtZlNEPIIseAe0dAsVTuHX9E4="
                ),
                TxnField.config_asset_decimals: Int(0),
                TxnField.config_asset_total: Int(1),
                TxnField.config_asset_manager: mangueira_account,
                TxnField.config_asset_clawback: Global.zero_address(),
                TxnField.config_asset_freeze: Global.zero_address(),
                TxnField.fee: Int(0),
            }
        ),
        InnerTxnBuilder.Submit(),  # cria uma manga como non-fungible token
        App.globalPut(GLOBAL_NA_MANGUEIRA, InnerTxn.created_asset_id()),
        # guarda o Asset ID da ultima manga criada na mangueira
        Approve(),
    )

    return Seq(
        If(nao_tem_manga).Then(
            nasce_manga
        ).Else(
            Reject()
        )
    )


def colhe_manga() -> Expr:
    manga = App.globalGet(GLOBAL_NA_MANGUEIRA)

    colher_da_mangueira = Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: manga,
                TxnField.asset_amount: Int(1),
                TxnField.asset_receiver: Txn.sender(),  # quem chamou a dApp
                TxnField.fee: Int(0),
            }
        ),
        InnerTxnBuilder.Submit(),  # envie o token MANGA pra quem disse ox
        App.globalPut(GLOBAL_NA_MANGUEIRA, Int(0)),
        # cancelar o Asset ID da manga que foi tirada da mangueira
        Approve(),
    )

    return colher_da_mangueira


def compile_stateful(program) -> str:
    return compileTeal(
        program, Mode.Application, assembleConstants=True, version=TEAL_VERSION
    )


if __name__ == "__main__":
    print(compile_stateful(pe_de_manga_approval()))


# File: https://github.com/seetadev/RoadOps/blob/347105e2c5df3247c9bd9ef0a669444b7c13b281/dev/algorand/arc-0020/smart_asa_asc.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Smart ASA PyTEAL reference implementation based on ARC-20
"""

__author__ = "Cosimo Bassi, Stefano De Angelis"
__email__ = "<cosimo.bassi@algorand.com>, <stefano.deangelis@algorand.com>"

from pyteal import (
    And,
    App,
    Approve,
    Assert,
    AssetHolding,
    AssetParam,
    BareCallActions,
    Bytes,
    CallConfig,
    Concat,
    Expr,
    Extract,
    Global,
    Gtxn,
    If,
    InnerTxn,
    InnerTxnBuilder,
    Int,
    Len,
    Mode,
    Not,
    OnCompleteAction,
    OptimizeOptions,
    Or,
    Reject,
    Return,
    Router,
    Seq,
    Subroutine,
    Suffix,
    TealType,
    Txn,
    TxnField,
    TxnType,
    abi,
    compileTeal,
)
from algosdk.future.transaction import StateSchema
from algosdk.constants import key_len_bytes


# / --- CONSTANTS
TEAL_VERSION = 6

# Descriptive field for the binding of Smart ASA App ID into the Underlying ASA url.
SMART_ASA_APP_BINDING = "smart-asa-app-id:"

# NOTE: The following costs could change over time with protocol upgrades.
OPTIN_COST = 100_000
UINTS_COST = 28_500
BYTES_COST = 50_000


def static_attrs(cls):
    return [k for k in cls.__dict__ if not k.startswith("__")]


# / --- SMART ASA ASC
# / --- --- GLOBAL STATE
class GlobalInts:
    total = Bytes("total")
    decimals = Bytes("decimals")
    default_frozen = Bytes("default_frozen")
    smart_asa_id = Bytes("smart_asa_id")
    frozen = Bytes("frozen")


class GlobalBytes:
    unit_name = Bytes("unit_name")
    name = Bytes("name")
    url = Bytes("url")
    metadata_hash = Bytes("metadata_hash")
    manager_addr = Bytes("manager_addr")
    reserve_addr = Bytes("reserve_addr")
    freeze_addr = Bytes("freeze_addr")
    clawback_addr = Bytes("clawback_addr")


class GlobalState(GlobalInts, GlobalBytes):
    @staticmethod
    def num_uints():
        return len(static_attrs(GlobalInts))

    @staticmethod
    def num_bytes():
        return len(static_attrs(GlobalBytes))

    @classmethod
    def schema(cls):
        return StateSchema(
            num_uints=cls.num_uints(),
            num_byte_slices=cls.num_bytes(),
        )


class SmartASAConfig(abi.NamedTuple):
    total: abi.Field[abi.Uint64]
    decimals: abi.Field[abi.Uint32]
    default_frozen: abi.Field[abi.Bool]
    unit_name: abi.Field[abi.String]
    name: abi.Field[abi.String]
    url: abi.Field[abi.String]
    metadata_hash: abi.Field[abi.DynamicArray[abi.Byte]]
    manager_addr: abi.Field[abi.Address]
    reserve_addr: abi.Field[abi.Address]
    freeze_addr: abi.Field[abi.Address]
    clawback_addr: abi.Field[abi.Address]


# / --- --- LOCAL STATE
# NOTE: Local State is needed only if the Smart ASA has `account_frozen`.
# Local State is not needed in case Smart ASA has just "global" `asset_freeze`.
class LocalInts:
    smart_asa_id = Bytes("smart_asa_id")
    frozen = Bytes("frozen")


class LocalBytes:
    ...


class LocalState(LocalInts, LocalBytes):
    @staticmethod
    def num_uints():
        return len(static_attrs(LocalInts))

    @staticmethod
    def num_bytes():
        return len(static_attrs(LocalBytes))

    @classmethod
    def schema(cls):
        return StateSchema(
            num_uints=cls.num_uints(),
            num_byte_slices=cls.num_bytes(),
        )


# / --- --- SUBROUTINES
@Subroutine(TealType.none)
def init_global_state() -> Expr:
    return Seq(
        App.globalPut(GlobalState.smart_asa_id, Int(0)),
        App.globalPut(GlobalState.total, Int(0)),
        App.globalPut(GlobalState.decimals, Int(0)),
        App.globalPut(GlobalState.default_frozen, Int(0)),
        # NOTE: ASA behaves excluding `unit_name` field if not declared:
        App.globalPut(GlobalState.unit_name, Bytes("")),
        # NOTE: ASA behaves excluding `name` field if not declared:
        App.globalPut(GlobalState.name, Bytes("")),
        # NOTE: ASA behaves excluding `url` field if not declared:
        App.globalPut(GlobalState.url, Bytes("")),
        # NOTE: ASA behaves excluding `metadata_hash` field if not declared:
        App.globalPut(GlobalState.metadata_hash, Bytes("")),
        App.globalPut(GlobalState.manager_addr, Global.zero_address()),
        App.globalPut(GlobalState.reserve_addr, Global.zero_address()),
        App.globalPut(GlobalState.freeze_addr, Global.zero_address()),
        App.globalPut(GlobalState.clawback_addr, Global.zero_address()),
        # Special Smart ASA fields
        App.globalPut(GlobalState.frozen, Int(0)),
    )


@Subroutine(TealType.none)
def init_local_state() -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    return Seq(
        App.localPut(Txn.sender(), LocalState.smart_asa_id, smart_asa_id),
        App.localPut(Txn.sender(), LocalState.frozen, Int(0)),
    )


@Subroutine(TealType.bytes)
def digit_to_ascii(i: Expr) -> Expr:
    """digit_to_ascii converts an integer < 10 to the ASCII byte that represents it"""
    return Extract(Bytes("0123456789"), i, Int(1))


@Subroutine(TealType.bytes)
def itoa(i: Expr) -> Expr:
    """itoa converts an integer to the ASCII byte string it represents."""
    return If(
        i == Int(0),
        Bytes("0"),
        Concat(
            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes("")),
            digit_to_ascii(i % Int(10)),
        ),
    )


@Subroutine(TealType.bytes)
def strip_len_prefix(abi_encoded: Expr) -> Expr:
    return Suffix(abi_encoded, Int(abi.Uint16TypeSpec().byte_length_static()))


# / --- --- UNDERLYING ASA CONFIG
UNDERLYING_ASA_TOTAL = Int(2**64 - 1)
UNDERLYING_ASA_DECIMALS = Int(0)
UNDERLYING_ASA_DEFAULT_FROZEN = Int(1)
UNDERLYING_ASA_UNIT_NAME = Bytes("S-ASA")
UNDERLYING_ASA_NAME = Bytes("SMART-ASA")
UNDERLYING_ASA_URL = Concat(
    Bytes(SMART_ASA_APP_BINDING), itoa(Global.current_application_id())
)
UNDERLYING_ASA_METADATA_HASH = Bytes("")
UNDERLYING_ASA_MANAGER_ADDR = Global.current_application_address()
UNDERLYING_ASA_RESERVE_ADDR = Global.current_application_address()
UNDERLYING_ASA_FREEZE_ADDR = Global.current_application_address()
UNDERLYING_ASA_CLAWBACK_ADDR = Global.current_application_address()


@Subroutine(TealType.uint64)
def underlying_asa_create_inner_tx() -> Expr:
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.fee: Int(0),
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset_total: UNDERLYING_ASA_TOTAL,
                TxnField.config_asset_decimals: UNDERLYING_ASA_DECIMALS,
                TxnField.config_asset_default_frozen: UNDERLYING_ASA_DEFAULT_FROZEN,
                TxnField.config_asset_unit_name: UNDERLYING_ASA_UNIT_NAME,
                TxnField.config_asset_name: UNDERLYING_ASA_NAME,
                TxnField.config_asset_url: UNDERLYING_ASA_URL,
                TxnField.config_asset_manager: UNDERLYING_ASA_MANAGER_ADDR,
                TxnField.config_asset_reserve: UNDERLYING_ASA_RESERVE_ADDR,
                TxnField.config_asset_freeze: UNDERLYING_ASA_FREEZE_ADDR,
                TxnField.config_asset_clawback: UNDERLYING_ASA_CLAWBACK_ADDR,
            }
        ),
        InnerTxnBuilder.Submit(),
        Return(InnerTxn.created_asset_id()),
    )


@Subroutine(TealType.none)
def smart_asa_transfer_inner_txn(
    smart_asa_id: Expr,
    asset_amount: Expr,
    asset_sender: Expr,
    asset_receiver: Expr,
) -> Expr:
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.fee: Int(0),
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.xfer_asset: smart_asa_id,
                TxnField.asset_amount: asset_amount,
                TxnField.asset_sender: asset_sender,
                TxnField.asset_receiver: asset_receiver,
            }
        ),
        InnerTxnBuilder.Submit(),
    )


@Subroutine(TealType.none)
def smart_asa_destroy_inner_txn(smart_asa_id: Expr) -> Expr:
    return Seq(
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.fee: Int(0),
                TxnField.type_enum: TxnType.AssetConfig,
                TxnField.config_asset: smart_asa_id,
            }
        ),
        InnerTxnBuilder.Submit(),
    )


@Subroutine(TealType.none)
def is_valid_address_bytes_length(address: Expr) -> Expr:
    # WARNING: Note this check only ensures proper bytes' length on `address`,
    # but doesn't ensure that those 32 bytes are a _proper_ Algorand address.
    return Assert(Len(address) == Int(key_len_bytes))


@Subroutine(TealType.uint64)
def circulating_supply(asset_id: Expr):
    smart_asa_reserve = AssetHolding.balance(
        Global.current_application_address(), asset_id
    )
    return Seq(smart_asa_reserve, UNDERLYING_ASA_TOTAL - smart_asa_reserve.value())


@Subroutine(TealType.none)
def getter_preconditions(asset_id: Expr) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == asset_id
    return Assert(
        smart_asa_id,
        is_correct_smart_asa_id,
    )


# / --- --- ABI
# / --- --- BARE CALLS
@Subroutine(TealType.none)
def asset_app_create() -> Expr:
    return Seq(
        # Preconditions
        # Not mandatory - Smart ASA Application self validate its state.
        Assert(
            Txn.global_num_uints() == Int(GlobalState.num_uints()),
            Txn.global_num_byte_slices() == Int(GlobalState.num_bytes()),
            Txn.local_num_uints() == Int(LocalState.num_uints()),
            Txn.local_num_byte_slices() == Int(LocalState.num_bytes()),
        ),
        init_global_state(),
        Approve(),
    )


smart_asa_abi = Router(
    "Smart ASA ref. implementation",
    BareCallActions(
        no_op=OnCompleteAction.create_only(asset_app_create()),
        # Rules governing a Smart ASA are only in place as long as the
        # controlling Smart Contract is not updatable.
        update_application=OnCompleteAction.always(Reject()),
        # Rules governing a Smart ASA are only in place as long as the
        # controlling Smart Contract is not deletable.
        delete_application=OnCompleteAction.always(Reject()),
        clear_state=OnCompleteAction.call_only(Reject()),
    ),
)


# / --- --- METHODS
@smart_asa_abi.method(opt_in=CallConfig.ALL)
def asset_app_optin(
    asset: abi.Asset,
    underlying_asa_optin: abi.AssetTransferTransaction,
) -> Expr:
    # On OptIn the frozen status must be set to `True` if account owns any
    # units of the underlying ASA. This prevents malicious users to circumvent
    # the `default_frozen` status by clearing their Local State. Note that this
    # could be avoided by the use of Boxes once available.
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == asset.asset_id()
    default_frozen = App.globalGet(GlobalState.default_frozen)
    freeze_account = App.localPut(Txn.sender(), LocalState.frozen, Int(1))
    account_balance = AssetHolding().balance(Txn.sender(), asset.asset_id())
    optin_to_underlying_asa = account_balance.hasValue()
    return Seq(
        # Preconditions
        Assert(
            smart_asa_id,
            is_correct_smart_asa_id,
            underlying_asa_optin.get().type_enum() == TxnType.AssetTransfer,
            underlying_asa_optin.get().xfer_asset() == smart_asa_id,
            underlying_asa_optin.get().sender() == Txn.sender(),
            underlying_asa_optin.get().asset_receiver() == Txn.sender(),
            underlying_asa_optin.get().asset_amount() == Int(0),
            underlying_asa_optin.get().asset_close_to() == Global.zero_address(),
        ),
        account_balance,
        Assert(optin_to_underlying_asa),
        # Effects
        init_local_state(),
        If(Or(default_frozen, account_balance.value() > Int(0))).Then(freeze_account),
        Approve(),
    )


@smart_asa_abi.method
def asset_create(
    total: abi.Uint64,
    decimals: abi.Uint32,
    default_frozen: abi.Bool,
    unit_name: abi.String,
    name: abi.String,
    url: abi.String,
    metadata_hash: abi.DynamicArray[abi.Byte],
    manager_addr: abi.Address,
    reserve_addr: abi.Address,
    freeze_addr: abi.Address,
    clawback_addr: abi.Address,
    *,
    output: abi.Uint64,
) -> Expr:

    is_creator = Txn.sender() == Global.creator_address()
    smart_asa_not_created = Not(App.globalGet(GlobalState.smart_asa_id))
    smart_asa_id = underlying_asa_create_inner_tx()

    return Seq(
        # Preconditions
        Assert(is_creator, smart_asa_not_created),
        is_valid_address_bytes_length(manager_addr.get()),
        is_valid_address_bytes_length(reserve_addr.get()),
        is_valid_address_bytes_length(freeze_addr.get()),
        is_valid_address_bytes_length(clawback_addr.get()),
        # Effects
        # Underlying ASA creation
        App.globalPut(GlobalState.smart_asa_id, smart_asa_id),
        # Smart ASA properties
        App.globalPut(GlobalState.total, total.get()),
        App.globalPut(GlobalState.decimals, decimals.get()),
        App.globalPut(GlobalState.default_frozen, default_frozen.get()),
        App.globalPut(GlobalState.unit_name, unit_name.get()),
        App.globalPut(GlobalState.name, name.get()),
        App.globalPut(GlobalState.url, url.get()),
        App.globalPut(
            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())
        ),
        App.globalPut(GlobalState.manager_addr, manager_addr.get()),
        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),
        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),
        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),
        output.set(App.globalGet(GlobalState.smart_asa_id)),
    )


@smart_asa_abi.method
def asset_config(
    config_asset: abi.Asset,
    total: abi.Uint64,
    decimals: abi.Uint32,
    default_frozen: abi.Bool,
    unit_name: abi.String,
    name: abi.String,
    url: abi.String,
    metadata_hash: abi.DynamicArray[abi.Byte],
    manager_addr: abi.Address,
    reserve_addr: abi.Address,
    freeze_addr: abi.Address,
    clawback_addr: abi.Address,
) -> Expr:

    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    current_manager_addr = App.globalGet(GlobalState.manager_addr)
    current_reserve_addr = App.globalGet(GlobalState.reserve_addr)
    current_freeze_addr = App.globalGet(GlobalState.freeze_addr)
    current_clawback_addr = App.globalGet(GlobalState.clawback_addr)

    is_manager_addr = Txn.sender() == current_manager_addr
    is_correct_smart_asa_id = smart_asa_id == config_asset.asset_id()

    update_reserve_addr = current_reserve_addr != reserve_addr.get()
    update_freeze_addr = current_freeze_addr != freeze_addr.get()
    update_clawback_addr = current_clawback_addr != clawback_addr.get()

    # NOTE: In ref. implementation Smart ASA total can not be configured to
    # less than its current circulating supply.
    is_valid_total = total.get() >= circulating_supply(smart_asa_id)

    return Seq(
        # Preconditions
        Assert(
            smart_asa_id,
            is_correct_smart_asa_id,
        ),  # NOTE: usless in ref. impl since 1 ASA : 1 App
        is_valid_address_bytes_length(manager_addr.get()),
        is_valid_address_bytes_length(reserve_addr.get()),
        is_valid_address_bytes_length(freeze_addr.get()),
        is_valid_address_bytes_length(clawback_addr.get()),
        Assert(is_manager_addr),
        If(update_reserve_addr).Then(
            Assert(current_reserve_addr != Global.zero_address())
        ),
        If(update_freeze_addr).Then(
            Assert(current_freeze_addr != Global.zero_address())
        ),
        If(update_clawback_addr).Then(
            Assert(current_clawback_addr != Global.zero_address())
        ),
        Assert(is_valid_total),
        # Effects
        App.globalPut(GlobalState.total, total.get()),
        App.globalPut(GlobalState.decimals, decimals.get()),
        App.globalPut(GlobalState.default_frozen, default_frozen.get()),
        App.globalPut(GlobalState.unit_name, unit_name.get()),
        App.globalPut(GlobalState.name, name.get()),
        App.globalPut(GlobalState.url, url.get()),
        App.globalPut(
            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())
        ),
        App.globalPut(GlobalState.manager_addr, manager_addr.get()),
        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),
        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),
        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),
    )


@smart_asa_abi.method
def asset_transfer(
    xfer_asset: abi.Asset,
    asset_amount: abi.Uint64,
    asset_sender: abi.Account,
    asset_receiver: abi.Account,
) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    clawback_addr = App.globalGet(GlobalState.clawback_addr)
    is_not_clawback = And(
        Txn.sender() == asset_sender.address(),
        Txn.sender() != clawback_addr,
    )

    # NOTE: Ref. implementation grants _minting_ premission to `reserve_addr`,
    # has restriction no restriction on who is the minting _receiver_.
    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off minting.
    is_minting = And(
        Txn.sender() == App.globalGet(GlobalState.reserve_addr),
        asset_sender.address() == Global.current_application_address(),
    )

    # NOTE: Ref. implementation grants _burning_ premission to `reserve_addr`,
    # has restriction both on burning _sender_ and _receiver_ to prevent
    # _clawback_ throug burning.
    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off burning.
    is_burning = And(
        Txn.sender() == App.globalGet(GlobalState.reserve_addr),
        asset_sender.address() == App.globalGet(GlobalState.reserve_addr),
        asset_receiver.address() == Global.current_application_address(),
    )

    is_clawback = Txn.sender() == clawback_addr
    is_correct_smart_asa_id = smart_asa_id == xfer_asset.asset_id()

    # NOTE: Ref. implementation checks that `smart_asa_id` is correct in Local
    # State since the App could generate a new Smart ASA (if the previous one
    # has been dystroied) requiring users to opt-in again to gain a coherent
    # new `frozen` status.
    is_current_smart_asa_id = And(
        smart_asa_id == App.localGet(asset_sender.address(), LocalState.smart_asa_id),
        smart_asa_id == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),
    )
    asset_frozen = App.globalGet(GlobalState.frozen)
    asset_sender_frozen = App.localGet(asset_sender.address(), LocalState.frozen)
    asset_receiver_frozen = App.localGet(asset_receiver.address(), LocalState.frozen)
    return Seq(
        # Preconditions
        Assert(
            smart_asa_id,
            is_correct_smart_asa_id,
        ),
        is_valid_address_bytes_length(asset_sender.address()),
        is_valid_address_bytes_length(asset_receiver.address()),
        If(is_not_clawback)
        .Then(
            # Asset Regular Transfer Preconditions
            Assert(
                Not(asset_frozen),
                Not(asset_sender_frozen),
                Not(asset_receiver_frozen),
                is_current_smart_asa_id,
            ),
        )
        .ElseIf(is_minting)
        .Then(
            # Asset Minting Preconditions
            Assert(
                Not(asset_frozen),
                Not(asset_receiver_frozen),
                smart_asa_id
                == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),
                # NOTE: Ref. implementation prevents minting more than `total`.
                circulating_supply(smart_asa_id) + asset_amount.get()
                <= App.globalGet(GlobalState.total),
            ),
        )
        .ElseIf(is_burning)
        .Then(
            # Asset Burning Preconditions
            Assert(
                Not(asset_frozen),
                Not(asset_sender_frozen),
                smart_asa_id
                == App.localGet(asset_sender.address(), LocalState.smart_asa_id),
            ),
        )
        .Else(
            # Asset Clawback Preconditions
            Assert(is_clawback),
            # NOTE: `is_current_smart_asa_id` implicitly checks that both
            # `asset_sender` and `asset_receiver` opted-in the Smart ASA
            # App. This ensures that _mint_ and _burn_ can not be
            # executed as _clawback_, since the Smart ASA App can not
            # opt-in to itself.
            Assert(is_current_smart_asa_id),
        ),
        # Effects
        smart_asa_transfer_inner_txn(
            xfer_asset.asset_id(),
            asset_amount.get(),
            asset_sender.address(),
            asset_receiver.address(),
        ),
    )


@smart_asa_abi.method
def asset_freeze(freeze_asset: abi.Asset, asset_frozen: abi.Bool) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()
    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)
    return Seq(
        # Asset Freeze Preconditions
        Assert(
            smart_asa_id,
            is_correct_smart_asa_id,
            is_freeze_addr,
        ),
        # Effects
        App.globalPut(GlobalState.frozen, asset_frozen.get()),
    )


@smart_asa_abi.method
def account_freeze(
    freeze_asset: abi.Asset,
    freeze_account: abi.Account,
    asset_frozen: abi.Bool,
) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()
    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)
    return Seq(
        # Account Freeze Preconditions
        is_valid_address_bytes_length(freeze_account.address()),
        Assert(smart_asa_id, is_correct_smart_asa_id, is_freeze_addr),
        # Effects
        App.localPut(freeze_account.address(), LocalState.frozen, asset_frozen.get()),
    )


@smart_asa_abi.method(close_out=CallConfig.ALL)
def asset_app_closeout(
    close_asset: abi.Asset,
    close_to: abi.Account,
) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == close_asset.asset_id()
    current_smart_asa_id = App.localGet(Txn.sender(), LocalState.smart_asa_id)
    is_current_smart_asa_id = current_smart_asa_id == close_asset.asset_id()
    account_balance = AssetHolding().balance(Txn.sender(), close_asset.asset_id())
    asset_creator = AssetParam().creator(close_asset.asset_id())
    asset_frozen = App.globalGet(GlobalState.frozen)
    asset_closer_frozen = App.localGet(Txn.sender(), LocalState.frozen)
    asa_closeout_relative_idx = Txn.group_index() + Int(1)
    return Seq(
        # Preconditions
        # NOTE: Smart ASA existence is not checked by default on close-out
        # since would be impossible to close-out destroyed assets.
        is_valid_address_bytes_length(close_to.address()),
        Assert(
            is_current_smart_asa_id,
            Global.group_size() > asa_closeout_relative_idx,
            Gtxn[asa_closeout_relative_idx].type_enum() == TxnType.AssetTransfer,
            Gtxn[asa_closeout_relative_idx].xfer_asset() == close_asset.asset_id(),
            Gtxn[asa_closeout_relative_idx].sender() == Txn.sender(),
            Gtxn[asa_closeout_relative_idx].asset_amount() == Int(0),
            Gtxn[asa_closeout_relative_idx].asset_close_to()
            == Global.current_application_address(),
        ),
        # Effects
        asset_creator,
        # NOTE: Skip checks if Underlying ASA has been destroyed to avoid
        # users' lock-in.
        If(asset_creator.hasValue()).Then(
            # NOTE: Smart ASA has not been destroyed.
            Assert(is_correct_smart_asa_id),
            If(Or(asset_frozen, asset_closer_frozen)).Then(
                # NOTE: If Smart ASA is frozen, users can only close-out to
                # Creator
                Assert(close_to.address() == Global.current_application_address())
            ),
            If(close_to.address() != Global.current_application_address()).Then(
                # NOTE: If the target of close-out is not Creator, it MUST be
                # opted-in to the current Smart ASA.
                Assert(
                    smart_asa_id
                    == App.localGet(close_to.address(), LocalState.smart_asa_id)
                )
            ),
            account_balance,
            smart_asa_transfer_inner_txn(
                close_asset.asset_id(),
                account_balance.value(),
                Txn.sender(),
                close_to.address(),
            ),
        ),
        # NOTE: If Smart ASA has been destroyed:
        #   1. The close-to address could be anyone
        #   2. No InnerTxn happens
        Approve(),
    )


@smart_asa_abi.method
def asset_destroy(destroy_asset: abi.Asset) -> Expr:
    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)
    is_correct_smart_asa_id = smart_asa_id == destroy_asset.asset_id()
    is_manager_addr = Txn.sender() == App.globalGet(GlobalState.manager_addr)
    return Seq(
        # Asset Destroy Preconditions
        Assert(
            smart_asa_id,
            is_correct_smart_asa_id,
            is_manager_addr,
        ),
        # Effects
        smart_asa_destroy_inner_txn(destroy_asset.asset_id()),
        init_global_state(),
    )


# / --- --- GETTERS
@smart_asa_abi.method
def get_asset_is_frozen(freeze_asset: abi.Asset, *, output: abi.Bool) -> Expr:
    return Seq(
        # Preconditions
        getter_preconditions(freeze_asset.asset_id()),
        # Effects
        output.set(App.globalGet(GlobalState.frozen)),
    )


@smart_asa_abi.method
def get_account_is_frozen(
    freeze_asset: abi.Asset, freeze_account: abi.Account, *, output: abi.Bool
) -> Expr:
    return Seq(
        # Preconditions
        getter_preconditions(freeze_asset.asset_id()),
        is_valid_address_bytes_length(freeze_account.address()),
        # Effects
        output.set(App.localGet(freeze_account.address(), LocalState.frozen)),
    )


@smart_asa_abi.method
def get_circulating_supply(asset: abi.Asset, *, output: abi.Uint64) -> Expr:
    return Seq(
        # Preconditions
        getter_preconditions(asset.asset_id()),
        # Effects
        output.set(circulating_supply(asset.asset_id())),
    )


@smart_asa_abi.method
def get_optin_min_balance(asset: abi.Asset, *, output: abi.Uint64) -> Expr:
    min_balance = Int(
        OPTIN_COST
        + UINTS_COST * LocalState.num_uints()
        + BYTES_COST * LocalState.num_bytes()
    )

    return Seq(
        # Preconditions
        getter_preconditions(asset.asset_id()),
        # Effects
        output.set(min_balance),
    )


@smart_asa_abi.method
def get_asset_config(asset: abi.Asset, *, output: SmartASAConfig) -> Expr:
    return Seq(
        # Preconditions
        getter_preconditions(asset.asset_id()),
        # Effects
        (total := abi.Uint64()).set(App.globalGet(GlobalState.total)),
        (decimals := abi.Uint32()).set(App.globalGet(GlobalState.decimals)),
        (default_frozen := abi.Bool()).set(App.globalGet(GlobalState.default_frozen)),
        (unit_name := abi.String()).set(App.globalGet(GlobalState.unit_name)),
        (name := abi.String()).set(App.globalGet(GlobalState.name)),
        (url := abi.String()).set(App.globalGet(GlobalState.url)),
        (metadata_hash_str := abi.String()).set(
            App.globalGet(GlobalState.metadata_hash)
        ),
        (metadata_hash := abi.make(abi.DynamicArray[abi.Byte])).decode(
            metadata_hash_str.encode()
        ),
        (manager_addr := abi.Address()).set(App.globalGet(GlobalState.manager_addr)),
        (reserve_addr := abi.Address()).set(App.globalGet(GlobalState.reserve_addr)),
        (freeze_addr := abi.Address()).set(App.globalGet(GlobalState.freeze_addr)),
        (clawback_addr := abi.Address()).set(App.globalGet(GlobalState.clawback_addr)),
        output.set(
            total,
            decimals,
            default_frozen,
            unit_name,
            name,
            url,
            metadata_hash,
            manager_addr,
            reserve_addr,
            freeze_addr,
            clawback_addr,
        ),
    )


def compile_stateful(program: Expr) -> str:
    return compileTeal(
        program,
        Mode.Application,
        version=TEAL_VERSION,
        assembleConstants=True,
        optimize=OptimizeOptions(scratch_slots=True),
    )


if __name__ == "__main__":
    # Allow quickly testing compilation.
    from smart_asa_test import test_compile

    test_compile(*smart_asa_abi.build_program())


# File: https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/voting_process/voting.py
#This defines voting functions using traditional majority, STAR, and approval protocols.
#All of the protocols below use Choice Coin to both quantify and send votes.
#The funcions also define the ability to create accounts for an arbitary amount of voters.
#The protocols below are minimum representations for two candidates, decisions,etc.
#Read the Docs to learn how to add more candiates, decisions, and how to implement this protocol 
#into you governance system.

from algosdk import account, encoding, mnemonic,transaction
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn
from algosdk.v2client import algod
from algorand_demo import choice_trade
algod_address = ""
algod_token = ""
#Initializes Client for node
headers = {"X-API-Key": algod_token }
algod_client = algod.AlgodClient(algod_token,algod_address,headers)
fund_address = "" #Put in main fund address here
fund_mnemonic = "" #Put in main fund receiver_mnemonic here
fund_key = mnemonic.to_private_key(fund_mnemonic)
choice_id = 17264161 #Official Test Asset ID for Choice Coin
decision_one = ""
decision_two = ""
test_address = ''
test_mnemonic = ''

def algo_inital(sender, key, receiver,comment):
    parameters = algod_client.suggested_params()
    #Initalize parameters
    transaction = PaymentTxn(sender, parameters, receiver, 300000,note=comment)
    #Defines an inital transaction for Algo.
    #Add some sort of hash to ensure that fund addresses are hashed properly
    #Add a hash to ensure that client addresses are protected
    signature = transaction.sign(key)
    #Signs the transaction with the sender's private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    return True



def count(address):
    message = ''
    error = ''
    account_info = algod_client.account_info(address)
    assets = account_info.get("assets")
    for asset in assets:
        if asset["asset-id"] ==  choice_id:
            amount = asset.get("amount")
            message = amount
            return message
    error = 'The account has not opted-in to the asset yet.'
    return error



#This is quantifies a voter's vote and allows its to be recorded on the Algorand Blockchain through Choice Coin.
#Each of the candiates/decisions will have their own Algorand Accounts to recieve these votes in the form of Choice Coin.
def choice_vote(sender, key, receiver,amount):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(sender, parameters, receiver, amount, choice_id)
    #Defines an inital transaction for choice Coin
    signature = transaction.sign(key)
    #Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    return True, final



def create_optin(receiver_mnemonic,receiver_address,index):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(receiver_address, parameters, receiver_address, 0, index)
    #Defines a transaction that will opt the receiver into the asset.
    key = mnemonic.to_private_key(receiver_mnemonic)
    signature = transaction.sign(key)
    algod_client.send_transaction(signature)
    #Opts-in the account to the asset
    return True


#This allows the organization to generate an arbitary amount of Algorand Accounts for its voters.
def initiate_new_accounts():
    x = input("How many voters do you need?")
    x = int(x)
    for y in range(0,x):
        private,public = account.generate_account()
        passphrase = mnemonic.from_private_key(private)
        algo_inital(fund_address,fund_key,public,"Balance to opt-in to Choice Coin")
        create_optin(passphrase,public,choice_id)
        print("Address: {}\nPasscode: \"{}\"".format(public, passphrase))


        
#This defines a basic majority scheme on the Algorand Blockchain using the choice_vote function described earlier.       
def new_vote(vote,address,t_mnemonic):
    private_key = mnemonic.to_private_key(mnemonic)
    if vote == "Yes":
        choice_vote(address,private_key,decision_one,100)
    elif vote == "No":
        choice_vote(address,private_key,decision_two,100)
    else:
        print("You did not submit the proper input")

#This defines a basic Star_Voting scheme using Choice Coin. Users are allowed to rate
#each candidate. Once they have done this, the choice_vote function will
#send the appropriate allocation of Choice Coin to the winner account.
#Read the docs to create a restriction on how many start per voter
#are possible.
def star_voting(address,t_mnemonic,candidate_rating,candiate_type):
    if candiate_type == 'one':
        candiate_rating = int(candidate_rating)
        amount = candiate_rating * 100
        private_key = mnemonic.to_private_key(t_mnemonic)
        choice_vote(address,private_key,decision_one,amount)
    elif candiate_type == 'two':
        candiate_rating = int(candidate_rating)
        amount = candiate_rating * 100
        private_key = mnemonic.to_private_key(t_mnemonic)
        choice_vote(address,private_key,decision_one,amount)
    print("Ballot Tabulated")

#This defines a basic approval voting system. Again, this allows the voter 
#to select all the decisons/candidates they approve of. This again only has two decisions.
#Read our Docs to find out more!
def approval_voting(address,t_mnemonic):
    first = input("Do you approve of first decision? Please answer using Yes or No")
    second = input("Do you approve of second decision? Please answer using Yes or No")
    first = first.lower()
    second = second.lower()
    if first == 'yes':
        choice_vote(address,private_key,decision_one,100)
    elif second == 'yes':
        choice_vote(address,private_key,decision_two,100)
        
def check_holdings(asset_id, address):
	"""
	Checks the asset balance for the specific address and asset id.
	"""
	account_info = client.account_info(address)
	assets = account_info.get("assets")
	for asset in assets:
		if asset['asset-id'] == asset_id:
			amount = asset.get("amount")
			print("Account {} has {}.".format(address, balance_formatter(amount, asset_id, client)))
			return
	print("Account {} must opt-in to Asset ID {}.".format(address, asset_id))
    
  
#This is a stateful smart contract to count the number of votes each candiate recieved
#on the Algorand Blockchain.
def count_votes():
    yes_count = check_holdings(decision_one)
    no_count = check_holding(decision_two)
    if yes_count > no_count:
        print("Decision One had the most votes!")
    if no_count > yes_count:
        print("Decision Two had the most votes!")


# File: https://github.com/Ecosteer-SRL/dvco-algorand/blob/00c9b22b07980fe9f6ced4363862aa7d05c6c416/worker/worker_algorand.py
 
#   ver:    0.5
#   date:   24/10/2022
#   author: georgiana-bud
import os
import base64
from typing import Tuple, Type, Optional, Union


 
#	WARNING:
#	NOTE:	the kmd.net and kmd.token files are in a folder
#		    named based on the release of kmd - HOWEVER - to date
#		    no easy way has been found to determine the version of kmd
#		    programmatically - find a way or pass the version
#		    as a configuration parameter



import  algosdk                                      #   better type support (not necessary)                
from    algosdk                     import mnemonic                                  
from    algosdk                     import account
from    algosdk.v2client            import algod
from    algosdk.wallet              import Wallet
from    algosdk                     import kmd
from    algosdk.future              import transaction
from    algosdk.future.transaction  import PaymentTxn
from    algosdk.future.transaction  import ApplicationNoOpTxn
from    algosdk.future.transaction  import ApplicationCreateTxn
from    algosdk.future.transaction  import ApplicationOptInTxn
from    algosdk.future.transaction  import ApplicationCloseOutTxn

from error import DopError 

#   class workerAlgorand
#   the following methods have to be implemented
#
#   (x) begin_transaction
#   (x) rollback
#   (x) commit
#   (x) create_user
#   (x) deploy_contract
#   (x) get_wallet_balance
#   (x) subscribe
#   (x) unsubscribe
#   balance                 NOTE:   not in first implementation
#   (x) get_balance         NOTE:   not fully implemented (product related balance)
#   admin_get_grants        NOTE:   not in first implementation - to be moved to chain 2 (offchain)
#   get_receipt             NOTE:   to be removed - to be considered a private/provider specific method
#   set_starting_balance    
#   (x) grant
#   (x) revoke


class workerAlgorand():
    
    def __init__ (self):
        pass


    def begin_transaction(self) -> DopError:
        return DopError(0,"")

    def rollback(self) -> DopError:
        return DopError(0,"")

    def commit(self) -> DopError:
        return DopError(0,"")

    def __wallet_id(
        self,
        wallet_name: str
        ) -> Tuple[str, DopError]:

        """
            returns the wallet id of the wallet named wallet_name
        """
        if self._i_kmd_client == None:
            return "",DopError(2,"Missing value for kmd client.")

        wallets = self._i_kmd_client.list_wallets()
        for arrayitem in wallets:
            if arrayitem.get("name") == wallet_name:
                walletid = arrayitem.get("id")
                return walletid,DopError(0,'')
                break
        return '',DopError(101,"The wallet id for the specified wallet name could not be retrieved.")

    def __account_mnemonic(
        self,
        wallet_name: str,
        wallet_password: str,
        account_address: str
        ) -> Tuple[str, DopError]:

        if self._i_kmd_client == None:
            return "",DopError(2,"Missing value for kmd client.")

        err: DopError
        wallet_id, err = self.__wallet_id(wallet_name)
        if err.isError():
            return "",err

        wallet_handle = self._i_kmd_client.init_wallet_handle(wallet_id, wallet_password)
        account_key = self._i_kmd_client.export_key(wallet_handle, wallet_password, account_address )
        key_mnemonic = mnemonic.from_private_key(account_key)

        #   check for error, exceptions, etc.
        return key_mnemonic, DopError(0,"")




    @staticmethod
    def dop_stateless_create(
        client: algosdk.v2client.algod.AlgodClient
    ,   teal_template_path: str                 #   the absolute path of the teal contract template
    ,   creator_address: str                    #   the address of the creator of the smart contract
        ) -> Tuple[str, DopError]:
        """
            creates the stateless smart contract
            if successful   -> returns the address of the stateless smart contract 
            otherwise       -> returns an empty string
        """

        #   compile the stateless teal prog
        #   set source code 
        #       the source code to be used for this example is DOP/dop.account/dop.account.teal.template
        #       NOTE:   the dop.account.teal (the source code to be compiled) is generated using the file 
        #               dop.account.teal.template by replacing the macro "_RECEIVERADDRESS_" with the "creator_address"
        #               see DOP/dop.account/00_create.sh - that contains the following cmd
        #               sed "s/_RECEIVERADDRESS_/$CREATOR/g" dop.account.teal.template > dop.account.teal


        #   read the template
        teal_template: str = ""
        try:
            with open(teal_template_path, 'r', encoding='utf-8') as f:
                teal_template = f.read()
        except Exception:
            return "",DopError(3,"Teal template file not found.")

        #   now the _RECEIVERADDRESS_ nacro has to be substituted with creator_address
        teal_source = teal_template.replace('_RECEIVERADDRESS_', creator_address)

        
        try:
            compile_response = client.compile(teal_source)
            #   return base64.b64decode(compile_response['result'])
            #   compile_response example
            #   {
            #       'hash': 'LILX6GOG4N6LAOTFT4WW5VTXK5AN4KA5TAN5CYAE7LX5GPC2XXU6NNHDTA', 
            #       'result': 'AyAHAgEABmTIAaCNBiYBIOKaz1eO1YI9t+Lp5CmWTNrK6kvjiZCylN6neTTnB6YYMgQiD0AAKTIEIxJAAAIkQzMAECMSQAAKMwAQJRJAAA0kQzMABygTQAAlIQRDIQVDMwAQIxNAABczARAlE0AADzMBGCQSQAAHMwAIIQYPQyRD'
            #   }
            #   where   'result'    holds the compiled code
            #           'hash'      is the address of the smart contract
        except Exception:
            return "",DopError(4,"Error compiling teal source.")

        smart_contract_address = compile_response['hash']

        #   TODO:   
        #           check if the stateless smart contract needs to be immediately funded
        return smart_contract_address,DopError(0,"")

    @staticmethod
    def dop_stateful_create(
        client: algosdk.v2client.algod.AlgodClient
    ,   teal_clear_program_path: str
    ,   teal_approval_program_path: str
    ,   creator_address: str
    ,   creator_private_key: str
    ,   smart_contract_address: str                     #   address of the stateless smart contract
        ) -> Tuple[str, DopError]:
        """
            creates the stateful smart contract
            if successful   -> returns the txn_id of the stateful smart contract creation transaction
            otherwise       -> returns an empty string
        """

        #ApplicationCreateTxn

        #   get and compile the clear program
        teal_clear_source: str = ""
        try:
            with open(teal_clear_program_path, 'r', encoding='utf-8') as f:
                teal_clear_source = f.read()
        except Exception:
            return "",DopError(5,"Teal clear file not found.")

        compile_response = client.compile(teal_clear_source)            
        clear_program = base64.b64decode(compile_response['result'])


        # declare on_complete as NoOp
        on_complete = transaction.OnComplete.NoOpOC.real

        #   get and compile the approval program
        teal_approval_source: str = ""
        try:
            with open(teal_approval_program_path, 'r', encoding='utf-8') as f:
                teal_approval_source = f.read()
        except Exception:
            return "",DopError(6,"Teal approval file not found.")

        compile_response = client.compile(teal_approval_source) 
        approval_program = base64.b64decode(compile_response['result'])           

        params = client.suggested_params()
        params.flat_fee = True
        params.fee = 1000

        #compile_result = base64.b64decode(compile_response['result'])
        
        smart_contract_arguments = {
            "args":     [smart_contract_address]    #   list of app arguments (goal app create --app-arg)
#       ,   "addrs":    [subscriber_address]        #   list of account arguments
        }

        app_args: list   = workerAlgorand.getArgs(smart_contract_arguments)

        # declare application state storage (immutable)
        local_ints      = 5
        local_bytes     = 5
        global_ints     = 5
        global_bytes    = 5

        # define schema (<class 'algosdk.future.transaction.StateSchema'>)
        global_schema   = transaction.StateSchema(global_ints, global_bytes)
        local_schema    = transaction.StateSchema(local_ints, local_bytes)

        unsigned_txn = ApplicationCreateTxn(creator_address, params, on_complete, approval_program, clear_program, global_schema, local_schema, app_args)
        # sign transaction
        signed_txn = unsigned_txn.sign(creator_private_key)
        txn_id = signed_txn.transaction.get_txid()

        #   send transaction
        try: 
            client.send_transactions([signed_txn])    
        except Exception as err:
            return txn_id, DopError(120, f"An error occurred while creating stateful \
                smart contract.")
        return (txn_id,DopError(0,""))

    @staticmethod
    def mnemonic_to_private_key(mnemonic_key: str) -> Tuple[str, DopError]:
        """
        convert a menmonic key into a "single string" private key
        """
        private_key: str = ""
        try:
            private_key = mnemonic.to_private_key(mnemonic_key)
        except Exception:
            return "",DopError(10,"Mnemonic could not be converted to private key.")

        return private_key,DopError(0,"")


    
    #   private method
    def __algorand_smart_contract_create(
        self
    ,   client: algosdk.v2client.algod.AlgodClient
    ,   creator_mnemonic: str
        ) -> Tuple[str, str, DopError]:
        
        """
            the DOP smart contract is a linked smart contract
            (there is a stateless part, to represent the smart contract account
            and a stateful part, holding the DOP logic)
            RETURNS:    
                    address of the stateless smart contract
                    app index of the stateful smart contract
                    DopError

            see https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/?from_query=call%20smart%20contract%20from%20javascript#call-noop
            see https://github.com/algorand/py-algorand-sdk/blob/5b496e0928af1dcae4e393693421f590a6111907/algosdk/future/transaction.py
            see https://developer.algorand.org/docs/rest-apis/algod/v2/
        """

        err: DopError
        creator_private_key: str

        creator_private_key, err = self.mnemonic_to_private_key(creator_mnemonic)
        if err.isError():
            return ("",0,err)
        creator_address       = account.address_from_private_key(creator_private_key)         #   this line to be deleted

        smart_contract_address, err = self.dop_stateless_create(client, self._i_stateless_teal_template_path, creator_address)
        if err.isError():
            return ("",0,err)

        txn_id, err = self.dop_stateful_create(client, self._i_teal_clear_program_path, self._i_teal_approval_program_path, creator_address, creator_private_key, smart_contract_address)

        if err.isError():
            return "",0,err

        # await confirmation
        confirmed_txn = self.wait_for_confirmation(client, txn_id, 4)  


        #   confirmed_txn holds:
        #   {
        #       'application-index': 392, 
        #       'confirmed-round': 66118, 
        #       'global-state-delta': [
        #                               {'key': 'a2V5', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, 
        #                               {'key': 'a2lk', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, 
        #                               {'key': 'bGlua2Vk', 'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}}, 
        #                               {'key': 'Y3JlYXRvcg==', 'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}}
        #                               ], 
        #       'pool-error': '', 
        #       'sender-rewards': 16230, 
        #       'txn': {'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', 
        #               'txn': {'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], 
        #                       'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', 
        #                       'apgs': {'nbs': 5, 'nui': 5}, 
        #                       'apls': {'nbs': 5, 'nui': 5}, 
        #                       'apsu': 'AyABASI=', 
        #                       'fee': 1000, 
        #                       'fv': 66017, 
        #                       'gen': 'private-v1', 
        #                       'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', 
        #                       'lv': 67017, 
        #                       'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', 
        #                       'type': 'appl'}
        #               }
        #       }


        # display results
        transaction_response = client.pending_transaction_info(txn_id)

        #   transaction_response
        #   {
        #       'application-index': 392, 
        #       'confirmed-round': 66118, 
        #       'global-state-delta': [
        #                               {
        #                                   'key': 'Y3JlYXRvcg==', 
        #                                   'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}
        #                               }, 
        #                               {
        #                                   'key': 'a2V5', 
        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}
        #                               }, 
        #                               {
        #                                   'key': 'a2lk', 
        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}
        #                               }, 
        #                               {
        #                                   'key': 'bGlua2Vk', 
        #                                   'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}
        #                               }
        #                               ], 
        #       'pool-error': '', 
        #       'sender-rewards': 16230, 
        #       'txn': {
        #                   'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', 
        #                   'txn': {
        #                               'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], 
        #                               'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', 
        #                               'apgs': {'nbs': 5, 'nui': 5}, 
        #                               'apls': {'nbs': 5, 'nui': 5}, 
        #                               'apsu': 'AyABASI=', 
        #                               'fee': 1000, 
        #                               'fv': 66017, 
        #                               'gen': 'private-v1', 
        #                               'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', 
        #                               'lv': 67017, 
        #                               'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', 
        #                               'type': 'appl'
        #                           }
        #               }
        #       }

        app_id = transaction_response['application-index']
        return (smart_contract_address, str(app_id), DopError(0,""))


    #   private method
    def __account_send(self, from_mnemonic, to_address, amount) -> Tuple[str,DopError]:

        """
        Sends tokens from one account to another
        """
        if self._i_algod_client == None:
            return "",DopError(1,"Missing value for algod client.")

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP OPTIN".encode()

        err: DopError

        from_private_key, err = self.mnemonic_to_private_key(from_mnemonic)
        if err.isError():
            return "",err
        from_address = account.address_from_private_key(from_private_key)

        
        params = self._i_algod_client.suggested_params()
        # comment out the next two (2) lines to use suggested fees
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP funds".encode()

        #   create an unsigned transaction
        unsigned_txn = PaymentTxn(from_address, params, to_address, amount, None, txn_note)

        #   sign the transaction using the private key of the sender (from_address)
        signed_txn = unsigned_txn.sign(from_private_key)

        #submit transaction
        txid = self._i_algod_client.send_transaction(signed_txn)
        print("Successfully sent transaction with txID: {}".format(txid))

        # wait for confirmation 
        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  
        except Exception as err:
            print(err)
            return "", DopError(301,'An exception occurred while waiting \
                for the confirmation of the send transaction.')
        
        return txid, DopError(0,)
    
    @staticmethod
    def wait_for_confirmation(
        client: algosdk.v2client.algod.AlgodClient
    ,   transaction_id: str
    ,   timeout: int
    ):
        """
        Wait until the transaction is confirmed or rejected, or until 'timeout'
        number of rounds have passed.
        Args:
            transaction_id (str): the transaction to wait for
            timeout (int): maximum number of rounds to wait    
        Returns:
            dict: pending transaction information, or throws an error if the transaction
                is not confirmed or rejected in the next timeout rounds
        """
        start_round = client.status()["last-round"] + 1
        current_round = start_round

        while current_round < start_round + timeout:
            try:
                pending_txn = client.pending_transaction_info(transaction_id)
            except Exception:
                return 
            if pending_txn.get("confirmed-round", 0) > 0:
                return pending_txn
            elif pending_txn["pool-error"]:  
                raise Exception(
                    'pool error: {}'.format(pending_txn["pool-error"]))
            client.status_after_block(current_round)                   
            current_round += 1
        raise Exception(
            'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))

    @staticmethod
    def Token(token: str, path: str) -> Tuple[DopError, str]:
        ntoken: str = token
        if ntoken == '':
            try:
                with open(path, 'r') as f:
                    ntoken = f.readline()
            except Exception as e:
                #print(str(e))
                return (DopError(20,"An exception occurred while reading token file."),ntoken)

            l: list = ntoken.split('\n')
            ntoken = l[0]
        return (DopError(), ntoken)

    @staticmethod 
    def Port(port: str, path: str) -> Tuple[DopError, str]:
        nport: str = port
        host: str = ''
        if nport == '':
            try:
                with open(path, 'r') as f:
                    host = f.readline()
            except:
                return (DopError(21,"An exception occurred while reading port file."),nport)

        l: list = host.split('\n')
        host = l[0]
        l = host.split(':')
        if len(l) > 1:
            nport = l[1]

        return (DopError(), nport)
        
    def algodToken(self) -> Tuple[DopError, str]:
        """
        returns the token of necessary to connect to the algod node
        NOTE:   the token is retrieved by reading and parsing the file "$ALGORAND_DATA/algod.token"
                so this function requires the macro ALGORAND_DATA to be defined and available
                to the process calling this method
        """

        token: str
        if 'atoken' in self._i_config:
            #   atoken passed in connstring - ignore file containing token
            token = self._i_config['atoken']
            self._i_algo_token = token
            return DopError(),token

        err, token = self.Token(self._i_algo_token, self._i_algo_token_file)
        if err.code == 0:
            self._i_algo_token = token

        return (err,token)

    def algodPort(self) -> Tuple[DopError, str]:
        """
        returns the TCP port the algod node is listening to
        NOTE:   the port is retrieved by reading and parsing the file "$ALGORAND_DATA/algod.net"
                so this function requires the macro ALGORAND_DATA to be defined and available
                to the process calling this method
        """
        port: int
        if 'anetprt' in self._i_config:
            #   anetprt passed in connstring - ignore file containing port
            port = int(self._i_config['anetprt'])
            self._i_algo_port = port
            return DopError(),port

        err, port = self.Port(self._i_algo_port, self._i_algo_net_file)
        if err.code == 0:
            self._i_algo_port = port
        return (err, port)

    def kmdToken(self) -> Tuple[DopError, str]:
        token: str
        if 'ktoken' in self._i_config:
            #   atoken passed in connstring - ignore file containing token
            token = self._i_config['ktoken']
            self._i_kmd_token = token
            return DopError(),token

        err, token = self.Token(self._i_kmd_token, self._i_kmd_token_file)
        if err.code == 0:
            self._i_kmd_token = token
        return (err, token)

    def kmdPort(self) -> Tuple[DopError, str]:
        port: int
        if 'knetprt' in self._i_config:
            #   anetprt passed in connstring - ignore file containing port
            port = int(self._i_config['knetprt'])
            self._i_kmd_port = port
            return DopError(),port

        err, port = self.Port(self._i_kmd_port, self._i_kmd_net_file)
        if err.code == 0:
            self._i_kmd_port = port
        return (err, port)

    def kmd(self) -> Tuple[DopError, algosdk.kmd.KMDClient]:
        err, kmd_token = self.kmdToken()
        if err.code != 0:
            return (err,None)
        err, kmd_port = self.kmdPort()
        if err.code != 0:
            return (err,None)

        kmd_ip_address: str = 'http://localhost:' 
        if 'knetip' in self._i_config:
            kmd_ip_address = 'http://' + self._i_config['knetip'] + ':'
        kmd_address = kmd_ip_address + str(kmd_port)

        kcl = kmd.KMDClient(kmd_token, kmd_address)

        try:
            #   NOTE:           it seems that the kmd can be instantiated only if using localhost
            #                   to be checked with algorand
            kcl.versions()  #   generates an exception if the kcl is not connected
        except Exception:
            return(DopError(22, "An exception occurred while initializing kmd client."),kcl)

        return(DopError(),kcl)
    
    def algod(self) -> Tuple[DopError, algosdk.v2client.algod.AlgodClient]:
        #   get algod token
        err, algod_token = self.algodToken()
        if err.code != 0:
            return (err,None)
        #   get algod port
        err, algod_port = self.algodPort()
        if err.code != 0:
            return (err,None)
        #   get algo node address (default is localhost)

        algod_ip_address: str = 'http://localhost:' 
        if 'anetip' in self._i_config:
            algod_ip_address = 'http://' + self._i_config['anetip'] + ':'
        #algod_address = 'http://localhost:' + str(algod_port)
        algod_address = algod_ip_address + str(algod_port)
        algocl = algod.AlgodClient(algod_token, algod_address)

        #   check if the algod client is valid
        try:
            algocl.status()
        except Exception:
            return(DopError(23, "Error in initializing algod client."),algocl)

        return(DopError(),algocl)

    @staticmethod
    def getArgs(argsobj: dict) -> list:
        args = argsobj.get("args")

        if args==None:
            return None

        if len(args) < 1:
            return None

        b_args: list = []
        for item in args:
            b_args.append(bytes(item,'utf-8'))
        return b_args

    @staticmethod
    def getAccounts(argsobj: dict) -> list:
        args = argsobj.get("addrs")

        if args==None:
            return None

        if len(args) < 1:
            return None

        return args

    def dopSmartContract(
        self
    ,   algod_client: algosdk.v2client.algod.AlgodClient
    ,   appid:  int                     #   smart contract index (address)
    ,   owner_mnemonic: str             #   private key (mnemonic) of the owner of the smart contract
    ,   scarguments: dict               #   {"args":[argslist], "addrs":[accountaddresseslist]}
    ,   transaction_note: str           #   the note field withon the transaction
    ) -> Tuple[str, DopError]:               #   error code, transaction id

        #   retrieve and change suggested params (for the transaction)        
        #   this could become an argument, to be investigated (future releases)
        params = algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000

        txn_note = transaction_note.encode()

        err: DopError
        owner_private_key: str
        owner_private_key,err   = self.mnemonic_to_private_key(owner_mnemonic)
        if err.isError():
            return "",err

        owner_address       = account.address_from_private_key(owner_private_key)         #   this line to be deleted

        arguments_list   = self.getArgs(scarguments)
        accounts_list    = self.getAccounts(scarguments)

        unsigned_txn = ApplicationNoOpTxn(owner_address, params, appid, arguments_list, accounts_list, None, None, txn_note)
        signed_txn = unsigned_txn.sign(owner_private_key)

        txid = ''
        try:
            txid = algod_client.send_transaction(signed_txn)
            #   print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #print(err)
            return "", DopError(202,f"An exception occurred when sending transaction.")

        return(txid, DopError(0,""))      #   now the transaction can be waited for

    def __default(self):
        #   set default parameters
        self._i_algo_token      = ''
        self._i_algo_port       = ''
        self._i_algod_client    = None

        self._i_kmd_token       = ''
        self._i_kmd_port        = ''
        self._i_kmd_client      = None

        self._i_config: dict   = {}
        
        algorand_data_path: str = '/home/ecosteer/dop/externals/algorand/net1/Primary'
        if 'ALGORAND_DATA' in os.environ:
            algorand_data_path = os.environ['ALGORAND_DATA']

        self._i_algo_token_file     = algorand_data_path + '/algod.token'           #   this has to go
        self._i_config['atokf']     = algorand_data_path + '/algod.token'

        self._i_algo_net_file       = algorand_data_path + '/algod.net'             #   this has to go
        self._i_config['anetf']     = algorand_data_path + '/algod.net'

        self._i_kmd_token_file      = algorand_data_path + '/kmd-v0.5/kmd.token'    #   this has to go
        self._i_config['ktokf']     = algorand_data_path + '/kmd-v0.5/kmd.token'

        self._i_kmd_net_file        = algorand_data_path + '/kmd-v0.5/kmd.net'      #   this has to go
        self._i_config['knetf']     = algorand_data_path + '/kmd-v0.5/kmd.net'
        

        dop_smart_contract_root_path: str = '/home/ecosteer/dop/intermediation/algorand/DOP'
        self._i_config['scrf'] = dop_smart_contract_root_path

        user_wallet: str            = "unencrypted-default-wallet"                  # wallet where the users are created
        user_wallet_password: str   = ""                                            # password to access the wallet
        self._i_config['usrwlab']   = user_wallet
        self._i_config['usrwpwd']   = user_wallet_password


        if 'DOP_SMART_CONTRACT_ROOT_FOLDER' in os.environ:
            dop_smart_contract_root_path = os.environ['DOP_SMART_CONTRACT_ROOT_FOLDER']
            
        self._i_stateless_teal_template_path    = dop_smart_contract_root_path + '/dop.account/dop.account.teal.template'
        self._i_config['sttp'] = 'dop.account/dop.account.teal.template'
        self._i_teal_approval_program_path      = dop_smart_contract_root_path + '/dop.stateful/dop.stateful.teal'
        self._i_config['tapp'] = 'dop.stateful/dop.stateful.teal'
        self._i_teal_clear_program_path         = dop_smart_contract_root_path + '/dop.clear/basicClear.teal'
        self._i_config['tcpp'] = 'dop.clear/basicClear.teal'

        self._i_config['ownmne'] = ''


    #============================================================================
    #   abstract methods
    #============================================================================
    #   NOTE:   init must become an abstract method
    def init(self, constring: str) -> DopError:

        self.__default()
                
        #   convert connstring into a dict (see config_to_dict in shared.utils.py)
        temp_config: dict = {}

        temp_list: list = constring.split(';')
        for el in temp_list:
            ell = el.split('=')
            if len(ell) != 2:
                continue
            temp_config[ell[0]]=ell[1]

        pars: list = [
            'atokf',
            'anetf',
            'ktokf',
            'knetf',
            'atoken',
            'anetprt',
            'anetip',
            'ktoken',
            'knetprt',
            'knetip',
            'scrf',
            'sttp',
            'tapp',
            'tcpp',
            'usrwlab',
            'usrwpwd',
            'ownmne'
            ]

        for p in pars:
            if p in temp_config:
                self._i_config[p] = temp_config[p]


        
        #   connection string parameters
        #   label   type        logic
        #   ------+---------+------------------------------------------------------------------------------------------------
        #   atokf   string      absolute path of the algod.token file
        #   anetf   string      absolute path of the algod.net file     
        #   ktokf   string      absolute path of the kmd.token file
        #   knetf   string      absolute path of the kmd.net file
        #   atoken  string      algod token (if this is defined then atokf will not be used)
        #   anetprt int         algod tcp ip port (if this is defined then the anetf will not be used - anetip required)
        #   anetip  string      algod tcp ip address (if this is defined then the anetf will not be used - anetprt required)
        #   ktoken  string      kmd token (if this is defined then atokf will not be used)
        #   knetprt int         kmd tcp ip port (if this is defined then the knetf will not be used - knetip required)
        #   knetip  string      kmd tcp ip address (if this is defined then the knetf will not be used - knetprt required)
        #   scrf    string      smart contract root folder      : absolute path of the folder containing sttp, atpt and tcpp
        #   sttp    string      stateless teal template path    : relative path of the stateless teal template
        #   tapp    string      teal approval program path      : relative path of the teal approval program
        #   tcpp    string      teal clear program path         : relative path of the teal clear program
        #	usrwlab	string		user wallet (the wallet used by the worker to create accounts)
		#	usrwpwd	string		user wallet password

        #   ownmne  string      mnemonic of the owner account to be used to fund newly created accounts

        #   example 1 (can be used only if the kmd and algod are running on localhost)
        #   atokf=/home/ecosteer/algorand/net1/Primary/algod.token;anetf=/home/ecosteer/algorand/net1/Primary/algod.net;\
        #   ktokf=/home/ecosteer/algorand/net1/Primary/kmd.token;knetf=/home/ecosteer/algorand/net1/Primary/kmd.net;\
        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\
        #   sttp=dop.account/dop.account.teal.template;\
        #   tapp=dop.stateful/dop.stateful.teal;\
        #   tcpp=dop.clear/basicClear.teal;

        #   example 2 (to be used if the kmd and algod are running on a remote host)
        #   atoken=45d2689bb4b555b757b00972d82c0a872f7b2aa136a5351768280dbe7cf2e9b2;\
        #   anetprt=18445;\
        #   anetip=192.178.20.30;\
        #   ktoken=d278689bb4b555b7502030465782c0a872f7b2aa136a5351768280dbe7cf2ab90;\
        #   knetprt=18435;\
        #   knetip=192.178.20.30;\
        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\
        #   sttp=dop.account/dop.account.teal.template;\
        #   tapp=dop.stateful/dop.stateful.teal;\
        #   tcpp=dop.clear/basicClear.teal;

        #   test only
        for el in self._i_config:
            print(el + ':[' + self._i_config[el] + ']')
        
        return DopError(0, "")

    def open(self) -> DopError:
        """
            open the algod client and the kmd client
            the following properties are valorized:
            1)  _i_algod_token
            2)  _i_algod_port
            3)  _i_kmd_token
            4)  _i_kmd_port
        """


        #   self.algod
        #   sets self._i_algod_token and self._i_algod_port
        err, self._i_algod_client = self.algod()
        if err.isError():
            return err

        err, self._i_kmd_client = self.kmd()
        if err.isError():
            return err

        if 'ownmne' in self._i_config: 
            self._own_mnemonic = self._i_config['ownmne']
        else:
            self._own_mnemonic = None
            return DopError(201, "Owner mnemonic not provided.")

        return err

    def close(self) -> DopError:
        #   TODO:   check if algod and kmd client have to be "closed" 
        return DopError(0,"")


    def get_balance(self,
                    publisher_address: str,                         #   EoA address of the publisher (contract owner)
                    subscriber_address: str,                        #   EoA address of the subscriber we want to check the balance 
                    contract_address: str) -> Tuple[dict, DopError]:   #   address (blockchain layer) of the contract) -> Tuple[dict, DopError]:
        """
        in this version this method is not "really" implemented
        """
        response = {}
        response['subscribed'] = 1
        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use DB
        response['credit'] = 100
        response['debit'] = 0

        return response, DopError(0,"")

    def create_user(self, username: str, password: str) -> Tuple[str, str, DopError]: 
        """
            creates a blockchain account and returns the address (public key) of the account and the password
            of the account (ethereum: input password, algorand, generated private key)

        """
        user_address = ""
        wallet_id: str
        err: DopError

        wallet_name = self._i_config['usrwlab']
        wallet_password = self._i_config['usrwpwd']

        wallet_id, err = self.__wallet_id(wallet_name)
        if err.isError():
            return "","",err

        
        try:
            wallet = Wallet(wallet_name, wallet_password, self._i_kmd_client)
            #   create the account
            account_address     = wallet.generate_key()
            account_mnemonic, err    = self.__account_mnemonic(wallet_name,wallet_password,account_address)
            if err.isError():
                return "","",err
            #   return err=0,account_address
            return account_address, account_mnemonic,DopError(0,"")

        except Exception as err:
            #   likely the password is wrong
            print(err)      #   logging etc.
            return "","",DopError(203,"An exception occurred while creating user.")

        return "","",DopError(1000,"")             # never hit


        return (user_address,user_mnemonic,DopError(0,""))
    


    def get_wallet_balance(self, account_address: str, currency="algo") -> Tuple[str, DopError]:
        """
            TODO:       return account_balance, DopError (as usual)
            TODO:       the method name should be change into "get_account_balance" to disambiguate between account and wallet
            NOTE:       the abstract was defined with a str return value
        """
        if self._i_algod_client == None:
            return "", DopError(1,"Missing value for algod client.")

        try:
            #   address is the account address - for instance: "4KNM6V4O2WBD3N7C5HSCTFSM3LFOUS7DRGILFFG6U54TJZYHUYMDPN26KY"
            from_account_info = self._i_algod_client.account_info(account_address)
            #   the account balance is in micro algos
            account_balance = from_account_info.get('amount')
            #print("Origin Account balance     : [{} microAlgos]".format(from_account_info.get('amount')))
            return account_balance, DopError(0,"")
        except Exception:
            return "",DopError(204,"An exception occurred while getting wallet balance.")

        
    def deploy_contract(self,
                        publisher_address: str,                 #   address of the owner account
                        secret: str,                            #   secret for the owner account (algorand: private key mnemonic of the owner)
                        tariff_period: int,                     #   period of the tariff 
                        tariff_price: int                       #   price of a period
                        ) -> Tuple[Optional[str], DopError]:
        """
            NOTE:
                The abstract method returns a transaction hash that is inserted into the 
                rdbms (transactions schema) - as this is typically a pending operation finalized by an event emitted by the monitor.
                For Algorand: this might require a complete different logic of the processor "product_create.py" - possibly a 
                processor specific for Algorand will have to be implemented.
                See also monitor_des.py - it processes the event (DEPLOY_CONTRACT) that is
                meant to close the pending op

                NOTE:   EnableDeveloperAPI must be set to true (node configuration file)
                NOTE:   https://developer.algorand.org/docs/run-a-node/reference/config/

                TODO:   review static and private method dop_stateful/dop_stateless/__algorand_smart_contract_create
        """

        #   publisher_address:      not used
        #   tariff_period:          not used (for future release)
        #   tariff_price:           not used (for future release)
        #   secret: is the mnemonic of the publisher
        
        smart_contract_address: str     #   the address of the stateless smart contract (the smart contract linked to the stateful smart contract)
                                        #   as the previously defined abstract method allows tp return just two values
                                        #   we will not return the smart contract address for the moment - to be checked
                                        #   in this release the smart_comtract_address will be encoded using the following string:
                                        #   %smart_contract_adress%@%app_id

        app_id: str                     #   the application id (this id will have to be used for invoking the smart contract)
        err: DopError

        if self._i_algod_client == None:
            #   must open before
            return ("",DopError(1,"Missing value for algod client."))

        smart_contract_address, app_id, err = self.__algorand_smart_contract_create(self._i_algod_client, secret) 
        if err.isError():
            return "", err
        #   TODO check if stateless contract has to be funded
        encoded_smart_contract_address: str = smart_contract_address + '@' + str(app_id)
        return (encoded_smart_contract_address, err)

    def algorand_sub_optin(     #   ALGORAND SPECIFIC
        self,
        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in
        application_address: str    #   application index of the smart contract the account wants to opt into
        ) -> DopError:
        """
        Algorand specific (an account has to optin before subscribing to a smart contract)
        this methid can be called by a specific Algorand processor provider (not an abstract method),
        for instance by the processor provider that implement the subscription logic
        SO: it has not be implemented as a private method - but an Algorand specific method.

        NOTE:   the subscriber, before subscribing the contract X, MUST opt-in to the contract X
        """
        #   see 01_sub_optin.py
        
        if self._i_algod_client == None:
            return DopError(1,"Missing value for algod client.")

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP OPTIN".encode()

        err: DopError

        #subscriber_private_key = mnemonic.to_private_key(from_mnemonic)
        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)
        if err.isError():
            return err
        subscriber_address = account.address_from_private_key(subscriber_private_key)

        appid = int(application_address)
        unsigned_txn = ApplicationOptInTxn(subscriber_address, params, appid, None, None, None, None, txn_note)
        signed_txn = unsigned_txn.sign(subscriber_private_key)

        txid =''
        try:
            txid = self._i_algod_client.send_transaction(signed_txn)
            #   print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #   print(err)
            return DopError(205,"An exception occurred when sending optin transaction.")

        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  
            #   TODO: confirmed_txn can be used to provide detailed log, see next
            #   commented lines
            #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
            #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

        except Exception as err:
            #   print(err)
            return DopError(302,"An exception occurred while waiting for confirmation of optin transaction.")

        return DopError(0,"")


    def algorand_sub_optout(     #   ALGORAND SPECIFIC
        self,
        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in
        application_address: str    #   application index of the smart contract the account wants to opt into
        ) -> DopError:
        """
        Algorand specific (symmetric to algorand_sub_optin)
        NOTE:   a subscriber that has unsubscribed should call optout, too
        """
        
        if self._i_algod_client == None:
            return DopError(1,"Missing value for algod client.")

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP OPTOUT".encode()

        err: DopError
        subscriber_private_key: str

        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)
        if err.isError():
            return err
        subscriber_address = account.address_from_private_key(subscriber_private_key)

        appid = int(application_address)
        unsigned_txn = ApplicationCloseOutTxn(subscriber_address, params, appid, None, None, None, None, txn_note)
        signed_txn = unsigned_txn.sign(subscriber_private_key)

        txid =''
        try:
            txid = self._i_algod_client.send_transaction(signed_txn)
            #   print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #   print(err)
            return DopError(206,"An exception occurred when sending optout transaction.")

        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  
            #   TODO: confirmed_txn can be used to provide detailed log, see next
            #   commented lines
            #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
            #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

        except Exception as err:
            #   print(err)
            return DopError(303,"An exception occurred while waiting for \
                        confirmation of optout transaction.")

        return DopError(0,"")


    def subscribe(self,
                  subscriber_addr: str,             #   subscriber address
                  subscriber_psw: str,              #   private key mnemonic
                  contract_address: str,            #   algorand application index
                  secret: str                       #   not used in this release
                  ) -> Tuple[str, DopError]:  
        """
        Subscribe to a contract
        """

        if self._i_algod_client == None:
            return "",DopError(1,"")        #   must be connected to a node

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP SUBSCRIBE".encode()

    #   the transaction type that has to be sent is of type ApplicationNoOpTxn
    #   see https://github.com/algorand/py-algorand-sdk/blob/5ca32cea62168ae339ccfdfbefaa6bc6ac094052/algosdk/future/transaction.py#L2040
    #   line 2040
        
        err: DopError
        subscriber_private_key: str

        subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)
        if err.isError():
            return "",err

        subscriber_address = account.address_from_private_key(subscriber_private_key)

        app_args : list = []
        app_args.append(bytes('subscribe','utf-8'))
        unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, contract_address, app_args, None, None, None, txn_note)
        signed_txn = unsigned_txn.sign(subscriber_private_key)

        txid = ''
        try:
            txid = self._i_algod_client.send_transaction(signed_txn)
            #print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #print(err)
            return "", DopError(207,"An exception occurred when sending subscribe transaction.")

        # wait for confirmation 
        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client,txid,4)

            #print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
            #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

        except Exception as err:
            #print(err)
            return "",DopError(304,"An exception occurred while waiting for confirmation \
                    of subscribe transaction.")

        return txid,DopError(0,"")


    def unsubscribe(self, 
                    subscriber_addr: str,               #   not used
                    subscriber_psw: str,                #   subscriber account private key mnemonic
                    contract_address: str             #   application index
                    #,secret: str                         #   not used 
                    ) -> Tuple[str, DopError]:
            """
            UnSubscribe from a contract
            return transaction id
            """

            if self._i_algod_client == None:
                return "",DopError(1,"Missing value for algod client.")        #   must be connected to a node

            params = self._i_algod_client.suggested_params()
            params.flat_fee = True
            params.fee = 1000
            txn_note = "DOP UNSUBSCRIBE".encode()

            err: DopError
            subscriber_private_key: str
            subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)
            if err.isError():
                return "",err
            subscriber_address = account.address_from_private_key(subscriber_private_key)

            application_index = int(contract_address)

            app_args : list = []
            app_args.append(bytes('unsubscribe','utf-8'))
            unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, application_index, app_args, None, None, None, txn_note)
            signed_txn = unsigned_txn.sign(subscriber_private_key)

            txid = ''
            try:
                txid = self._i_algod_client.send_transaction(signed_txn)
                #print("Successfully sent transaction with txID: {}".format(txid))

            except Exception as err:
                #print(err)
                return "", DopError(208,'An exception occurred when sending unsubscribe transaction.')

            # wait for confirmation 
            try:
                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  

                #print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
                #print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

            except Exception as err:

                return "",DopError(305,'An exception occurred while waiting for \
                            confirmation of unsubscribe transaction')

            return txid,DopError(0,'')


    def grant(self,
              publisher_address: str,       #   not used
              publisher_passw: str,         #   publisher private key mnemonic
              contract_address: str,        #   application index            
              subscriber_address: str       #   address of the subscriber to be granted
              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError
              
            # see 06_pub_call_grant.py
            if self._i_algod_client == None:
                return "",DopError(1,"Missing value for algod client.")

            smart_contract_arguments = {
                    "args":     ['grant']                   #   list of app arguments
                ,   "addrs":    [subscriber_address]        #   list of account arguments
                }

            transaction_note = "DOP GRANT"

            err: DopError
            txid: str = ""
            txid, err = self.dopSmartContract(
                self._i_algod_client
            ,   int(contract_address)
            ,   publisher_passw
            ,   smart_contract_arguments
            ,   transaction_note
            )

            if err.isError():
                return "",err

            try:
                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  

                #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
                #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

            except Exception as err:
                #print(err)
                return txid,DopError(306,"An exception occurred while waiting for \
                    confirmation of grant transaction.")

            return txid,DopError(0,"")
            



    def revoke(self,
              publisher_address: str,       #   not used
              publisher_passw: str,         #   publisher private key mnemonic
              contract_address: str,        #   application index            
              subscriber_address: str       #   address of the subscriber to be revoked
              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError

              # see 07_pub_call_revoke.py
            if self._i_algod_client == None:
                return "",DopError(1,"Missing value for algod client.")

            smart_contract_arguments = {
                "args":     ['revoke']                   #   list of app arguments
            ,   "addrs":    [subscriber_address]        #   list of account arguments
            }

            transaction_note = "DOP REVOKE"

            txid: str = ""
            err: DopError
            txid, err = self.dopSmartContract(
                self._i_algod_client
            ,   contract_address
            ,   publisher_passw
            ,   smart_contract_arguments
            ,   transaction_note
            )

            if err.isError():
                return "",err

            try:
                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  

                #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
                #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

            except Exception as err:
                #print(err)
                return txid,DopError(307,"An exception occurred while waiting for \
                    confirmation of revoke transaction.")

            return txid,DopError(0,"")



    def balance(self,
                subscriber_address: str,                            #   subscriber EoA address
                secret: str,                                        #   subscriber contract secret
                contract_address: str) -> Tuple[dict, DopError]:       #   address (blockchain layer) of the contract
        """
        Get the balance of a user with `address` of the contract with `contract_address`
        """
        """
        in this version this method is not "really" implemented
        """
        response = {}
        response['subscribed'] = 1
        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use postgres DB
        response['credit'] = 100
        response['debit'] = 0

        return (response, DopError(0,""))

    
    def admin_get_grants(self,
                        publisher_address: str,             #   EoA address of the publisher (contract owner)
                        contract_address: str) -> Tuple[list, DopError]:    #   address (blockchain layer) of the contract
        """
        This method is used by the publisher only in order to retrieve the list 
        of the EoA address of the granted subscribers
        """
        return [], DopError()


    def set_starting_balance(self, 
                            address,
                            amount) -> str: # EoA of the user 
        """
        Sets the starting balance of an EoA
        """
        #self._own_mnemonic = "ability improve suspect canyon castle fire flock forum monitor travel know write similar denial thought \
        #    online ripple squeeze this finish jar parrot rabbit ability crouch"
        if self._own_mnemonic == None:
            return ""

        txid, err = self.__account_send(from_mnemonic = self._own_mnemonic, to_address=address, amount=amount)
        if err.isError():
            return "" 

        return txid





# File: https://github.com/Fracture-Labs/FractureDAO/blob/c41923fed2b894e4fde9b7dc1c687917beff4d5a/contract/contract.py
from pyteal import *
import os

# Global state 
# - totalApproved (int)

# Local state 
# Delegatee account (6 int)
# - NumOfTrustees (int)
# - Threshold (int) 
# - Trustee_address (max 4): Trustee_approval_status (unapproved: Int(1), approved: Int(2)) (int)

def approval_program():
    
    on_create = Seq(
        App.globalPut(Bytes("totalApproved"), Int(0)),
        Approve(),
    )


    # Ensure trustee has not approved before
    # get(delegatee_account, key_of_sender_aka_trustee)
    # Note: if the key is not there, Int(0) is returned so we cannot initialise it as UInt(0) 
    ensure_trustee_unapproved = Int(1) == App.localGet(Txn.accounts[1], Txn.accounts[0])
    ensure_unapproved = Int(1) == App.localGet(Txn.accounts[1], Txn.accounts[0])
    num_of_approved_trustees = App.localGet(Txn.accounts[1], Bytes("Approved"))
    threshold = App.localGet(Txn.accounts[1], Bytes("Threshold"))
    g_approved = App.globalGet(Bytes("totalApproved"))

    new_num_of_approved_trustees = ScratchVar(TealType.uint64)
    new_g_approved = ScratchVar(TealType.uint64)
    on_req_kfrags = Seq(
        # Ensure there is a target account to apporve for
        Assert(Txn.accounts.length() == Int(1)),
        # Ensure this trustee has not previously approved this account
        Assert(ensure_trustee_unapproved),
        # Ensure this account has not been approved
        Assert(ensure_unapproved),
        # Store state to approve the account
        App.localPut(Txn.accounts[1], Txn.accounts[0], Int(2)),
        # Store state of new total approved trustees 
        new_num_of_approved_trustees.store(num_of_approved_trustees + Int(1)),
        App.localPut(Txn.accounts[1], Bytes("Approved"), new_num_of_approved_trustees.load()),
        # Update global state if it has been approved
        If(new_num_of_approved_trustees.load() >= threshold)
        .Then(App.globalPut(Bytes("totalApproved"), g_approved + Int(1))),
        Approve(),
    )

    on_call = Seq(
        # First, lets fail immediately if this transaction is grouped with any others
        Assert(Global.group_size() == Int(1)), 
        Cond(
            [Txn.application_args[0] == Bytes("reqKfrags"), on_req_kfrags ],
        )
    )

    # OptIn from the delegatee
    # - allows the app to write into their local state
    # - take the Txn.accounts max 4 https://developer.algorand.org/docs/get-details/parameter_tables/?from_query=reference%20#smart-signature-constraints
    i = ScratchVar(TealType.uint64)
    on_optIn = Seq(
        Assert(Txn.accounts.length() > Int(0)),
        # Threshold for approval
        Assert(Btoi(Txn.application_args[0]) <= Txn.accounts.length()),
        # Loop through all the foreign accounts (aka trustees)
        i.store(Int(1)),
        While(i.load() < Txn.accounts.length()+Int(1) ).Do(Seq([
        # Set Approved state as unapproved Int(1)
        App.localPut(Txn.accounts[0], Txn.accounts[i.load()], Int(1)),
        i.store(i.load() + Int(1))
        ])),
        # Set NumOfTrustees given
        App.localPut(Txn.accounts[0], Bytes("NumOfTrustees"), Txn.accounts.length()),
        # Set Threshold required to approve kfrags 
        App.localPut(Txn.accounts[0], Bytes("Threshold"), Btoi(Txn.application_args[0])),
        App.localPut(Txn.accounts[0], Bytes("Approved"), Int(0)),
        Approve(),
    )

    program = Cond(
        [Txn.application_id() == Int(0), on_create],
        [Txn.on_completion() == OnComplete.NoOp, on_call],
        [Txn.on_completion() == OnComplete.OptIn, on_optIn],
        [
            Or(
                Txn.on_completion() == OnComplete.CloseOut,
                Txn.on_completion() == OnComplete.UpdateApplication,
            ),
            Reject(),
        ],
    )

    return compileTeal(program, Mode.Application, version=5)

def clear_state_program():
   program = Approve()
   # Mode.Application specifies that this is a stateful smart contract
   return compileTeal(program, Mode.Application, version=5)

path = os.path.dirname(os.path.abspath(__file__))


# compile program to TEAL assembly
with open(os.path.join(path, "./approval.teal"), "w") as f:
    approval_program_teal = approval_program()
    f.write(approval_program_teal)


    # compile program to TEAL assembly
with open(os.path.join(path, "./clear.teal"), "w") as f:
    clear_state_program_teal = clear_state_program()
    f.write(clear_state_program_teal)
    
print(approval_program())
print(clear_state_program())



# File: https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/is_deletable.py
"""Detector for finding execution paths missing DeleteApplication check."""

from typing import List, TYPE_CHECKING, Tuple

from tealer.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DetectorType,
)

from tealer.detectors.utils import (
    detect_missing_tx_field_validations_group,
    detect_missing_tx_field_validations_group_complete,
)
from tealer.utils.teal_enums import TealerTransactionType
from tealer.utils.output import ExecutionPaths

if TYPE_CHECKING:
    from tealer.utils.output import ListOutput
    from tealer.teal.basic_blocks import BasicBlock
    from tealer.teal.context.block_transaction_context import BlockTransactionContext
    from tealer.teal.teal import Teal


class IsDeletable(AbstractDetector):  # pylint: disable=too-few-public-methods
    """Detector to find execution paths missing DeleteApplication check.

    Stateful smart contracts(application) can be deleted in algorand. If the
    application transaction of type DeleteApplication is approved by the application,
    then the application will be deleted. Contracts can check the application
    transaction type using OnCompletion field.

    This detector tries to find execution paths that approve the application
    transaction("return 1") and doesn't check the OnCompletion field against
    DeleteApplication value. Execution paths that only execute if the application
    transaction is not DeleteApplication are excluded.
    """

    NAME = "is-deletable"
    DESCRIPTION = "Deletable Applications"
    TYPE = DetectorType.STATEFULL

    IMPACT = DetectorClassification.HIGH
    CONFIDENCE = DetectorClassification.HIGH

    WIKI_URL = "https://github.com/crytic/tealer/wiki/Detector-Documentation#deletable-application"
    WIKI_TITLE = "Deletable Application"
    WIKI_DESCRIPTION = (
        "Application can be deleted by sending an `DeleteApplication` type application call. "
    )
    WIKI_EXPLOIT_SCENARIO = """
```py
@router.method(delete_application=CallConfig.CALL)
def delete_application() -> Expr:
    return Assert(Txn.sender() == Global.creator_address())
```

Eve steals application creator's private key and deletes the application. Application's assets are permanently lost.
"""

    WIKI_RECOMMENDATION = """
Do not approve `DeleteApplication` type application calls.
"""

    def detect(self) -> "ListOutput":
        """Detect execution paths with missing DeleteApplication check.

        Returns:
            ExecutionPaths instance containing the list of vulnerable execution
            paths along with name, check, impact, confidence and other detector
            information.
        """

        def checks_field(block_ctx: "BlockTransactionContext") -> bool:
            # return False if Txn Type can be DeleteApplication.
            # return True if Txn Type cannot be DeleteApplication.
            return not TealerTransactionType.ApplDeleteApplication in block_ctx.transaction_types

        # there should be a better to decide which function to call ??
        if self.tealer.output_group:
            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:
            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance
            return list(
                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)
            )

        output: List[
            Tuple["Teal", List[List["BasicBlock"]]]
        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)
        detector_output: "ListOutput" = []
        for contract, vulnerable_paths in output:
            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))

        return detector_output


# File: https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/adaptors/algod_application.py
from base64 import b64decode
from typing import List, Optional, cast

from algosdk.v2client import models
from pyk.kast.inner import KApply, KInner, KLabel, KSort, KToken
from pyk.kast.manip import split_config_from

from kavm.adaptors.teal_key_value import (
    list_state_to_dict_bytes_bytes,
    list_state_to_dict_bytes_ints,
    teal_key_value_store_from_k_cell,
)
from kavm.pyk_utils import map_bytes_bytes, map_bytes_ints


class KAVMApplicationParams(models.ApplicationParams):
    inverted_attribute_map = {v: k for k, v in models.ApplicationParams.attribute_map.items()}


class KAVMApplication(models.Application):
    """
    Convenience class abstracting an Algorand smart contract (aka stateful application)
    """

    inverted_attribute_map = {v: k for k, v in models.Application.attribute_map.items()}

    @staticmethod
    def from_k_cell(term: KInner, creator: str) -> 'KAVMApplication':
        """
        Parse a KAVMApplication instance from a Kast term
        """
        (_, subst) = split_config_from(term)
        parsed_app_id = int(cast(KToken, subst['APPID_CELL']).token)
        parsed_approval_program = b64decode(cast(KToken, subst['APPROVALPGM_CELL']).token)
        parsed_clear_state_program = b64decode(cast(KToken, subst['CLEARSTATEPGM_CELL']).token)
        parsed_global_state = teal_key_value_store_from_k_cell(
            subst['GLOBALINTS_CELL']
        ) + teal_key_value_store_from_k_cell(subst['GLOBALBYTES_CELL'])
        parsed_params = KAVMApplicationParams(
            # approval_pgm_src=subst['APPROVALPGMSRC_CELL'],
            # clear_state_pgm_src=subst['CLEARSTATEPGMSRC_CELL'],
            creator=creator,
            approval_program=parsed_approval_program if parsed_approval_program else None,
            clear_state_program=parsed_clear_state_program if parsed_clear_state_program else None,
            local_state_schema=models.ApplicationStateSchema(
                num_uint=int(cast(KToken, subst['LOCALNUMINTS_CELL']).token),
                num_byte_slice=int(cast(KToken, subst['LOCALNUMBYTES_CELL']).token),
            ),
            global_state_schema=models.ApplicationStateSchema(
                num_uint=int(cast(KToken, subst['GLOBALNUMINTS_CELL']).token),
                num_byte_slice=int(cast(KToken, subst['GLOBALNUMBYTES_CELL']).token),
            ),
            global_state=parsed_global_state if len(parsed_global_state) else None,
            # extra_pages=int(cast(KToken, subst['EXTRAPAGES_CELL']).token),
        )
        return KAVMApplication(id=parsed_app_id, params=parsed_params)


def application_k_term(
    app_id: int,
    global_state_schema: Optional[models.ApplicationStateSchema] = None,
    local_state_schema: Optional[models.ApplicationStateSchema] = None,
    global_state: Optional[List[models.TealKeyValue]] = None,
) -> KInner:
    global_num_ints = global_state_schema.num_uint if global_state_schema else 0
    global_num_byte_slice = global_state_schema.num_byte_slice if global_state_schema else 0
    local_num_ints = local_state_schema.num_uint if local_state_schema else 0
    local_num_byte_slice = local_state_schema.num_byte_slice if local_state_schema else 0
    global_bytes = list_state_to_dict_bytes_bytes(global_state) if global_state else {}
    global_ints = list_state_to_dict_bytes_ints(global_state) if global_state else {}

    return KApply(
        label=KLabel(name='<app>', params=()),
        args=(
            KApply(label=KLabel(name='<appID>', params=()), args=(KToken(token=str(app_id), sort=KSort(name='Int')),)),
            KApply(
                label=KLabel(name='<approvalPgmSrc>', params=()),
                args=(KApply(label=KLabel(name='.K', params=()), args=()),),
            ),
            KApply(
                label=KLabel(name='<clearStatePgmSrc>', params=()),
                args=(KApply(label=KLabel(name='.K', params=()), args=()),),
            ),
            KApply(
                label=KLabel(name='<approvalPgm>', params=()), args=(KToken(token='""', sort=KSort(name='String')),)
            ),
            KApply(
                label=KLabel(name='<clearStatePgm>', params=()), args=(KToken(token='""', sort=KSort(name='String')),)
            ),
            KApply(
                label=KLabel(name='<globalState>', params=()),
                args=(
                    KApply(
                        label=KLabel(name='<globalNumInts>', params=()),
                        args=(KToken(token=str(global_num_ints), sort=KSort(name='Int')),),
                    ),
                    KApply(
                        label=KLabel(name='<globalNumBytes>', params=()),
                        args=(KToken(token=str(global_num_byte_slice), sort=KSort(name='Int')),),
                    ),
                    KApply(
                        label=KLabel(name='<globalBytes>', params=()),
                        args=[map_bytes_bytes(global_bytes)],
                    ),
                    KApply(
                        label=KLabel(name='<globalInts>', params=()),
                        args=[map_bytes_ints(global_ints)],
                    ),
                ),
            ),
            KApply(
                label=KLabel(name='<localState>', params=()),
                args=(
                    KApply(
                        label=KLabel(name='<localNumInts>', params=()),
                        args=(KToken(token=str(local_num_ints), sort=KSort(name='Int')),),
                    ),
                    KApply(
                        label=KLabel(name='<localNumBytes>', params=()),
                        args=(KToken(token=str(local_num_byte_slice), sort=KSort(name='Int')),),
                    ),
                ),
            ),
            KApply(label=KLabel(name='<extraPages>', params=()), args=(KToken(token='0', sort=KSort(name='Int')),)),
        ),
    )


# File: https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/permissioned-voting/assets/permissioned-voting-approval.py
from pyteal import *

def approval_program():
    """
    https://developer.algorand.org/solutions/example-permissioned-voting-stateful-smart-contract-application/?query=asset%2520contract
    To implement a permissioned voting application on Algorand, a central authority is needed to
    provide users the right to vote. In this example, this is handled by an Algorand Standard
    Asset. The central authority creates a vote token and then gives voters who have registered
    one voting token. The voter then registers within a round range with the voting smart
    contract, by Opting into the contract. Voters then vote by grouping two transactions.
    The first is a smart contract call to vote for either candidate A or candidate B, and
    the second is transferring the vote token back to the central authority. Voting is only
    allowed within the voting range.
    """
    # Check to see that the application ID is not set, indicating this is a creation call.
    # Store the creator address to global state.
    # Store both register and voting round ranges to global state.
    # Store Asset ID to global state
    on_creation = Seq([
        App.globalPut(Bytes("Creator"), Txn.sender()),
        Assert(Txn.application_args.length() == Int(5)),
        App.globalPut(Bytes("RegBegin"), Btoi(Txn.application_args[0])),
        App.globalPut(Bytes("RegEnd"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("VoteBegin"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("VoteEnd"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("AssetID"), Btoi(Txn.application_args[4])),
        Return(Int(1))
    ])

    # Always verify that the RekeyTo property of any transaction is set to the ZeroAddress
    # unless the contract is specifically involved ina rekeying operation.
    no_rekey_addr = Txn.rekey_to() == Global.zero_address()

    # Checks whether the sender is creator.
    is_creator = Txn.sender() == App.globalGet(Bytes("Creator"))

    # Checks whether sender has voted before or not.
    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))

    on_closeout = Seq([
        get_vote_of_sender,
        If(And(Global.round() <= App.globalGet(Bytes("VoteEnd")), get_vote_of_sender.hasValue()),
            App.globalPut(get_vote_of_sender.value(), App.globalGet(get_vote_of_sender.value()) - Int(1))
        ),
        Return(Int(1))
    ])

    # Checks that the first argument to the smart contract is the word register.
    # Verifies that the round is currently between registration begin and end rounds.
    on_register = Return(
        And(
        no_rekey_addr,
        Txn.application_args[0] == Bytes("register"),
        Global.round() >= App.globalGet(Bytes("RegBegin")),
        Global.round() <= App.globalGet(Bytes("RegEnd")))
    )

    # Verifies the first application argument contains the string vote.
    # Verifies the vote call is between the beginning and end of the voting round ranges.
    # Verifies that two transactions are in the group.
    # Checks that the second transaction is an asset transfer, and the token transferred is the vote token.
    # Checks that the second transaction receiver is the creator of the application.
    # Checks if the account has already voted, and if so, just returns true with no change to global state.
    # Verifies that the user is either voting for candidate A or B.
    # Reads the candidates current total from the global state and increments the value.
    # Stores the candidate choice to the users local state.
    choice = Txn.application_args[1]
    choice_tally = App.globalGet(choice)
    on_vote = Seq([
        Assert(And(
            no_rekey_addr,
            Global.round() >= App.globalGet(Bytes("VoteBegin")),
            Global.round() <= App.globalGet(Bytes("VoteEnd"))
        )),
        Assert(And(
            Global.group_size() == Int(2),
            Gtxn[1].type_enum() == TxnType.AssetTransfer,
            Gtxn[1].asset_receiver() == App.globalGet(Bytes("Creator")),
            Gtxn[1].xfer_asset() == App.globalGet(Bytes("AssetID")),
            Gtxn[1].asset_amount() == Int(1),
            Or(choice == Bytes("candidatea"), choice == Bytes("candidateb"))
        )),
        get_vote_of_sender,
        If(get_vote_of_sender.hasValue(),
            Return(Int(0))
        ),
        App.globalPut(choice, choice_tally + Int(1)),
        App.localPut(Int(0), Bytes("voted"), choice),
        Return(Int(1))
    ])

    # Verfies that the application_id is 0, jumps to on_creation.
    # Verifies that DeleteApplication is used and verifies that sender is creator.
    # Verifies that UpdateApplication is used and verifies that sender is creator.
    # Verifies that closeOut is used and jumps to on_closeout.
    # Verifies that the account has opted in and jumps to on_register.
    # Verifies that first argument is "vote" and jumps to on_vote.
    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, on_register],
        [Txn.application_args[0] == Bytes("vote"), on_vote]
    )

    return program

optimize_options = OptimizeOptions(scratch_slots=True)
if __name__ == "__main__":
    print(compileTeal(approval_program(), Mode.Application, version = 5, optimize=optimize_options))


# File: https://github.com/defimono/algorand_asset_price_oracle/blob/8a2d410737d0795ea2f5a7e497b03f39e84af00c/handler.py
import json

from algosdk import account
from algosdk.future import transaction
from algosdk.future.transaction import wait_for_confirmation
from dotenv import load_dotenv

from modules.config.algod_client import initialize_algod_client
from modules.config.load_config import load_config
from modules.config.logger import logger
import requests

load_dotenv()


def get_updated_price():
    """
    Query public API for ALGO price information. Will query, parse, and return a float representation pegged to USD.
    :return: float representation of price
    """
    url = "https://api.coinbase.com/v2/prices/ALGO-USD/buy"

    raw_response = requests.get(url)

    price_data = raw_response.json()

    real_price = price_data.get('data').get('amount')

    parsed_price = float(real_price)

    logger.info("Got real price from coinbase set to: ${}".format(parsed_price))

    return parsed_price


def call_noop(algod_client, app_id, private_key, app_args):
    """
    Call the update function in the deployed application with the new application TEAL
    :param algod_client: preconfigured algod client for desired chain (main, test, or beta)
    :param app_args: app args to pass to teal function inside smart contract on chain
    :param app_id: application id to update
    :param private_key: private key to authenticate and approve ourselves following the teal logic
    :return: raw transaction response of the update function
    """
    sender = account.address_from_private_key(private_key)

    logger.debug("Sender wallet: {}".format(sender))

    # get node suggested parameters
    params = algod_client.suggested_params()

    logger.debug("params: {}".format(params))

    # create unsigned transaction
    txn = transaction.ApplicationNoOpTxn(sender, params, app_id, app_args)

    logger.debug("txn: {}".format(txn))

    # sign transaction
    signed_txn = txn.sign(private_key)

    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    algod_client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(algod_client, tx_id, 10)


def lambda_handler(event, context):
    try:
        app_config = load_config()

        algod_address = app_config.get("algod_address")

        algod_token = app_config.get("algod_token")

        algod_client = initialize_algod_client(algod_address, algod_token)

        oracle_app_id = app_config.get("oracle_app_id")

        admin_private_key = app_config.get("admin_private_key")

        # get new price
        real_price = get_updated_price()

        # Real price is to fixed point to get round the issues with float in
        # teal
        price_fixed_point = int(real_price * 10 ** 2)

        logger.info(
            "Setting 2 digit fixed point price to: {} ".format(price_fixed_point))

        # call noop with new price and sign with service account
        # 2 meas we want two digits in the fixed point precision of the price
        app_args = ["update_price", price_fixed_point, 2]

        # Call the update operation in the published stateful algorand smart
        # contract
        call_noop(algod_client, oracle_app_id, admin_private_key, app_args)

        logger.info("Application update called successfully")

        # If called via API Gateway, return a formatted response body as
        # needed.
        response = {
            "statusCode": 200,
            "body": json.dumps(price_fixed_point)
        }

        return response

    except Exception as error:
        logger.error("{}".format(error))

        response = {
            "statusCode": 500,
            "body": json.dumps(error)
        }

        return response


if __name__ == "__main__":
    """
    Local development helper.
    """
    logger.info(lambda_handler(None, None))


# File: https://github.com/aldur/tc-asa/blob/3570860ecc32d92ace483e2f3472b0a301f4cdc2/tc_asa.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Transfer-controlled Algorand Standard Asset (TC-ASA).

Ties an ASA to an ASC (Algorand Smart Contract) and exposes methods to
mint/burn/transfer.

Enables custom / extended logic around transfers.
"""

import dataclasses

from pyteal import (
    And,
    App,
    Approve,
    Assert,
    AssetHolding,
    Bytes,
    Cond,
    Expr,
    Global,
    InnerTxnBuilder,
    Int,
    Mode,
    Not,
    OnComplete,
    Or,
    Reject,
    Seq,
    Txn,
    TxnField,
    TxnType,
    compileTeal,
)
from pyteal.ast.asset import AssetParam

from state import AVMState
from abi import ABI

TEAL_VERSION = 6


@dataclasses.dataclass
class Config(AVMState):
    master: AVMState.Address  # Master address (can be multi-sig)

    # The asset may be globally "frozen", no transfers will be approved until it is "unfrozen".
    is_frozen: AVMState.UInt = AVMState.UInt(0)

    # Corresponding ASA token
    asa: AVMState.UInt = AVMState.UInt(0)  # Wil be set by `init`


@dataclasses.dataclass
class LocalConfig(AVMState):
    is_locked: AVMState.UInt = AVMState.UInt(0)
    is_whitelisted: AVMState.UInt = AVMState.UInt(0)


Keys = Config.to_keys("Keys")
LocalKeys = LocalConfig.to_keys("LocalKeys")


TC_ASA_RESERVE = Global.current_application_address()


UNLOCKED = Int(ABI.FALSE)
LOCKED = Int(ABI.TRUE)
LOCK_INTERFACE = {
    "name": "setLock",
    "args": [
        {"name": "user", "type": "account", "desc": "User to lock/unlock."},
        {
            "name": "isLocked",
            "type": "bool",
            "desc": "Lock (`true`) / unlock (`false`).",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(LOCK_INTERFACE)
def set_lock_unlock(args: ABI.TealArgs) -> Expr:
    """
    Specific users may be "locked" by `master` so that they cannot transfer
    their tokens without being "unlocked first".
    """
    is_locked_arg = args.isLocked
    precondition = And(
        is_master(Txn.sender()),
        Or(  # Pedantic
            is_locked_arg == UNLOCKED,
            is_locked_arg == LOCKED,
        ),
        Not(App.localGet(args.user, LocalKeys.is_locked) == is_locked_arg),
    )

    return Seq(
        Assert(precondition),
        # Lock user (account #1)
        App.localPut(args.user, LocalKeys.is_locked, is_locked_arg),
        Approve(),
    )


def _is_locked(account: Expr) -> Expr:
    return App.localGet(account, LocalKeys.is_locked) == LOCKED


NOT_WHITELISTED = Int(ABI.FALSE)
WHITELISTED = Int(ABI.TRUE)
WHITELIST_INTERFACE = {
    "name": "setWhitelist",
    "args": [
        {"name": "user", "type": "account", "desc": "User to whitelist."},
        {
            "name": "isWhitelisted",
            "type": "bool",
            "desc": "Whitelist (`true`) / remove whitelist (`false`).",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(WHITELIST_INTERFACE)
def set_whitelist(args: ABI.TealArgs) -> Expr:
    """
    Whitelist a user.
    """
    whitelist_arg = args.isWhitelisted
    precondition = And(
        is_master(Txn.sender()),
        Or(  # Pedantic
            whitelist_arg == NOT_WHITELISTED,
            whitelist_arg == WHITELISTED,
        ),
        Not(App.localGet(args.user, LocalKeys.is_whitelisted) == whitelist_arg),
    )

    return Seq(
        Assert(precondition),
        # Whitelist user (account #1)
        App.localPut(args.user, LocalKeys.is_whitelisted, whitelist_arg),
        Approve(),
    )


def _is_whitelisted(account: Expr) -> Expr:
    return App.localGet(account, LocalKeys.is_whitelisted) == WHITELISTED


NOT_FROZEN = Int(ABI.FALSE)
FROZEN = Int(ABI.TRUE)
FREEZE_INTERFACE = {
    "name": "setFreeze",
    "args": [
        {
            "name": "isFrozen",
            "type": "bool",
            "desc": "Frozen (`true`) / not frozen (`false`).",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(FREEZE_INTERFACE)
def set_freeze_unfreeze_token(args: ABI.TealArgs) -> Expr:
    """
    The asset may be "frozen" by `master`, at which point no transfers will be
    approved until it is "unfrozen".
    """
    freeze_arg = args.isFrozen

    precondition = And(
        is_master(Txn.sender()),
        Or(  # Pedantic
            freeze_arg == NOT_FROZEN,
            freeze_arg == FROZEN,
        ),
        Not(App.globalGet(Keys.is_frozen) == freeze_arg),
    )

    return Seq(
        Assert(precondition),
        App.globalPut(Keys.is_frozen, freeze_arg),
        Approve(),
    )


def _is_frozen():
    return App.globalGet(Keys.is_frozen) == FROZEN


def is_master(account: Expr) -> Expr:
    """
    Check whether the provided `account` is the `master`.
    """
    return account == App.globalGet(Keys.master)


MINT_INTERFACE = {
    "name": "mint",
    "args": [
        {
            "name": "user",
            "type": "account",
            "desc": "The user that will receive the funds.",
        },
        {
            "name": "amount",
            "type": "uint64",
            "desc": "Amount of funds to mint to the user.",
        },
        {
            "name": "asset",
            "type": "asset",
            "desc": "Reference to the ASA controlled by this smart contract.",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(MINT_INTERFACE)
def mint(args: ABI.TealArgs) -> Expr:
    """
    `master` can mint new tokens into circulation.

    The `user` receiving the funds must be `whitelisted` and the asset must NOT
    be `frozen`.
    """
    asset = args.asset
    is_tc_asa = asset_is_tc_asa(asset)

    user = args.user
    amount = args.amount
    positive_amount = amount > Int(0)

    token_is_not_frozen = Not(_is_frozen())
    user_is_whitelisted = _is_whitelisted(args.user)

    precondition = And(
        is_master(Txn.sender()),
        is_tc_asa,
        positive_amount,
        token_is_not_frozen,
        user_is_whitelisted,
    )

    tc_asa_mint = [
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),
        InnerTxnBuilder.SetField(TxnField.xfer_asset, App.globalGet(Keys.asa)),
        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),
        InnerTxnBuilder.SetField(TxnField.asset_receiver, user),
        InnerTxnBuilder.SetField(TxnField.asset_sender, TC_ASA_RESERVE),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.Submit(),
    ]

    return Seq(
        Assert(precondition),
        *tc_asa_mint,
        Approve(),
    )


BURN_INTERFACE = {
    "name": "burn",
    "args": [
        {
            "name": "user",
            "type": "account",
            "desc": "Funds will be burned from this user's balance.",
        },
        {
            "name": "amount",
            "type": "uint64",
            "desc": "Amount of funds to burn.",
        },
        {
            "name": "asset",
            "type": "asset",
            "desc": "Reference to the ASA controlled by this smart contract.",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(BURN_INTERFACE)
def burn(args: ABI.TealArgs) -> Expr:
    """
    `master` can transfer from a user back to the treasury.
    """
    asset = args.asset
    user = args.user
    amount = args.amount
    is_tc_asa = asset_is_tc_asa(asset)

    positive_amount = amount > Int(0)

    precondition = And(
        is_master(Txn.sender()),
        is_tc_asa,
        positive_amount,
    )

    tc_asa_burn = [
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),
        InnerTxnBuilder.SetField(TxnField.xfer_asset, App.globalGet(Keys.asa)),
        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),
        InnerTxnBuilder.SetField(TxnField.asset_sender, user),
        InnerTxnBuilder.SetField(TxnField.asset_receiver, TC_ASA_RESERVE),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.Submit(),
    ]

    return Seq(
        Assert(precondition),
        *tc_asa_burn,
        Approve(),
    )


TRANSFER_INTERFACE = {
    "name": "transfer",  # TC-ASA standard.
    "args": [
        {
            "name": "receiver",
            "type": "account",
            "desc": "The user that will receive the funds.",
        },
        {
            "name": "amount",
            "type": "uint64",
            "desc": "Amount of funds to transfer to the user.",
        },
        {
            "name": "asset",
            "type": "asset",
            "desc": "Reference to the ASA controlled by this smart contract.",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(TRANSFER_INTERFACE)
def transfer(args: ABI.TealArgs) -> Expr:
    """Controlled transfer of the underlying ASA from `Transaction.Sender` to `user`."""
    asset = args.asset
    is_tc_asa = asset_is_tc_asa(asset)

    receiver = args.receiver
    amount = args.amount
    positive_amount = amount > Int(0)

    no_self_payment = Txn.sender() != receiver

    token_is_not_frozen = Not(_is_frozen())

    sender_is_not_locked = Not(_is_locked(Txn.sender()))

    sender_has_enough_balance = Seq(  # pedantic, the ASA clawback will underflow if not
        sender_asset_balance := AssetHolding.balance(Txn.sender(), asset),
        sender_asset_balance.value() - amount >= Int(0),
    )

    sender_is_whitelisted = _is_whitelisted(Txn.sender())
    receiver_is_whitelisted = _is_whitelisted(receiver)

    precondition = And(
        is_tc_asa,
        positive_amount,
        no_self_payment,
        token_is_not_frozen,
        sender_is_not_locked,
        sender_has_enough_balance,
        sender_is_whitelisted,
        receiver_is_whitelisted,
    )

    tc_asa_transfer = [
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),
        InnerTxnBuilder.SetField(TxnField.xfer_asset, App.globalGet(Keys.asa)),
        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),
        InnerTxnBuilder.SetField(TxnField.asset_receiver, receiver),
        InnerTxnBuilder.SetField(TxnField.asset_sender, Txn.sender()),
        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),
        InnerTxnBuilder.Submit(),
    ]

    return Seq(
        Assert(precondition),
        *tc_asa_transfer,
        Approve(),
    )


def asset_is_tc_asa(e: Expr) -> Expr:
    """Check that provided asset is the TC-ASA handled by this contract."""
    return e == App.globalGet(Keys.asa)


INIT_INTERFACE = {
    "name": "init",
    "desc": "Transfer the ASA reserve into the ASC.",
    "args": [
        {
            "name": "asset",
            "type": "asset",
            "desc": "Reference to the ASA controlled by this smart contract.",
        },
    ],
    "returns": {"type": "void"},
}


@ABI.method(INIT_INTERFACE)
def init(args: ABI.TealArgs):
    current_app_address = Global.current_application_address()
    precondition = And(
        is_master(Txn.sender()),
        App.globalGet(Keys.asa) == Int(0),  # This prevents double initialization.
        Seq(
            asset_clawback := AssetParam.clawback(args.asset),
            Assert(asset_clawback.hasValue()),
            asset_clawback.value() == TC_ASA_RESERVE,
        ),
        Seq(
            asset_freeze := AssetParam.freeze(args.asset),
            Assert(asset_freeze.hasValue()),
            asset_freeze.value() == TC_ASA_RESERVE,
        ),
        Seq(
            asset_manager := AssetParam.manager(args.asset),
            Assert(asset_manager.hasValue()),
            asset_manager.value() == TC_ASA_RESERVE,
        ),
        Seq(
            asset_reserve := AssetParam.reserve(args.asset),
            Assert(asset_reserve.hasValue()),
            asset_reserve.value() == TC_ASA_RESERVE,
        ),
        Seq(
            asset_default_frozen := AssetParam.defaultFrozen(args.asset),
            Assert(asset_default_frozen.hasValue()),
            asset_default_frozen.value() == Int(1),
        ),
    )
    return Seq(
        Assert(precondition),
        asa_total_supply := AssetParam.total(args.asset),
        Assert(asa_total_supply.hasValue()),
        # Global storage for TC-ASA and role ASA
        App.globalPut(Keys.asa, args.asset),
        # Opt-in
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),
        InnerTxnBuilder.SetField(TxnField.xfer_asset, args.asset),
        InnerTxnBuilder.SetField(TxnField.asset_amount, Int(0)),
        InnerTxnBuilder.SetField(TxnField.sender, current_app_address),
        InnerTxnBuilder.SetField(TxnField.asset_receiver, current_app_address),
        InnerTxnBuilder.Submit(),
        # Clawback reserve
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),
        InnerTxnBuilder.SetField(TxnField.xfer_asset, args.asset),
        InnerTxnBuilder.SetField(TxnField.asset_amount, asa_total_supply.value()),
        InnerTxnBuilder.SetField(TxnField.asset_sender, Txn.sender()),
        InnerTxnBuilder.SetField(TxnField.asset_receiver, current_app_address),
        InnerTxnBuilder.Submit(),
        Approve(),
    )


def on_create(cfg: Config) -> Expr:
    """Writes provided configuration to global state."""
    return Seq(
        *(  # NOTE: Here we are calling an API of `Config` that seems out of place here.
            # Refactor this to provide the mapping AVM key/value under a better API.
            App.globalPut(Bytes(Config.field_to_key(f)), cfg.encode_to_avm(f))
            for f in dataclasses.fields(cfg)
        ),
        Approve(),
    )


def on_call(_: Config) -> Expr:
    precondition = And(
        Txn.application_args.length() >= Int(ABI.ON_CALL_NUM_APP_ARGS),
    )

    selector = Txn.application_args[ABI.ON_CALL_NUM_APP_ARGS - 1]
    return Seq(
        Assert(precondition),
        # Poor man dispatcher based on ABI selectors.
        Cond(*([selector == Bytes(k), f()] for k, f in ABI.DISPATCH_TABLE.items())),
    )


def on_optin(_: Config) -> Expr:
    return Seq(Approve())


def on_update(_: Config) -> Expr:
    precondition = is_master(Txn.sender())
    return Seq(Assert(precondition), Approve())


def on_delete(_: Config) -> Expr:
    return Seq(Reject())


def on_closeout_or_clear(_: Config) -> Expr:
    return Seq(Reject())


def asc_approval(cfg: Config) -> Expr:
    return Cond(
        [Txn.application_id() == Int(0), on_create(cfg)],
        [Txn.on_completion() == OnComplete.NoOp, on_call(cfg)],
        [Txn.on_completion() == OnComplete.OptIn, on_optin(cfg)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout_or_clear(cfg)],
        [Txn.on_completion() == OnComplete.UpdateApplication, on_update(cfg)],
        [Txn.on_completion() == OnComplete.DeleteApplication, on_delete(cfg)],
        # ClearStateProgram will execute on ClearState, no need to worry about it here.
    )


def compile_stateful(program) -> str:
    return compileTeal(
        program, Mode.Application, assembleConstants=True, version=TEAL_VERSION
    )


if __name__ == "__main__":
    # Allow quickly testing compilation.
    path = "/tmp/tc_asa.teal"
    with open(path, "w") as f:
        print(f"Writing compiled TC-ASA to '{path}'.")
        f.write(
            compile_stateful(
                asc_approval(
                    Config(
                        master=AVMState.Address(
                            "Y76M3MSY6DKBRHBL7C3NNDXGS5IIMQVQVUAB6MP4XEMMGVF2QWNPL226CA"
                        )
                    )
                )
            )
        )


# File: https://github.com/natyrix/algorand/blob/2bd1d8ee68e74cbc6a0e6d35ff83fef89b2dac08/scripts/smart_contract.py
import base64
import os
from algosdk.future import transaction
from algosdk import mnemonic
from algosdk.v2client import algod
from pyteal import *
from dotenv import load_dotenv

API_KEY = "3L6Urqa3Bs1PE1ghfZcgx9FHti0mtDSp2ECv3jql"
# user declared account mnemonics
benefactor_mnemonic = "angry spend ice estate spoil title deer divide once crazy head magnet supreme icon secret unfair domain section clean scrub want stairs excite abandon dad"
sender_mnemonic = "across wrap wisdom museum piece patch custom wait price discover cloud group garbage dry prize purity fetch burger blood purchase wrist ramp between above lesson"

print("API_KEY")
print(API_KEY)

print("MNEMONIC")
print(sender_mnemonic)

# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config
algod_address = "https://testnet-algorand.api.purestake.io/ps2"
algod_token = API_KEY

# helper function to compile program source
def compile_smart_signature(client, source_code):
    compile_response = client.compile(source_code)
    return compile_response['result'], compile_response['hash']

# helper function that converts a mnemonic passphrase into a private signing key
def get_private_key_from_mnemonic(mn) :
    private_key = mnemonic.to_private_key(mn)
    return private_key



def payment_transaction(creator_mnemonic, amt, rcv, algod_client)->dict:
    params = algod_client.suggested_params()
    add = mnemonic.to_public_key(creator_mnemonic)
    key = mnemonic.to_private_key(creator_mnemonic)
    unsigned_txn = transaction.PaymentTxn(add, params, rcv, amt)
    signed = unsigned_txn.sign(key)
    txid = algod_client.send_transaction(signed)
    pmtx = transaction.wait_for_confirmation(algod_client, txid , 5)
    return pmtx

def lsig_payment_txn(escrowProg, escrow_address, amt, rcv, algod_client):
    params = algod_client.suggested_params()
    unsigned_txn = transaction.PaymentTxn(escrow_address, params, rcv, amt)
    encodedProg = escrowProg.encode()
    program = base64.decodebytes(encodedProg)
    lsig = transaction.LogicSigAccount(program)
    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)
    tx_id = algod_client.send_transaction(stxn)
    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)
    return pmtx

"""Basic Donation Escrow"""

def donation_escrow(benefactor):
    Fee = Int(1000)

    #Only the benefactor account can withdraw from this escrow
    program = And(
        Txn.type_enum() == TxnType.Payment,
        Txn.fee() <= Fee,
        Txn.receiver() == Addr(benefactor),
        Global.group_size() == Int(1),
        Txn.rekey_to() == Global.zero_address()
    )

    # Mode.Signature specifies that this is a smart signature
    return compileTeal(program, Mode.Signature, version=5)

def main() :
    # initialize an algodClient
    algod_client = algod.AlgodClient(algod_token, algod_address)


    # define private keys
    receiver_public_key = mnemonic.to_public_key(benefactor_mnemonic)

    print("--------------------------------------------")
    print("Compiling Donation Smart Signature......")

    stateless_program_teal = donation_escrow(receiver_public_key)
    escrow_result, escrow_address= compile_smart_signature(algod_client, stateless_program_teal)

    print("Program:", escrow_result)
    print("hash: ", escrow_address)

    print("--------------------------------------------")
    print("Activating Donation Smart Signature......")

    # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator
    amt = 2001000
    payment_transaction(sender_mnemonic, amt, escrow_address, algod_client)

    print("--------------------------------------------")
    print("Withdraw from Donation Smart Signature......")

    # Withdraws 1 ALGO from smart signature using logic signature.
    withdrawal_amt = 1000000
    lsig_payment_txn(escrow_result, escrow_address, withdrawal_amt, receiver_public_key, algod_client)

main()

# File: https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/plugin_example/rekey_plugin/tealer_rekey_plugin/detectors/rekeyto_stateless.py
"""Detector for finding execution paths missing RekeyTo check."""

from typing import List, TYPE_CHECKING, Tuple

from tealer.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DetectorType,
)
from tealer.detectors.utils import detect_missing_tx_field_validations_group
from tealer.utils.output import ExecutionPaths


if TYPE_CHECKING:
    from tealer.teal.basic_blocks import BasicBlock
    from tealer.utils.output import ListOutput
    from tealer.teal.context.block_transaction_context import BlockTransactionContext
    from tealer.teal.teal import Teal


class CanRekey(AbstractDetector):  # pylint: disable=too-few-public-methods
    """Detector to find execution paths missing RekeyTo check.

    TEAL, from version 2 onwards supports rekeying of accounts.
    An account can be rekeyed to a different address. Once rekeyed,
    rekeyed address has entire authority over the account. Contract
    Accounts can also be rekeyed. If RekeyTo field of the transaction
    is set to malicious actor's address, then they can control the account
    funds, assets directly bypassing the contract's restrictions.

    This detector tries to find execution paths that approve the algorand
    transaction("return 1") and doesn't check the RekeyTo transaction field.
    Additional to checking rekeying of it's own contract, detector also finds
    execution paths that doesn't check RekeyTo field of other transactions
    in the atomic group.
    """

    NAME = "rekey-to"
    DESCRIPTION = "Rekeyable Logic Signatures"
    TYPE = DetectorType.STATELESS

    IMPACT = DetectorClassification.HIGH
    CONFIDENCE = DetectorClassification.HIGH

    WIKI_URL = "https://github.com/crytic/tealer/wiki/Detector-Documentation#rekeyable-logicsig"
    WIKI_TITLE = "Rekeyable LogicSig"
    WIKI_DESCRIPTION = (
        "Logic signature does not validate `RekeyTo` field."
        " Attacker can submit a transaction with `RekeyTo` field set to their address and take control over the account."
        " More at [building-secure-contracts/not-so-smart-contracts/algorand/rekeying]"
        "(https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/algorand/rekeying)"
    )
    WIKI_EXPLOIT_SCENARIO = """
```py
def withdraw(...) -> Expr:
    return Seq(
        [
            Assert(
                And(
                    Txn.type_enum() == TxnType.Payment,
                    Txn.first_valid() % period == Int(0),
                    Txn.last_valid() == Txn.first_valid() + duration,
                    Txn.receiver() == receiver,
                    Txn.amount() == amount,
                    Txn.first_valid() < timeout,
                )
            ),
            Approve(),
        ]
    )
```

Alice signs the logic-sig to allow recurring payments to Bob.\
 Eve uses the logic-sig and submits a valid transaction with `RekeyTo` field set to her address.\
 Eve takes over Alice's account.
"""

    WIKI_RECOMMENDATION = """
Validate `RekeyTo` field in the LogicSig.
"""

    def detect(self) -> "ListOutput":
        """Detect execution paths with missing CloseRemainderTo check.

        Returns:
            ExecutionPaths instance containing the list of vulnerable execution
            paths along with name, check, impact, confidence and other detector
            information.
        """

        def checks_field(block_ctx: "BlockTransactionContext") -> bool:
            # return False if RekeyTo field can have any address.
            # return True if RekeyTo should have some address or zero address
            return not block_ctx.rekeyto.any_addr

        output: List[
            Tuple["Teal", List[List["BasicBlock"]]]
        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)
        detector_output: "ListOutput" = []
        for contract, vulnerable_paths in output:
            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))

        return detector_output


# File: https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Choice_Coin_Voting/vote.py
# Open Source under Apache License

# This code defines a decenteralized voting system on the Algorand Blockchain.
# It uses Choice Coin, an Algorand Standard Asset, to record votes on a distributed ledger.
# The system makes both efficiency and security a priority.
# An escrow account holds the total number of Choice Coin required for the voting process, and Algorand accounts for each of the decisions made.
# Each of the individual decisions made by the voters connect back to the escrow account.
# In turn, one Choice Coin transfers to the appropriate decision account through a stateless smart contract.
# Furthermore, a SHA-512 hashing algorithm is used to encrypt voter information at all stages, ensuring that private information is made secure.
# This is especially useful where voters need to give personal identification for verification purposes.

# Imports and dependicies include the Algorand Python SDK, the Python Hashlib library, and the Python Matplotlib library.
from algosdk import account, encoding, mnemonic, transaction
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn
from algosdk.v2client import algod
import hashlib
import matplotlib
import matplotlib.pyplot as plt
import random
import base64
import io

plt.style.use('fivethirtyeight')


# Matplot parameters for the matplotlib function to generate a new plot.
matplotlib.use('TkAgg')
algod_address = ""  # Put Algod Token here
algod_token = ""  # Put Algod Client address here
headers = {"X-API-Key": algod_token}
# Initializes client for node.
algod_client = algod.AlgodClient(algod_token, algod_address, headers)

# Escrow creation.
escrow_address = ""  # Put in main fund address here
# Put in main fund receiver_mnemonic here
escrow_mnemonic = ""
escrow_key = mnemonic.to_private_key(escrow_mnemonic)
choice_id = 21364625  # Official Test Asset ID for Choice Coin

# Decisions.
# To add more decisions for the election process, add the address for the new decision here.
# Then, add an appropriate boolean statement at line 100 of this file. Be sure to also add additional
# counts at line 148 of this file as well.
decision_one = ""
decision_two = ""
corporate_decision_one = ""
corporate_decision_two = ""

# Clawback Address required to reset accounts to start new voting process.
# Sets up accounts for both the regular election process and the corporate decision process.
# Add more accounts to adjust for more decisions.
clawback_address = ""
clawback_mnemonic = ""
clawback_key = mnemonic.to_private_key(clawback_mnemonic)

# This function counts the number of Choice Coin in an account.
# It first fetches the account_info, and specifically searches among the assets that the account owns for Choice Coin.
# It then returns the number of Choice Coin that the account owns.


def count(address):
    message = ''
    error = ''
    account_info = algod_client.account_info(address)  # Fetch account information for the address.
    assets = account_info.get("assets")  # Fetch asset information.
    for asset in assets:
        # Iterate over assets until Choice Coin is reached. Return the amount if it exists.
        if asset["asset-id"] == choice_id:
            amount = asset.get("amount")
            message = amount
            return message
    error = 'The account has not opted-in to the asset yet.'
    return error

# This function hashes a string using the SHA-512 cryptographic scheme.
# SHA-512 is a post-quantum cryptographic scheme, thus ensuring that private information is made secure from malicious attackers.


def hashing(item):
    # Assumes the default UTF-8.
    hash_object = hashlib.sha512(item.encode())  # This encodes the string with the SHA-512 scheme.
    item = hash_object.hexdigest()  # This returns the hexadecimal encode as a string.
    return item

# This function defines a stateless smart contract on the Algorand Network.
# It sends Choice Coin to the appropriate destination address based on user input.


def choice_vote(sender, key, receiver, amount, comment):
    parameters = algod_client.suggested_params()  # Sets suggested parameters
    # transaction = AssetTransferTxn(sender, parameters, receiver, amount, choice_id, note=comment)
    transaction = AssetTransferTxn(sender, parameters, receiver, 0, choice_id, note=comment)
    # Defines an inital transaction for Choice Coin
    signature = transaction.sign(key)
    # Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    # Sends the transaction with the signature
    final = transaction.get_txid()
    return True, final

# This function describes a methodology for Electoral Voting on the Choice Coin platform.
# It calls the choice_vote() function with the appropriate inputs based on which decision the voter selected.
# It is currently defined for two candidates/decisions, but it can be easily amended to include more.


def election_voting(vote):
    message = ''
    if vote == 'YES':  # Add more boolean statements for more decisions or candidates.
        # choice_vote() function called for "YES".
        TX_ID = choice_vote(escrow_address, escrow_key, decision_one,
                            100, "Tabulated using Choice Coin")
        message = "Ballot Tabulated. \n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/" + \
            TX_ID[1] + "."
        # AlgoExplorer returned for validation.
    elif vote == 'NO':
        TX_ID = choice_vote(escrow_address, escrow_key, decision_two,
                            100, "Tabulated using Choice Coin")
        message = "Ballot Tabulated. \n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/" + \
            TX_ID[1] + "."
    return message

# This defines a corporate voting mechanism using Choice Coin.
# It works very similarly to the electoral voting scheme defined earlier.
# However, it does introduce the stake as a new variable.
# The stake defines the ownership stake of the shareholder that is voting.


def corporate_voting(vote, stake):
    message = ''
    stake = int(stake)  # Define the ownership stake.
    amount = 100 * stake
    comment = "Tabulated using Choice Coin"
    if vote == 'YES':
        choice_vote(escrow_address, escrow_key, corporate_decision_one, amount, comment)
        # Call the choice_vote() function that sends the appropriate number of Choice Coin based on the ownership stake.
        message = "Ballot Tabulated"
    elif vote == 'NO':
        choice_vote(escrow_address, escrow_key, corporate_decision_two, amount, comment)
        message = "Ballot Tabulated"
    return message

# Returns a dynamic bar-graph showing the results of the vote.
# Uses PyPlot for both corporate and electoral voting.


def show_results(yes_count, no_count):
    names = ['Candidate 1', 'Candidate 2']  # Define the two decisions.
    values = [yes_count, no_count]  # Fetch the total number of votes for each decision.
    # Define a new pyplot
    s = io.BytesIO()
    plt.figure(figsize=(9, 3))
    plt.subplots()
    plt.xlabel('Candidates')
    plt.ylabel('Vote Count')
    plt.bar(names, values)
    for i, v in enumerate(values):
        plt.text(i, v, int(v), color='black', fontweight='bold')
    
    plt.suptitle('Election Results')
    plt.savefig('./static/img/plot.png', dpi=400, format='png', bbox_inches="tight")
    plt.close()
    s = base64.b64encode(s.getvalue()).decode('utf-8').replace("\n", "")
    # Return the results.


def show_corporate_results(yes_count, no_count):
    names = ['Decision 1', 'Decision 2']
    values = [yes_count, no_count]
    plt.figure(figsize=(9, 3))
    plt.subplots()
    plt.xlabel('Candidates')
    plt.ylabel('Vote Count')
    plt.bar(names, values)
    for i, v in enumerate(values):
        plt.text(i, v, int(v), color='black', fontweight='bold')
    
    plt.suptitle('Corporate Voting Results')
    plt.savefig('/home/archie/Inital_Demo/static/img/Figure_2.png')

# Counts the total number of votes to return a statement regarding which candidate has won.
# Applies to both corporate and electoral voting.


def count_votes():
    yes_count = count(decision_one)
    no_count = count(decision_two)
    show_results(yes_count, no_count)
    if yes_count > no_count:
        if yes_count == 1:
            return "The Voting Process has ended. Candidate One received the most votes with {0} vote.".format(yes_count)
        else:
            return "The Voting Process has ended. Candidate One received the most votes with {0} votes.".format(yes_count)
    if no_count > yes_count:
        if no_count == 1:
            return "The Voting Process has ended. Candidate Two received the most votes with {0} vote.".format(no_count)
        else:
            return "The Voting Process has ended. Candidate Two received the most votes with {0} votes.".format(no_count)

    else:
        # Random sample generated from adiabatic quantum computer.
        # Generated using QunatumQuery.py.
        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0,
                          1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]
        # Random sample from quantum sample.
        Q = random.choice(quantum_sample)
        if Q:
            return("Tie. The Quantum Oracle selects Candidate One!")
        else:
            return("Tie. The Quantum Oracle selects Candidate Two!")


def count_corporate_votes():
    yes_count = count(corporate_decision_one)
    no_count = count(corporate_decision_two)
    show_corporate_results(yes_count, no_count)
    if yes_count > no_count:
        return "The Voting Process has ended. Decision One had the most votes!"
    if no_count > yes_count:
        return "Decision Two had the most votes!"
    else:
        # Random sample generated from adiabatic quantum computer.
        # Generated using QunatumQuery.py.
        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0,
                          1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]
        # Random sample from quantum sample.
        Q = random.choice(quantum_sample)
        if Q:
            return("Tie. The Quantum Oracle selects Decision One!")
        else:
            return("Tie. The Quantum Oracle selects Decision Two!")

# This function resets the voting accounts to start a new voting process.
# It uses the clawback functionality built into Choice Coin to send the Choice Coin back to the main escrow account.


def reset_votes():
    message = ''
    params = algod_client.suggested_params()
    yes_count = count(decision_one)
    no_count = count(decision_two)
    # Fetches the total number of Choice Coin in each account.
    if yes_count > 0:
        transaction_2 = AssetTransferTxn(
            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=decision_one)
        signature_2 = transaction_2.sign(clawback_key)
        algod_client.send_transaction(signature_2)
        # Defines a clawback transaction to send Choice Coin back to the escrow account if the number of Choice Coin in the account exceeds zero.
    if no_count > 0:
        transaction_3 = AssetTransferTxn(
            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=decision_two)
        signature_3 = transaction_3.sign(clawback_key)
        algod_client.send_transaction(signature_3)
    message = 'Vote accounts reset. New Voting Process started.'
    return message


def reset_corporate_votes():
    message = ''
    params = algod_client.suggested_params()
    yes_count = count(corporate_decision_one)
    no_count = count(corporate_decision_two)
    if yes_count > 0:
        transaction_2 = AssetTransferTxn(
            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=corporate_decision_one)
        signature_2 = transaction_2.sign(clawback_key)
        algod_client.send_transaction(signature_2)
    if no_count > 0:
        transaction_3 = AssetTransferTxn(
            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=corporate_decision_two)
        signature_3 = transaction_3.sign(clawback_key)
        algod_client.send_transaction(signature_3)
    message = 'Vote accounts reset. New Voting Process started.'
    return message


# File: https://github.com/Ecosteer-SRL/dvco-algorand/blob/00c9b22b07980fe9f6ced4363862aa7d05c6c416/worker/worker_algorand.py
 
#   ver:    0.5
#   date:   24/10/2022
#   author: georgiana-bud
import os
import base64
from typing import Tuple, Type, Optional, Union


 
#	WARNING:
#	NOTE:	the kmd.net and kmd.token files are in a folder
#		    named based on the release of kmd - HOWEVER - to date
#		    no easy way has been found to determine the version of kmd
#		    programmatically - find a way or pass the version
#		    as a configuration parameter



import  algosdk                                      #   better type support (not necessary)                
from    algosdk                     import mnemonic                                  
from    algosdk                     import account
from    algosdk.v2client            import algod
from    algosdk.wallet              import Wallet
from    algosdk                     import kmd
from    algosdk.future              import transaction
from    algosdk.future.transaction  import PaymentTxn
from    algosdk.future.transaction  import ApplicationNoOpTxn
from    algosdk.future.transaction  import ApplicationCreateTxn
from    algosdk.future.transaction  import ApplicationOptInTxn
from    algosdk.future.transaction  import ApplicationCloseOutTxn

from error import DopError 

#   class workerAlgorand
#   the following methods have to be implemented
#
#   (x) begin_transaction
#   (x) rollback
#   (x) commit
#   (x) create_user
#   (x) deploy_contract
#   (x) get_wallet_balance
#   (x) subscribe
#   (x) unsubscribe
#   balance                 NOTE:   not in first implementation
#   (x) get_balance         NOTE:   not fully implemented (product related balance)
#   admin_get_grants        NOTE:   not in first implementation - to be moved to chain 2 (offchain)
#   get_receipt             NOTE:   to be removed - to be considered a private/provider specific method
#   set_starting_balance    
#   (x) grant
#   (x) revoke


class workerAlgorand():
    
    def __init__ (self):
        pass


    def begin_transaction(self) -> DopError:
        return DopError(0,"")

    def rollback(self) -> DopError:
        return DopError(0,"")

    def commit(self) -> DopError:
        return DopError(0,"")

    def __wallet_id(
        self,
        wallet_name: str
        ) -> Tuple[str, DopError]:

        """
            returns the wallet id of the wallet named wallet_name
        """
        if self._i_kmd_client == None:
            return "",DopError(2,"Missing value for kmd client.")

        wallets = self._i_kmd_client.list_wallets()
        for arrayitem in wallets:
            if arrayitem.get("name") == wallet_name:
                walletid = arrayitem.get("id")
                return walletid,DopError(0,'')
                break
        return '',DopError(101,"The wallet id for the specified wallet name could not be retrieved.")

    def __account_mnemonic(
        self,
        wallet_name: str,
        wallet_password: str,
        account_address: str
        ) -> Tuple[str, DopError]:

        if self._i_kmd_client == None:
            return "",DopError(2,"Missing value for kmd client.")

        err: DopError
        wallet_id, err = self.__wallet_id(wallet_name)
        if err.isError():
            return "",err

        wallet_handle = self._i_kmd_client.init_wallet_handle(wallet_id, wallet_password)
        account_key = self._i_kmd_client.export_key(wallet_handle, wallet_password, account_address )
        key_mnemonic = mnemonic.from_private_key(account_key)

        #   check for error, exceptions, etc.
        return key_mnemonic, DopError(0,"")




    @staticmethod
    def dop_stateless_create(
        client: algosdk.v2client.algod.AlgodClient
    ,   teal_template_path: str                 #   the absolute path of the teal contract template
    ,   creator_address: str                    #   the address of the creator of the smart contract
        ) -> Tuple[str, DopError]:
        """
            creates the stateless smart contract
            if successful   -> returns the address of the stateless smart contract 
            otherwise       -> returns an empty string
        """

        #   compile the stateless teal prog
        #   set source code 
        #       the source code to be used for this example is DOP/dop.account/dop.account.teal.template
        #       NOTE:   the dop.account.teal (the source code to be compiled) is generated using the file 
        #               dop.account.teal.template by replacing the macro "_RECEIVERADDRESS_" with the "creator_address"
        #               see DOP/dop.account/00_create.sh - that contains the following cmd
        #               sed "s/_RECEIVERADDRESS_/$CREATOR/g" dop.account.teal.template > dop.account.teal


        #   read the template
        teal_template: str = ""
        try:
            with open(teal_template_path, 'r', encoding='utf-8') as f:
                teal_template = f.read()
        except Exception:
            return "",DopError(3,"Teal template file not found.")

        #   now the _RECEIVERADDRESS_ nacro has to be substituted with creator_address
        teal_source = teal_template.replace('_RECEIVERADDRESS_', creator_address)

        
        try:
            compile_response = client.compile(teal_source)
            #   return base64.b64decode(compile_response['result'])
            #   compile_response example
            #   {
            #       'hash': 'LILX6GOG4N6LAOTFT4WW5VTXK5AN4KA5TAN5CYAE7LX5GPC2XXU6NNHDTA', 
            #       'result': 'AyAHAgEABmTIAaCNBiYBIOKaz1eO1YI9t+Lp5CmWTNrK6kvjiZCylN6neTTnB6YYMgQiD0AAKTIEIxJAAAIkQzMAECMSQAAKMwAQJRJAAA0kQzMABygTQAAlIQRDIQVDMwAQIxNAABczARAlE0AADzMBGCQSQAAHMwAIIQYPQyRD'
            #   }
            #   where   'result'    holds the compiled code
            #           'hash'      is the address of the smart contract
        except Exception:
            return "",DopError(4,"Error compiling teal source.")

        smart_contract_address = compile_response['hash']

        #   TODO:   
        #           check if the stateless smart contract needs to be immediately funded
        return smart_contract_address,DopError(0,"")

    @staticmethod
    def dop_stateful_create(
        client: algosdk.v2client.algod.AlgodClient
    ,   teal_clear_program_path: str
    ,   teal_approval_program_path: str
    ,   creator_address: str
    ,   creator_private_key: str
    ,   smart_contract_address: str                     #   address of the stateless smart contract
        ) -> Tuple[str, DopError]:
        """
            creates the stateful smart contract
            if successful   -> returns the txn_id of the stateful smart contract creation transaction
            otherwise       -> returns an empty string
        """

        #ApplicationCreateTxn

        #   get and compile the clear program
        teal_clear_source: str = ""
        try:
            with open(teal_clear_program_path, 'r', encoding='utf-8') as f:
                teal_clear_source = f.read()
        except Exception:
            return "",DopError(5,"Teal clear file not found.")

        compile_response = client.compile(teal_clear_source)            
        clear_program = base64.b64decode(compile_response['result'])


        # declare on_complete as NoOp
        on_complete = transaction.OnComplete.NoOpOC.real

        #   get and compile the approval program
        teal_approval_source: str = ""
        try:
            with open(teal_approval_program_path, 'r', encoding='utf-8') as f:
                teal_approval_source = f.read()
        except Exception:
            return "",DopError(6,"Teal approval file not found.")

        compile_response = client.compile(teal_approval_source) 
        approval_program = base64.b64decode(compile_response['result'])           

        params = client.suggested_params()
        params.flat_fee = True
        params.fee = 1000

        #compile_result = base64.b64decode(compile_response['result'])
        
        smart_contract_arguments = {
            "args":     [smart_contract_address]    #   list of app arguments (goal app create --app-arg)
#       ,   "addrs":    [subscriber_address]        #   list of account arguments
        }

        app_args: list   = workerAlgorand.getArgs(smart_contract_arguments)

        # declare application state storage (immutable)
        local_ints      = 5
        local_bytes     = 5
        global_ints     = 5
        global_bytes    = 5

        # define schema (<class 'algosdk.future.transaction.StateSchema'>)
        global_schema   = transaction.StateSchema(global_ints, global_bytes)
        local_schema    = transaction.StateSchema(local_ints, local_bytes)

        unsigned_txn = ApplicationCreateTxn(creator_address, params, on_complete, approval_program, clear_program, global_schema, local_schema, app_args)
        # sign transaction
        signed_txn = unsigned_txn.sign(creator_private_key)
        txn_id = signed_txn.transaction.get_txid()

        #   send transaction
        try: 
            client.send_transactions([signed_txn])    
        except Exception as err:
            return txn_id, DopError(120, f"An error occurred while creating stateful \
                smart contract.")
        return (txn_id,DopError(0,""))

    @staticmethod
    def mnemonic_to_private_key(mnemonic_key: str) -> Tuple[str, DopError]:
        """
        convert a menmonic key into a "single string" private key
        """
        private_key: str = ""
        try:
            private_key = mnemonic.to_private_key(mnemonic_key)
        except Exception:
            return "",DopError(10,"Mnemonic could not be converted to private key.")

        return private_key,DopError(0,"")


    
    #   private method
    def __algorand_smart_contract_create(
        self
    ,   client: algosdk.v2client.algod.AlgodClient
    ,   creator_mnemonic: str
        ) -> Tuple[str, str, DopError]:
        
        """
            the DOP smart contract is a linked smart contract
            (there is a stateless part, to represent the smart contract account
            and a stateful part, holding the DOP logic)
            RETURNS:    
                    address of the stateless smart contract
                    app index of the stateful smart contract
                    DopError

            see https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/?from_query=call%20smart%20contract%20from%20javascript#call-noop
            see https://github.com/algorand/py-algorand-sdk/blob/5b496e0928af1dcae4e393693421f590a6111907/algosdk/future/transaction.py
            see https://developer.algorand.org/docs/rest-apis/algod/v2/
        """

        err: DopError
        creator_private_key: str

        creator_private_key, err = self.mnemonic_to_private_key(creator_mnemonic)
        if err.isError():
            return ("",0,err)
        creator_address       = account.address_from_private_key(creator_private_key)         #   this line to be deleted

        smart_contract_address, err = self.dop_stateless_create(client, self._i_stateless_teal_template_path, creator_address)
        if err.isError():
            return ("",0,err)

        txn_id, err = self.dop_stateful_create(client, self._i_teal_clear_program_path, self._i_teal_approval_program_path, creator_address, creator_private_key, smart_contract_address)

        if err.isError():
            return "",0,err

        # await confirmation
        confirmed_txn = self.wait_for_confirmation(client, txn_id, 4)  


        #   confirmed_txn holds:
        #   {
        #       'application-index': 392, 
        #       'confirmed-round': 66118, 
        #       'global-state-delta': [
        #                               {'key': 'a2V5', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, 
        #                               {'key': 'a2lk', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, 
        #                               {'key': 'bGlua2Vk', 'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}}, 
        #                               {'key': 'Y3JlYXRvcg==', 'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}}
        #                               ], 
        #       'pool-error': '', 
        #       'sender-rewards': 16230, 
        #       'txn': {'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', 
        #               'txn': {'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], 
        #                       'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', 
        #                       'apgs': {'nbs': 5, 'nui': 5}, 
        #                       'apls': {'nbs': 5, 'nui': 5}, 
        #                       'apsu': 'AyABASI=', 
        #                       'fee': 1000, 
        #                       'fv': 66017, 
        #                       'gen': 'private-v1', 
        #                       'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', 
        #                       'lv': 67017, 
        #                       'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', 
        #                       'type': 'appl'}
        #               }
        #       }


        # display results
        transaction_response = client.pending_transaction_info(txn_id)

        #   transaction_response
        #   {
        #       'application-index': 392, 
        #       'confirmed-round': 66118, 
        #       'global-state-delta': [
        #                               {
        #                                   'key': 'Y3JlYXRvcg==', 
        #                                   'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}
        #                               }, 
        #                               {
        #                                   'key': 'a2V5', 
        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}
        #                               }, 
        #                               {
        #                                   'key': 'a2lk', 
        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}
        #                               }, 
        #                               {
        #                                   'key': 'bGlua2Vk', 
        #                                   'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}
        #                               }
        #                               ], 
        #       'pool-error': '', 
        #       'sender-rewards': 16230, 
        #       'txn': {
        #                   'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', 
        #                   'txn': {
        #                               'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], 
        #                               'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', 
        #                               'apgs': {'nbs': 5, 'nui': 5}, 
        #                               'apls': {'nbs': 5, 'nui': 5}, 
        #                               'apsu': 'AyABASI=', 
        #                               'fee': 1000, 
        #                               'fv': 66017, 
        #                               'gen': 'private-v1', 
        #                               'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', 
        #                               'lv': 67017, 
        #                               'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', 
        #                               'type': 'appl'
        #                           }
        #               }
        #       }

        app_id = transaction_response['application-index']
        return (smart_contract_address, str(app_id), DopError(0,""))


    #   private method
    def __account_send(self, from_mnemonic, to_address, amount) -> Tuple[str,DopError]:

        """
        Sends tokens from one account to another
        """
        if self._i_algod_client == None:
            return "",DopError(1,"Missing value for algod client.")

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP OPTIN".encode()

        err: DopError

        from_private_key, err = self.mnemonic_to_private_key(from_mnemonic)
        if err.isError():
            return "",err
        from_address = account.address_from_private_key(from_private_key)

        
        params = self._i_algod_client.suggested_params()
        # comment out the next two (2) lines to use suggested fees
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP funds".encode()

        #   create an unsigned transaction
        unsigned_txn = PaymentTxn(from_address, params, to_address, amount, None, txn_note)

        #   sign the transaction using the private key of the sender (from_address)
        signed_txn = unsigned_txn.sign(from_private_key)

        #submit transaction
        txid = self._i_algod_client.send_transaction(signed_txn)
        print("Successfully sent transaction with txID: {}".format(txid))

        # wait for confirmation 
        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  
        except Exception as err:
            print(err)
            return "", DopError(301,'An exception occurred while waiting \
                for the confirmation of the send transaction.')
        
        return txid, DopError(0,)
    
    @staticmethod
    def wait_for_confirmation(
        client: algosdk.v2client.algod.AlgodClient
    ,   transaction_id: str
    ,   timeout: int
    ):
        """
        Wait until the transaction is confirmed or rejected, or until 'timeout'
        number of rounds have passed.
        Args:
            transaction_id (str): the transaction to wait for
            timeout (int): maximum number of rounds to wait    
        Returns:
            dict: pending transaction information, or throws an error if the transaction
                is not confirmed or rejected in the next timeout rounds
        """
        start_round = client.status()["last-round"] + 1
        current_round = start_round

        while current_round < start_round + timeout:
            try:
                pending_txn = client.pending_transaction_info(transaction_id)
            except Exception:
                return 
            if pending_txn.get("confirmed-round", 0) > 0:
                return pending_txn
            elif pending_txn["pool-error"]:  
                raise Exception(
                    'pool error: {}'.format(pending_txn["pool-error"]))
            client.status_after_block(current_round)                   
            current_round += 1
        raise Exception(
            'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))

    @staticmethod
    def Token(token: str, path: str) -> Tuple[DopError, str]:
        ntoken: str = token
        if ntoken == '':
            try:
                with open(path, 'r') as f:
                    ntoken = f.readline()
            except Exception as e:
                #print(str(e))
                return (DopError(20,"An exception occurred while reading token file."),ntoken)

            l: list = ntoken.split('\n')
            ntoken = l[0]
        return (DopError(), ntoken)

    @staticmethod 
    def Port(port: str, path: str) -> Tuple[DopError, str]:
        nport: str = port
        host: str = ''
        if nport == '':
            try:
                with open(path, 'r') as f:
                    host = f.readline()
            except:
                return (DopError(21,"An exception occurred while reading port file."),nport)

        l: list = host.split('\n')
        host = l[0]
        l = host.split(':')
        if len(l) > 1:
            nport = l[1]

        return (DopError(), nport)
        
    def algodToken(self) -> Tuple[DopError, str]:
        """
        returns the token of necessary to connect to the algod node
        NOTE:   the token is retrieved by reading and parsing the file "$ALGORAND_DATA/algod.token"
                so this function requires the macro ALGORAND_DATA to be defined and available
                to the process calling this method
        """

        token: str
        if 'atoken' in self._i_config:
            #   atoken passed in connstring - ignore file containing token
            token = self._i_config['atoken']
            self._i_algo_token = token
            return DopError(),token

        err, token = self.Token(self._i_algo_token, self._i_algo_token_file)
        if err.code == 0:
            self._i_algo_token = token

        return (err,token)

    def algodPort(self) -> Tuple[DopError, str]:
        """
        returns the TCP port the algod node is listening to
        NOTE:   the port is retrieved by reading and parsing the file "$ALGORAND_DATA/algod.net"
                so this function requires the macro ALGORAND_DATA to be defined and available
                to the process calling this method
        """
        port: int
        if 'anetprt' in self._i_config:
            #   anetprt passed in connstring - ignore file containing port
            port = int(self._i_config['anetprt'])
            self._i_algo_port = port
            return DopError(),port

        err, port = self.Port(self._i_algo_port, self._i_algo_net_file)
        if err.code == 0:
            self._i_algo_port = port
        return (err, port)

    def kmdToken(self) -> Tuple[DopError, str]:
        token: str
        if 'ktoken' in self._i_config:
            #   atoken passed in connstring - ignore file containing token
            token = self._i_config['ktoken']
            self._i_kmd_token = token
            return DopError(),token

        err, token = self.Token(self._i_kmd_token, self._i_kmd_token_file)
        if err.code == 0:
            self._i_kmd_token = token
        return (err, token)

    def kmdPort(self) -> Tuple[DopError, str]:
        port: int
        if 'knetprt' in self._i_config:
            #   anetprt passed in connstring - ignore file containing port
            port = int(self._i_config['knetprt'])
            self._i_kmd_port = port
            return DopError(),port

        err, port = self.Port(self._i_kmd_port, self._i_kmd_net_file)
        if err.code == 0:
            self._i_kmd_port = port
        return (err, port)

    def kmd(self) -> Tuple[DopError, algosdk.kmd.KMDClient]:
        err, kmd_token = self.kmdToken()
        if err.code != 0:
            return (err,None)
        err, kmd_port = self.kmdPort()
        if err.code != 0:
            return (err,None)

        kmd_ip_address: str = 'http://localhost:' 
        if 'knetip' in self._i_config:
            kmd_ip_address = 'http://' + self._i_config['knetip'] + ':'
        kmd_address = kmd_ip_address + str(kmd_port)

        kcl = kmd.KMDClient(kmd_token, kmd_address)

        try:
            #   NOTE:           it seems that the kmd can be instantiated only if using localhost
            #                   to be checked with algorand
            kcl.versions()  #   generates an exception if the kcl is not connected
        except Exception:
            return(DopError(22, "An exception occurred while initializing kmd client."),kcl)

        return(DopError(),kcl)
    
    def algod(self) -> Tuple[DopError, algosdk.v2client.algod.AlgodClient]:
        #   get algod token
        err, algod_token = self.algodToken()
        if err.code != 0:
            return (err,None)
        #   get algod port
        err, algod_port = self.algodPort()
        if err.code != 0:
            return (err,None)
        #   get algo node address (default is localhost)

        algod_ip_address: str = 'http://localhost:' 
        if 'anetip' in self._i_config:
            algod_ip_address = 'http://' + self._i_config['anetip'] + ':'
        #algod_address = 'http://localhost:' + str(algod_port)
        algod_address = algod_ip_address + str(algod_port)
        algocl = algod.AlgodClient(algod_token, algod_address)

        #   check if the algod client is valid
        try:
            algocl.status()
        except Exception:
            return(DopError(23, "Error in initializing algod client."),algocl)

        return(DopError(),algocl)

    @staticmethod
    def getArgs(argsobj: dict) -> list:
        args = argsobj.get("args")

        if args==None:
            return None

        if len(args) < 1:
            return None

        b_args: list = []
        for item in args:
            b_args.append(bytes(item,'utf-8'))
        return b_args

    @staticmethod
    def getAccounts(argsobj: dict) -> list:
        args = argsobj.get("addrs")

        if args==None:
            return None

        if len(args) < 1:
            return None

        return args

    def dopSmartContract(
        self
    ,   algod_client: algosdk.v2client.algod.AlgodClient
    ,   appid:  int                     #   smart contract index (address)
    ,   owner_mnemonic: str             #   private key (mnemonic) of the owner of the smart contract
    ,   scarguments: dict               #   {"args":[argslist], "addrs":[accountaddresseslist]}
    ,   transaction_note: str           #   the note field withon the transaction
    ) -> Tuple[str, DopError]:               #   error code, transaction id

        #   retrieve and change suggested params (for the transaction)        
        #   this could become an argument, to be investigated (future releases)
        params = algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000

        txn_note = transaction_note.encode()

        err: DopError
        owner_private_key: str
        owner_private_key,err   = self.mnemonic_to_private_key(owner_mnemonic)
        if err.isError():
            return "",err

        owner_address       = account.address_from_private_key(owner_private_key)         #   this line to be deleted

        arguments_list   = self.getArgs(scarguments)
        accounts_list    = self.getAccounts(scarguments)

        unsigned_txn = ApplicationNoOpTxn(owner_address, params, appid, arguments_list, accounts_list, None, None, txn_note)
        signed_txn = unsigned_txn.sign(owner_private_key)

        txid = ''
        try:
            txid = algod_client.send_transaction(signed_txn)
            #   print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #print(err)
            return "", DopError(202,f"An exception occurred when sending transaction.")

        return(txid, DopError(0,""))      #   now the transaction can be waited for

    def __default(self):
        #   set default parameters
        self._i_algo_token      = ''
        self._i_algo_port       = ''
        self._i_algod_client    = None

        self._i_kmd_token       = ''
        self._i_kmd_port        = ''
        self._i_kmd_client      = None

        self._i_config: dict   = {}
        
        algorand_data_path: str = '/home/ecosteer/dop/externals/algorand/net1/Primary'
        if 'ALGORAND_DATA' in os.environ:
            algorand_data_path = os.environ['ALGORAND_DATA']

        self._i_algo_token_file     = algorand_data_path + '/algod.token'           #   this has to go
        self._i_config['atokf']     = algorand_data_path + '/algod.token'

        self._i_algo_net_file       = algorand_data_path + '/algod.net'             #   this has to go
        self._i_config['anetf']     = algorand_data_path + '/algod.net'

        self._i_kmd_token_file      = algorand_data_path + '/kmd-v0.5/kmd.token'    #   this has to go
        self._i_config['ktokf']     = algorand_data_path + '/kmd-v0.5/kmd.token'

        self._i_kmd_net_file        = algorand_data_path + '/kmd-v0.5/kmd.net'      #   this has to go
        self._i_config['knetf']     = algorand_data_path + '/kmd-v0.5/kmd.net'
        

        dop_smart_contract_root_path: str = '/home/ecosteer/dop/intermediation/algorand/DOP'
        self._i_config['scrf'] = dop_smart_contract_root_path

        user_wallet: str            = "unencrypted-default-wallet"                  # wallet where the users are created
        user_wallet_password: str   = ""                                            # password to access the wallet
        self._i_config['usrwlab']   = user_wallet
        self._i_config['usrwpwd']   = user_wallet_password


        if 'DOP_SMART_CONTRACT_ROOT_FOLDER' in os.environ:
            dop_smart_contract_root_path = os.environ['DOP_SMART_CONTRACT_ROOT_FOLDER']
            
        self._i_stateless_teal_template_path    = dop_smart_contract_root_path + '/dop.account/dop.account.teal.template'
        self._i_config['sttp'] = 'dop.account/dop.account.teal.template'
        self._i_teal_approval_program_path      = dop_smart_contract_root_path + '/dop.stateful/dop.stateful.teal'
        self._i_config['tapp'] = 'dop.stateful/dop.stateful.teal'
        self._i_teal_clear_program_path         = dop_smart_contract_root_path + '/dop.clear/basicClear.teal'
        self._i_config['tcpp'] = 'dop.clear/basicClear.teal'

        self._i_config['ownmne'] = ''


    #============================================================================
    #   abstract methods
    #============================================================================
    #   NOTE:   init must become an abstract method
    def init(self, constring: str) -> DopError:

        self.__default()
                
        #   convert connstring into a dict (see config_to_dict in shared.utils.py)
        temp_config: dict = {}

        temp_list: list = constring.split(';')
        for el in temp_list:
            ell = el.split('=')
            if len(ell) != 2:
                continue
            temp_config[ell[0]]=ell[1]

        pars: list = [
            'atokf',
            'anetf',
            'ktokf',
            'knetf',
            'atoken',
            'anetprt',
            'anetip',
            'ktoken',
            'knetprt',
            'knetip',
            'scrf',
            'sttp',
            'tapp',
            'tcpp',
            'usrwlab',
            'usrwpwd',
            'ownmne'
            ]

        for p in pars:
            if p in temp_config:
                self._i_config[p] = temp_config[p]


        
        #   connection string parameters
        #   label   type        logic
        #   ------+---------+------------------------------------------------------------------------------------------------
        #   atokf   string      absolute path of the algod.token file
        #   anetf   string      absolute path of the algod.net file     
        #   ktokf   string      absolute path of the kmd.token file
        #   knetf   string      absolute path of the kmd.net file
        #   atoken  string      algod token (if this is defined then atokf will not be used)
        #   anetprt int         algod tcp ip port (if this is defined then the anetf will not be used - anetip required)
        #   anetip  string      algod tcp ip address (if this is defined then the anetf will not be used - anetprt required)
        #   ktoken  string      kmd token (if this is defined then atokf will not be used)
        #   knetprt int         kmd tcp ip port (if this is defined then the knetf will not be used - knetip required)
        #   knetip  string      kmd tcp ip address (if this is defined then the knetf will not be used - knetprt required)
        #   scrf    string      smart contract root folder      : absolute path of the folder containing sttp, atpt and tcpp
        #   sttp    string      stateless teal template path    : relative path of the stateless teal template
        #   tapp    string      teal approval program path      : relative path of the teal approval program
        #   tcpp    string      teal clear program path         : relative path of the teal clear program
        #	usrwlab	string		user wallet (the wallet used by the worker to create accounts)
		#	usrwpwd	string		user wallet password

        #   ownmne  string      mnemonic of the owner account to be used to fund newly created accounts

        #   example 1 (can be used only if the kmd and algod are running on localhost)
        #   atokf=/home/ecosteer/algorand/net1/Primary/algod.token;anetf=/home/ecosteer/algorand/net1/Primary/algod.net;\
        #   ktokf=/home/ecosteer/algorand/net1/Primary/kmd.token;knetf=/home/ecosteer/algorand/net1/Primary/kmd.net;\
        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\
        #   sttp=dop.account/dop.account.teal.template;\
        #   tapp=dop.stateful/dop.stateful.teal;\
        #   tcpp=dop.clear/basicClear.teal;

        #   example 2 (to be used if the kmd and algod are running on a remote host)
        #   atoken=45d2689bb4b555b757b00972d82c0a872f7b2aa136a5351768280dbe7cf2e9b2;\
        #   anetprt=18445;\
        #   anetip=192.178.20.30;\
        #   ktoken=d278689bb4b555b7502030465782c0a872f7b2aa136a5351768280dbe7cf2ab90;\
        #   knetprt=18435;\
        #   knetip=192.178.20.30;\
        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\
        #   sttp=dop.account/dop.account.teal.template;\
        #   tapp=dop.stateful/dop.stateful.teal;\
        #   tcpp=dop.clear/basicClear.teal;

        #   test only
        for el in self._i_config:
            print(el + ':[' + self._i_config[el] + ']')
        
        return DopError(0, "")

    def open(self) -> DopError:
        """
            open the algod client and the kmd client
            the following properties are valorized:
            1)  _i_algod_token
            2)  _i_algod_port
            3)  _i_kmd_token
            4)  _i_kmd_port
        """


        #   self.algod
        #   sets self._i_algod_token and self._i_algod_port
        err, self._i_algod_client = self.algod()
        if err.isError():
            return err

        err, self._i_kmd_client = self.kmd()
        if err.isError():
            return err

        if 'ownmne' in self._i_config: 
            self._own_mnemonic = self._i_config['ownmne']
        else:
            self._own_mnemonic = None
            return DopError(201, "Owner mnemonic not provided.")

        return err

    def close(self) -> DopError:
        #   TODO:   check if algod and kmd client have to be "closed" 
        return DopError(0,"")


    def get_balance(self,
                    publisher_address: str,                         #   EoA address of the publisher (contract owner)
                    subscriber_address: str,                        #   EoA address of the subscriber we want to check the balance 
                    contract_address: str) -> Tuple[dict, DopError]:   #   address (blockchain layer) of the contract) -> Tuple[dict, DopError]:
        """
        in this version this method is not "really" implemented
        """
        response = {}
        response['subscribed'] = 1
        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use DB
        response['credit'] = 100
        response['debit'] = 0

        return response, DopError(0,"")

    def create_user(self, username: str, password: str) -> Tuple[str, str, DopError]: 
        """
            creates a blockchain account and returns the address (public key) of the account and the password
            of the account (ethereum: input password, algorand, generated private key)

        """
        user_address = ""
        wallet_id: str
        err: DopError

        wallet_name = self._i_config['usrwlab']
        wallet_password = self._i_config['usrwpwd']

        wallet_id, err = self.__wallet_id(wallet_name)
        if err.isError():
            return "","",err

        
        try:
            wallet = Wallet(wallet_name, wallet_password, self._i_kmd_client)
            #   create the account
            account_address     = wallet.generate_key()
            account_mnemonic, err    = self.__account_mnemonic(wallet_name,wallet_password,account_address)
            if err.isError():
                return "","",err
            #   return err=0,account_address
            return account_address, account_mnemonic,DopError(0,"")

        except Exception as err:
            #   likely the password is wrong
            print(err)      #   logging etc.
            return "","",DopError(203,"An exception occurred while creating user.")

        return "","",DopError(1000,"")             # never hit


        return (user_address,user_mnemonic,DopError(0,""))
    


    def get_wallet_balance(self, account_address: str, currency="algo") -> Tuple[str, DopError]:
        """
            TODO:       return account_balance, DopError (as usual)
            TODO:       the method name should be change into "get_account_balance" to disambiguate between account and wallet
            NOTE:       the abstract was defined with a str return value
        """
        if self._i_algod_client == None:
            return "", DopError(1,"Missing value for algod client.")

        try:
            #   address is the account address - for instance: "4KNM6V4O2WBD3N7C5HSCTFSM3LFOUS7DRGILFFG6U54TJZYHUYMDPN26KY"
            from_account_info = self._i_algod_client.account_info(account_address)
            #   the account balance is in micro algos
            account_balance = from_account_info.get('amount')
            #print("Origin Account balance     : [{} microAlgos]".format(from_account_info.get('amount')))
            return account_balance, DopError(0,"")
        except Exception:
            return "",DopError(204,"An exception occurred while getting wallet balance.")

        
    def deploy_contract(self,
                        publisher_address: str,                 #   address of the owner account
                        secret: str,                            #   secret for the owner account (algorand: private key mnemonic of the owner)
                        tariff_period: int,                     #   period of the tariff 
                        tariff_price: int                       #   price of a period
                        ) -> Tuple[Optional[str], DopError]:
        """
            NOTE:
                The abstract method returns a transaction hash that is inserted into the 
                rdbms (transactions schema) - as this is typically a pending operation finalized by an event emitted by the monitor.
                For Algorand: this might require a complete different logic of the processor "product_create.py" - possibly a 
                processor specific for Algorand will have to be implemented.
                See also monitor_des.py - it processes the event (DEPLOY_CONTRACT) that is
                meant to close the pending op

                NOTE:   EnableDeveloperAPI must be set to true (node configuration file)
                NOTE:   https://developer.algorand.org/docs/run-a-node/reference/config/

                TODO:   review static and private method dop_stateful/dop_stateless/__algorand_smart_contract_create
        """

        #   publisher_address:      not used
        #   tariff_period:          not used (for future release)
        #   tariff_price:           not used (for future release)
        #   secret: is the mnemonic of the publisher
        
        smart_contract_address: str     #   the address of the stateless smart contract (the smart contract linked to the stateful smart contract)
                                        #   as the previously defined abstract method allows tp return just two values
                                        #   we will not return the smart contract address for the moment - to be checked
                                        #   in this release the smart_comtract_address will be encoded using the following string:
                                        #   %smart_contract_adress%@%app_id

        app_id: str                     #   the application id (this id will have to be used for invoking the smart contract)
        err: DopError

        if self._i_algod_client == None:
            #   must open before
            return ("",DopError(1,"Missing value for algod client."))

        smart_contract_address, app_id, err = self.__algorand_smart_contract_create(self._i_algod_client, secret) 
        if err.isError():
            return "", err
        #   TODO check if stateless contract has to be funded
        encoded_smart_contract_address: str = smart_contract_address + '@' + str(app_id)
        return (encoded_smart_contract_address, err)

    def algorand_sub_optin(     #   ALGORAND SPECIFIC
        self,
        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in
        application_address: str    #   application index of the smart contract the account wants to opt into
        ) -> DopError:
        """
        Algorand specific (an account has to optin before subscribing to a smart contract)
        this methid can be called by a specific Algorand processor provider (not an abstract method),
        for instance by the processor provider that implement the subscription logic
        SO: it has not be implemented as a private method - but an Algorand specific method.

        NOTE:   the subscriber, before subscribing the contract X, MUST opt-in to the contract X
        """
        #   see 01_sub_optin.py
        
        if self._i_algod_client == None:
            return DopError(1,"Missing value for algod client.")

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP OPTIN".encode()

        err: DopError

        #subscriber_private_key = mnemonic.to_private_key(from_mnemonic)
        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)
        if err.isError():
            return err
        subscriber_address = account.address_from_private_key(subscriber_private_key)

        appid = int(application_address)
        unsigned_txn = ApplicationOptInTxn(subscriber_address, params, appid, None, None, None, None, txn_note)
        signed_txn = unsigned_txn.sign(subscriber_private_key)

        txid =''
        try:
            txid = self._i_algod_client.send_transaction(signed_txn)
            #   print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #   print(err)
            return DopError(205,"An exception occurred when sending optin transaction.")

        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  
            #   TODO: confirmed_txn can be used to provide detailed log, see next
            #   commented lines
            #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
            #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

        except Exception as err:
            #   print(err)
            return DopError(302,"An exception occurred while waiting for confirmation of optin transaction.")

        return DopError(0,"")


    def algorand_sub_optout(     #   ALGORAND SPECIFIC
        self,
        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in
        application_address: str    #   application index of the smart contract the account wants to opt into
        ) -> DopError:
        """
        Algorand specific (symmetric to algorand_sub_optin)
        NOTE:   a subscriber that has unsubscribed should call optout, too
        """
        
        if self._i_algod_client == None:
            return DopError(1,"Missing value for algod client.")

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP OPTOUT".encode()

        err: DopError
        subscriber_private_key: str

        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)
        if err.isError():
            return err
        subscriber_address = account.address_from_private_key(subscriber_private_key)

        appid = int(application_address)
        unsigned_txn = ApplicationCloseOutTxn(subscriber_address, params, appid, None, None, None, None, txn_note)
        signed_txn = unsigned_txn.sign(subscriber_private_key)

        txid =''
        try:
            txid = self._i_algod_client.send_transaction(signed_txn)
            #   print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #   print(err)
            return DopError(206,"An exception occurred when sending optout transaction.")

        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  
            #   TODO: confirmed_txn can be used to provide detailed log, see next
            #   commented lines
            #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
            #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

        except Exception as err:
            #   print(err)
            return DopError(303,"An exception occurred while waiting for \
                        confirmation of optout transaction.")

        return DopError(0,"")


    def subscribe(self,
                  subscriber_addr: str,             #   subscriber address
                  subscriber_psw: str,              #   private key mnemonic
                  contract_address: str,            #   algorand application index
                  secret: str                       #   not used in this release
                  ) -> Tuple[str, DopError]:  
        """
        Subscribe to a contract
        """

        if self._i_algod_client == None:
            return "",DopError(1,"")        #   must be connected to a node

        params = self._i_algod_client.suggested_params()
        params.flat_fee = True
        params.fee = 1000
        txn_note = "DOP SUBSCRIBE".encode()

    #   the transaction type that has to be sent is of type ApplicationNoOpTxn
    #   see https://github.com/algorand/py-algorand-sdk/blob/5ca32cea62168ae339ccfdfbefaa6bc6ac094052/algosdk/future/transaction.py#L2040
    #   line 2040
        
        err: DopError
        subscriber_private_key: str

        subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)
        if err.isError():
            return "",err

        subscriber_address = account.address_from_private_key(subscriber_private_key)

        app_args : list = []
        app_args.append(bytes('subscribe','utf-8'))
        unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, contract_address, app_args, None, None, None, txn_note)
        signed_txn = unsigned_txn.sign(subscriber_private_key)

        txid = ''
        try:
            txid = self._i_algod_client.send_transaction(signed_txn)
            #print("Successfully sent transaction with txID: {}".format(txid))

        except Exception as err:
            #print(err)
            return "", DopError(207,"An exception occurred when sending subscribe transaction.")

        # wait for confirmation 
        try:
            confirmed_txn = self.wait_for_confirmation(self._i_algod_client,txid,4)

            #print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
            #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

        except Exception as err:
            #print(err)
            return "",DopError(304,"An exception occurred while waiting for confirmation \
                    of subscribe transaction.")

        return txid,DopError(0,"")


    def unsubscribe(self, 
                    subscriber_addr: str,               #   not used
                    subscriber_psw: str,                #   subscriber account private key mnemonic
                    contract_address: str             #   application index
                    #,secret: str                         #   not used 
                    ) -> Tuple[str, DopError]:
            """
            UnSubscribe from a contract
            return transaction id
            """

            if self._i_algod_client == None:
                return "",DopError(1,"Missing value for algod client.")        #   must be connected to a node

            params = self._i_algod_client.suggested_params()
            params.flat_fee = True
            params.fee = 1000
            txn_note = "DOP UNSUBSCRIBE".encode()

            err: DopError
            subscriber_private_key: str
            subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)
            if err.isError():
                return "",err
            subscriber_address = account.address_from_private_key(subscriber_private_key)

            application_index = int(contract_address)

            app_args : list = []
            app_args.append(bytes('unsubscribe','utf-8'))
            unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, application_index, app_args, None, None, None, txn_note)
            signed_txn = unsigned_txn.sign(subscriber_private_key)

            txid = ''
            try:
                txid = self._i_algod_client.send_transaction(signed_txn)
                #print("Successfully sent transaction with txID: {}".format(txid))

            except Exception as err:
                #print(err)
                return "", DopError(208,'An exception occurred when sending unsubscribe transaction.')

            # wait for confirmation 
            try:
                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  

                #print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
                #print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

            except Exception as err:

                return "",DopError(305,'An exception occurred while waiting for \
                            confirmation of unsubscribe transaction')

            return txid,DopError(0,'')


    def grant(self,
              publisher_address: str,       #   not used
              publisher_passw: str,         #   publisher private key mnemonic
              contract_address: str,        #   application index            
              subscriber_address: str       #   address of the subscriber to be granted
              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError
              
            # see 06_pub_call_grant.py
            if self._i_algod_client == None:
                return "",DopError(1,"Missing value for algod client.")

            smart_contract_arguments = {
                    "args":     ['grant']                   #   list of app arguments
                ,   "addrs":    [subscriber_address]        #   list of account arguments
                }

            transaction_note = "DOP GRANT"

            err: DopError
            txid: str = ""
            txid, err = self.dopSmartContract(
                self._i_algod_client
            ,   int(contract_address)
            ,   publisher_passw
            ,   smart_contract_arguments
            ,   transaction_note
            )

            if err.isError():
                return "",err

            try:
                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  

                #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
                #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

            except Exception as err:
                #print(err)
                return txid,DopError(306,"An exception occurred while waiting for \
                    confirmation of grant transaction.")

            return txid,DopError(0,"")
            



    def revoke(self,
              publisher_address: str,       #   not used
              publisher_passw: str,         #   publisher private key mnemonic
              contract_address: str,        #   application index            
              subscriber_address: str       #   address of the subscriber to be revoked
              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError

              # see 07_pub_call_revoke.py
            if self._i_algod_client == None:
                return "",DopError(1,"Missing value for algod client.")

            smart_contract_arguments = {
                "args":     ['revoke']                   #   list of app arguments
            ,   "addrs":    [subscriber_address]        #   list of account arguments
            }

            transaction_note = "DOP REVOKE"

            txid: str = ""
            err: DopError
            txid, err = self.dopSmartContract(
                self._i_algod_client
            ,   contract_address
            ,   publisher_passw
            ,   smart_contract_arguments
            ,   transaction_note
            )

            if err.isError():
                return "",err

            try:
                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  

                #   print("Transaction information: {}".format(json.dumps(confirmed_txn, indent=4)))
                #   print("Decoded note: {}".format(base64.b64decode(confirmed_txn["txn"]["txn"]["note"]).decode()))

            except Exception as err:
                #print(err)
                return txid,DopError(307,"An exception occurred while waiting for \
                    confirmation of revoke transaction.")

            return txid,DopError(0,"")



    def balance(self,
                subscriber_address: str,                            #   subscriber EoA address
                secret: str,                                        #   subscriber contract secret
                contract_address: str) -> Tuple[dict, DopError]:       #   address (blockchain layer) of the contract
        """
        Get the balance of a user with `address` of the contract with `contract_address`
        """
        """
        in this version this method is not "really" implemented
        """
        response = {}
        response['subscribed'] = 1
        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use postgres DB
        response['credit'] = 100
        response['debit'] = 0

        return (response, DopError(0,""))

    
    def admin_get_grants(self,
                        publisher_address: str,             #   EoA address of the publisher (contract owner)
                        contract_address: str) -> Tuple[list, DopError]:    #   address (blockchain layer) of the contract
        """
        This method is used by the publisher only in order to retrieve the list 
        of the EoA address of the granted subscribers
        """
        return [], DopError()


    def set_starting_balance(self, 
                            address,
                            amount) -> str: # EoA of the user 
        """
        Sets the starting balance of an EoA
        """
        #self._own_mnemonic = "ability improve suspect canyon castle fire flock forum monitor travel know write similar denial thought \
        #    online ripple squeeze this finish jar parrot rabbit ability crouch"
        if self._own_mnemonic == None:
            return ""

        txid, err = self.__account_send(from_mnemonic = self._own_mnemonic, to_address=address, amount=amount)
        if err.isError():
            return "" 

        return txid





# File: https://github.com/Tao242dn/algo-rpg-cli/blob/75e5ce829abd131fe964909785110608999a66ee/contents.py
plot_summary = """
A text-based RPG unfolds entirely within the command-line interface, where players' actions directly interact with the Algorand blockchain.

A command-line interface (CLI) based RPG guides new users through the concepts of the Algorand blockchain.

The game mechanics directly utilize Algorand's features, turning abstract technical concepts into tangible actions within the game's narrative.

This provides a hands-on, interactive learning experience for newcomers to Algorand, making the technology more accessible and engaging.
"""

quests = [
    "Environmental Check [red](command: env)[/red] Before we begin our journey, let's ensure your surroundings are properly configured. Use the env command to check if your system meets the requirements for interacting with the Algorand blockchain. This involves verifying the necessary software and tools are installed and that your environment variables are set correctly.",
    
    "Account Creation [red](command: account)[/red] Every adventurer needs an identity! Create your Algorand account using the account command. This will generate a unique address and private key, which are essential for managing your assets and interacting with the blockchain. Keep your private key safe  it's the key to your digital kingdom!",
    
    "Funding Your Adventure [red](command: fund)[/red] Every great quest requires provisions. Fund your newly created Algorand account using the fund command. You'll need some Algo (Algorand's native cryptocurrency) to pay for transaction fees and interact with the blockchain. Think of it as stocking up on potions and supplies before embarking on a dangerous journey.",
    
    "Checking Your Provisions [red](command: balance)[/red] Wise adventurers keep track of their resources. Use the balance command to check the balance of your Algorand account. This will show you how much Algo you have available for your quests.",
    
    "Sharing the Spoils [red](command: send)[/red] Generosity is a virtue, even in the digital realm. Use the send command to send Algo to another Algorand account. This is like sharing your treasure with a fellow adventurer [bold](note: 1 Algo = 1_000_000 MicroAlgos)[/bold]",
    
    "Project Genesis [red](command: init)[/red] Time to craft something new! Use the init command to initialize a new Algorand project. This creates the foundation for building your own smart contracts  the magical spells of the Algorand world. We recommend using project name [red]auction_project[/red] match with my default template.",
    
    "Constructing the Spell [red](command: build)[/red]: With a project in place, you can now begin building your smart contract. The build command compiles your code into the bytecode that the Algorand Virtual Machine (AVM) understands. This is like carefully inscribing the runes of your spell.",
    
    "Trial Run [red](command: test)[/red]: Before unleashing your magic upon the world, it's wise to practice. Use the test command to test your smart contract in a safe, isolated environment. This allows you to identify and fix any bugs or vulnerabilities before deploying it to the main blockchain.",
    
    "Scrutiny of the Sages [red](command: audit)[/red] Even the most skilled mages seek peer review. Use the audit command to analyze your smart contract for potential security flaws and inefficiencies. This is like having a council of wise mages examine your spell for weaknesses.",
    
    "Unleashing the Magic [red](command: deploy)[/red] Once you're confident in your creation, it's time to deploy your smart contract to the Algorand blockchain. The deploy command makes your contract live, allowing other users to interact with it. Your spell is now active in the world!",
    
    "Preserving the Lore [red](command: upload)[/red] Important artifacts and knowledge deserve to be preserved. Use the upload command to upload files to IPFS (InterPlanetary File System), a decentralized storage network. This ensures that your data is immutable and accessible to anyone, even if parts of the network go offline. Think of it as storing your magical scrolls in a secure, distributed library."
]

qa_dict = {
    "Who founded Algorand?": [["Vitalik Buterin", "Satoshi Nakamoto", "Silvio Micali", "Charles Hoskinson"], "Silvio Micali"],
    
    "What consensus mechanism does Algorand use?": [["Proof-of-Work", "Delegated Proof-of-Stake", "Byzantine Fault Tolerance", "Pure Proof-of-Stake (PPoS)"], "Pure Proof-of-Stake (PPoS)"],
    
    "What is the native cryptocurrency of Algorand?": [["ALGO", "ETH", "BTC", "SOL"], "ALGO"],
    
    "How does Algorand ensure decentralization?": [["Mining", "Random selection of validators", "Staking", "Proof of Work"], "Random selection of validators"],
    
    "What is the average block time on Algorand?": [["3.7 seconds", "10 minutes", "15 seconds", "1 hour"], "3.7 seconds"],
    
    "How does Algorand solve the blockchain trilemma?": [["Mining", "Proof-of-Stake", "Scalability, security, decentralization", "Validators"], "Scalability, security, decentralization"],
    
    "How does Algorand handle transaction finality?": [["Immediate finality", "Confirmation in 10 blocks", "Delayed finality", "Stochastic finality"], "Immediate finality"],
    
    "What is the main purpose of Algorand?": [["Smart contracts", "NFT minting", "High-speed transactions", "DeFi"], "High-speed transactions"],
    
    "What is Algorands approach to scalability?": [["Sidechains", "Layer-2", "Sharding", "Efficient consensus"], "Efficient consensus"],
    
    "How does Algorand achieve low transaction costs?": [["High gas fees", "Layer-2", "Efficient consensus", "Sharding"], "Efficient consensus"],
    
    "What feature allows Algorand to handle multiple transactions simultaneously?": [["Parallel processing", "Atomic transfers", "Sharding", "Multi-threading"], "Atomic transfers"],
    
    "What is the Algorand Foundations role?": [["Funding and research", "Governance and development", "Marketing and promotion", "Community building"], "Governance and development"],
    
    "How does TEAL ensure smart contract security in Algorand?": [["Formal verification", "Stack-based language", "Sandboxing", "Static analysis"], "Stack-based language"],
    
    "How does Algorand handle stateful vs. stateless smart contracts?": [["Combined execution", "Separate execution environments", "Dynamic switching", "Hybrid approach"], "Separate execution environments"],
    
    "Explain Algorands approach to optimizing transaction throughput in its protocol?": [["Sharding", "Fast consensus and block finality", "Large block sizes", "Off-chain transactions"], "Fast consensus and block finality"],
    
    "What role do relay nodes play in Algorands network architecture?": [["Facilitate communication", "Validate transactions", "Store blockchain data", "Execute smart contracts"], "Facilitate communication"],
    
    "Discuss the role of Algorands Virtual Machine (AVM) in executing contracts?": [["Compiles TEAL code", "Executes TEAL scripts", "Manages state", "Verifies transactions"], "Executes TEAL scripts"],
    
    "Explain how atomic transfers are implemented in Algorand?": [["Single transactions", "Grouped transactions", "Chained transactions", "Smart contracts"], "Grouped transactions"],
    
    "What are the engineering challenges in implementing Algorand Standard Assets (ASA)?": [["Tokenization standards", "Custom asset creation", "Decentralized exchange", "Security audits"], "Custom asset creation"],
    
    "How does Algorand manage network latency and ensure consistency?": [["Centralized servers", "Fast block propagation", "Caching mechanisms", "Redundant networks"], "Fast block propagation"],
    
    "What is the TEAL programming language used for in Algorand?": [["Writing smart contracts", "Developing dApps", "Building blockchain infrastructure", "Creating cryptographic algorithms"], "Writing smart contracts"],
    
    "What are Algorand Smart Contracts (ASC1)?": [["Off-chain contracts", "Layer-2 smart contracts", "Layer-1 smart contracts", "Hybrid smart contracts"], "Layer-1 smart contracts"],
    
    "What is an Algorand Standard Asset (ASA)?": [["Native cryptocurrency", "Custom tokens framework", "Stablecoin protocol", "Decentralized exchange"], "Custom tokens framework"],
    
    "How does Algorand handle smart contract execution fees?": [["Fixed fees", "Based on complexity", "Gas fees", "Transaction size"], "Based on complexity"],
    
    "What is a Stateful Smart Contract in Algorand?": [["Stateless contract", "Maintains state", "Temporary contract", "Immutable contract"], "Maintains state"],
    
    "How are nodes incentivized in the Algorand network?": [["Transaction fees", "Block rewards", "Staking rewards", "Mining rewards"], "Block rewards"],
    
    "What are the security implications of Algorands PPoS model?": [["Increases centralization risk", "Reduces centralization risk", "Vulnerable to 51% attacks", "Requires high energy consumption"], "Reduces centralization risk"],
    
    "What is Cryptographic Sortition in Algorand?": [["Random number generation", "Selects consensus participants", "Encrypts transactions", "Verifies block integrity"], "Selects consensus participants"],
    
    "Can anyone participate in Algorand's consensus?": [["Yes", "No", "Only selected nodes", "Only authorized participants"], "Yes"],
    
    "What year was Algorand launched?": [["2017", "2018", "2019", "2020"], "2019"]
}

choice_content = "[bold green]Choose an option you would like:\n1. Option [red]Q&A[/red]  you can interactive with AI really insteresting huh.\n2. With [red]Game[/red]  we start the game explore 11 quests.\n3. Let [red]Quiz[/red]  if you want to test your knowledge.\n4. Or [red]Quit[/red]  quit the game, your journey is over.[/bold green]\nTell me what your choice"

after_credits = """
Thank you for playing AlgoRPG!

We hope you enjoyed your adventure through the world of Algorand and that the game helped you learn more about blockchain technology. Your feedback is valuable to us, so please let us know what you thought of your experience. Did you find the game helpful in understanding Algorand? What did you enjoy most? What could we improve?

We're constantly working to make AlgoRPG even better, so your input is greatly appreciated.
""" 

# File: https://github.com/gwumex/choice/blob/0821bddd5da1f1a4c5710fb0c8372a857600f338/vote.py
# Open Source under Apache License



# This code defines a decenteralized voting system on the Algorand Blockchain.

# It uses Choice Coin, an Algorand Standard Asset, to record votes on a distributed ledger.

# The system makes both efficiency and security a priority.

# An escrow account holds the total number of Choice Coin required for the voting process, and Algorand accounts for each of the decisions are made.

# Each of the individual decisions made by the voters connect back to the escrow account.

# In turn, one Choice Coin transfers to the appropriate decision account through a stateless smart contract.

# Furthermore, a SHA-512 hashing algorithm is used to encrypt voter information at all stages, ensuring that private information is made secure.

# This is especially useful where voters need to give personal identification for verification purposes.



# Imports and dependicies include the Algorand Python SDK, the Python Hashlib library, and the Python Matplotlib library.

from algosdk import account, encoding, mnemonic, transaction

from algosdk.future.transaction import AssetTransferTxn, PaymentTxn

from algosdk.v2client import algod

import hashlib

import matplotlib

import matplotlib.pyplot as plt

import random

import numpy as np



# Matplot parameters for the matplotlib function to generate a new plot.

matplotlib.use('TkAgg')

# Put Algod Client address here

algod_address = "https://testnet-algorand.api.purestake.io/ps2"

# Put Algod Token here

algod_token = "3nErwJTbc94LTx3AxczGBNymarZg6cF8gWTqiDIf"

headers = {"X-API-Key": algod_token}

# Initializes client for node.

algod_client = algod.AlgodClient(algod_token, algod_address, headers)



# Escrow creation.

# Put in main fund address here

# Put in main fund receiver_mnemonic here

escrow_address = ""

escrow_mnemonic = ""

escrow_key = mnemonic.to_private_key(escrow_mnemonic)

choice_id = 21364625  # Official Test Asset ID for Choice Coin



# Decisions.

# To add more decisions for the election process, add the address for the new decision here.

# Then, add an appropriate boolean statement at line 100 of this file. Be sure to also add additional

# counts at line 148 of this file as well.

decision_one = ""

decision_two = ""

corporate_decision_one = ""

corporate_decision_two = ""



# Clawback Address required to reset accounts to start new voting process.

# Sets up accounts for both the regular election process and the corporate decision process.

# Add more accounts to adjust for more decisions.

clawback_address = ""

clawback_mnemonic = ""

clawback_key = mnemonic.to_private_key(clawback_mnemonic)



# This function counts the number of Choice Coin in an account.

# It first fetches the account_info, and specifically searches among the assets that the account owns for Choice Coin.

# It then returns the number of Choice Coin that the account owns.





def count(address):

    message = ''

    error = ''

    # Fetch account information for the address.

    account_info = algod_client.account_info(address)

    assets = account_info.get("assets")  # Fetch asset information.

    for asset in assets:

        # Iterate over assets until Choice Coin is reached. Return the amount if it exists.

        if asset["asset-id"] == choice_id:

            amount = asset.get("amount")

            message = amount

            return message

    error = 'The account has not opted-in to the asset yet.'

    return error



# This function hashes a string using the SHA-512 cryptographic scheme.

# SHA-512 is a post-quantum cryptographic scheme, thus ensuring that private information is made secure from malicious attackers.





def hashing(item):

    # Assumes the default UTF-8.

    # This encodes the string with the SHA-512 scheme.

    hash_object = hashlib.sha512(item.encode())

    # This returns the hexadecimal encode as a string.

    item = hash_object.hexdigest()

    return item



# This function defines a stateless smart contract on the Algorand Network.

# It sends Choice Coin to the appropriate destination address based on user input.





def choice_vote(sender, key, receiver, amount, comment):

    parameters = algod_client.suggested_params()  # Sets suggested parameters

    transaction = AssetTransferTxn(

        sender, parameters, receiver, amount, choice_id, note=comment)

    # Defines an inital transaction for Choice Coin

    signature = transaction.sign(key)

    # Signs the transaction with the senders private key

    algod_client.send_transaction(signature)

    # Sends the transaction with the signature

    final = transaction.get_txid()

    return True, final



# This function describes a methodology for Electoral Voting on the Choice Coin platform.

# It calls the choice_vote() function with the appropriate inputs based on which decision the voter selected.

# It is currently defined for two candidates/decisions, but it can be easily amended to include more.





def election_voting(vote):

    message = ''

    # Add more boolean statements for more decisions or candidates.

    if vote == 'YES':

        # choice_vote() function called for "YES".

        TX_ID = choice_vote(escrow_address, escrow_key,

                            decision_one, 100, "Tabulated using Choice Coin")

        message = "Ballot Tabulated. \n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/" + \

            TX_ID[1] + "."

        # AlgoExplorer returned for validation.

    elif vote == 'NO':

        TX_ID = choice_vote(escrow_address, escrow_key,

                            decision_two, 100, "Tabulated using Choice Coin")

        message = "Ballot Tabulated. \n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/" + \

            TX_ID[1] + "."

    return message



# This defines a corporate voting mechanism using Choice Coin.

# It works very similarly to the electoral voting scheme defined earlier.

# However, it does introduce the stake as a new variable.

# The stake defines the ownership stake of the shareholder that is voting.





def corporate_voting(vote, stake):

    message = ''

    stake = int(stake)  # Define the ownership stake.

    amount = 100 * stake

    if vote == 'YES':

        comment = "Tabulated using Choice Coin"

        choice_vote(escrow_address, escrow_key,

                    corporate_decision_one, amount, comment)

        # Call the choice_vote() function that sends the appropriate number of Choice Coin based on the ownership stake.

        message = "Ballot Tabulated"

    elif vote == 'NO':

        comment = "Tabulated using Choice Coin"

        choice_vote(escrow_address, escrow_key,

                    corporate_decision_two, amount, comment)

        message = "Ballot Tabulated"

    return message



# Returns a dynamic bar-graph showing the results of the vote.

# Uses PyPlot for both corporate and electoral voting.





def show_results(yes_count, no_count):

    names = ['Candidate 1', 'Candidate 2']  # Define the two decisions.

    # Fetch the total number of votes for each decision.

    values = [yes_count, no_count]

    # Define a new pyplot

    data = np.arange(4000).reshape((100,40))

    plt.figure(figsize=(15, 6))

    plt.subplot(131)

    plt.bar(names, values)

    plt.title('Election Results', fontdict = {'fontsize' : 20})

    plt.savefig('static/img/Figure_1', bbox_inches='tight')

   

    # Return the results.





def show_corporate_results(yes_count, no_count):

    names = ['Decision 1', 'Decision 2']

    values = [yes_count, no_count]

    plt.figure(figsize=(9, 3))

    plt.subplot(131)

    plt.bar(names, values)

    plt.suptitle('Corporate Voting Results')

    plt.savefig('/home/archie/Inital_Demo/static/img/Figure_2.png')



# Counts the total number of votes to return a statement regarding which candidate has won.

# Applies to both corporate and electoral voting.





def count_votes():

    yes_count = int(count(decision_one)/100)

    no_count = int(count(decision_two)/100)

    show_results(yes_count, no_count)

    if yes_count > no_count:

        if yes_count == 1:

            return "The Voting Process has ended. Candidate One received the most votes with {0} vote.".format(yes_count)

        else:

            return "The Voting Process has ended. Candidate One received the most votes with {0} votes.".format(yes_count)

    if no_count > yes_count:

        if no_count == 1:

            return "The Voting Process has ended. Candidate Two received the most votes with {0} vote.".format(no_count)

        else:

            return "The Voting Process has ended. Candidate Two received the most votes with {0} votes.".format(no_count)



    else:

        # Random sample generated from adiabatic quantum computer.

        # Generated using QunatumQuery.py.

        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,

                          0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]

        # Random sample from quantum sample.

        Q = random.choice(quantum_sample)

        if Q:

            return("Tie. The Quantum Oracle selects Candidate One!")

        else:

            return("Tie. The Quantum Oracle selects Candidate Two!")





def count_corporate_votes():

    yes_count = count(corporate_decision_one)

    no_count = count(corporate_decision_two)

    show_corporate_results(yes_count, no_count)

    if yes_count > no_count:

        return "The Voting Process has ended. Decision One had the most votes!"

    if no_count > yes_count:

        return "Decision Two had the most votes!"

    else:

        # Random sample generated from adiabatic quantum computer.

        # Generated using QunatumQuery.py.

        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,

                          0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]

        # Random sample from quantum sample.

        Q = random.choice(quantum_sample)

        if Q:

            return("Tie. The Quantum Oracle selects Decision One!")

        else:

            return("Tie. The Quantum Oracle selects Decision Two!")



# This function resets the voting accounts to start a new voting process.

# It uses the clawback functionality built into Choice Coin to send the Choice Coin back to the main escrow account.





def reset_votes():

    message = ''

#    params = algod_client.suggested_params()

#    yes_count = count(decision_one)

#    no_count = count(decision_two)

    # Fetches the total number of Choice Coin in each account.

#    if yes_count > 0:

#        transaction_2 = AssetTransferTxn(

#            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=decision_one)

#        signature_2 = transaction_2.sign(clawback_key)

#        algod_client.send_transaction(signature_2)

        # Defines a clawback transaction to send Choice Coin back to the escrow account if the number of Choice Coin in the account exceeds zero.

#    if no_count > 0:

#        transaction_3 = AssetTransferTxn(

#            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=decision_two)

#        signature_3 = transaction_3.sign(clawback_key)

#        algod_client.send_transaction(signature_3)

    message = 'Vote accounts reset. New Voting Process started.'

    return message





def reset_corporate_votes():

    message = ''

    params = algod_client.suggested_params()

    yes_count = count(corporate_decision_one)

    no_count = count(corporate_decision_two)

    if yes_count > 0:

        transaction_2 = AssetTransferTxn(

            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=corporate_decision_one)

        signature_2 = transaction_2.sign(clawback_key)

        algod_client.send_transaction(signature_2)

    if no_count > 0:

        transaction_3 = AssetTransferTxn(

            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=corporate_decision_two)

        signature_3 = transaction_3.sign(clawback_key)

        algod_client.send_transaction(signature_3)

    message = 'Vote accounts reset. New Voting Process started.'

    return message



# File: https://github.com/ChoiceCoin/Smart_Contracts/blob/785460d5ed406ef3fb7acfaeaa4cf2f8dd54cbfd/Smarter_Contracts_Bash/jessika_Smarter_Contracts_Bash/game.py

import random as r
from algosdk import account, encoding, mnemonic,transaction
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn
from algosdk.v2client import algod

#This is an Algogenous Smart Contract for a guessing game where if  the user wins he/she gets a reward of a particular amount of a token of your choice and if the player loses he/she loses that same amount of a token of your choice 
#Connect to the Algorand Client (This is for sandbox) here. 
algod_address = "http://localhost:4001"
algod_token = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

#Initializes Client for node
headers = {"X-API-Key": algod_token }
algod_client = algod.AlgodClient(algod_token,algod_address,headers)


#The fund address and fund mnemonic defined below should belong to the creator account that controls the asset that you want to offer.

#In this code I created an ASA TEE COIN on the testnet which I used to reward the user, but you can decide to change it up and use your own asa with a diffrent address and passphrase

#The address I used is  KE3P22YHKMC23OHDPYIMGVG7DHA6GP6T6DBROYRTZX3RQJ73Y2EFM5OEO4
#The passphrase  is : light truck alley era debris mango country lake solution impact captain casual steel mechanic coil ceiling exhibit reject skirt february apart parent master able random
#Warning !!!! This is solely for development purposes and the tokens have 0 value.

creator_address = "KE3P22YHKMC23OHDPYIMGVG7DHA6GP6T6DBROYRTZX3RQJ73Y2EFM5OEO4" #Put the creator address here. 
creator_mnemonic = "light truck alley era debris mango country lake solution impact captain casual steel mechanic coil ceiling exhibit reject skirt february apart parent master able random" #Put the creator mnemonic here. 
fund_key = mnemonic.to_private_key(creator_mnemonic)

#Asset ID for Tee Coin
asset_id = "88713385"

#Welocome Screen
#This prompts the user to input his/her name,testnet address with sufficent algos and the required asa, and their passpharase
print("WELCOME TO THE PRICE IS RIGHT \nGUESS THE RIGHT NUMBER AND GET A CHANCE TO WIN ANY AMOUNT TEECOIN\n---------DISCLAIMER---------\nYOU CAN ALSO LOSE THAT AMOUNT OF TEECOIN IF YOU DONT GUESS RIGHT.")
user_name = input('Type your name : ').title()
print(f'Hello {user_name}.')
user_said = input(f'{user_name} do you want to play Number Guessing game (Y/N) : ').lower()

while True:
    try: 
        user_wage =int(input("ENTER THE AMOUNT OF TEECOIN YOU WANT TO WAGER: "))

    

    except ValueError:
        print("THIS IS NOT A NUMBER")
        continue
    else:
        break
        

user_address = input("\n ENTER YOUR TESTNET ADDRESS WITH SUFFICIENT TESTNET ALGOS: ")
user_key = input("\n PASTE YOUR PASSPHRASE IN THE CORRECT SYNTAX: ")
reciver_address = user_address
reciver_mnemonic = user_key
reciver_key = mnemonic.to_private_key(reciver_mnemonic)
amount = int(user_wage) * 100 
amount2 = amount / 100 
index = asset_id






#This defines a stateless transfer of funds from the creator account  to the user account.  
def asset_transfer_fund(creator_address, fund_key, reciver_address,amount, index = asset_id):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(creator_address, parameters, reciver_address, amount, index =  asset_id )
    signature = transaction.sign(fund_key)
    #Signs the transaction
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    print("TRANSACTION ID : " ,final)
    return True, final

#This defines a stateless transfer of funds from the  user account to the creator account. 
def asset_transfer_user(reciver_address, reciver_key, creator_address, amount, index = asset_id):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(reciver_address, parameters, creator_address, amount, index =  asset_id )
    signature = transaction.sign(reciver_key)
    #Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    print("TRANSACTION ID : ",final)
    return True, final

#This automates the optin action so the user can recieve the token
def optin(reciver_mnemonic,reciver_address,amount,index):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(reciver_address, parameters, reciver_address, 0, index = asset_id)
    key = mnemonic.to_private_key(reciver_mnemonic)
    signature = transaction.sign(key)
    algod_client.send_transaction(signature)
    #Opts-in the account to the asset
    return True




#This defines the game logic
def Main(user_said):

    while True:
        

        if ('y' not in user_said) and ('n' not in user_said) and (user_said != True):
            user_said = input('Invalid keyword\nType again : ').lower()

        elif 'y' in user_said:
            winning_number = r.randint(1,100)
            user_guessed = int(input('\nYou have 6 guesses.\nGuess any number between 1 and 100\nGuess the number : '))
            turn = 1

            while True:
            
                if winning_number == user_guessed:
                    print(f'Congrats you guessed the number in {turn} times.')
                    
                    return 1
                    

                elif turn == 6:
                    print(f'Sorry You can\'t guess the number. The number is {winning_number}.')
                    return 0
                   

                else:
                    if winning_number > user_guessed:
                        print('Too Low')
                    else:
                        print('Too High')

                    print(f'You have {6-turn} guesses left.')
                    
                    turn += 1
                    user_guessed = int(input('Guess again : '))

        

#This checks if the user wins or loses and calls the respective functions to carry out the appropriate transaction which prints out the transaction id which can be verified on algoexplorer.
if Main(user_said) == 1:
    print("YOU WON" ,amount2, " TeeCoin" )
    optin(reciver_mnemonic,reciver_address,amount,index)
    asset_transfer_fund(creator_address, fund_key, reciver_address,amount, index = asset_id)
else :
    print("YOU LOST",amount2, " TeeCoin" )
    optin(reciver_mnemonic,reciver_address,amount,index)
    asset_transfer_user(reciver_address, reciver_key, creator_address, amount, index = asset_id)


# File: https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/fee_check.py
"""Detector for finding execution paths missing Fee check."""

from typing import List, TYPE_CHECKING, Tuple

from tealer.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DetectorType,
)
from tealer.detectors.utils import (
    detect_missing_tx_field_validations_group,
    detect_missing_tx_field_validations_group_complete,
)
from tealer.utils.algorand_constants import MAX_TRANSACTION_COST
from tealer.utils.output import ExecutionPaths

if TYPE_CHECKING:
    from tealer.utils.output import ListOutput
    from tealer.teal.basic_blocks import BasicBlock
    from tealer.teal.context.block_transaction_context import BlockTransactionContext
    from tealer.teal.teal import Teal


class MissingFeeCheck(AbstractDetector):  # pylint: disable=too-few-public-methods
    """Detector to find execution paths missing Fee check.

    The fee for stateless contract transactions will be deducted
    from the contract account or the LogicSig signer account. An
    attacker could set the fee to high value and drain the account
    funds in form of fees.

    This detector tries to find execution paths that approve the algorand
    transaction("return 1") and doesn't check the Fee field.
    """

    NAME = "missing-fee-check"
    DESCRIPTION = "Missing Fee Field Validation"
    TYPE = DetectorType.STATELESS

    IMPACT = DetectorClassification.HIGH
    CONFIDENCE = DetectorClassification.HIGH

    WIKI_URL = (
        "https://github.com/crytic/tealer/wiki/Detector-Documentation#missing-fee-field-validation"
    )
    WIKI_TITLE = "Missing Fee Field Validation"
    WIKI_DESCRIPTION = (
        "LogicSig does not validate `Fee` field."
        " Attacker can submit a transaction with `Fee` field set to large value and drain the account balance."
        " More at [building-secure-contracts/not-so-smart-contracts/algorand/unchecked_transaction_fee]"
        "(https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/algorand/unchecked_transaction_fee)"
    )
    WIKI_EXPLOIT_SCENARIO = """
```py
def withdraw(...) -> Expr:
    return Seq(
        [
            Assert(
                And(
                    Txn.type_enum() == TxnType.Payment,
                    Txn.first_valid() % period == Int(0),
                    Txn.last_valid() == Txn.first_valid() + duration,
                    Txn.receiver() == receiver,
                    Txn.amount() == amount,
                    Txn.first_valid() < timeout,
                )
            ),
            Approve(),
        ]
    )
```

Alice signs the logic-sig to allow recurring payments to Bob.\
 Eve uses the logic-sig and submits a valid transaction with `Fee` set to 1 million ALGOs.\
 Alice loses 1 million ALGOs.
"""

    WIKI_RECOMMENDATION = """
Validate `Fee` field in the LogicSig.
"""

    def detect(self) -> "ListOutput":
        """Detect execution paths with missing Fee check.

        Returns:
            ExecutionPaths instance containing the list of vulnerable execution
            paths along with name, check, impact, confidence and other detector
            information.
        """

        def checks_field(block_ctx: "BlockTransactionContext") -> bool:
            # returns True if fee is bounded by some unknown value
            # or is bounded by some known value less than maximum transaction cost.
            return block_ctx.max_fee_unknown or block_ctx.max_fee <= MAX_TRANSACTION_COST

        # there should be a better to decide which function to call ??
        if self.tealer.output_group:
            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:
            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance
            return list(
                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)
            )

        output: List[
            Tuple["Teal", List[List["BasicBlock"]]]
        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)
        detector_output: "ListOutput" = []
        for contract, vulnerable_paths in output:
            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))

        return detector_output


# File: https://github.com/ChoiceCoin/Choice-V1/blob/6597152bea3dc46545d7c969b76ead8d1ebf7c9d/contracts/Democratic_Rewards.py
#Stateless Smart Contracts on the Algorand Blockhain to send rewards for Democratic Participation.
#Choice Coin seeks to provide rewards to its community for participating in their local democracy.
#The inagaural democratic rewards program will focus on the advocacy for blockchain and cryptocurrency acceptance.

  
from algosdk import account, encoding, mnemonic,transaction
from algosdk.future.transaction import AssetTransferTxn, PaymentTxn
from algosdk.v2client import algod


algod_address = ""
algod_token = ""
# Initializes Client for node
headers = {"X-API-Key": algod_token }
algod_client = algod.AlgodClient(algod_token,algod_address,headers)
reserve_address = "" # Put in main fund address here
reserve_mnemonic = "" # Put in main fund receiver_mnemonic here
reserve_key = mnemonic.to_private_key(reserve_mnemonic)
asset_id =  # Probably will want to change if when we create a new asset

def choice_trade(sender, key, receiver, amount, index,comment):
    parameters = algod_client.suggested_params()
    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)
    #Defines an inital transaction for choice Coin
    signature = transaction.sign(key)
    #Signs the transaction with the senders private key
    algod_client.send_transaction(signature)
    #Sends the transaction with the signature
    final = transaction.get_txid()
    return True, final




def init_democratic_participation():
    parameters = algod_client.suggested_params()
    choice_trade(reserve_address,reserve_key,participation_awards,"Value",asset_id,'Initial Democratic Participation Rewards')


def democratic_awards(query,address):
    if query == 'Letter to local legistature':
        comment = 'Here is your Choice Coin Reward. \n Thanks for sending a letter to your local government'
        reward_amount = ""#Amount of Reward
        choice_trade(fund_address, fund_key, address, reward_amount, asset_id,comment)
    else:
        comment = "Here is you Choice Coin Reward! \n Thanks for participating in our democracy!"
        reward_amount = ""#Amount of Reward
        choice_trade(fund_address, fund_key, address, reward_amount, asset_id,comment)



# File: https://github.com/arty-arty/thefairrandomizer/blob/aa040d0fd50fe85a7e640a05a0b1419490b8a1ff/contract/mainWithNumber.py
import base64
from email import message

from algosdk.future import transaction
from algosdk import mnemonic
from algosdk.v2client import algod
from pyteal import *
from pytealutils.strings import atoi

sender_mnemonic = "paste your own mnemonic here"
receiver_public_key = "UFAGBH5BHBAKDSSSBKP6LAZ7VFIA3ETNK7LVNEH6KXRRNTYE6WYHTEMEGU"
fee_provider_public_key = "I4P7CYNN2S24FJ546IS76M2RJDIAAHJ6CHF7MGH3RBJAPFSDZNNZDRGRSE"
#algod_address = "http://localhost:4001"
#algod_token = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

algod_address = "https://node.testnet.algoexplorerapi.io"
algod_token = ""


def compile_smart_signature(client, source_code):
    compile_response = client.compile(source_code)
    return compile_response['result'], compile_response['hash']


def wait_for_confirmation(client, transaction_id, timeout):
    start_round = client.status()["last-round"] + 1
    current_round = start_round

    while current_round < start_round + timeout:
        try:
            pending_txn = client.pending_transaction_info(transaction_id)
        except Exception:
            return
        if pending_txn.get("confirmed-round", 0) > 0:
            return pending_txn
        elif pending_txn["pool-error"]:
            raise Exception('pool error: {}'.format(pending_txn["pool-error"]))
        client.status_after_block(current_round)
        current_round += 1
    raise Exception(
        'pending tx not found in timeout rounds, timeout value = {}'.format(timeout))

#{"blockSeedTakenFromBlockWithId": "25010658", "publicKey": "40ps3+H7aCMHsosRXB8D/cT/T/SyErbpVVYjI9/SxcY=", "randNumber": "230", "proof": "5rQ79zemy800T2Gze6Lf6E+u3S/+6W0RwHOOBXlFHnolsHKJzHlXABlOf0ZBdSUFdTYyznEpj4MOpJCZX9NMgFajlpwHPRbp8Oa7E5hAswI="}


def verified_random_announcer(benefactor, feeprovider):
    #fee_cond = Txn.fee() <= Global.min_txn_fee()
    fee_cond = Gtxn[0].fee() == Int(0)
    safety_cond = And(
        Global.group_size() == Int(2),
        Gtxn[0].type_enum() == TxnType.Payment,
        Gtxn[0].close_remainder_to() == Global.zero_address(),
        Gtxn[0].asset_close_to() == Global.zero_address(),
        Gtxn[0].rekey_to() == Global.zero_address(),
        Gtxn[0].amount() == Int(0),
        Gtxn[1].type_enum() == TxnType.Payment,
        Gtxn[1].close_remainder_to() == Global.zero_address(),
        Gtxn[1].asset_close_to() == Global.zero_address(),
        Gtxn[1].rekey_to() == Global.zero_address(),
        Gtxn[1].amount() == Int(0),
    )

    futureBlockId = JsonRef.as_uint64(
        Txn.note(), Bytes("blockSeedTakenFromBlockWithId"))
    blockSeed = Block.seed(futureBlockId)
    #message = Sha256(blockSeed)
    message = blockSeed
    proof = Base64Decode.std(JsonRef.as_string(
        Txn.note(), Bytes("proof")))
    randNumber0 = JsonRef.as_uint64(
        Txn.note(), Bytes("randNumber"))

    publicKey = Base64Decode.std(JsonRef.as_string(
        Txn.note(), Bytes("publicKey")))

    program = And(
        Gtxn[1].sender() == Addr(feeprovider),
        Gtxn[1].receiver() == Addr(feeprovider),
        randNumber0 == GetByte(proof, Int(0)),
        #blockSeed == actualBlockSeed,
        VrfVerify.algorand(message, proof, publicKey).outputReducer(
            lambda x, y: y == Int(1))
    )
    safe_program = And(fee_cond, safety_cond, program)
    return compileTeal(safe_program, Mode.Signature, version=7)


def payment_transaction(creator_mnemonic, amt, rcv, algod_client):
    params = algod_client.suggested_params()
    add = mnemonic.to_public_key(creator_mnemonic)
    key = mnemonic.to_private_key(creator_mnemonic)
    unsigned_txn = transaction.PaymentTxn(
        add, params, rcv, amt, note="Yeah".encode())
    signed = unsigned_txn.sign(key)
    txid = algod_client.send_transaction(signed)
    pmtx = wait_for_confirmation(algod_client, txid, 5)
    return pmtx


#{"blockSeed": "3P5WUDZKFHH7BLSYJYZUGJ5KLCFO72M7733MVWAE5JXD7N7MY54A", "proof": "bICa1Ajt27oTDzMf5O02vdfuYNvfBBAsrqr8f05jh0vuqTfHy7yV+82QRCw52erX6rlhzZ6Pdv8XyhWZTvOG4eksdNN6QhAYZyJo408wYgs=", "publicKey": "H/IBtJ8dSMRjYo344o/gtfiZToq9+cfPOHtCG6dfZ/U=", "randNumber": "087"}


def lsig_payment_txn(escrowProg, escrow_address, amt, rcv, algod_client):
    params = algod_client.suggested_params()
    unsigned_txn = transaction.PaymentTxn(
        escrow_address, params, rcv, amt, note='''{"blockSeed": "3P5WUDZKFHH7BLSYJYZUGJ5KLCFO72M7733MVWAE5JXD7N7MY54A", "proof": "bICa1Ajt27oTDzMf5O02vdfuYNvfBBAsrqr8f05jh0vuqTfHy7yV+82QRCw52erX6rlhzZ6Pdv8XyhWZTvOG4eksdNN6QhAYZyJo408wYgs=", "publicKey": "H/IBtJ8dSMRjYo344o/gtfiZToq9+cfPOHtCG6dfZ/U="}'''.encode())
    encodedProg = escrowProg.encode()
    program = base64.decodebytes(encodedProg)
    lsig = transaction.LogicSig(program)
    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)
    tx_id = algod_client.send_transaction(stxn)
    pmtx = wait_for_confirmation(algod_client, tx_id, 10)
    return pmtx


def main():
    algod_client = algod.AlgodClient(algod_token, algod_address)

    print("--------------------------------------------")
    print("Compiling Donation Smart Signature ...")
    stateless_program_teal = verified_random_announcer(
        receiver_public_key, fee_provider_public_key)
    escrow_result, escrow_address = compile_smart_signature(
        algod_client, stateless_program_teal)
    print("Program:", escrow_result)
    print("Contract Address:", escrow_address)

    # print("--------------------------------------------")
    #print("Sending Fund to Donation Smart Signature ...")
    #amt = 220000
    #payment_transaction(sender_mnemonic, amt, escrow_address, algod_client)

    # print("--------------------------------------------")
    #print("Withdraw from Donation Smart Signature ...")
    #withdrawal_amt = 0
    # lsig_payment_txn(escrow_result, escrow_address,
    #                withdrawal_amt, receiver_public_key, algod_client)


if __name__ == "__main__":
    main()


# File: https://github.com/ChoiceCoin/Algorand-Protocol/blob/1f920b76c6c31eff23ed07b2248aabee32c821ae/AtomicTransfers/MoonX_Atomic_Transfer_Bash/transfer.py
import os , json
import easygui

from algosdk import account, mnemonic 
from algosdk.v2client import algod
from algosdk.future import transaction

mn1 = 'shuffle speed split bread mansion limb daughter destroy minimum town pistol slam leaf slide potato mule alpha furnace glass humble ladder kiss eight abandon gasp'
mn2 = 'hazard dust join live water venue few grant neglect road illegal sad mammal demand often must infant horn magic piano goat exchange deny ability tag'

def createAccount():
    private_key, address = account.generate_account()
    print("Receiver address: {}".format(address))
    print("Receivers mnemonic passphrase: {}".format(mnemonic.from_private_key(private_key)))
    return private_key, address

def get_address(mn):
    pk_account_a = mnemonic.to_private_key(mn)
    address = account.address_from_private_key(pk_account_a)
    print("Address :", address)
    return address

def getInfo(algod_client, addr):
    try:
        accountInfo = algod_client.account_info(addr)
        return accountInfo
    except Exception as e:
        print("Error Occured {}".format(str(e)))
        exit()


def printAccount(account_info_1, account_info_2, indent=4):
    try:
        data = [[account_info_1['address'], account_info_1['amount'] / 1000000],
                [account_info_2['address'], account_info_2['amount'] / 1000000]]
        format_row = "{:<2}{:>12}"
        print("{:<60} {:<15}".format("Address","Amount(Algo)"))
        for account in data:
            print(format_row.format(*account))
        print("")
    except Exception as e:
        print("Error Occur: " + str(e))


def transfer():
    try:
        print("########### CHOICE-COIN ATOMIC TRANSFER ##################")
           # user declared algod connection parameters
        algod_address = "https://testnet-algorand.api.purestake.io/ps2"
        algod_token = "HfiEnjsWGW28EEEdqURGt40hxXT3hVSs6nkGAr9Y"
        headers = {"X-API-Key": algod_token }


        # Initialize an algodClient
        algod_client = algod.AlgodClient(algod_token, algod_address, headers)

        account_1 = get_address(mn1)
        account_2 = get_address(mn2)

        account_1_key = mnemonic.to_private_key(mn1)
        account_2_key = mnemonic.to_private_key(mn2)
        print('Getting account information....')
        account_1_info = getInfo(algod_client, account_1)
        account_2_info = getInfo(algod_client, account_2)
        printAccount(account_1_info, account_2_info)


        print('Generating receivers account...')
        acount_3_key, account_3 = createAccount()

        amount = easygui.enterbox("Algo amount")
        amount = int(amount) * 1000000
        print("Creating transactions...")
        params = algod_client.suggested_params()
        txn_1 = transaction.PaymentTxn(account_1, params, account_3, amount)
        txn_2 = transaction.PaymentTxn(account_2, params, account_3, amount)
        print('Calculating Group ID...')
        gid = transaction.calculate_group_id([txn_1, txn_2])
        txn_1.group = gid
        txn_2.group = gid

        print('Signing transaction....')
        stxn_1 = txn_1.sign(account_1_key)
        stxn_2 = txn_2.sign(account_2_key)
        signed_group = [stxn_1, stxn_2]
        print('Sending Transaction')
        tx_id = algod_client.send_transactions(signed_group)
        print("TransactionId: {}".format(tx_id))
        confirmed_txn = transaction.wait_for_confirmation(algod_client, tx_id)
        print("Transaction confirmed")
        print(f'Visit https://testnet.algoexplorer.io/tx/{tx_id}')
        print("Transaction information: {}\n".format(json.dumps(confirmed_txn)))
    except Exception as e:
        print("Error occured: " + str(e))




if __name__ == '__main__':
    transfer()

# File: https://github.com/algorandfoundation/algokit-cli/blob/d7fdc1207d443c056d5bf6a616ec01b253ea25e2/src/algokit/cli/tasks/transfer.py
import logging

import click
from algokit_utils import AlgoAmount, AssetTransferParams, PaymentParams, SendAtomicTransactionComposerResults

from algokit.cli.common.constants import AlgorandNetwork, ExplorerEntityType
from algokit.cli.common.utils import get_explorer_url
from algokit.cli.tasks.utils import (
    get_account_with_private_key,
    get_address,
    get_asset_decimals,
    load_algod_client,
    validate_address,
    validate_balance,
)
from algokit.core.utils import get_algorand_client_for_network

logger = logging.getLogger(__name__)

# TODO: upon algokit nfd lookup being implemented receiver will also allow nfd lookups


@click.command(name="transfer", help="""Transfer algos or assets from one account to another.""")
@click.option("--sender", "-s", type=click.STRING, help="Address or alias of the sender account.", required=True)
@click.option(
    "--receiver",
    "-r",
    type=click.STRING,
    help="Address or alias to an account that will receive the asset(s).",
    required=True,
)
@click.option(
    "--asset",
    "--id",
    "asset_id",
    type=click.INT,
    help="Asset ID to transfer. Defaults to 0 (Algo).",
    default=0,
    required=False,
)
@click.option("--amount", "-a", type=click.INT, help="Amount to transfer.", required=True)
@click.option(
    "--whole-units",
    "whole_units",
    is_flag=True,
    type=click.BOOL,
    help=(
        "Use whole units (Algos | ASAs) instead of smallest divisible units (for example, microAlgos). "
        "Disabled by default."
    ),
    default=False,
    required=False,
)
@click.option(
    "-n",
    "--network",
    type=click.Choice([choice.value for choice in AlgorandNetwork]),
    default=AlgorandNetwork.LOCALNET,
    required=False,
    help=f"Network to use. Refers to `{AlgorandNetwork.LOCALNET}` by default.",
)
def transfer(  # noqa: PLR0913
    *,
    sender: str,
    receiver: str,
    asset_id: int,
    amount: int,
    whole_units: bool,
    network: AlgorandNetwork,
) -> None:
    # Load addresses and accounts from mnemonics or aliases
    sender_account = get_account_with_private_key(sender)
    receiver_address = get_address(receiver)

    # Get algod client
    algod_client = load_algod_client(network)

    # Convert amount to whole units if specified
    if whole_units:
        amount = amount * (10 ** get_asset_decimals(asset_id, algod_client))

    # Validate inputs
    validate_address(receiver_address)
    validate_balance(algod_client, sender_account, asset_id, amount)
    validate_balance(algod_client, receiver_address, asset_id)

    # Transfer algos or assets depending on asset_id
    txn_response: SendAtomicTransactionComposerResults | None = None
    algorand = get_algorand_client_for_network(network)
    try:
        if asset_id == 0:
            txn_response = (
                algorand.new_group()
                .add_payment(
                    PaymentParams(
                        sender=sender_account.address,
                        receiver=receiver_address,
                        amount=AlgoAmount(micro_algo=amount),
                        signer=sender_account.signer,
                    )
                )
                .send()
            )
        else:
            txn_response = (
                algorand.new_group()
                .add_asset_transfer(
                    AssetTransferParams(
                        sender=sender_account.address,
                        receiver=receiver_address,
                        amount=amount,
                        asset_id=asset_id,
                        signer=sender_account.signer,
                    ),
                )
                .send()
            )

        txn_url = get_explorer_url(
            identifier=txn_response.tx_ids[0],
            network=network,
            entity_type=ExplorerEntityType.TRANSACTION,
        )
        click.echo(f"Successfully performed transfer. See details at {txn_url}")

    except Exception as err:
        logger.debug(err, exc_info=True)
        raise click.ClickException("Failed to perform transfer") from err


# File: https://github.com/manicdon7/algorand/blob/c12ccc8b6be34ae27fe836d267cdf66e25740079/.venv/Lib/site-packages/algokit_utils/_transfer.py
import dataclasses
import logging
from typing import TYPE_CHECKING

import algosdk.transaction
from algosdk.account import address_from_private_key
from algosdk.atomic_transaction_composer import AccountTransactionSigner
from algosdk.transaction import AssetTransferTxn, PaymentTxn, SuggestedParams

from algokit_utils.models import Account

if TYPE_CHECKING:
    from algosdk.v2client.algod import AlgodClient

__all__ = ["TransferParameters", "transfer", "TransferAssetParameters", "transfer_asset"]
logger = logging.getLogger(__name__)


@dataclasses.dataclass(kw_only=True)
class TransferParametersBase:
    """Parameters for transferring ALGOs between accounts

    Args:
        from_account (Account | AccountTransactionSigner): The account (with private key) or signer that will send
            the ALGOs
        to_address (str): The account address that will receive the ALGOs
        suggested_params (SuggestedParams | None): (optional) transaction parameters
        note (str | bytes | None): (optional) transaction note
        fee_micro_algos (int | None): (optional) The flat fee you want to pay, useful for covering extra fees in a
            transaction group or app call
        max_fee_micro_algos (int | None): (optional) The maximum fee that you are happy to pay (default: unbounded)
            - if this is set it's possible the transaction could get rejected during network congestion
    """

    from_account: Account | AccountTransactionSigner
    to_address: str
    suggested_params: SuggestedParams | None = None
    note: str | bytes | None = None
    fee_micro_algos: int | None = None
    max_fee_micro_algos: int | None = None


@dataclasses.dataclass(kw_only=True)
class TransferParameters(TransferParametersBase):
    """Parameters for transferring ALGOs between accounts"""

    micro_algos: int


@dataclasses.dataclass(kw_only=True)
class TransferAssetParameters(TransferParametersBase):
    """Parameters for transferring assets between accounts

    Args:
       asset_id (int): The asset id that will be transfered
       amount (int): The amount to send
       clawback_from (str | None): An address of a target account from which to perform a clawback operation. Please
           note, in such cases senderAccount must be equal to clawback field on ASA metadata.
    """

    asset_id: int
    amount: int
    clawback_from: str | None = None


def _check_fee(transaction: PaymentTxn | AssetTransferTxn, max_fee: int | None) -> None:
    if max_fee is not None:
        # Once a transaction has been constructed by algosdk, transaction.fee indicates what the total transaction fee
        # Will be based on the current suggested fee-per-byte value.
        if transaction.fee > max_fee:
            raise Exception(
                f"Cancelled transaction due to high network congestion fees. "
                f"Algorand suggested fees would cause this transaction to cost {transaction.fee} ALGOs. "
                f"Cap for this transaction is {max_fee} ALGOs."
            )
        if transaction.fee > algosdk.constants.MIN_TXN_FEE:
            logger.warning(
                f"Algorand network congestion fees are in effect. "
                f"This transaction will incur a fee of {transaction.fee} ALGOs."
            )


def transfer(client: "AlgodClient", parameters: TransferParameters) -> PaymentTxn:
    """Transfer ALGOs between accounts"""

    params = parameters
    params.suggested_params = parameters.suggested_params or client.suggested_params()
    from_account = params.from_account
    sender = _get_address(from_account)
    transaction = PaymentTxn(
        sender=sender,
        receiver=params.to_address,
        amt=params.micro_algos,
        note=params.note.encode("utf-8") if isinstance(params.note, str) else params.note,
        sp=params.suggested_params,
    )  # type: ignore[no-untyped-call]

    result = _send_transaction(client=client, transaction=transaction, parameters=params)
    assert isinstance(result, PaymentTxn)
    return result


def transfer_asset(client: "AlgodClient", parameters: TransferAssetParameters) -> AssetTransferTxn:
    """Transfer assets between accounts"""

    params = parameters
    params.suggested_params = parameters.suggested_params or client.suggested_params()
    sender = _get_address(parameters.from_account)
    suggested_params = parameters.suggested_params or client.suggested_params()
    xfer_txn = AssetTransferTxn(
        sp=suggested_params,
        sender=sender,
        receiver=params.to_address,
        close_assets_to=None,
        revocation_target=params.clawback_from,
        amt=params.amount,
        note=params.note,
        index=params.asset_id,
        rekey_to=None,
    )  # type: ignore[no-untyped-call]

    result = _send_transaction(client=client, transaction=xfer_txn, parameters=params)
    assert isinstance(result, AssetTransferTxn)
    return result


def _send_transaction(
    client: "AlgodClient",
    transaction: PaymentTxn | AssetTransferTxn,
    parameters: TransferAssetParameters | TransferParameters,
) -> PaymentTxn | AssetTransferTxn:
    if parameters.fee_micro_algos:
        transaction.fee = parameters.fee_micro_algos

    if parameters.suggested_params is not None and not parameters.suggested_params.flat_fee:
        _check_fee(transaction, parameters.max_fee_micro_algos)

    signed_transaction = transaction.sign(parameters.from_account.private_key)  # type: ignore[no-untyped-call]
    client.send_transaction(signed_transaction)

    txid = transaction.get_txid()  # type: ignore[no-untyped-call]
    logger.debug(f"Sent transaction {txid} type={transaction.type} from {_get_address(parameters.from_account)}")

    return transaction


def _get_address(account: Account | AccountTransactionSigner) -> str:
    if type(account) is Account:
        return account.address
    else:
        address = address_from_private_key(account.private_key)  # type: ignore[no-untyped-call]
        return str(address)


# File: https://github.com/Ganainmtech/Algorand_Bytes/blob/6d78e8afabc809164c366607e1a9892af80c6750/localnet_examples/Intermediate/00_atomicTransfer.py
'''
This script demonstrates how to execute multiple transactions atomically, ensuring all transactions in a group either succeed or fail together.

This is where you would include any setup code needed, such as:

- Import the necessary libraries and modules:
  from algokit_utils.beta.algorand_client import *
- Generate Algorand Accounts
- Fund the accounts

You can find all the foundational code in the 'Beginner' folder.
'''

# Initialize the Algorand Client
algorand = AlgorandClient.default_local_net()

# Group transactions for atomic transfer
group_tx = algorand.new_group()

# Add the first payment transaction to the group
group_tx.add_payment(
    PayParams(
        sender=receiver_one.address,   # Address of the first sender
        receiver=receiver_two.address, # Address of the first receiver
        amount=1_000_000               # Amount to transfer (in microAlgos)
    ))

# Add the second payment transaction to the group
group_tx.add_payment(
    PayParams(
        sender=receiver_two.address,   # Address of the second sender
        receiver=receiver_one.address, # Address of the second receiver
        amount=1_000_000               # Amount to transfer (in microAlgos)
    ))

# Execute the grouped transactions atomically
group_tx.execute()

'''
About atomic transfers:
- Atomic transfers or swaps ensure that every transaction in a group either all succeed or else all fail.
- You can use this structure to execute multiple transactions as a single atomic unit.

Why Use Atomic Transfers?
- Atomic transfers are essential when you need to ensure consistency and reliability across multiple transactions. For example:
  - When performing a swap or exchange where multiple parties are involved, you want to ensure that all parts of the transaction complete successfully before finalizing.
  - In decentralized finance (DeFi) applications, atomic transfers can be used to maintain integrity and prevent partial or failed transactions that could lead to unexpected outcomes.

Remember:
- Atomic transfers are subject to the Algorand networks transaction limits and fees. Make sure you account for these in your planning.
- The success of atomic transfers depends on the overall validity of the group transaction. If any single transaction fails validation, the entire group will be rejected.
'''


# File: https://github.com/atsoc1993/Hot-Potato-Contract-AVM/blob/e2e4979b491c97f4d333eeaf1332fecd566e505d/AlgoPotatoClient.py
# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "asset", "name": "asset"}, {"type": "txn", "name": "mbr_payment"}], "name": "asset_opt_in", "returns": {"type": "void"}, "desc": "Confirm the minimum balance requirement for the asset opt in of 100,000 Microalgo, or 0.1 Algo, was sent to the contract\n(Prevents potential usage of Algo funds reserves for games or excess mbr from box deletions)", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "txn", "name": "asset_deposit"}, {"type": "txn", "name": "mbr_fee"}], "name": "create_game", "returns": {"type": "void"}, "desc": "Initializes a game\n- Dynamically confirms the contract is the receiver of both the asset deposit and mbr fee - Gets the asset id and amount transferred from the asset deposit - Constructs a box name instance using the sender and current global counter - Constructs a box value template with only non-default values being player 1 address, asset (0 if algo), asset deposit amount, and player 1 round (current round) - Writes the box name and value", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "(address,uint64)", "name": "game_box_name", "struct": "GameBoxName"}, {"type": "txn", "name": "asset_deposit"}], "name": "prime_game_vrf", "returns": {"type": "void"}, "desc": "Asserts the contract is the receiver of player 2's asset deposit\nGets the current game details Verifies that the asset deposit matches the game details, Updates the current game box with player 2's information Writes the updated information into box storage", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "(address,uint64)", "name": "game_box_name", "struct": "GameBoxName"}], "name": "play_game", "returns": {"type": "string"}, "desc": "Initializes the \"Hot Potato\" Game\n- Starts with an ensure budget requiring 14 inner txns - Gets the game information - Ensures a player 2 has joined and the game is ready - Gets the VRF Output % 240, see \"get_vrf_output_modulo\" for information on why the # 240 was chosen - Verifies both users are opted in or asset is Algorand which does not require opt in - If either of the users are not opted into the asset then the reward goes to the user that is still opted in - If both users are not opted in the first to opt in can claim the reward - If the VRF round has expired (1,512 rounds have passed since the VRF round selected) a new VRF round is created 9 rounds into the future - Hot Potato game starts, the contract sends Algo or Asset zero amount transactions to both players until the target modulo is reached - The player the 'Hot Potato' was on at the target modulo receives the reward - The reward is dispensed and the box is deleted to prevent state bloat - A little string is returned that states which player won", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "(address,uint64)", "name": "game_box_name", "struct": "GameBoxName"}], "name": "cancel_game", "returns": {"type": "void"}, "desc": "Cancels a game if and only if there is no active player 2\nDispenses the asset deposit to player 1", "events": [], "readonly": false, "recommendations": {}}], "name": "AlgoPotato", "state": {"keys": {"box": {}, "global": {"games_played": {"key": "Z2FtZXNfcGxheWVk", "keyType": "AVMString", "valueType": "AVMUint64"}, "counter": {"key": "Y291bnRlcg==", "keyType": "AVMString", "valueType": "AVMUint64"}, "vrf_app_id": {"key": "dnJmX2FwcF9pZA==", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"game_box": {"keyType": "GameBoxName", "valueType": "GameBoxValue", "prefix": ""}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 3}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"GameBoxName": [{"name": "player_1", "type": "address"}, {"name": "counter", "type": "uint64"}], "GameBoxValue": [{"name": "player_1", "type": "address"}, {"name": "player_2", "type": "address"}, {"name": "player_1_round", "type": "uint64"}, {"name": "player_2_round", "type": "uint64"}, {"name": "vrf_round", "type": "uint64"}, {"name": "asset", "type": "uint64"}, {"name": "asset_amount", "type": "uint64"}]}, "byteCode": {"approval": "CiAFAAEEAu/ojZ4CJgYMZ2FtZXNfcGxheWVkB2NvdW50ZXIIAAAAAAAAAAAABBUffHUDBoEBMRhAABUoImcpImeACnZyZl9hcHBfaWQhBGcxG0EAlIIFBCjFvuoEA+IL6gSpwiWGBC85JNcEg1HatzYaAI4FAFQAQAAtABEAAiJDMRkURDEYRDYaAYgEHiNDMRkURDEYRDYaAYgBqUkVFlcGAkxQJwRMULAjQzEZFEQxGEQ2GgExFiMJiAESI0MxGRREMRhEMRYlCTEWIwmIAH4jQzEZFEQxGEQ2GgEXwDAxFiMJiAAzI0MxGUD/kTEYFEQjQ4oBAIv/OBBJIxJBAAmL/zgHMgoSRImLACQSQf/4i/84FDIKEkSJigIAi/+I/9IyCov+cABFAUAAG4v/OAiBoI0GEkSxMgqyFIv+shEkshAisgGziYv/OAgURImKAgCL/oj/nYv/iP+YIkmL/jgQSSMSSUAAB4sCJBJBAFsjRIsDQQA+IowAi/44CIwBiwFJRCIpZUQjCClMZzEAIillRBZQMQAyAzIGFosAFk8FFk8ETwRQTwNQKlAqUE8CUExQv4mLAiQSQf/Ei/44EYwAi/44EowBQv+1IkL/oooCAIv/iP8di/6+RIv/OBBJJBJAAAeLASMSQQBWI0SLASMSQQAziwBJV1gIKqhEV2AIi/84CBaoRIsASVcgIDIDEkQxAFwgMgYWXEgyBoEJCBZcUIv+TL+JiwBJV1gIi/84ERaoRFdgCIv/OBIWqERC/8YiQv+nigEBIkcGK0cHgZpOMgwNQQAYsYEGshCBBbIZJwWyHicFsh8isgGzQv/fi/++TElOAowARElXUAhJjAYqqUQyBkyBUFsJgegLDUEB2yJJjA6MC4sASVcAIIwBSVcgIIwCSYFYW0lOAowHgWBbJQuMCEABHSMrjAWMCYsOQAAlMgaBCQgWiwBMXFCL/0y/gBFWUkYgUm91bmQgZXhwaXJlZIwAiYsJQAASi/+8SCIoZUQjCChMZ4sFjACJMgOMA4sLIwiMDCKMCosKiwwMiwOMBEEAOIsKJRhJjA1AAASLAYwDiw1BAASLAowDiwqLCxJBAGuLB0AAT7GLCLIIiwOyByOyECKyAbOLA4wEiwSL/7xIIihlRCMIKExniwESQQATgA5QbGF5ZXIgMSBXaW5zIYwAiYAOUGxheWVyIDIgV2lucyGMAImxiwiyEosDshSLB7IRJLIQIrIBs0L/qosHQAAYsSKyCIsDsgcjshAisgGziwojCIwKQv9NsSKyEosDshSLB7IRJLIQIrIBs0L/4YsBiwdwAEUBQAA8sYsIshKLArIUiweyESSyECKyAbMigB5QbGF5ZXIgMSBGb3JmZWl0IGJ5IG9wdGluZyBvdXSMBYwJQv6iiwKLB3AARQFAADyxiwiyEosBshSLB7IRJLIQIrIBsyKAHlBsYXllciAyIEZvcmZlaXQgYnkgb3B0aW5nIG91dIwFjAlC/lsjK4wFjAlC/lKxiwBJFRZXBgJMUCEEshiABEfCDCOyGosGshqyGoEGshAisgGztD5JVwAEJwQSRFcGAIAB8KoXjAsjjA5C/eyKAQCL/75ESVcAIExJVyAgSwGBWFtJTgNOBEyBYFtOAzIDEkRAABGxsgeyCCOyECKyAbOL/7xIibFMshKLALIRshQkshAisgGzQv/n", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 4, "patch": 2}}, "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcG90YXRvLkFsZ29Qb3RhdG8uX19hbGdvcHlfZW50cnlwb2ludF93aXRoX2luaXQoKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDQgMiA2MDAwMTE4ODcKICAgIGJ5dGVjYmxvY2sgImdhbWVzX3BsYXllZCIgImNvdW50ZXIiIDB4MDAwMDAwMDAwMDAwMDAwMCAiIiAweDE1MWY3Yzc1IDB4MDY4MTAxCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBhbGdvcG90YXRvLnB5OjQxCiAgICAvLyBzZWxmLmdhbWVzX3BsYXllZCA9IFVJbnQ2NCgwKQogICAgYnl0ZWNfMCAvLyAiZ2FtZXNfcGxheWVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQyCiAgICAvLyBzZWxmLmNvdW50ZXIgPSBVSW50NjQoMCkKICAgIGJ5dGVjXzEgLy8gImNvdW50ZXIiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQKICAgIC8vIHNlbGYudnJmX2FwcF9pZCA9IEFwcGxpY2F0aW9uKDYwMDAxMTg4NykgI1Rlc3RuZXQKICAgIHB1c2hieXRlcyAidnJmX2FwcF9pZCIKICAgIGludGMgNCAvLyA2MDAwMTE4ODcKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzEKICAgIC8vIGNsYXNzIEFsZ29Qb3RhdG8oQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AxMAogICAgcHVzaGJ5dGVzcyAweDI4YzViZWVhIDB4MDNlMjBiZWEgMHhhOWMyMjU4NiAweDJmMzkyNGQ3IDB4ODM1MWRhYjcgLy8gbWV0aG9kICJhc3NldF9vcHRfaW4oYXNzZXQsdHhuKXZvaWQiLCBtZXRob2QgImNyZWF0ZV9nYW1lKHR4bix0eG4pdm9pZCIsIG1ldGhvZCAicHJpbWVfZ2FtZV92cmYoKGFkZHJlc3MsdWludDY0KSx0eG4pdm9pZCIsIG1ldGhvZCAicGxheV9nYW1lKChhZGRyZXNzLHVpbnQ2NCkpc3RyaW5nIiwgbWV0aG9kICJjYW5jZWxfZ2FtZSgoYWRkcmVzcyx1aW50NjQpKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2Fzc2V0X29wdF9pbl9yb3V0ZUA1IG1haW5fY3JlYXRlX2dhbWVfcm91dGVANiBtYWluX3ByaW1lX2dhbWVfdnJmX3JvdXRlQDcgbWFpbl9wbGF5X2dhbWVfcm91dGVAOCBtYWluX2NhbmNlbF9nYW1lX3JvdXRlQDkKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzEKICAgIC8vIGNsYXNzIEFsZ29Qb3RhdG8oQVJDNENvbnRyYWN0KToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fY2FuY2VsX2dhbWVfcm91dGVAOToKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDY4CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzEKICAgIC8vIGNsYXNzIEFsZ29Qb3RhdG8oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDY4CiAgICAvLyBAYWJpbWV0aG9kCiAgICBjYWxsc3ViIGNhbmNlbF9nYW1lCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3BsYXlfZ2FtZV9yb3V0ZUA4OgogICAgLy8gYWxnb3BvdGF0by5weTo0MDcKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gYWxnb3BvdGF0by5weTo0MDcKICAgIC8vIEBhYmltZXRob2QKICAgIGNhbGxzdWIgcGxheV9nYW1lCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9wcmltZV9nYW1lX3ZyZl9yb3V0ZUA3OgogICAgLy8gYWxnb3BvdGF0by5weToyNDcKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICAvLyBhbGdvcG90YXRvLnB5OjI0NwogICAgLy8gQGFiaW1ldGhvZAogICAgY2FsbHN1YiBwcmltZV9nYW1lX3ZyZgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfZ2FtZV9yb3V0ZUA2OgogICAgLy8gYWxnb3BvdGF0by5weToxODAKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMyAvLyAyCiAgICAtCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIGFsZ29wb3RhdG8ucHk6MTgwCiAgICAvLyBAYWJpbWV0aG9kCiAgICBjYWxsc3ViIGNyZWF0ZV9nYW1lCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2Fzc2V0X29wdF9pbl9yb3V0ZUA1OgogICAgLy8gYWxnb3BvdGF0by5weTo2MQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBhbGdvcG90YXRvLnB5OjMxCiAgICAvLyBjbGFzcyBBbGdvUG90YXRvKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBc3NldHMKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgLy8gYWxnb3BvdGF0by5weTo2MQogICAgLy8gQGFiaW1ldGhvZAogICAgY2FsbHN1YiBhc3NldF9vcHRfaW4KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDEwOgogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAxMgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBhbGdvcG90YXRvLkFsZ29Qb3RhdG8uY29udHJhY3RfaXNfcmVjZWl2ZXIodHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNvbnRyYWN0X2lzX3JlY2VpdmVyOgogICAgLy8gYWxnb3BvdGF0by5weTo0OC01MgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBjb250cmFjdF9pc19yZWNlaXZlcigKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHR4bjogZ3R4bi5UcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gYWxnb3BvdGF0by5weTo1NgogICAgLy8gaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBieiBjb250cmFjdF9pc19yZWNlaXZlcl9lbHNlX2JvZHlAMgogICAgLy8gYWxnb3BvdGF0by5weTo1NwogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAoKY29udHJhY3RfaXNfcmVjZWl2ZXJfYWZ0ZXJfaWZfZWxzZUA1OgogICAgcmV0c3ViCgpjb250cmFjdF9pc19yZWNlaXZlcl9lbHNlX2JvZHlAMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6NTgKICAgIC8vIGVsaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXI6CiAgICBmcmFtZV9kaWcgMAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICA9PQogICAgYnogY29udHJhY3RfaXNfcmVjZWl2ZXJfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBhbGdvcG90YXRvLnB5OjU5CiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X3JlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIHJldHN1YgoKCi8vIGFsZ29wb3RhdG8uQWxnb1BvdGF0by5hc3NldF9vcHRfaW4oYXNzZXQ6IHVpbnQ2NCwgbWJyX3BheW1lbnQ6IHVpbnQ2NCkgLT4gdm9pZDoKYXNzZXRfb3B0X2luOgogICAgLy8gYWxnb3BvdGF0by5weTo2MS02NgogICAgLy8gQGFiaW1ldGhvZAogICAgLy8gZGVmIGFzc2V0X29wdF9pbigKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFzc2V0OiBBc3NldCwKICAgIC8vICAgICBtYnJfcGF5bWVudDogZ3R4bi5UcmFuc2FjdGlvbgogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjcyCiAgICAvLyBzZWxmLmNvbnRyYWN0X2lzX3JlY2VpdmVyKG1icl9wYXltZW50KQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5Ojc0CiAgICAvLyBpZiBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmlzX29wdGVkX2luKGFzc2V0KSA9PSBGYWxzZToKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXNzZXRfb3B0X2luX2Vsc2VfYm9keUAyCiAgICAvLyBhbGdvcG90YXRvLnB5Ojc1CiAgICAvLyBhc3NlcnQgbWJyX3BheW1lbnQuYW1vdW50ID09IDEwMF8wMDAKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBwdXNoaW50IDEwMDAwMCAvLyAxMDAwMDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6OTAtOTMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGFsZ29wb3RhdG8ucHk6OTIKICAgIC8vIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6OTAKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMiAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBhbGdvcG90YXRvLnB5OjkwLTkzCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgphc3NldF9vcHRfaW5fZWxzZV9ib2R5QDI6CiAgICAvLyBhbGdvcG90YXRvLnB5Ojc5CiAgICAvLyBhc3NlcnQgbWJyX3BheW1lbnQuYW1vdW50ID09IDAKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICAhCiAgICBhc3NlcnQKICAgIHJldHN1YgoKCi8vIGFsZ29wb3RhdG8uQWxnb1BvdGF0by5jcmVhdGVfZ2FtZShhc3NldF9kZXBvc2l0OiB1aW50NjQsIG1icl9mZWU6IHVpbnQ2NCkgLT4gdm9pZDoKY3JlYXRlX2dhbWU6CiAgICAvLyBhbGdvcG90YXRvLnB5OjE4MC0xODUKICAgIC8vIEBhYmltZXRob2QKICAgIC8vIGRlZiBjcmVhdGVfZ2FtZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFzc2V0X2RlcG9zaXQ6IGd0eG4uVHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWJyX2ZlZTogZ3R4bi5UcmFuc2FjdGlvbgogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjE5NAogICAgLy8gc2VsZi5jb250cmFjdF9pc19yZWNlaXZlcihhc3NldF9kZXBvc2l0KQogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjE5NQogICAgLy8gc2VsZi5jb250cmFjdF9pc19yZWNlaXZlcihtYnJfZmVlKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjEwNgogICAgLy8gYXNzZXRfaWQgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjEwNwogICAgLy8gYW1vdW50X2RlcG9zaXRlZCA9IFVJbnQ2NCgwKQogICAgZHVwCiAgICAvLyBhbGdvcG90YXRvLnB5OjEwOQogICAgLy8gYXNzZXJ0IGFzc2V0X2RlcG9zaXQudHlwZSBpbiAoVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQsIFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyKQogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBUeXBlRW51bQogICAgZHVwCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgZHVwCiAgICBibnogY3JlYXRlX2dhbWVfYm9vbF90cnVlQDMKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgID09CiAgICBieiBjcmVhdGVfZ2FtZV9ib29sX2ZhbHNlQDQKCmNyZWF0ZV9nYW1lX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCmNyZWF0ZV9nYW1lX2Jvb2xfbWVyZ2VANToKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTA5CiAgICAvLyBhc3NlcnQgYXNzZXRfZGVwb3NpdC50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuUGF5bWVudCwgVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIpCiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTExCiAgICAvLyBpZiBhc3NldF9kZXBvc2l0LnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgMwogICAgYnogY3JlYXRlX2dhbWVfZWxzZV9ib2R5QDcKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTEyCiAgICAvLyBhc3NldF9pZCA9IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gYWxnb3BvdGF0by5weToxMTMKICAgIC8vIGFtb3VudF9kZXBvc2l0ZWQgPSBhc3NldF9kZXBvc2l0LmFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIGZyYW1lX2J1cnkgMQoKY3JlYXRlX2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTE5CiAgICAvLyBhc3NlcnQgYW1vdW50X2RlcG9zaXRlZCAhPSAwCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTMyCiAgICAvLyBzZWxmLmNvdW50ZXIgKz0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImNvdW50ZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY291bnRlciBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBieXRlY18xIC8vICJjb3VudGVyIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTMzCiAgICAvLyB1c2VyX2FkZHIgPSBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjEzNAogICAgLy8gY291bnRlciA9IGFyYzQuVUludDY0KHNlbGYuY291bnRlcikKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJjb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvdW50ZXIgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBhbGdvcG90YXRvLnB5OjEzNi0xMzkKICAgIC8vIHJldHVybiBHYW1lQm94TmFtZSgKICAgIC8vICAgICBwbGF5ZXJfMT11c2VyX2FkZHIsCiAgICAvLyAgICAgY291bnRlcj1jb3VudGVyCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTUyCiAgICAvLyB1c2VyX2FkZHIgPSBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjE1NgogICAgLy8gcGxheWVyXzI9QWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgLy8gYWxnb3BvdGF0by5weToxNTcKICAgIC8vIHBsYXllcl8xX3JvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTYwCiAgICAvLyBhc3NldD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICBmcmFtZV9kaWcgMAogICAgaXRvYgogICAgLy8gYWxnb3BvdGF0by5weToxNjEKICAgIC8vIGFzc2V0X2Ftb3VudD1hcmM0LlVJbnQ2NChhc3NldF9hbW91bnQpCiAgICB1bmNvdmVyIDUKICAgIGl0b2IKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTU0LTE2MgogICAgLy8gcmV0dXJuIEdhbWVCb3hWYWx1ZSgKICAgIC8vICAgICAgICAgcGxheWVyXzE9dXNlcl9hZGRyLAogICAgLy8gICAgICAgICBwbGF5ZXJfMj1BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMV9yb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMl9yb3VuZD1hcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICAgICAgdnJmX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgICAgICBhc3NldD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyAgICAgICAgIGFzc2V0X2Ftb3VudD1hcmM0LlVJbnQ2NChhc3NldF9hbW91bnQpCiAgICAvLyApCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgLy8gYWxnb3BvdGF0by5weToxNTgKICAgIC8vIHBsYXllcl8yX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgYnl0ZWNfMiAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTU0LTE2MgogICAgLy8gcmV0dXJuIEdhbWVCb3hWYWx1ZSgKICAgIC8vICAgICAgICAgcGxheWVyXzE9dXNlcl9hZGRyLAogICAgLy8gICAgICAgICBwbGF5ZXJfMj1BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMV9yb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMl9yb3VuZD1hcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICAgICAgdnJmX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgICAgICBhc3NldD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyAgICAgICAgIGFzc2V0X2Ftb3VudD1hcmM0LlVJbnQ2NChhc3NldF9hbW91bnQpCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTU5CiAgICAvLyB2cmZfcm91bmQ9YXJjNC5VSW50NjQoMCksCiAgICBieXRlY18yIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgLy8gYWxnb3BvdGF0by5weToxNTQtMTYyCiAgICAvLyByZXR1cm4gR2FtZUJveFZhbHVlKAogICAgLy8gICAgICAgICBwbGF5ZXJfMT11c2VyX2FkZHIsCiAgICAvLyAgICAgICAgIHBsYXllcl8yPUFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgICAgIHBsYXllcl8xX3JvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgICAgIHBsYXllcl8yX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgICAgICB2cmZfcm91bmQ9YXJjNC5VSW50NjQoMCksCiAgICAvLyAgICAgICAgIGFzc2V0PWFyYzQuVUludDY0KGFzc2V0X2lkKSwKICAgIC8vICAgICAgICAgYXNzZXRfYW1vdW50PWFyYzQuVUludDY0KGFzc2V0X2Ftb3VudCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gYWxnb3BvdGF0by5weToyMDMKICAgIC8vIHNlbGYuZ2FtZV9ib3hbZ2FtZV9ib3hfbmFtZV0gPSBnYW1lX2JveF92YWx1ZS5jb3B5KCkKICAgIGJveF9wdXQKICAgIHJldHN1YgoKY3JlYXRlX2dhbWVfZWxzZV9ib2R5QDc6CiAgICAvLyBhbGdvcG90YXRvLnB5OjExNQogICAgLy8gZWxpZiBhc3NldF9kZXBvc2l0LnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXI6CiAgICBmcmFtZV9kaWcgMgogICAgaW50Y18yIC8vIGF4ZmVyCiAgICA9PQogICAgYnogY3JlYXRlX2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMAogICAgLy8gYWxnb3BvdGF0by5weToxMTYKICAgIC8vIGFzc2V0X2lkID0gYXNzZXRfZGVwb3NpdC54ZmVyX2Fzc2V0LmlkCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFhmZXJBc3NldAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjExNwogICAgLy8gYW1vdW50X2RlcG9zaXRlZCA9IGFzc2V0X2RlcG9zaXQuYXNzZXRfYW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBmcmFtZV9idXJ5IDEKICAgIGIgY3JlYXRlX2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMAoKY3JlYXRlX2dhbWVfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgY3JlYXRlX2dhbWVfYm9vbF9tZXJnZUA1CgoKLy8gYWxnb3BvdGF0by5BbGdvUG90YXRvLnByaW1lX2dhbWVfdnJmKGdhbWVfYm94X25hbWU6IGJ5dGVzLCBhc3NldF9kZXBvc2l0OiB1aW50NjQpIC0+IHZvaWQ6CnByaW1lX2dhbWVfdnJmOgogICAgLy8gYWxnb3BvdGF0by5weToyNDctMjUyCiAgICAvLyBAYWJpbWV0aG9kCiAgICAvLyBkZWYgcHJpbWVfZ2FtZV92cmYoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2JveF9uYW1lOiBHYW1lQm94TmFtZSwKICAgIC8vICAgICBhc3NldF9kZXBvc2l0OiBndHhuLlRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjI2MQogICAgLy8gc2VsZi5jb250cmFjdF9pc19yZWNlaXZlcihhc3NldF9kZXBvc2l0KQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjI2MwogICAgLy8gZ2FtZV9ib3ggPSBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0yCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2JveCBlbnRyeSBleGlzdHMKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjE4CiAgICAvLyBhc3NlcnQgYXNzZXRfZGVwb3NpdC50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQpCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludGNfMiAvLyBheGZlcgogICAgPT0KICAgIGJueiBwcmltZV9nYW1lX3ZyZl9ib29sX3RydWVAMwogICAgZnJhbWVfZGlnIDEKICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBieiBwcmltZV9nYW1lX3ZyZl9ib29sX2ZhbHNlQDQKCnByaW1lX2dhbWVfdnJmX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCnByaW1lX2dhbWVfdnJmX2Jvb2xfbWVyZ2VANToKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjE4CiAgICAvLyBhc3NlcnQgYXNzZXRfZGVwb3NpdC50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQpCiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjIwCiAgICAvLyBpZiBhc3NldF9kZXBvc2l0LnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgMQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGJ6IHByaW1lX2dhbWVfdnJmX2Vsc2VfYm9keUA3CiAgICAvLyBhbGdvcG90YXRvLnB5OjIyMQogICAgLy8gYXNzZXJ0IGdhbWVfYm94X3ZhbHVlLmFzc2V0ID09IDAKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGV4dHJhY3QgODggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ5dGVjXzIgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBiPT0KICAgIGFzc2VydAogICAgLy8gYWxnb3BvdGF0by5weToyMjIKICAgIC8vIGFzc2VydCBnYW1lX2JveF92YWx1ZS5hc3NldF9hbW91bnQgPT0gYXNzZXRfZGVwb3NpdC5hbW91bnQKICAgIGV4dHJhY3QgOTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBpdG9iCiAgICBiPT0KICAgIGFzc2VydAoKcHJpbWVfZ2FtZV92cmZfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gYWxnb3BvdGF0by5weToyNDAKICAgIC8vIGFzc2VydCBnYW1lX2JveC5wbGF5ZXJfMiA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBleHRyYWN0IDMyIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBhbGdvcG90YXRvLnB5OjI0MQogICAgLy8gZ2FtZV9ib3gucGxheWVyXzIgPSBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICByZXBsYWNlMiAzMgogICAgLy8gYWxnb3BvdGF0by5weToyNDIKICAgIC8vIGdhbWVfYm94LnBsYXllcl8yX3JvdW5kID0gYXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKQogICAgZ2xvYmFsIFJvdW5kCiAgICBpdG9iCiAgICByZXBsYWNlMiA3MgogICAgLy8gYWxnb3BvdGF0by5weToyNDMKICAgIC8vIGdhbWVfYm94LnZyZl9yb3VuZCA9IGFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCArIDkpCiAgICBnbG9iYWwgUm91bmQKICAgIHB1c2hpbnQgOSAvLyA5CiAgICArCiAgICBpdG9iCiAgICByZXBsYWNlMiA4MAogICAgLy8gYWxnb3BvdGF0by5weToyNjgKICAgIC8vIHNlbGYuZ2FtZV9ib3hbZ2FtZV9ib3hfbmFtZV0gPSBnYW1lX2JveC5jb3B5KCkKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpwcmltZV9nYW1lX3ZyZl9lbHNlX2JvZHlANzoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjI1CiAgICAvLyBhc3NlcnQgZ2FtZV9ib3hfdmFsdWUuYXNzZXQgPT0gYXNzZXRfZGVwb3NpdC54ZmVyX2Fzc2V0LmlkCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBleHRyYWN0IDg4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFhmZXJBc3NldAogICAgaXRvYgogICAgYj09CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjI2CiAgICAvLyBhc3NlcnQgZ2FtZV9ib3hfdmFsdWUuYXNzZXRfYW1vdW50ID09IGFzc2V0X2RlcG9zaXQuYXNzZXRfYW1vdW50CiAgICBleHRyYWN0IDk2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBpdG9iCiAgICBiPT0KICAgIGFzc2VydAogICAgYiBwcmltZV9nYW1lX3ZyZl9hZnRlcl9pZl9lbHNlQDgKCnByaW1lX2dhbWVfdnJmX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIHByaW1lX2dhbWVfdnJmX2Jvb2xfbWVyZ2VANQoKCi8vIGFsZ29wb3RhdG8uQWxnb1BvdGF0by5wbGF5X2dhbWUoZ2FtZV9ib3hfbmFtZTogYnl0ZXMpIC0+IGJ5dGVzOgpwbGF5X2dhbWU6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQwNy00MTEKICAgIC8vIEBhYmltZXRob2QKICAgIC8vIGRlZiBwbGF5X2dhbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2JveF9uYW1lOiBHYW1lQm94TmFtZSwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMSAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA2CiAgICBieXRlY18zIC8vICIiCiAgICBkdXBuIDcKCnBsYXlfZ2FtZV93aGlsZV90b3BAMjU6CiAgICBwdXNoaW50IDEwMDEwIC8vIDEwMDEwCiAgICBnbG9iYWwgT3Bjb2RlQnVkZ2V0CiAgICA+CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfd2hpbGVAMzAKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgIGl0eG5fZmllbGQgT25Db21wbGV0aW9uCiAgICBieXRlYyA1IC8vIDB4MDY4MTAxCiAgICBpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQogICAgYnl0ZWMgNSAvLyAweDA2ODEwMQogICAgaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBwbGF5X2dhbWVfd2hpbGVfdG9wQDI1CgpwbGF5X2dhbWVfYWZ0ZXJfd2hpbGVAMzA6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQzMQogICAgLy8gZ2FtZV9ib3ggPSBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZV9ib3ggZW50cnkgZXhpc3RzCiAgICAvLyBhbGdvcG90YXRvLnB5OjQwNQogICAgLy8gYXNzZXJ0IGdhbWVfYm94LnZyZl9yb3VuZCAhPSAwCiAgICBkdXAKICAgIGV4dHJhY3QgODAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICBieXRlY18yIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgYiE9CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mjg4CiAgICAvLyBpZiBHbG9iYWwucm91bmQgLSB2cmZfcm91bmQubmF0aXZlID4gMTUxMjoKICAgIGdsb2JhbCBSb3VuZAogICAgc3dhcAogICAgLy8gYWxnb3BvdGF0by5weToyODYKICAgIC8vIHZyZl9yb3VuZCA9IGdhbWVfYm94LnZyZl9yb3VuZAogICAgcHVzaGludCA4MCAvLyA4MAogICAgLy8gYWxnb3BvdGF0by5weToyODgKICAgIC8vIGlmIEdsb2JhbC5yb3VuZCAtIHZyZl9yb3VuZC5uYXRpdmUgPiAxNTEyOgogICAgZXh0cmFjdF91aW50NjQKICAgIC0KICAgIHB1c2hpbnQgMTUxMiAvLyAxNTEyCiAgICA+CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAzNgogICAgLy8gYWxnb3BvdGF0by5weToyODkKICAgIC8vIHJldHVybiBVSW50NjQoMCksIEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDE0CiAgICBmcmFtZV9idXJ5IDExCgpwbGF5X2dhbWVfYWZ0ZXJfaW5saW5lZF9hbGdvcG90YXRvLkFsZ29Qb3RhdG8uZ2V0X3ZyZl9vdXRwdXRfbW9kdWxvQDM3OgogICAgLy8gYWxnb3BvdGF0by5weTozNjkKICAgIC8vIHBsYXllcl8xID0gZ2FtZV9ib3gucGxheWVyXzEubmF0aXZlCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzcwCiAgICAvLyBwbGF5ZXJfMiA9IGdhbWVfYm94LnBsYXllcl8yLm5hdGl2ZQogICAgZHVwCiAgICBleHRyYWN0IDMyIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBhbGdvcG90YXRvLnB5OjM3MgogICAgLy8gYXNzZXQgPSBnYW1lX2JveC5hc3NldC5uYXRpdmUKICAgIGR1cAogICAgcHVzaGludCA4OCAvLyA4OAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSA3CiAgICAvLyBhbGdvcG90YXRvLnB5OjM3MwogICAgLy8gYXNzZXRfYW1vdW50ID0gZ2FtZV9ib3guYXNzZXRfYW1vdW50Lm5hdGl2ZSAqIDIKICAgIHB1c2hpbnQgOTYgLy8gOTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBpbnRjXzMgLy8gMgogICAgKgogICAgZnJhbWVfYnVyeSA4CiAgICAvLyBhbGdvcG90YXRvLnB5OjM3NQogICAgLy8gaWYgYXNzZXQgPT0gMDoKICAgIGJueiBwbGF5X2dhbWVfZWxzZV9ib2R5QDQwCiAgICAvLyBhbGdvcG90YXRvLnB5OjM3NgogICAgLy8gcmV0dXJuIFRydWUsIFN0cmluZygnJykKICAgIGludGNfMSAvLyAxCiAgICBieXRlY18zIC8vICIiCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2J1cnkgOQoKcGxheV9nYW1lX2FmdGVyX2lubGluZWRfYWxnb3BvdGF0by5BbGdvUG90YXRvLnZlcmlmeV9ib3RoX3VzZXJzX29wdGVkX2luQDQ1OgogICAgLy8gYWxnb3BvdGF0by5weTo0MzkKICAgIC8vIGlmIHZhbGlkX3ZyZl9yb3VuZCA9PSBGYWxzZToKICAgIGZyYW1lX2RpZyAxNAogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlAMgogICAgLy8gYWxnb3BvdGF0by5weTo0NDAKICAgIC8vIGdhbWVfYm94LnZyZl9yb3VuZCA9IGFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCArIDkpCiAgICBnbG9iYWwgUm91bmQKICAgIHB1c2hpbnQgOSAvLyA5CiAgICArCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgcmVwbGFjZTIgODAKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQxCiAgICAvLyBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdID0gZ2FtZV9ib3guY29weSgpCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQyCiAgICAvLyByZXR1cm4gU3RyaW5nKCJWUkYgUm91bmQgZXhwaXJlZCIpCiAgICBwdXNoYnl0ZXMgIlZSRiBSb3VuZCBleHBpcmVkIgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsYXlfZ2FtZV9lbHNlX2JvZHlAMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQ0CiAgICAvLyBlbGlmIG5vdCBib3RoX3VzZXJzX29wdGVkX2ludG9fYXNzZXQ6CiAgICBmcmFtZV9kaWcgOQogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlANAogICAgLy8gYWxnb3BvdGF0by5weTo0NDYKICAgIC8vIGRlbCBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gYWxnb3BvdGF0by5weTo0NDgKICAgIC8vIHNlbGYuZ2FtZXNfcGxheWVkICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJnYW1lc19wbGF5ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXNfcGxheWVkIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjXzAgLy8gImdhbWVzX3BsYXllZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ1MAogICAgLy8gcmV0dXJuIHJldHVybl9tZXNzYWdlCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsYXlfZ2FtZV9lbHNlX2JvZHlANDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzIxCiAgICAvLyBwb3RhdG9faG9sZGVyID0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzIzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UobW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50ICsgMSk6CiAgICBmcmFtZV9kaWcgMTEKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDEyCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxMAoKcGxheV9nYW1lX2Zvcl9oZWFkZXJAODoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzIzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UobW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50ICsgMSk6CiAgICBmcmFtZV9kaWcgMTAKICAgIGZyYW1lX2RpZyAxMgogICAgPAogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2J1cnkgNAogICAgYnogcGxheV9nYW1lX2FmdGVyX2ZvckAyMgogICAgLy8gYWxnb3BvdGF0by5weTozMjQKICAgIC8vIGlmIGkgJSAyID09IDA6CiAgICBmcmFtZV9kaWcgMTAKICAgIGludGNfMyAvLyAyCiAgICAlCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTMKICAgIGJueiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMQogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMwoKcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBhbGdvcG90YXRvLnB5OjMyNwogICAgLy8gaWYgaSAlIDIgIT0gMDoKICAgIGZyYW1lX2RpZyAxMwogICAgYnogcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMTMKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9idXJ5IDMKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gYWxnb3BvdGF0by5weTozMzAKICAgIC8vIGlmIGkgPT0gbW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50OgogICAgZnJhbWVfZGlnIDEwCiAgICBmcmFtZV9kaWcgMTEKICAgID09CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAxOAogICAgLy8gYWxnb3BvdGF0by5weTozMzEKICAgIC8vIGlmIGFzc2V0X2lkID09IDA6CiAgICBmcmFtZV9kaWcgNwogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlAMTYKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzMyLTMzNQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBvdGF0b19ob2xkZXIsCiAgICAvLyAgICAgYW1vdW50PWFzc2V0X2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyA4CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZnJhbWVfZGlnIDMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzMyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzMyLTMzNQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBvdGF0b19ob2xkZXIsCiAgICAvLyAgICAgYW1vdW50PWFzc2V0X2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAxNzoKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9idXJ5IDQKCnBsYXlfZ2FtZV9hZnRlcl9mb3JAMjI6CiAgICBmcmFtZV9kaWcgNAogICAgLy8gYWxnb3BvdGF0by5weTo0NTcKICAgIC8vIGRlbCBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gYWxnb3BvdGF0by5weTo0NTkKICAgIC8vIHNlbGYuZ2FtZXNfcGxheWVkICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJnYW1lc19wbGF5ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXNfcGxheWVkIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjXzAgLy8gImdhbWVzX3BsYXllZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ2MQogICAgLy8gaWYgcG90YXRvX2hvbGRlciA9PSBwbGF5ZXJfMToKICAgIGZyYW1lX2RpZyAxCiAgICA9PQogICAgYnogcGxheV9nYW1lX2Vsc2VfYm9keUA2CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ2MgogICAgLy8gcmV0dXJuIFN0cmluZygiUGxheWVyIDEgV2lucyEiKQogICAgcHVzaGJ5dGVzICJQbGF5ZXIgMSBXaW5zISIKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpwbGF5X2dhbWVfZWxzZV9ib2R5QDY6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ2NAogICAgLy8gcmV0dXJuIFN0cmluZygiUGxheWVyIDIgV2lucyEiKQogICAgcHVzaGJ5dGVzICJQbGF5ZXIgMiBXaW5zISIKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpwbGF5X2dhbWVfZWxzZV9ib2R5QDE2OgogICAgLy8gYWxnb3BvdGF0by5weTozMzctMzQxCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wb3RhdG9faG9sZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgOAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIDMKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIDcKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBhbGdvcG90YXRvLnB5OjMzNwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzM3LTM0MQogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXRfaWQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cG90YXRvX2hvbGRlciwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9YXNzZXRfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMTcKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDE4OgogICAgLy8gYWxnb3BvdGF0by5weTozNDQKICAgIC8vIGlmIGFzc2V0X2lkID09IDA6CiAgICBmcmFtZV9kaWcgNwogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlAMjAKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzQ1LTM0OAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBvdGF0b19ob2xkZXIsCiAgICAvLyAgICAgYW1vdW50PTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBhbGdvcG90YXRvLnB5OjM0NwogICAgLy8gYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjM0NQogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBhbGdvcG90YXRvLnB5OjM0NS0zNDgKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wb3RhdG9faG9sZGVyLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDIxOgogICAgLy8gYWxnb3BvdGF0by5weTozMjMKICAgIC8vIGZvciBpIGluIHVyYW5nZShtb2R1bG9fMjQwX3ZyZl9ieXRlc19hc19pbnQgKyAxKToKICAgIGZyYW1lX2RpZyAxMAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMTAKICAgIGIgcGxheV9nYW1lX2Zvcl9oZWFkZXJAOAoKcGxheV9nYW1lX2Vsc2VfYm9keUAyMDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzUwLTM1NAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXRfaWQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cG90YXRvX2hvbGRlciwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGFsZ29wb3RhdG8ucHk6MzUzCiAgICAvLyBhc3NldF9hbW91bnQ9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgMwogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgNwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzUwCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gYWxnb3BvdGF0by5weTozNTAtMzU0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wb3RhdG9faG9sZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMjEKCnBsYXlfZ2FtZV9lbHNlX2JvZHlANDA6CiAgICAvLyBhbGdvcG90YXRvLnB5OjM3OAogICAgLy8gZWxpZiBwbGF5ZXJfMS5pc19vcHRlZF9pbihBc3NldChhc3NldCkpID09IEZhbHNlOgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyA3CiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlANDIKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mzc5LTM4MwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cGxheWVyXzIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFzc2V0X2Ftb3VudAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIDgKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAyCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyA3CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gYWxnb3BvdGF0by5weTozNzkKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMiAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBhbGdvcG90YXRvLnB5OjM3OS0zODMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBsYXllcl8yLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBhbGdvcG90YXRvLnB5OjM4NQogICAgLy8gcmV0dXJuIEZhbHNlLCBTdHJpbmcoIlBsYXllciAxIEZvcmZlaXQgYnkgb3B0aW5nIG91dCIpCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICJQbGF5ZXIgMSBGb3JmZWl0IGJ5IG9wdGluZyBvdXQiCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2J1cnkgOQogICAgLy8gYWxnb3BvdGF0by5weTo0MzcKICAgIC8vIGJvdGhfdXNlcnNfb3B0ZWRfaW50b19hc3NldCwgcmV0dXJuX21lc3NhZ2UgPSBzZWxmLnZlcmlmeV9ib3RoX3VzZXJzX29wdGVkX2luKGdhbWVfYm94LmNvcHkoKSkKICAgIGIgcGxheV9nYW1lX2FmdGVyX2lubGluZWRfYWxnb3BvdGF0by5BbGdvUG90YXRvLnZlcmlmeV9ib3RoX3VzZXJzX29wdGVkX2luQDQ1CgpwbGF5X2dhbWVfZWxzZV9ib2R5QDQyOgogICAgLy8gYWxnb3BvdGF0by5weTozODcKICAgIC8vIGVsaWYgcGxheWVyXzIuaXNfb3B0ZWRfaW4oQXNzZXQoYXNzZXQpKSA9PSBGYWxzZToKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgNwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBwbGF5X2dhbWVfZWxzZV9ib2R5QDQ0CiAgICAvLyBhbGdvcG90YXRvLnB5OjM4OC0zOTIKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBsYXllcl8xLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyA4CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgMQogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgNwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mzg4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gYWxnb3BvdGF0by5weTozODgtMzkyCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wbGF5ZXJfMSwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9YXNzZXRfYW1vdW50CiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gYWxnb3BvdGF0by5weTozOTQKICAgIC8vIHJldHVybiBGYWxzZSwgU3RyaW5nKCJQbGF5ZXIgMiBGb3JmZWl0IGJ5IG9wdGluZyBvdXQiKQogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiUGxheWVyIDIgRm9yZmVpdCBieSBvcHRpbmcgb3V0IgogICAgZnJhbWVfYnVyeSA1CiAgICBmcmFtZV9idXJ5IDkKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDM3CiAgICAvLyBib3RoX3VzZXJzX29wdGVkX2ludG9fYXNzZXQsIHJldHVybl9tZXNzYWdlID0gc2VsZi52ZXJpZnlfYm90aF91c2Vyc19vcHRlZF9pbihnYW1lX2JveC5jb3B5KCkpCiAgICBiIHBsYXlfZ2FtZV9hZnRlcl9pbmxpbmVkX2FsZ29wb3RhdG8uQWxnb1BvdGF0by52ZXJpZnlfYm90aF91c2Vyc19vcHRlZF9pbkA0NQoKcGxheV9nYW1lX2Vsc2VfYm9keUA0NDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mzk3CiAgICAvLyByZXR1cm4gVHJ1ZSwgU3RyaW5nKCcnKQogICAgaW50Y18xIC8vIDEKICAgIGJ5dGVjXzMgLy8gIiIKICAgIGZyYW1lX2J1cnkgNQogICAgZnJhbWVfYnVyeSA5CiAgICAvLyBhbGdvcG90YXRvLnB5OjQzNwogICAgLy8gYm90aF91c2Vyc19vcHRlZF9pbnRvX2Fzc2V0LCByZXR1cm5fbWVzc2FnZSA9IHNlbGYudmVyaWZ5X2JvdGhfdXNlcnNfb3B0ZWRfaW4oZ2FtZV9ib3guY29weSgpKQogICAgYiBwbGF5X2dhbWVfYWZ0ZXJfaW5saW5lZF9hbGdvcG90YXRvLkFsZ29Qb3RhdG8udmVyaWZ5X2JvdGhfdXNlcnNfb3B0ZWRfaW5ANDUKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDM2OgogICAgLy8gYWxnb3BvdGF0by5weToyOTMtMjk4CiAgICAvLyByZXN1bHQsIHR4biA9IGFiaV9jYWxsW0J5dGVzXSgKICAgIC8vICAgICAnbXVzdF9nZXQodWludDY0LGJ5dGVbXSlieXRlW10nLAogICAgLy8gICAgIHZyZl9yb3VuZCwKICAgIC8vICAgICBnYW1lX2JveF9hc19ieXRlcywKICAgIC8vICAgICBhcHBfaWQ9NjAwMDExODg3LAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gYWxnb3BvdGF0by5weToyOTYKICAgIC8vIGdhbWVfYm94X2FzX2J5dGVzLAogICAgZnJhbWVfZGlnIDAKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBhbGdvcG90YXRvLnB5OjI5NwogICAgLy8gYXBwX2lkPTYwMDAxMTg4NywKICAgIGludGMgNCAvLyA2MDAwMTE4ODcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gYWxnb3BvdGF0by5weToyOTMtMjk4CiAgICAvLyByZXN1bHQsIHR4biA9IGFiaV9jYWxsW0J5dGVzXSgKICAgIC8vICAgICAnbXVzdF9nZXQodWludDY0LGJ5dGVbXSlieXRlW10nLAogICAgLy8gICAgIHZyZl9yb3VuZCwKICAgIC8vICAgICBnYW1lX2JveF9hc19ieXRlcywKICAgIC8vICAgICBhcHBfaWQ9NjAwMDExODg3LAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4NDdjMjBjMjMgLy8gbWV0aG9kICJtdXN0X2dldCh1aW50NjQsYnl0ZVtdKWJ5dGVbXSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIGV4dHJhY3QgNiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjMwMQogICAgLy8gbW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50ID0gb3AuYnRvaSgodnJmX2J5dGVzX2FzX2ludGVnZXIubmF0aXZlICUgMjQwKS5ieXRlcykKICAgIHB1c2hieXRlcyAweGYwCiAgICBiJQogICAgYnRvaQogICAgZnJhbWVfYnVyeSAxMQogICAgLy8gYWxnb3BvdGF0by5weTozMDMKICAgIC8vIHJldHVybiBtb2R1bG9fMjQwX3ZyZl9ieXRlc19hc19pbnQsIFRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDE0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQzNQogICAgLy8gbW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50LCB2YWxpZF92cmZfcm91bmQgPSBzZWxmLmdldF92cmZfb3V0cHV0X21vZHVsbyhnYW1lX2JveC5jb3B5KCkpCiAgICBiIHBsYXlfZ2FtZV9hZnRlcl9pbmxpbmVkX2FsZ29wb3RhdG8uQWxnb1BvdGF0by5nZXRfdnJmX291dHB1dF9tb2R1bG9AMzcKCgovLyBhbGdvcG90YXRvLkFsZ29Qb3RhdG8uY2FuY2VsX2dhbWUoZ2FtZV9ib3hfbmFtZTogYnl0ZXMpIC0+IHZvaWQ6CmNhbmNlbF9nYW1lOgogICAgLy8gYWxnb3BvdGF0by5weTo0NjgtNDcyCiAgICAvLyBAYWJpbWV0aG9kCiAgICAvLyBkZWYgY2FuY2VsX2dhbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2JveF9uYW1lOiBHYW1lQm94TmFtZQogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ3NwogICAgLy8gZ2FtZV9ib3ggPSBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2JveCBlbnRyeSBleGlzdHMKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDc5CiAgICAvLyBwbGF5ZXJfMSA9IGdhbWVfYm94LnBsYXllcl8xLm5hdGl2ZQogICAgZHVwCiAgICBleHRyYWN0IDAgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBzd2FwCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ4MAogICAgLy8gcGxheWVyXzIgPSBnYW1lX2JveC5wbGF5ZXJfMi5uYXRpdmUKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDgzCiAgICAvLyBhc3NldCA9IGdhbWVfYm94LmFzc2V0Lm5hdGl2ZQogICAgZGlnIDEKICAgIHB1c2hpbnQgODggLy8gODgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGNvdmVyIDQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDg0CiAgICAvLyBhc3NldF9hbW91bnQgPSBnYW1lX2JveC5hc3NldF9hbW91bnQubmF0aXZlCiAgICBzd2FwCiAgICBwdXNoaW50IDk2IC8vIDk2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgMwogICAgLy8gYWxnb3BvdGF0by5weTo0ODYKICAgIC8vIGFzc2VydCBwbGF5ZXJfMiA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDg4CiAgICAvLyBpZiBhc3NldCA9PSAwOgogICAgYm56IGNhbmNlbF9nYW1lX2Vsc2VfYm9keUAzCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ4OS00OTIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wbGF5ZXJfMSwKICAgIC8vICAgICBhbW91bnQ9YXNzZXRfYW1vdW50CiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gYWxnb3BvdGF0by5weTo0ODkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gYWxnb3BvdGF0by5weTo0ODktNDkyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9cGxheWVyXzEsCiAgICAvLyAgICAgYW1vdW50PWFzc2V0X2Ftb3VudAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmNhbmNlbF9nYW1lX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIGFsZ29wb3RhdG8ucHk6NTAxCiAgICAvLyBkZWwgc2VsZi5nYW1lX2JveFtnYW1lX2JveF9uYW1lXQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHJldHN1YgoKY2FuY2VsX2dhbWVfZWxzZV9ib2R5QDM6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ5NS00OTkKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wbGF5ZXJfMSwKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ5NQogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDk1LTQ5OQogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBsYXllcl8xLAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFzc2V0X2Ftb3VudAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgY2FuY2VsX2dhbWVfYWZ0ZXJfaWZfZWxzZUA1Cg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [1179], "errorMessage": "ARC4 prefix is valid"}, {"pc": [504, 510, 523, 555, 565, 635, 667, 673, 1204, 1209], "errorMessage": "Index access is out of bounds"}, {"pc": [132, 147, 175, 194, 214], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [241], "errorMessage": "can only call when creating"}, {"pc": [135, 150, 178, 197, 217], "errorMessage": "can only call when not creating"}, {"pc": [391, 402], "errorMessage": "check self.counter exists"}, {"pc": [474, 633, 1202], "errorMessage": "check self.game_box entry exists"}, {"pc": [757, 858], "errorMessage": "check self.games_played exists"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class GameBoxName:
    """Struct for GameBoxName"""
    player_1: str
    counter: int

@dataclasses.dataclass(frozen=True)
class GameBoxValue:
    """Struct for GameBoxValue"""
    player_1: str
    player_2: str
    player_1_round: int
    player_2_round: int
    vrf_round: int
    asset: int
    asset_amount: int


@dataclasses.dataclass(frozen=True, kw_only=True)
class AssetOptInArgs:
    """Dataclass for asset_opt_in arguments"""
    asset: int
    mbr_payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "asset_opt_in(asset,txn)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateGameArgs:
    """Dataclass for create_game arguments"""
    asset_deposit: algokit_utils.AppMethodCallTransactionArgument | None = None
    mbr_fee: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "create_game(txn,txn)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class PrimeGameVrfArgs:
    """Dataclass for prime_game_vrf arguments"""
    game_box_name: GameBoxName
    asset_deposit: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "prime_game_vrf((address,uint64),txn)void"

@dataclasses.dataclass(frozen=True, kw_only=True)
class PlayGameArgs:
    """Dataclass for play_game arguments"""
    game_box_name: GameBoxName

    @property
    def abi_method_signature(self) -> str:
        return "play_game((address,uint64))string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CancelGameArgs:
    """Dataclass for cancel_game arguments"""
    game_box_name: GameBoxName

    @property
    def abi_method_signature(self) -> str:
        return "cancel_game((address,uint64))void"


class AlgoPotatoParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def asset_opt_in(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "asset_opt_in(asset,txn)void",
            "args": method_args,
        }))

    def create_game(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_game(txn,txn)void",
            "args": method_args,
        }))

    def prime_game_vrf(
        self,
        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "prime_game_vrf((address,uint64),txn)void",
            "args": method_args,
        }))

    def play_game(
        self,
        args: tuple[GameBoxName] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "play_game((address,uint64))string",
            "args": method_args,
        }))

    def cancel_game(
        self,
        args: tuple[GameBoxName] | CancelGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "cancel_game((address,uint64))void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class AlgoPotatoCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def asset_opt_in(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "asset_opt_in(asset,txn)void",
            "args": method_args,
        }))

    def create_game(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_game(txn,txn)void",
            "args": method_args,
        }))

    def prime_game_vrf(
        self,
        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "prime_game_vrf((address,uint64),txn)void",
            "args": method_args,
        }))

    def play_game(
        self,
        args: tuple[GameBoxName] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "play_game((address,uint64))string",
            "args": method_args,
        }))

    def cancel_game(
        self,
        args: tuple[GameBoxName] | CancelGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "cancel_game((address,uint64))void",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class AlgoPotatoSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def asset_opt_in(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "asset_opt_in(asset,txn)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def create_game(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_game(txn,txn)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def prime_game_vrf(
        self,
        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "prime_game_vrf((address,uint64),txn)void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def play_game(
        self,
        args: tuple[GameBoxName] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "play_game((address,uint64))string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def cancel_game(
        self,
        args: tuple[GameBoxName] | CancelGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[None]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "cancel_game((address,uint64))void",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    games_played: int
    counter: int
    vrf_app_id: int

class AlgoPotatoState:
    """Methods to access state for the current AlgoPotato app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def games_played(self) -> int:
        """Get the current value of the games_played key in global_state state"""
        value = self.app_client.state.global_state.get_value("games_played")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def counter(self) -> int:
        """Get the current value of the counter key in global_state state"""
        value = self.app_client.state.global_state.get_value("counter")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

    @property
    def vrf_app_id(self) -> int:
        """Get the current value of the vrf_app_id key in global_state state"""
        value = self.app_client.state.global_state.get_value("vrf_app_id")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "GameBoxValue": GameBoxValue
        }

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def game_box(self) -> "_MapState[GameBoxName, GameBoxValue]":
        """Get values from the game_box map in box state"""
        return _MapState(
            self.app_client.state.box,
            "game_box",
            self._struct_classes.get("GameBoxValue")
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class AlgoPotatoClient:
    """Client for interacting with AlgoPotato smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = AlgoPotatoParams(self.app_client)
        self.create_transaction = AlgoPotatoCreateTransactionParams(self.app_client)
        self.send = AlgoPotatoSend(self.app_client)
        self.state = AlgoPotatoState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "AlgoPotatoClient":
        return AlgoPotatoClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AlgoPotatoClient":
        return AlgoPotatoClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "AlgoPotatoClient":
        return AlgoPotatoClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "AlgoPotatoComposer":
        return AlgoPotatoComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["asset_opt_in(asset,txn)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_game(txn,txn)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["prime_game_vrf((address,uint64),txn)void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["play_game((address,uint64))string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["cancel_game((address,uint64))void"],
        return_value: algokit_utils.ABIReturn | None
    ) -> None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | str:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class AlgoPotatoBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating AlgoPotato contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class AlgoPotatoFactory(algokit_utils.TypedAppFactoryProtocol[AlgoPotatoBareCallCreateParams, None, None]):
    """Factory for deploying and managing AlgoPotatoClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = AlgoPotatoFactoryParams(self.app_factory)
        self.create_transaction = AlgoPotatoFactoryCreateTransaction(self.app_factory)
        self.send = AlgoPotatoFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: AlgoPotatoBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[AlgoPotatoClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return AlgoPotatoClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AlgoPotatoClient:
        """Get an app client by creator address and name"""
        return AlgoPotatoClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> AlgoPotatoClient:
        """Get an app client by app ID"""
        return AlgoPotatoClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class AlgoPotatoFactoryParams:
    """Parameters for creating transactions for AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AlgoPotatoFactoryCreateParams(app_factory)
        self.update = AlgoPotatoFactoryUpdateParams(app_factory)
        self.delete = AlgoPotatoFactoryDeleteParams(app_factory)

class AlgoPotatoFactoryCreateParams:
    """Parameters for 'create' operations of AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def asset_opt_in(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the asset_opt_in(asset,txn)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "asset_opt_in(asset,txn)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def create_game(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_game(txn,txn)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_game(txn,txn)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def prime_game_vrf(
        self,
        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the prime_game_vrf((address,uint64),txn)void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "prime_game_vrf((address,uint64),txn)void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def play_game(
        self,
        args: tuple[GameBoxName] | PlayGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the play_game((address,uint64))string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "play_game((address,uint64))string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def cancel_game(
        self,
        args: tuple[GameBoxName] | CancelGameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the cancel_game((address,uint64))void ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "cancel_game((address,uint64))void",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class AlgoPotatoFactoryUpdateParams:
    """Parameters for 'update' operations of AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class AlgoPotatoFactoryDeleteParams:
    """Parameters for 'delete' operations of AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class AlgoPotatoFactoryCreateTransaction:
    """Create transactions for AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AlgoPotatoFactoryCreateTransactionCreate(app_factory)


class AlgoPotatoFactoryCreateTransactionCreate:
    """Create new instances of AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class AlgoPotatoFactorySend:
    """Send calls to AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = AlgoPotatoFactorySendCreate(app_factory)


class AlgoPotatoFactorySendCreate:
    """Send create calls to AlgoPotato contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[AlgoPotatoClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return AlgoPotatoClient(result[0]), result[1]


class AlgoPotatoComposer:
    """Composer for creating transaction groups for AlgoPotato contract calls"""

    def __init__(self, client: "AlgoPotatoClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def asset_opt_in(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AlgoPotatoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.asset_opt_in(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "asset_opt_in(asset,txn)void", v
            )
        )
        return self

    def create_game(
        self,
        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AlgoPotatoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_game(txn,txn)void", v
            )
        )
        return self

    def prime_game_vrf(
        self,
        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AlgoPotatoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.prime_game_vrf(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "prime_game_vrf((address,uint64),txn)void", v
            )
        )
        return self

    def play_game(
        self,
        args: tuple[GameBoxName] | PlayGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AlgoPotatoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.play_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "play_game((address,uint64))string", v
            )
        )
        return self

    def cancel_game(
        self,
        args: tuple[GameBoxName] | CancelGameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "AlgoPotatoComposer":
        self._composer.add_app_call_method_call(
            self.client.params.cancel_game(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "cancel_game((address,uint64))void", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "AlgoPotatoComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "AlgoPotatoComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)


# File: https://github.com/Vradss/BUILDH3R_WORKSHOPS/blob/7f9c2a5abec474893022c115e1ace1c9367b10e3/June/Algorand/main.py
# import the modules to interactive with the chain
from algokit_utils.beta.algorand_client import (
    AlgorandClient,
    AssetCreateParams,
    AssetOptInParams,
    AssetTransferParams,
    PayParams,
)
# Create our client
algorand = AlgorandClient.default_local_net()

# dispenser.address = public key | dispenser.signer = private key
dispenser = algorand.account.dispenser()
#print("Dispenser Address:", dispenser.address)

#Create a Wallet & first algorand account
creator = algorand.account.random()
#print("Creator Address:", creator.address)
#print(algorand.account.get_information(creator.address))

#Create first transaction
algorand.send.payment(
    PayParams(
        sender=dispenser.address,
        receiver=creator.address,
        amount=10_000_000
    )
)

#print(algorand.account.get_information(creator.address))

#Create Token
sent_txn = algorand.send.asset_create(
    AssetCreateParams(
        sender=creator.address,
        total=1000,
        asset_name="BUILDH3R",
        unit_name="H3R",
        manager=creator.address,
        clawback=creator.address,
        freeze=creator.address
        
    )
)

#Extract asset ID to identify in blockchain
asset_id = sent_txn["confirmation"]["asset-index"]
#print("Asset ID", asset_id)


# Create the receiver
receiver_vrads = algorand.account.random()
#print("Receiver Address:", receiver_vrads.address)

# Transfer the asset from creator to receiver

algorand.send.payment(
    PayParams(
        sender=dispenser.address,
        receiver=receiver_vrads.address,
        amount=10_000_000
    )
)

# The atomic transfer segment : add opt_in
group_tx = algorand.new_group()

group_tx.add_asset_opt_in(
    AssetOptInParams(
        sender=receiver_vrads.address,
        asset_id=asset_id
    )
)

group_tx.add_payment(
    PayParams(
        sender=receiver_vrads.address,
        receiver=creator.address,
        amount=1_000_000
    )
)

group_tx.add_asset_transfer(
    AssetTransferParams(
        sender=creator.address,
        receiver=receiver_vrads.address,
        asset_id=asset_id,
        amount=10
    )
)

group_tx.execute()

#print(algorand.account.get_information(receiver_vrads.address))

print("Receiver Account Asset Balance:", algorand.account.get_information(receiver_vrads.address)['assets'][0]['amount'])
print("Creator Account Asset Balance:", algorand.account.get_information(creator.address)['assets'][0]['amount'])

algorand.send.asset_transfer(
    AssetTransferParams(
        sender=creator.address,
        receiver=creator.address,
        asset_id=asset_id,
        amount=2,
        clawback_target=receiver_vrads.address
    )
)

print("Post clawback")

print("Receiver Account Asset Balance:", algorand.account.get_information(receiver_vrads.address)['assets'][0]['amount'])
print("Creator Account Asset Balance:", algorand.account.get_information(creator.address)['assets'][0]['amount'])

# File: https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/pyteal/ast/txn.py
from enum import Enum
from typing import Callable, Optional, Union, cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import (
    TealInputError,
    TealCompileError,
    verifyFieldVersion,
    verifyProgramVersion,
)
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.leafexpr import LeafExpr
from pyteal.ast.expr import Expr
from pyteal.ast.int import EnumInt
from pyteal.ast.array import Array

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class TxnType:
    """Enum of all possible transaction types."""

    Unknown = EnumInt("unknown")  # T2PT7
    Payment = EnumInt("pay")  # T2PT7
    KeyRegistration = EnumInt("keyreg")  # T2PT7
    AssetConfig = EnumInt("acfg")  # T2PT7
    AssetTransfer = EnumInt("axfer")  # T2PT7
    AssetFreeze = EnumInt("afrz")  # T2PT7
    ApplicationCall = EnumInt("appl")  # T2PT7


TxnType.__module__ = "pyteal"


class TxnField(Enum):
    sender = (0, "Sender", TealType.bytes, False, 2)
    fee = (1, "Fee", TealType.uint64, False, 2)
    first_valid = (2, "FirstValid", TealType.uint64, False, 2)
    first_valid_time = (3, "FirstValidTime", TealType.uint64, False, 7)
    last_valid = (4, "LastValid", TealType.uint64, False, 2)
    note = (5, "Note", TealType.bytes, False, 2)
    lease = (6, "Lease", TealType.bytes, False, 2)
    receiver = (7, "Receiver", TealType.bytes, False, 2)
    amount = (8, "Amount", TealType.uint64, False, 2)
    close_remainder_to = (9, "CloseRemainderTo", TealType.bytes, False, 2)
    vote_pk = (10, "VotePK", TealType.bytes, False, 2)
    selection_pk = (11, "SelectionPK", TealType.bytes, False, 2)
    vote_first = (12, "VoteFirst", TealType.uint64, False, 2)
    vote_last = (13, "VoteLast", TealType.uint64, False, 2)
    vote_key_dilution = (14, "VoteKeyDilution", TealType.uint64, False, 2)
    type = (15, "Type", TealType.bytes, False, 2)
    type_enum = (16, "TypeEnum", TealType.uint64, False, 2)
    xfer_asset = (17, "XferAsset", TealType.uint64, False, 2)
    asset_amount = (18, "AssetAmount", TealType.uint64, False, 2)
    asset_sender = (19, "AssetSender", TealType.bytes, False, 2)
    asset_receiver = (20, "AssetReceiver", TealType.bytes, False, 2)
    asset_close_to = (21, "AssetCloseTo", TealType.bytes, False, 2)
    group_index = (22, "GroupIndex", TealType.uint64, False, 2)
    tx_id = (23, "TxID", TealType.bytes, False, 2)
    application_id = (24, "ApplicationID", TealType.uint64, False, 2)
    on_completion = (25, "OnCompletion", TealType.uint64, False, 2)
    application_args = (26, "ApplicationArgs", TealType.bytes, True, 2)
    num_app_args = (27, "NumAppArgs", TealType.uint64, False, 2)
    accounts = (28, "Accounts", TealType.bytes, True, 2)
    num_accounts = (2, "NumAccounts", TealType.uint64, False, 2)
    approval_program = (30, "ApprovalProgram", TealType.bytes, False, 2)
    clear_state_program = (31, "ClearStateProgram", TealType.bytes, False, 2)
    rekey_to = (32, "RekeyTo", TealType.bytes, False, 2)
    config_asset = (33, "ConfigAsset", TealType.uint64, False, 2)
    config_asset_total = (34, "ConfigAssetTotal", TealType.uint64, False, 2)
    config_asset_decimals = (35, "ConfigAssetDecimals", TealType.uint64, False, 2)
    config_asset_default_frozen = (
        36,
        "ConfigAssetDefaultFrozen",
        TealType.uint64,
        False,
        2,
    )
    config_asset_unit_name = (37, "ConfigAssetUnitName", TealType.bytes, False, 2)
    config_asset_name = (38, "ConfigAssetName", TealType.bytes, False, 2)
    config_asset_url = (39, "ConfigAssetURL", TealType.bytes, False, 2)
    config_asset_metadata_hash = (
        40,
        "ConfigAssetMetadataHash",
        TealType.bytes,
        False,
        2,
    )
    config_asset_manager = (41, "ConfigAssetManager", TealType.bytes, False, 2)
    config_asset_reserve = (42, "ConfigAssetReserve", TealType.bytes, False, 2)
    config_asset_freeze = (43, "ConfigAssetFreeze", TealType.bytes, False, 2)
    config_asset_clawback = (44, "ConfigAssetClawback", TealType.bytes, False, 2)
    freeze_asset = (45, "FreezeAsset", TealType.uint64, False, 2)
    freeze_asset_account = (46, "FreezeAssetAccount", TealType.bytes, False, 2)
    freeze_asset_frozen = (47, "FreezeAssetFrozen", TealType.uint64, False, 2)
    assets = (48, "Assets", TealType.uint64, True, 3)
    num_assets = (49, "NumAssets", TealType.uint64, False, 3)
    applications = (50, "Applications", TealType.uint64, True, 3)
    num_applications = (51, "NumApplications", TealType.uint64, False, 3)
    global_num_uints = (52, "GlobalNumUint", TealType.uint64, False, 3)
    global_num_byte_slices = (53, "GlobalNumByteSlice", TealType.uint64, False, 3)
    local_num_uints = (54, "LocalNumUint", TealType.uint64, False, 3)
    local_num_byte_slices = (55, "LocalNumByteSlice", TealType.uint64, False, 3)
    extra_program_pages = (56, "ExtraProgramPages", TealType.uint64, False, 4)
    nonparticipation = (57, "Nonparticipation", TealType.uint64, False, 5)
    logs = (58, "Logs", TealType.bytes, True, 5)
    num_logs = (59, "NumLogs", TealType.uint64, False, 5)
    created_asset_id = (60, "CreatedAssetID", TealType.uint64, False, 5)
    created_application_id = (61, "CreatedApplicationID", TealType.uint64, False, 5)
    last_log = (62, "LastLog", TealType.bytes, False, 6)
    state_proof_pk = (63, "StateProofPK", TealType.bytes, False, 6)
    approval_program_pages = (64, "ApprovalProgramPages", TealType.bytes, True, 7)
    num_approval_program_pages = (
        65,
        "NumApprovalProgramPages",
        TealType.uint64,
        False,
        7,
    )
    clear_state_program_pages = (66, "ClearStateProgramPages", TealType.bytes, True, 7)
    num_clear_state_program_pages = (
        67,
        "NumClearStateProgramPages",
        TealType.uint64,
        False,
        7,
    )

    def __init__(
        self, id: int, name: str, type: TealType, is_array: bool, min_version: int
    ) -> None:
        self.id = id
        self.arg_name = name
        self.ret_type = type
        self.is_array = is_array
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.ret_type


TxnField.__module__ = "pyteal"


class TxnExpr(LeafExpr):
    """An expression that accesses a transaction field from the current transaction."""

    def __init__(self, op: Op, name: str, field: TxnField) -> None:
        super().__init__()
        if field.is_array:
            raise TealInputError("Unexpected array field: {}".format(field))
        self.op = op
        self.name = name
        self.field = field

    def __str__(self):
        return "({} {})".format(self.name, self.field.arg_name)

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            "Program version too low to use op {}".format(self.op),
        )

        op = TealOp(self, self.op, self.field.arg_name)
        return TealBlock.FromOp(options, op)

    def type_of(self):
        return self.field.type_of()


TxnExpr.__module__ = "pyteal"


class TxnaExpr(LeafExpr):
    """An expression that accesses a transaction array field from the current transaction."""

    @staticmethod
    def __validate_index_or_throw(index: Union[int, Expr]):
        if not isinstance(index, (int, Expr)):
            raise TealInputError(
                f"Invalid index type:  Expected int or Expr, but received {index}."
            )
        if isinstance(index, Expr):
            require_type(index, TealType.uint64)

    def __init__(
        self,
        staticOp: Op,
        dynamicOp: Optional[Op],
        name: str,
        field: TxnField,
        index: Union[int, Expr],
    ) -> None:
        super().__init__()
        if not field.is_array:
            raise TealInputError("Unexpected non-array field: {}".format(field))
        self.__validate_index_or_throw(index)

        self.staticOp = staticOp
        self.dynamicOp = dynamicOp
        self.name = name
        self.field = field
        self.index = index

    def __str__(self):
        return "({} {} {})".format(self.name, self.field.arg_name, self.index)

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        opToUse = self.staticOp if type(self.index) is int else self.dynamicOp
        if opToUse is None:
            raise TealCompileError("Dynamic array indexing not supported", self)

        verifyProgramVersion(
            opToUse.min_version,
            options.version,
            "Program version too low to use op {}".format(opToUse),
        )

        if type(self.index) is int:
            op = TealOp(self, opToUse, self.field.arg_name, self.index)
            return TealBlock.FromOp(options, op)

        op = TealOp(self, opToUse, self.field.arg_name)
        return TealBlock.FromOp(options, op, cast(Expr, self.index))

    def type_of(self):
        return self.field.type_of()


TxnaExpr.__module__ = "pyteal"


class TxnExprBuilder:
    def __init__(self, op: Op, name: str):
        self.op = op
        self.name = name

    def __call__(self, field: TxnField) -> TxnExpr:
        return TxnExpr(self.op, self.name, field)


TxnExprBuilder.__module__ = "pyteal"


class TxnaExprBuilder:
    def __init__(self, staticOp: Op, dynamicOp: Optional[Op], name: str):
        self.staticOp = staticOp
        self.dynamicOp = dynamicOp
        self.name = name

    def __call__(self, field: TxnField, index: Union[int, Expr]) -> TxnaExpr:
        return TxnaExpr(self.staticOp, self.dynamicOp, self.name, field, index)


TxnaExprBuilder.__module__ = "pyteal"


class TxnArray(Array):
    """Represents a transaction array field."""

    def __init__(
        self, txnObject: "TxnObject", accessField: TxnField, lengthField: TxnField
    ) -> None:
        self.txnObject = txnObject
        self.accessField = accessField
        self.lengthField = lengthField

    def length(self) -> TxnExpr:
        return self.txnObject.makeTxnExpr(self.lengthField)

    def __getitem__(self, index: Union[int, Expr]) -> TxnaExpr:
        if type(index) is int:
            if index < 0:
                raise TealInputError("Invalid array index: {}".format(index))
        else:
            require_type(cast(Expr, index), TealType.uint64)

        return self.txnObject.makeTxnaExpr(self.accessField, index)


TxnArray.__module__ = "pyteal"


class TxnObject:
    """Represents a transaction and its fields."""

    def __init__(
        self,
        makeTxnExpr: Callable[[TxnField], TxnExpr],
        makeTxnaExpr: Callable[[TxnField, Union[int, Expr]], TxnaExpr],
    ) -> None:
        self.makeTxnExpr = makeTxnExpr
        self.makeTxnaExpr = makeTxnaExpr

    def sender(self) -> TxnExpr:
        """Get the 32 byte address of the sender.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#sender
        """
        return self.makeTxnExpr(TxnField.sender)

    def fee(self) -> TxnExpr:
        """Get the transaction fee in micro Algos.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#fee
        """
        return self.makeTxnExpr(TxnField.fee)

    def first_valid(self) -> TxnExpr:
        """Get the first valid round number.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#firstvalid
        """
        return self.makeTxnExpr(TxnField.first_valid)

    def first_valid_time(self) -> TxnExpr:
        """Get the UNIX timestamp of block before txn.FirstValid. Fails if negative.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#firstvalidtime
        """
        return self.makeTxnExpr(TxnField.first_valid_time)

    def last_valid(self) -> TxnExpr:
        """Get the last valid round number.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#lastvalid
        """
        return self.makeTxnExpr(TxnField.last_valid)

    def note(self) -> TxnExpr:
        """Get the transaction note.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#note
        """
        return self.makeTxnExpr(TxnField.note)

    def lease(self) -> TxnExpr:
        """Get the transaction lease.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#lease
        """
        return self.makeTxnExpr(TxnField.lease)

    def receiver(self) -> TxnExpr:
        """Get the 32 byte address of the receiver.

        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#receiver
        """
        return self.makeTxnExpr(TxnField.receiver)

    def amount(self) -> TxnExpr:
        """Get the amount of the transaction in micro Algos.

        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#amount
        """
        return self.makeTxnExpr(TxnField.amount)

    def close_remainder_to(self) -> TxnExpr:
        """Get the 32 byte address of the CloseRemainderTo field.

        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#closeremainderto
        """
        return self.makeTxnExpr(TxnField.close_remainder_to)

    def vote_pk(self) -> TxnExpr:
        """Get the root participation public key.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votepk
        """
        return self.makeTxnExpr(TxnField.vote_pk)

    def selection_pk(self) -> TxnExpr:
        """Get the VRF public key.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#selectionpk
        """
        return self.makeTxnExpr(TxnField.selection_pk)

    def vote_first(self) -> TxnExpr:
        """Get the first round that the participation key is valid.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votefirst
        """
        return self.makeTxnExpr(TxnField.vote_first)

    def vote_last(self) -> TxnExpr:
        """Get the last round that the participation key is valid.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votelast
        """
        return self.makeTxnExpr(TxnField.vote_last)

    def vote_key_dilution(self) -> TxnExpr:
        """Get the dilution for the 2-level participation key.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votekeydilution
        """
        return self.makeTxnExpr(TxnField.vote_key_dilution)

    def nonparticipation(self) -> TxnExpr:
        """Marks an account nonparticipating for rewards.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#nonparticipation

        Requires program version 5 or higher.
        """
        return self.makeTxnExpr(TxnField.nonparticipation)

    def type(self) -> TxnExpr:
        """Get the type of this transaction as a byte string.

        In most cases it is preferable to use :any:`type_enum()` instead.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#type
        """
        return self.makeTxnExpr(TxnField.type)

    def type_enum(self) -> TxnExpr:
        """Get the type of this transaction.

        See :any:`TxnType` for possible values.
        """
        return self.makeTxnExpr(TxnField.type_enum)

    def xfer_asset(self) -> TxnExpr:
        """Get the ID of the asset being transferred.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#xferasset
        """
        return self.makeTxnExpr(TxnField.xfer_asset)

    def asset_amount(self) -> TxnExpr:
        """Get the amount of the asset being transferred, measured in the asset's units.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetamount
        """
        return self.makeTxnExpr(TxnField.asset_amount)

    def asset_sender(self) -> TxnExpr:
        """Get the 32 byte address of the subject of clawback.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetsender
        """
        return self.makeTxnExpr(TxnField.asset_sender)

    def asset_receiver(self) -> TxnExpr:
        """Get the recipient of the asset transfer.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetreceiver
        """
        return self.makeTxnExpr(TxnField.asset_receiver)

    def asset_close_to(self) -> TxnExpr:
        """Get the closeout address of the asset transfer.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetcloseto
        """
        return self.makeTxnExpr(TxnField.asset_close_to)

    def group_index(self) -> TxnExpr:
        """Get the position of the transaction within the atomic transaction group.

        A stand-alone transaction is implictly element 0 in a group of 1.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#group
        """
        return self.makeTxnExpr(TxnField.group_index)

    def tx_id(self) -> TxnExpr:
        """Get the 32 byte computed ID for the transaction."""
        return self.makeTxnExpr(TxnField.tx_id)

    def application_id(self) -> TxnExpr:
        """Get the application ID from the ApplicationCall portion of the current transaction.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.application_id)

    def on_completion(self) -> TxnExpr:
        """Get the on completion action from the ApplicationCall portion of the transaction.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.on_completion)

    def approval_program(self) -> TxnExpr:
        """Get the approval program.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.approval_program)

    def clear_state_program(self) -> TxnExpr:
        """Get the clear state program.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.clear_state_program)

    def rekey_to(self) -> TxnExpr:
        """Get the sender's new 32 byte AuthAddr.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#rekeyto
        """
        return self.makeTxnExpr(TxnField.rekey_to)

    def config_asset(self) -> TxnExpr:
        """Get the asset ID in asset config transaction.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#configasset
        """
        return self.makeTxnExpr(TxnField.config_asset)

    def config_asset_total(self) -> TxnExpr:
        """Get the total number of units of this asset created.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#total
        """
        return self.makeTxnExpr(TxnField.config_asset_total)

    def config_asset_decimals(self) -> TxnExpr:
        """Get the number of digits to display after the decimal place when displaying the asset.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#decimals
        """
        return self.makeTxnExpr(TxnField.config_asset_decimals)

    def config_asset_default_frozen(self) -> TxnExpr:
        """Check if the asset's slots are frozen by default or not.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#defaultfrozen
        """
        return self.makeTxnExpr(TxnField.config_asset_default_frozen)

    def config_asset_unit_name(self) -> TxnExpr:
        """Get the unit name of the asset.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#unitname
        """
        return self.makeTxnExpr(TxnField.config_asset_unit_name)

    def config_asset_name(self) -> TxnExpr:
        """Get the asset name.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetname
        """
        return self.makeTxnExpr(TxnField.config_asset_name)

    def config_asset_url(self) -> TxnExpr:
        """Get the asset URL.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#url
        """
        return self.makeTxnExpr(TxnField.config_asset_url)

    def config_asset_metadata_hash(self) -> TxnExpr:
        """Get the 32 byte commitment to some unspecified asset metdata.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#metadatahash
        """
        return self.makeTxnExpr(TxnField.config_asset_metadata_hash)

    def config_asset_manager(self) -> TxnExpr:
        """Get the 32 byte asset manager address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#manageraddr
        """
        return self.makeTxnExpr(TxnField.config_asset_manager)

    def config_asset_reserve(self) -> TxnExpr:
        """Get the 32 byte asset reserve address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#reserveaddr
        """
        return self.makeTxnExpr(TxnField.config_asset_reserve)

    def config_asset_freeze(self) -> TxnExpr:
        """Get the 32 byte asset freeze address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeaddr
        """
        return self.makeTxnExpr(TxnField.config_asset_freeze)

    def config_asset_clawback(self) -> TxnExpr:
        """Get the 32 byte asset clawback address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#clawbackaddr
        """
        return self.makeTxnExpr(TxnField.config_asset_clawback)

    def created_asset_id(self) -> TxnExpr:
        """Get the asset ID allocated by the creation of an ASA.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig` and this is an asset creation transaction.

        Requires program version 5 or higher.

        * v5 - Only works on inner transactions.
        * >= v6 - Works on top-level and inner transactions.
        """
        return self.makeTxnExpr(TxnField.created_asset_id)

    def freeze_asset(self) -> TxnExpr:
        """Get the asset ID being frozen or un-frozen.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeasset
        """
        return self.makeTxnExpr(TxnField.freeze_asset)

    def freeze_asset_account(self) -> TxnExpr:
        """Get the 32 byte address of the account whose asset slot is being frozen or un-frozen.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeaccount
        """
        return self.makeTxnExpr(TxnField.freeze_asset_account)

    def freeze_asset_frozen(self) -> TxnExpr:
        """Get the new frozen value for the asset.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetfrozen
        """
        return self.makeTxnExpr(TxnField.freeze_asset_frozen)

    def global_num_uints(self) -> TxnExpr:
        """Get the schema count of global state integers in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.global_num_uints)

    def global_num_byte_slices(self) -> TxnExpr:
        """Get the schema count of global state byte slices in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.global_num_byte_slices)

    def local_num_uints(self) -> TxnExpr:
        """Get the schema count of local state integers in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.local_num_uints)

    def local_num_byte_slices(self) -> TxnExpr:
        """Get the schema count of local state byte slices in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.local_num_byte_slices)

    def extra_program_pages(self) -> TxnExpr:
        """Get the number of additional pages for each of the application's approval and clear state programs.

        1 additional page means 2048 more total bytes, or 1024 for each program.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 4 or higher.
        """
        return self.makeTxnExpr(TxnField.extra_program_pages)

    def created_application_id(self) -> TxnExpr:
        """Get the application ID allocated by the creation of an application.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 5 or higher.

        * v5 - Only works on inner transactions.
        * >= v6 - Works on top-level and inner transactions.
        """
        return self.makeTxnExpr(TxnField.created_application_id)

    def last_log(self) -> TxnExpr:
        """A convenience method for getting the last logged message from a transaction.

        Only application calls may log a message. Returns an empty string if no messages were logged.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.

        Requires program version 6 or higher.
        """
        return self.makeTxnExpr(TxnField.last_log)

    def state_proof_pk(self) -> TxnExpr:
        """Get the state proof public key commitment from a transaction.

        Requires program version 6 or higher.
        """
        return self.makeTxnExpr(TxnField.state_proof_pk)

    @property
    def application_args(self) -> TxnArray:
        """Application call arguments array.

        :type: TxnArray
        """
        return TxnArray(self, TxnField.application_args, TxnField.num_app_args)

    @property
    def accounts(self) -> TxnArray:
        """The accounts array in an ApplicationCall transaction.

        :type: TxnArray
        """
        return TxnArray(self, TxnField.accounts, TxnField.num_accounts)

    @property
    def assets(self) -> TxnArray:
        """The foreign asset array in an ApplicationCall transaction.

        :type: TxnArray

        Requires program version 3 or higher.
        """
        return TxnArray(self, TxnField.assets, TxnField.num_assets)

    @property
    def applications(self) -> TxnArray:
        """The applications array in an ApplicationCall transaction.

        :type: TxnArray

        Requires program version 3 or higher.
        """
        return TxnArray(self, TxnField.applications, TxnField.num_applications)

    @property
    def logs(self) -> TxnArray:
        """The log messages emitted by an application call.

        :type: TxnArray

        Requires program version 5 or higher.

        * v5 - Only works on inner transactions.
        * >= v6 - Works on top-level and inner transactions.
        """
        return TxnArray(self, TxnField.logs, TxnField.num_logs)

    @property
    def approval_program_pages(self) -> TxnArray:
        """The approval program pages.

        :type: TxnArray

        Requires program version 7 or higher.
        """
        return TxnArray(
            self, TxnField.approval_program_pages, TxnField.num_approval_program_pages
        )

    @property
    def clear_state_program_pages(self) -> TxnArray:
        """The clear state program pages.

        :type: TxnArray

        Requires program version 7 or higher.
        """
        return TxnArray(
            self,
            TxnField.clear_state_program_pages,
            TxnField.num_clear_state_program_pages,
        )


TxnObject.__module__ = "pyteal"

Txn: TxnObject = TxnObject(
    TxnExprBuilder(Op.txn, "Txn"), TxnaExprBuilder(Op.txna, Op.txnas, "Txna")
)

Txn.__module__ = "pyteal"


# File: https://github.com/damees/algorand-oracle/blob/f7f078f9d153341d1ba546ff66e8afbf2685f114/algorand-oracle-smart-contracts/src/algorand_oracle.py
from pyteal import *


ADMIN_KEY = Bytes("admin")
WHITELISTED_KEY = Bytes("whitelisted")
REQUESTS_BALANCE_KEY = Bytes("requests_balance")
MAX_BUY_AMOUNT = Int(1000000000)
MIN_BUY_AMOUNT = Int(10000000)
REQUESTS_SELLER = Addr("N5ICVTFKS7RJJHGWWM5QXG2L3BV3GEF6N37D2ZF73O4PCBZCXP4HV3K7CY")
MARKET_EXCHANGE_NOTE = Bytes("algo-oracle-app-4")


def approval_program():
    on_creation = Seq(
        [
            Assert(Txn.application_args.length() == Int(0)),
            App.localPut(Int(0), ADMIN_KEY, Int(1)),
            Return(Int(1))
        ]
    )

    is_contract_admin = App.localGet(Int(0), ADMIN_KEY)

    # set/remove an admin for this contract
    admin_status = Btoi(Txn.application_args[2])
    set_admin = Seq(
        [
            Assert(
                And(
                    is_contract_admin,
                    Txn.application_args.length() == Int(3),
                    Txn.accounts.length() == Int(1),
                    )
            ),
            App.localPut(Int(1), ADMIN_KEY, admin_status),
            Return(Int(1)),
        ]
    )

    register = Seq(
        [
            App.localPut(Int(0), WHITELISTED_KEY, Int(0)), Return(Int(1))
        ]
    )

    # Depending on what you do, you should always consider implementing a whitelisting to
    # control who access your app. This will allow you to process offchain validation before
    # allowing an account to call you app.
    # You may also consider case by case whitelisting to allow access to specific business methods.
    whitelist = Seq(
        [
            Assert(
                And(
                    is_contract_admin,
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1)
                )
            ),
            App.localPut(Int(1), WHITELISTED_KEY, Int(1)),
            Return(Int(1))
        ]
    )

    # This should be added to the checklist of business methods.
    is_whitelisted = App.localGet(Int(0), WHITELISTED_KEY)

    # An admin can increase the request balance of a user.
    requests_amount = Btoi(Txn.application_args[1])
    allocate_requests = Seq(
        [
            Assert(
                And(
                    is_contract_admin,  # Sent by admin
                    Txn.application_args.length() == Int(3),  # receiver and amount are provided
                    Txn.accounts.length() == Int(1),
                    App.localGet(Int(1), WHITELISTED_KEY),  # receiver is whitelisted
                )
            ),
            App.localPut(
                Int(1),
                REQUESTS_BALANCE_KEY,
                App.localGet(Int(1), REQUESTS_BALANCE_KEY) + requests_amount
            ),
            Return(Int(1))
        ]
    )

    # a client can buy requests
    buy_requests = Seq(
        [
            Assert(
                And(
                    is_whitelisted,
                    Global.group_size() == Int(2),  # buying requests must be done using an atomic transfer
                    Gtxn[0].type_enum() == TxnType.Payment,  # the first transaction must be a payment...
                    Gtxn[0].receiver() == REQUESTS_SELLER,  # ...to our address
                    Gtxn[0].amount() >= MIN_BUY_AMOUNT,  # we don't sell for less than 10...
                    Gtxn[0].amount() <= MAX_BUY_AMOUNT,  # ...or more than 1000 ALGO
                    Txn.group_index() == Int(1),  # call to the contract is the second transaction
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1)  # the address which will use the requests must be provided
                )
            ),
            App.localPut(
                Int(1),
                REQUESTS_BALANCE_KEY,
                App.localGet(Int(1), REQUESTS_BALANCE_KEY) + (Gtxn[0].amount() / Int(100000)),
                ),
            Return(Int(1))
        ]
    )

    market_exchange_rate_request = Seq(
        [
            Assert(
                And(
                    is_whitelisted,
                    Txn.note() == MARKET_EXCHANGE_NOTE,
                    Txn.application_args.length() == Int(4),
                    Txn.accounts.length() == Int(0),
                    App.localGet(Int(0), REQUESTS_BALANCE_KEY) >= Int(1)
                )
            ),
            App.localPut(
                Int(0),
                REQUESTS_BALANCE_KEY,
                App.localGet(Int(0), REQUESTS_BALANCE_KEY) - Int(1),
                ),
            Return(Int(1))
        ]
    )
    # Implement other oracle methods...

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_contract_admin)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_contract_admin)],
        [Txn.on_completion() == OnComplete.CloseOut, Return(Int(1))],
        [Txn.on_completion() == OnComplete.OptIn, register],
        [Txn.application_args[0] == Bytes("set_admin"), set_admin],
        [Txn.application_args[0] == Bytes("whitelist"), whitelist],
        [Txn.application_args[0] == Bytes("allocate_requests"), allocate_requests],
        [Txn.application_args[0] == Bytes("buy_requests"), buy_requests],
        [Txn.application_args[0] == Bytes("get_market_exchange_rate"), market_exchange_rate_request]
    )
    return program


def clear_state_program():
    program = Seq(
        [
            Return(Int(1))
        ]
    )

    return program


if __name__ == "__main__":
    with open("algorand_oracle_approval.teal", "w") as f:
        compiled = compileTeal(approval_program(), mode=Mode.Application, version=5)
        f.write(compiled)

    with open("algorand_oracle_clear_state.teal", "w") as f:
        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=5)
        f.write(compiled)


# File: https://github.com/0xLiquidGlass/unnamed/blob/b0d80257651279c7a3b02073f5e2f0d313fe7455/unnamedwallet/src/AtomicTxUtils.py
"""
Written by Liquid Glass

Documentation for atomic transactions: https://developer.algorand.org/docs/get-details/atomic_transfers/

Useable functions when imported:

Note that atomic transfers will require a minimum of TWO transactions for the transaction to go through

Each atomic transaction can handle a maximum of 16 individual transactions as of 2023 Apr 3

Otherwise, use NormalTxUtils library for just a single transaction

1. initiate_unsigned_tx(currentUtxo, receivingAddress, sendAmount)

This function will prepare the transaction parameters for ONE transaction and holds the prepared transaction

2. batch_every_unsigned_tx()

Where this function will batch all of the prepared transaction in batches of 16

3. calculate_group_id()

This function will calculate the hash for every atomic transaction batch

4. sign_these_unsigned_txs(relevantPrivateKeys)

This function will sign all of the prepared transactions (which is previously unsigned) with the correct
private key passed to the relevantPrivateKeys paramater

5. batch_every_signed_tx()

This function will group all of the individual signed transactions in batches of 16

6. broadcast_every_signed_txs()

This function will broadcast (or send) every batch of atomic transaction (that has 16 individual regular
transactions in it) and if successful, the transaction ID and the block which the transaction was confirmed
on will be printed as output
"""

from globals.AlgodUtils import algodClient
from algosdk import transaction

params = algodClient.suggested_params()

listUnsignedTx = []
listBatchedUnsignedTx = []
listSignedTx = []
listBatchedSignedTx = []

countFrom = int(0)

def initiate_unsigned_tx(currentUtxo, receivingAddress, sendAmount, closeToAddress):
        preparedTx = transaction.PaymentTxn(currentUtxo, params, receivingAddress, sendAmount
                                            , closeToAddress)
        # For testing
        # print(preparedTx)
        listUnsignedTx.append(preparedTx)

def batch_every_unsigned_tx():
        countUpTo = len(listUnsignedTx)
        countIncrement = int(16)
        for currentUnsignedTx in range(countFrom, countUpTo, countIncrement):
                batchedUnsignedTx = listUnsignedTx[currentUnsignedTx : currentUnsignedTx + 16]
                # For testing
                # print(batchedUnsignedTx)
                listBatchedUnsignedTx.append(batchedUnsignedTx)

def calculate_group_id():
        for currentBatchUnsignedTx in listBatchedUnsignedTx:
                transaction.assign_group_id(currentBatchUnsignedTx)

def sign_these_unsigned_txs(relevantPrivateKeys):
        countUpTo = len(listUnsignedTx)
        countIncrement = int(1)
        for currentUnsignedTxIndex in range(countFrom, countUpTo, countIncrement):
                currentUnsignedTx = listUnsignedTx[currentUnsignedTxIndex]
                correspondingPrivateKey = relevantPrivateKeys[currentUnsignedTxIndex]
                signedTx = currentUnsignedTx.sign(correspondingPrivateKey)
                listSignedTx.append(signedTx)

def batch_every_signed_tx():
        countUpTo = len(listSignedTx)
        countIncrement = int(16)
        for currentSignedTx in range(countFrom, countUpTo, countIncrement):
                batchedSignedTx = listSignedTx[currentSignedTx : currentSignedTx + 16]
                listBatchedSignedTx.append(batchedSignedTx)

def broadcast_atomic_txs():
        numberOfTransactions = len(listBatchedSignedTx)
        countUpTo = len(listBatchedSignedTx)
        countIncrement = int(1)
        print("\nYou have {} transactions in queue" .format(numberOfTransactions))
        print("\nDo not quit while the transaction is still in progress")
        for currentBatchedSignedTxIndex in range(countFrom, countUpTo, countIncrement):
                numberOfBatchesLeft = numberOfTransactions - (currentBatchedSignedTxIndex + int(1))
                print("\nNumber of batches left: {}" .format(numberOfBatchesLeft))
                currentTxBatch = listBatchedSignedTx[currentBatchedSignedTxIndex]
                txId = algodClient.send_transactions(currentTxBatch)
                confirmedTx =  transaction.wait_for_confirmation(algodClient, txId, 10)
                print("\nTransaction ID: {}" .format(txId))
                print("\nConfirmed in round {}" .format(confirmedTx.get("confirmed-round", 0)))


# File: https://github.com/hodgerpodger/staketaxcsv/blob/98e02ecf0d00e0152d03359fb2f383352ee4702e/src/staketaxcsv/algo/api/indexer.py
import datetime
import logging
import math
import os
import time
from typing import Optional, Tuple
from requests import Session
from requests.adapters import HTTPAdapter, Retry

from staketaxcsv.algo.config_algo import localconfig
from staketaxcsv.common.debug_util import debug_cache
from staketaxcsv.settings_csv import ALGO_INDEXER_NODE, REPORTS_DIR

# https://developer.algorand.org/docs/get-details/indexer/#paginated-results
INDEXER_LIMIT = 2000


# API documentation: https://editor.swagger.io/?url=https://openapi.algonode.cloud/indexer2.oas3.json
class Indexer:
    session = None

    def __init__(self):
        if not Indexer.session:
            Indexer.session = Session()
            retries = Retry(total=5, backoff_factor=2, status_forcelist=[429, 500, 502, 503, 504])
            Indexer.session.mount("https://", HTTPAdapter(max_retries=retries))

    def account_exists(self, address):
        endpoint = f"v2/accounts/{address}/transactions"
        params = {"limit": 1}

        _, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        return status_code == 200

    @debug_cache(os.path.join(REPORTS_DIR, "algo", "accounts"))
    def get_account(self, address: str) -> Optional[dict]:
        """
        This function retrieves account information for a given address.

        Args:
          address (str): The address of the Algorand account that we want to retrieve information for.

        Returns:
          A dictionary containing information about the account if successful, `None` otherwise.
          See account schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Account
        """
        endpoint = f"v2/accounts/{address}"
        params = {"include-all": True}

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        if status_code == 200:
            return data["account"]
        else:
            return None

    def get_transaction(self, txid: str) -> Optional[dict]:
        """
        This function retrieves a transaction with a given ID.

        Args:
          txid (str): The ID of the transaction ID that is being requested.

        Returns:
          A dictionary containing information about a transaction if successful, `None` otherwise.
          See transaction schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Transaction
        """
        endpoint = f"v2/transactions/{txid}"

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint)

        if status_code == 200:
            return data["transaction"]
        else:
            return None

    def get_transactions(self,
                         address: str,
                         after_date: Optional[datetime.date] = None,
                         before_date: Optional[datetime.date] = None,
                         min_round: Optional[int] = None,
                         next: Optional[str] = None) -> Tuple[list, Optional[str]]:
        """
        This function retrieves transactions for a given address with optional filters and pagination.

        Args:
          address (str): The Algorand address for which to retrieve transactions.
          after_date (Optional[datetime.date]): Include results after the given date.
          before_date (Optional[datetime.date]): Include results before the given date.
          min_round (Optional[int]): The minimum round number for transactions to be included in the
        results. Transactions with a round number lower than this value will be excluded.
          next (Optional[str]): An optional string that represents a token used to
        retrieve the next page of results in a multi-page request. It is returned in the response of the
        previous request and can be passed as a parameter to this function to retrieve the next page of
        transactions.

        Returns:
          a tuple containing a list of transactions and an optional string representing the next token for
        pagination. See transaction schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Transaction
        """
        endpoint = f"v2/accounts/{address}/transactions"
        params = {"limit": INDEXER_LIMIT}
        if after_date:
            params["after-time"] = after_date.isoformat()
        if before_date:
            params["before-time"] = before_date.isoformat()
        if min_round:
            params["min-round"] = min_round
        if next:
            params["next"] = next

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        if status_code == 200:
            return data["transactions"], data.get("next-token")
        else:
            return [], None

    @debug_cache(os.path.join(REPORTS_DIR, "algo", "transactions"))
    def get_all_transactions(self, address: str) -> list:
        """
        This function retrieves all transactions for a given address within a specified date range and
        minimum round, using a maximum number of queries and transactions per query. The transactions are
        obtained by making multiple queries to the indexer API, with a maximum number of transactions per
        query determined by the `localconfig.limit` parameter.

        Returns:
            list: List of transaction objects that match the specified criteria,
                see schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Transaction
        """
        next = None
        out = []

        max_txs = localconfig.limit
        max_queries = math.ceil(max_txs / INDEXER_LIMIT)
        logging.info("max_txs: %s, max_queries: %s", max_txs, max_queries)

        after_date = None
        before_date = None
        if localconfig.start_date:
            after_date = datetime.date.fromisoformat(localconfig.start_date)
        if localconfig.end_date:
            before_date = datetime.date.fromisoformat(localconfig.end_date) + datetime.timedelta(days=1)

        for _ in range(max_queries):
            transactions, next = self.get_transactions(
                address, after_date, before_date, localconfig.min_round, next)
            out.extend(transactions)

            if not next:
                break

        return out

    def get_transactions_by_group(self, group_id: str) -> list[dict]:
        """
        This function retrieves a list of transactions associated with a specific group ID.

        Args:
          group_id (str): The group ID. More details on transaction groups\
          at https://developer.algorand.org/docs/get-details/atomic_transfers/

        Returns:
          This function returns a list of dictionaries containing transaction data for a specific group ID.
        """
        endpoint = "v2/transactions"
        params = {"group-id": group_id}

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        if status_code == 200:
            return data["transactions"]
        else:
            return []

    @debug_cache(os.path.join(REPORTS_DIR, "algo", "transactions"))
    def get_transactions_by_app(self, app_id: int, round: int, address: Optional[str] = None) -> list[dict]:
        """
        This function retrieves a list of transactions for a specific application ID, round, and optional
        address.

        Args:
          app_id (int): The ID of the application for which transactions are being requested.
          round (int): The round number of the transactions to retrieve.
          address (Optional[str]): Optional parameter to filter transactions by a specific address.

        Returns:
          This function returns a list of dictionaries containing transactions made with the specified parameters.
        """
        endpoint = "v2/transactions"
        params = {
            "limit": INDEXER_LIMIT,
            "application-id": app_id,
            "round": round
        }
        if address:
            params["address"] = address

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        if status_code == 200:
            return data["transactions"]
        else:
            return []

    @debug_cache(os.path.join(REPORTS_DIR, "algo", "assets"))
    def get_asset(self, id: int) -> Optional[dict]:
        """
        This function retrieves asset information.

        Args:
          id (int): Algorand Standard Asset (ASA) id.

        Returns:
          A dictionary containing asset details if successful, `None` otherwise.
          See asset params schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Asset
        """
        endpoint = f"v2/assets/{id}"
        params = {"include-all": True}

        # Temporarily slow down asset requests until we either cache them
        # or https://github.com/algorand/go-algorand/issues/5250 is resolved.
        time.sleep(0.1)

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        if status_code == 200:
            return data["asset"]
        else:
            return None

    @debug_cache(os.path.join(REPORTS_DIR, "algo", "assets"))
    def get_deleted_asset(self, id: int) -> Optional[dict]:
        """
        This function retrieves information for an asset that has been deleted.

        Args:
          id (int): Algorand Standard Asset (ASA) id.

        Returns:
          A dictionary containing asset details if successful, `None` otherwise.
          See asset params schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Asset
        """
        endpoint = f"v2/assets/{id}/transactions"
        params = {"tx-type": "acfg"}

        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)

        if status_code == 200 and len(data.get("transactions", [])) > 0:
            return data["transactions"][0]["asset-config-transaction"]
        else:
            return None

    def _query(self, node_url, endpoint, params=None):
        url = f"{node_url}/{endpoint}"

        logging.info("Querying Algo Indexer %s with params %s...", url, params)

        try:
            response = Indexer.session.get(url, params=params, timeout=5)
        except Exception as e:
            logging.error("Exception when querying '%s', exception=%s", url, str(e))
        else:
            return response.json(), response.status_code

        return {}, 599


# File: https://github.com/johnnyknoxville1337/voting-contract/blob/fae150f93a98bc0b048a103971785ce891c96eed/src/Beaker/voting.py
from pyteal import *
from typing import Final
from beaker import Application, AccountStateValue, ApplicationStateValue, Authorize, bare_external, external, create, opt_in


class Voting(Application):
    proposal: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.bytes
    )
    start_time: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    end_time: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    result: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.bytes
    )
    num_of_yays: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    num_of_nays: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    vote_choice: Final[AccountStateValue] = AccountStateValue(
        stack_type=TealType.bytes
    )
    has_vote: Final[AccountStateValue] = AccountStateValue(
        stack_type=TealType.uint64
    )

    @create
    def create(self):
        return self.initialize_application_state()

    @opt_in
    def optin(self):
        return self.initialize_account_state()

    @external(authorize=Authorize.only(Global.creator_address()))
    def create_proposal(self, proposal: abi.String, end_time: abi.Uint64):
        return Seq(
            self.proposal.set(proposal.get()),
            self.start_time.set(Global.latest_timestamp()),
            self.end_time.set(Global.latest_timestamp() + end_time.get())
        )

    @external(authorize=Authorize.opted_in(Global.current_application_id()))
    def vote(
        self,
        vote_choice: abi.String,
        key: abi.String,
        app: abi.Application # type: ignore[assignment]
    ):
        return Seq(
            (is_staking := App.localGetEx(account=Txn.sender(), app=app.application_id(), key=key.get())),
            Assert(is_staking.hasValue()),
            Assert(
                And(
                    Global.latest_timestamp() >= self.start_time,
                    Global.latest_timestamp() <= self.end_time
                )
            ),
            Assert(is_staking.value() == Int(1)),
            Assert(self.has_vote == Int(0)),
            If(vote_choice.get() == Bytes("yes"))
            .Then(
                self.vote_choice.set(Bytes("yes")),
                self.num_of_yays.increment()
            )
            .ElseIf(vote_choice.get() == Bytes("no"))
            .Then(
                self.vote_choice.set(Bytes("no")),
                self.num_of_nays.increment()
            ),
            self.has_vote.set(Int(1))
        )

    @external
    def get_vote_result(self):
        return Seq(
            Assert(Global.latest_timestamp() > self.end_time),
            If(self.num_of_yays > self.num_of_nays)
            .Then(self.result.set(Bytes("passed")))
            .ElseIf(self.num_of_yays < self.num_of_nays)
            .Then(self.result.set(Bytes("rejected")))
            .Else(self.result.set(Bytes("tie")))
        )

    @bare_external(close_out=CallConfig.CALL, clear_state=CallConfig.CALL)
    def clear_vote(self):
        return Seq(
            Assert(self.has_vote == Int(1)),
            If(self.vote_choice == Bytes("yes"))
            .Then(
                Assert(self.num_of_yays >= Int(1)),
                self.num_of_yays.decrement()
            )
            .ElseIf(self.vote_choice == Bytes("no")).
            Then(
                Assert(self.num_of_nays >= Int(1)),
                self.num_of_nays.decrement()
            ),
            self.vote_choice.set(Bytes("")),
            self.has_vote.set(Int(0))
        )


Voting().dump()


# File: https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/permissioned-voting/assets/permissioned-voting-approval.py
from pyteal import *

def approval_program():
    """
    https://developer.algorand.org/solutions/example-permissioned-voting-stateful-smart-contract-application/?query=asset%2520contract
    To implement a permissioned voting application on Algorand, a central authority is needed to
    provide users the right to vote. In this example, this is handled by an Algorand Standard
    Asset. The central authority creates a vote token and then gives voters who have registered
    one voting token. The voter then registers within a round range with the voting smart
    contract, by Opting into the contract. Voters then vote by grouping two transactions.
    The first is a smart contract call to vote for either candidate A or candidate B, and
    the second is transferring the vote token back to the central authority. Voting is only
    allowed within the voting range.
    """
    # Check to see that the application ID is not set, indicating this is a creation call.
    # Store the creator address to global state.
    # Store both register and voting round ranges to global state.
    # Store Asset ID to global state
    on_creation = Seq([
        App.globalPut(Bytes("Creator"), Txn.sender()),
        Assert(Txn.application_args.length() == Int(5)),
        App.globalPut(Bytes("RegBegin"), Btoi(Txn.application_args[0])),
        App.globalPut(Bytes("RegEnd"), Btoi(Txn.application_args[1])),
        App.globalPut(Bytes("VoteBegin"), Btoi(Txn.application_args[2])),
        App.globalPut(Bytes("VoteEnd"), Btoi(Txn.application_args[3])),
        App.globalPut(Bytes("AssetID"), Btoi(Txn.application_args[4])),
        Return(Int(1))
    ])

    # Always verify that the RekeyTo property of any transaction is set to the ZeroAddress
    # unless the contract is specifically involved ina rekeying operation.
    no_rekey_addr = Txn.rekey_to() == Global.zero_address()

    # Checks whether the sender is creator.
    is_creator = Txn.sender() == App.globalGet(Bytes("Creator"))

    # Checks whether sender has voted before or not.
    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))

    on_closeout = Seq([
        get_vote_of_sender,
        If(And(Global.round() <= App.globalGet(Bytes("VoteEnd")), get_vote_of_sender.hasValue()),
            App.globalPut(get_vote_of_sender.value(), App.globalGet(get_vote_of_sender.value()) - Int(1))
        ),
        Return(Int(1))
    ])

    # Checks that the first argument to the smart contract is the word register.
    # Verifies that the round is currently between registration begin and end rounds.
    on_register = Return(
        And(
        no_rekey_addr,
        Txn.application_args[0] == Bytes("register"),
        Global.round() >= App.globalGet(Bytes("RegBegin")),
        Global.round() <= App.globalGet(Bytes("RegEnd")))
    )

    # Verifies the first application argument contains the string vote.
    # Verifies the vote call is between the beginning and end of the voting round ranges.
    # Verifies that two transactions are in the group.
    # Checks that the second transaction is an asset transfer, and the token transferred is the vote token.
    # Checks that the second transaction receiver is the creator of the application.
    # Checks if the account has already voted, and if so, just returns true with no change to global state.
    # Verifies that the user is either voting for candidate A or B.
    # Reads the candidates current total from the global state and increments the value.
    # Stores the candidate choice to the users local state.
    choice = Txn.application_args[1]
    choice_tally = App.globalGet(choice)
    on_vote = Seq([
        Assert(And(
            no_rekey_addr,
            Global.round() >= App.globalGet(Bytes("VoteBegin")),
            Global.round() <= App.globalGet(Bytes("VoteEnd"))
        )),
        Assert(And(
            Global.group_size() == Int(2),
            Gtxn[1].type_enum() == TxnType.AssetTransfer,
            Gtxn[1].asset_receiver() == App.globalGet(Bytes("Creator")),
            Gtxn[1].xfer_asset() == App.globalGet(Bytes("AssetID")),
            Gtxn[1].asset_amount() == Int(1),
            Or(choice == Bytes("candidatea"), choice == Bytes("candidateb"))
        )),
        get_vote_of_sender,
        If(get_vote_of_sender.hasValue(),
            Return(Int(0))
        ),
        App.globalPut(choice, choice_tally + Int(1)),
        App.localPut(Int(0), Bytes("voted"), choice),
        Return(Int(1))
    ])

    # Verfies that the application_id is 0, jumps to on_creation.
    # Verifies that DeleteApplication is used and verifies that sender is creator.
    # Verifies that UpdateApplication is used and verifies that sender is creator.
    # Verifies that closeOut is used and jumps to on_closeout.
    # Verifies that the account has opted in and jumps to on_register.
    # Verifies that first argument is "vote" and jumps to on_vote.
    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, on_register],
        [Txn.application_args[0] == Bytes("vote"), on_vote]
    )

    return program

optimize_options = OptimizeOptions(scratch_slots=True)
if __name__ == "__main__":
    print(compileTeal(approval_program(), Mode.Application, version = 5, optimize=optimize_options))


# File: https://github.com/Algofiorg/smart-contracts/blob/64b8995a81e7ccbb080ee4401b1dbe7a9ac181ef/contracts/governance/voting_escrow.py
"""Vote Escrow Contract"""

from pyteal import *

from contracts.governance.constants import *
from contracts.governance.contract_strings import VotingEscrowStrings
from contracts.governance.subroutines import (
    MagicAssert,
    decrement,
    increment,
    opt_into_asa,
    send_asa,
    verify_txn_is_sending_asa_to_contract,
)
from contracts.utils.wrapped_var import *


class VotingEscrowUser:
    """Data structure for user state in the voting escrow contract"""

    def __init__(self, user_index):
        # LOCAL STATE
        self.amount_locked = WrappedVar(
            VotingEscrowStrings.user_amount_locked, LOCAL_VAR, user_index
        )
        self.lock_start_time = WrappedVar(
            VotingEscrowStrings.user_lock_start_time,
            LOCAL_VAR,
            user_index,
        )
        self.lock_duration = WrappedVar(
            VotingEscrowStrings.user_lock_duration, LOCAL_VAR, user_index
        )
        self.amount_vebank = WrappedVar(
            VotingEscrowStrings.user_amount_vebank, LOCAL_VAR, user_index
        )
        self.boost_multiplier = WrappedVar(
            VotingEscrowStrings.user_boost_multiplier,
            LOCAL_VAR,
            user_index,
        )
        self.update_time = WrappedVar(
            VotingEscrowStrings.user_last_update_time,
            LOCAL_VAR,
            user_index,
        )

    def get_lock_end_time(self):
        """Get the time at which the lock expires"""
        return self.lock_start_time.get() + self.lock_duration.get()


class VotingEscrow:
    """Vote Escrow Contract"""

    def __init__(self):
        # GLOBAL STATE
        self.dao_address = WrappedVar(
            VotingEscrowStrings.dao_address, GLOBAL_VAR
        )
        self.emergency_dao_address = WrappedVar(
            VotingEscrowStrings.emergency_dao_address, GLOBAL_VAR
        )
        self.asset_id = WrappedVar(
            VotingEscrowStrings.asset_id, GLOBAL_VAR
        )
        self.total_locked = WrappedVar(
            VotingEscrowStrings.total_locked, GLOBAL_VAR
        )
        self.total_vebank = WrappedVar(
            VotingEscrowStrings.total_vebank, GLOBAL_VAR
        )
        self.admin_contract_app_id = WrappedVar(
            VotingEscrowStrings.admin_contract_app_id, GLOBAL_VAR
        )

        # HELPER CLASSES
        self.sending_user = VotingEscrowUser(Int(0))
        self.target_user = VotingEscrowUser(Int(1))

    # CREATION

    def on_creation(self):
        """Creates the voting escrow contract"""
        dao_address = Txn.accounts[1]
        emergency_dao_address = Txn.accounts[2]

        return Seq(
            # set dao address
            self.dao_address.put(dao_address),
            # set emergency dao address
            self.emergency_dao_address.put(emergency_dao_address),
            self.total_vebank.put(ZERO_AMOUNT),
            self.total_locked.put(ZERO_AMOUNT),
            Approve(),
        )

    # ADMIN

    def on_set_admin_contract_app_id(self):
        """Sets the admin contract app id"""
        admin_contract_app_id = Txn.applications[1]

        return Seq(
            # set new rewards manager app id
            self.admin_contract_app_id.put(admin_contract_app_id),
            Approve(),
        )

    def on_set_gov_token_id(self):
        """Sets the gov token id"""
        return Seq(
            # set gov token id
            self.asset_id.put(Txn.assets[0]),
            # opt into gov asset
            opt_into_asa(self.asset_id.get()),
            Approve(),
        )

    # OPT IN / CLOSE OUT

    def on_opt_in(self):
        """Called on opt in"""
        return Seq(
            MagicAssert(Gtxn[PREVIOUS_TRANSACTION].sender() == Txn.sender()),
            MagicAssert(
                Gtxn[PREVIOUS_TRANSACTION].application_id()
                == self.admin_contract_app_id.get()
            ),
            MagicAssert(
                Gtxn[PREVIOUS_TRANSACTION].on_completion() == OnComplete.OptIn
            ),
            Approve(),
        )

    def on_close_out(self):
        """Called on close out"""
        return Seq(
            # assert user has no locked bank
            MagicAssert(self.sending_user.amount_locked.get() == ZERO_AMOUNT),
            Approve(),
        )

    # HELPER FUNCTIONS

    def calculate_vebank_amount(self, amount_locked, time_remaining):
        """Calculates the amount of veBANK a user has"""
        return WideRatio([amount_locked, time_remaining], [SECONDS_PER_YEAR])

    def update_boost(self, user: VotingEscrowUser):
        """Updates the user's boost"""
        return Seq(
            [
                If(self.total_vebank.get() > ZERO_AMOUNT)
                .Then(
                    user.boost_multiplier.put(
                        WideRatio(
                            [user.amount_vebank.get(), FIXED_12_SCALE_FACTOR],
                            [self.total_vebank.get()],
                        )
                    )
                )
                .Else(user.boost_multiplier.put(ZERO_AMOUNT))
            ]
        )

    def update_vebank_data(self, user: VotingEscrowUser):
        """Updates a user's veBANK data"""
        current_time = Global.latest_timestamp()
        time_delta = current_time - user.update_time.get()
        lock_end_time = user.get_lock_end_time()
        lock_time_remaining = lock_end_time - current_time

        on_update = Seq(
            # update user state if time_delta is non zero
            If(time_delta > ZERO_AMOUNT).Then(
                Seq(
                    # decrement user vebank from total
                    decrement(self.total_vebank, user.amount_vebank.get()),
                    # recalculate user vebank amount
                    If(current_time > lock_end_time)
                    .Then(
                        user.amount_vebank.put(ZERO_AMOUNT),
                    )
                    .Else(
                        Seq(
                            user.amount_vebank.put(
                                self.calculate_vebank_amount(
                                    user.amount_locked.get(),
                                    lock_time_remaining,
                                )
                            ),
                            # increment new user vebank to total
                            increment(
                                self.total_vebank, user.amount_vebank.get()
                            ),
                        ),
                    ),
                    # recalculate user boost
                    self.update_boost(user),
                    # update user latest update time
                    user.update_time.put(current_time),
                ),
            ),
        )

        return on_update

    # USER FUNCTIONS

    def on_lock(self):
        """
        Locks user's BANK and grants veBANK (stored in local state)
        veBANK = BANK * (lock_duration / 4 years)
        Locking for 4 years grants maximum weight. Min lock duration is 7 days
        """
        gov_token_txn_index = PREVIOUS_TRANSACTION
        current_timestamp = Global.latest_timestamp()

        lock_duration = Btoi(Txn.application_args[1])
        lock_amount = Gtxn[gov_token_txn_index].asset_amount()
        vebank_amount = self.calculate_vebank_amount(
            lock_amount, lock_duration
        )

        return Seq(
            # verify asset being sent to voting escrow contract
            verify_txn_is_sending_asa_to_contract(
                gov_token_txn_index, self.asset_id.get()
            ),
            # verify user has zero existing locked amount
            MagicAssert(self.sending_user.amount_locked.get() == ZERO_AMOUNT),
            # verify lock duration
            MagicAssert(lock_duration >= MIN_LOCK_TIME_SECONDS),
            MagicAssert(lock_duration <= MAX_LOCK_TIME_SECONDS),
            # verify non zero ve bank amount
            MagicAssert(vebank_amount > ZERO_AMOUNT),
            # set amount locked
            self.sending_user.amount_locked.put(lock_amount),
            # set lock start time
            self.sending_user.lock_start_time.put(current_timestamp),
            # set lock duration
            self.sending_user.lock_duration.put(lock_duration),
            # set vebank amount
            self.sending_user.amount_vebank.put(vebank_amount),
            # set update time
            self.sending_user.update_time.put(current_timestamp),
            # update global totals
            increment(self.total_locked, lock_amount),
            increment(self.total_vebank, vebank_amount),
            # recalculate user boost
            self.update_boost(self.sending_user),
            Approve(),
        )

    def on_update_vebank_data(self):
        """
        Update a user's and global veBANK and lock state
        Anyone can call this for any user
        """

        return Seq(
            [
                # update target user vebank data
                self.update_vebank_data(self.target_user),
                Approve(),
            ]
        )

    def on_claim(self):
        """Sends back user's locked BANK after the lock expires"""
        lock_end_time = self.sending_user.get_lock_end_time()
        current_time = Global.latest_timestamp()

        return Seq(
            # verify amount locked is non zero
            MagicAssert(self.sending_user.amount_locked.get() > ZERO_AMOUNT),
            # verify lock has expired
            MagicAssert(current_time > lock_end_time),
            # return asset to user
            send_asa(
                self.asset_id.get(),
                self.sending_user.amount_locked.get(),
                Txn.sender(),
            ),
            # decrement user amount from total
            decrement(
                self.total_locked, self.sending_user.amount_locked.get()
            ),
            # set user amount locked to zero
            self.sending_user.amount_locked.put(ZERO_AMOUNT),
            # reset user lock start time to
            self.sending_user.lock_start_time.put(UNSET),
            # reset user lock duration
            self.sending_user.lock_duration.put(UNSET),
            # reset user update time
            self.sending_user.update_time.put(UNSET),
            Approve(),
        )

    def on_extend_lock(self):
        """Adds time to existing user lock."""
        extend_duration_seconds = Btoi(Txn.application_args[1])
        current_time = Global.latest_timestamp()
        lock_end_time = self.sending_user.get_lock_end_time()
        duration_remaining = (
            If(current_time < lock_end_time)
            .Then(lock_end_time - current_time)
            .Else(Int(0))
        )
        total_new_duration = duration_remaining + extend_duration_seconds
        current_vebank_balance = self.sending_user.amount_vebank.get()
        locked_amount = self.sending_user.amount_locked.get()

        new_vebank_balance = self.calculate_vebank_amount(
            locked_amount, total_new_duration
        )

        return Seq(
            # verify user has non zero locked amount
            MagicAssert(locked_amount > ZERO_AMOUNT),
            # verify extend duration is non zero
            MagicAssert(extend_duration_seconds > ZERO_AMOUNT),
            # validate new total duration
            MagicAssert(total_new_duration >= MIN_LOCK_TIME_SECONDS),
            MagicAssert(total_new_duration <= MAX_LOCK_TIME_SECONDS),
            # update global total vebank
            decrement(self.total_vebank, current_vebank_balance),
            increment(self.total_vebank, new_vebank_balance),
            # set new user vebank amount
            self.sending_user.amount_vebank.put(new_vebank_balance),
            # set new user lock duration
            self.sending_user.lock_duration.put(total_new_duration),
            # set new user lock start time
            self.sending_user.lock_start_time.put(current_time),
            # recalculate user boost
            self.update_boost(self.sending_user),
            Approve(),
        )

    def on_increase_lock_amount(self):
        """Increases the amount of BANK locked, without changing lock duration"""
        gov_token_txn_index = PREVIOUS_TRANSACTION
        current_time = Global.latest_timestamp()
        lock_end_time = self.sending_user.get_lock_end_time()
        lock_duration = lock_end_time - current_time
        additional_amount_to_lock = Gtxn[gov_token_txn_index].asset_amount()
        existing_amount_locked = self.sending_user.amount_locked.get()
        new_vebank = self.calculate_vebank_amount(
            existing_amount_locked + additional_amount_to_lock, lock_duration
        )

        return Seq(
            # verify previous transaction is payment to this contract
            verify_txn_is_sending_asa_to_contract(
                gov_token_txn_index, self.asset_id.get()
            ),
            # verify the users current amount locked is non zero
            MagicAssert(self.sending_user.amount_locked.get() > ZERO_AMOUNT),
            # verify remaining lock duration is greater than minimum
            MagicAssert(lock_duration >= MIN_LOCK_TIME_SECONDS),
            # verify additional amount to lock is non zero
            MagicAssert(additional_amount_to_lock > ZERO_AMOUNT),
            # verify additional vebank amount is non zero
            MagicAssert(new_vebank > self.sending_user.amount_vebank.get()),
            # increment total locked
            increment(self.total_locked, additional_amount_to_lock),
            # increment user locked
            increment(
                self.sending_user.amount_locked, additional_amount_to_lock
            ),
            decrement(
                self.total_vebank, self.sending_user.amount_vebank.get()
            ),
            # increment total vebank
            increment(self.total_vebank, new_vebank),
            # increment user vebank
            self.sending_user.amount_vebank.put(new_vebank),
            # recalculate user boost
            self.update_boost(self.sending_user),
            Approve(),
        )

    def approval_program(self):
        """Voting escrow approval program."""
        # sender checks
        sender_is_dao = Or(
            Txn.sender() == self.dao_address.get(),
            Txn.sender() == self.emergency_dao_address.get(),
        )
        # check on complete
        is_no_op = Txn.on_completion() == OnComplete.NoOp
        is_opt_in = Txn.on_completion() == OnComplete.OptIn
        is_close_out = Txn.on_completion() == OnComplete.CloseOut
        # on call method
        on_call_method = Txn.application_args[0]

        return Cond(
            [Txn.application_id() == Int(0), self.on_creation()],
            [Txn.on_completion() == OnComplete.DeleteApplication, Reject()],
            [is_opt_in, self.on_opt_in()],
            [is_close_out, self.on_close_out()],
            # admin functions
            [
                sender_is_dao,
                Cond(
                    [
                        is_no_op,
                        Cond(
                            [
                                on_call_method
                                == Bytes(
                                    VotingEscrowStrings.set_gov_token_id
                                ),
                                self.on_set_gov_token_id(),
                            ],
                            [
                                on_call_method
                                == Bytes(
                                    VotingEscrowStrings.set_admin_contract_app_id
                                ),
                                self.on_set_admin_contract_app_id(),
                            ],
                        ),
                    ]
                ),
            ],
            # user functions
            [
                is_no_op,
                Cond(
                    # target user
                    [
                        on_call_method
                        == Bytes(VotingEscrowStrings.update_vebank_data),
                        self.on_update_vebank_data(),
                    ],
                    # lock (does not require vebank update)
                    [
                        on_call_method
                        == Bytes(VotingEscrowStrings.lock),
                        self.on_lock(),
                    ],
                    # user
                    [
                        TRUE,
                        Seq(
                            self.update_vebank_data(self.sending_user),
                            Cond(
                                [
                                    on_call_method
                                    == Bytes(
                                        VotingEscrowStrings.extend_lock
                                    ),
                                    self.on_extend_lock(),
                                ],
                                [
                                    on_call_method
                                    == Bytes(
                                        VotingEscrowStrings.increase_lock_amount
                                    ),
                                    self.on_increase_lock_amount(),
                                ],
                                [
                                    on_call_method
                                    == Bytes(VotingEscrowStrings.claim),
                                    self.on_claim(),
                                ],
                            ),
                        ),
                    ],
                ),
            ],
        )

    def clear_state_program(self):
        """Clear state program for the voting escrow contract."""
        return Seq(
            # decrement user vebank amount from total
            decrement(
                self.total_vebank, self.sending_user.amount_vebank.get()
            ),
            # decrement user locked amount from total
            decrement(
                self.total_locked, self.sending_user.amount_locked.get()
            ),
            Approve(),
        )


# File: https://github.com/GoraNetwork/algokit_default_template/blob/38a15bdfe2fff9820b1abb9b01c8a4a278c32d9d/template_content/protocol/assets/helpers/voting_base.py
from pyteal import *
from .key_map import key_map
import sys
import pathlib
import os
from voting_approval import hash_type
sys.path.append(os.path.join(pathlib.Path(__file__).parent.resolve(),'../..'))
from utils.abi_types import LocalHistoryEntry,ProposalsEntry
from utils.gora_pyteal_utils import calc_box_cost,SmartAssert
global_keys = key_map["voting_global"]
main_local_keys = key_map["main_local"]

def on_clear_logic():
    MAIN_APP = App.globalGet(global_keys["main_app"])
    current_round = App.globalGet(global_keys["round"])
    local_stake_account_pk = App.localGetEx(Txn.accounts[1], MAIN_APP, main_local_keys["local_public_key"])

    return Seq([
        local_stake_account_pk,
        SmartAssert(local_stake_account_pk.value() == Txn.sender()),
        (previous_vote_bytes := App.box_get(Txn.accounts[1])),
        previous_vote_bytes,
        (previous_vote := LocalHistoryEntry()).decode(previous_vote_bytes.value()),
        (previous_proposal_entry := ProposalsEntry()).set(previous_vote.proposal_entry),
        (sender_vote_round := abi.Uint64()).set(previous_proposal_entry.vote_round),
        (sender_vote_hash := abi.make(hash_type)).set(previous_proposal_entry.vote_hash),
        If(sender_vote_round.get() == current_round)
        .Then(
            Approve()
        )
        .ElseIf(
            sender_vote_round.get() < current_round
        )
        .Then(
            Seq([
                InnerTxnBuilder.Begin(),
                InnerTxnBuilder.SetFields({
                    TxnField.type_enum: TxnType.Payment,
                    TxnField.receiver: Txn.sender(),
                    TxnField.amount: calc_box_cost(abi.size_of(hash_type),abi.size_of(ProposalsEntry))
                }),
                InnerTxnBuilder.Submit(),
                App.box_delete(sender_vote_hash.get())
                # TODO: do we want to delete their previous vote box here too?
            ])
        ),
        Approve()
    ])

# File: https://github.com/bytesdruid/Voting/blob/805017f6b4cd126daa77c4bc9b9f894faf333f87/voting_contract.py
from pyteal import *

def approval_program():
    on_creation = Seq(
        [
            # name of this application
            App.globalPut(Bytes("AppName"), Bytes("Community 1 Governance Application")),
            # choice A
            App.globalPut(Bytes("Option A"), Bytes("Description for option one.")),
            # choice B
            App.globalPut(Bytes("Option B"), Bytes("Description for option two.")),
            # creator is set to the contract creator
            App.globalPut(Bytes("Creator"), Txn.sender()),
            # expecting four arguments for the registration and voting time frames
            Assert(Txn.application_args.length() == Int(4)),
            # registration begins blockround
            App.globalPut(Bytes("RegBegin"), Btoi(Txn.application_args[0])),
            # registration ending blockround
            App.globalPut(Bytes("RegEnd"), Btoi(Txn.application_args[1])),
            # vote begining blockround
            App.globalPut(Bytes("VoteBegin"), Btoi(Txn.application_args[2])),
            # vote ending blockround
            App.globalPut(Bytes("VoteEnd"), Btoi(Txn.application_args[3])),
            Return(Int(1)),
        ]
    )

    # checks to see if txn sender is the contract creator
    is_creator = Txn.sender() == App.globalGet(Bytes("Creator"))

    # this gets the sender vote from an external application's local state
    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))

    # when delete app is called get vote of sender is called and the if statement is called
    on_closeout = Seq(
        [
            get_vote_of_sender,
            # if vote hasnt ended and the user has voted, we delete their vote
            If(
                And(
                    Global.round() <= App.globalGet(Bytes("VoteEnd")),
                    get_vote_of_sender.hasValue(),
                ),
                App.globalPut(
                    get_vote_of_sender.value(),
                    App.globalGet(get_vote_of_sender.value()) - Int(1),
                ),
            ),
            # otherwise we just approve the app deletion
            Return(Int(1)),
        ]
    )

    # checks that the registration period is active before approving opt in
    on_register = Return(
        And(
            Global.round() >= App.globalGet(Bytes("RegBegin")),
            Global.round() <= App.globalGet(Bytes("RegEnd")),
        )
    )

    # first app arg is assigned to choice variable
    choice = Txn.application_args[1]
    # gets the current choice count value
    choice_tally = App.globalGet(choice)

    # this is the only noop call in this application
    on_vote = Seq(
        [
            # first we check that the voting period is active
            Assert(
                And(
                    Global.round() >= App.globalGet(Bytes("VoteBegin")),
                    Global.round() <= App.globalGet(Bytes("VoteEnd")),
                )
            ),
            # next the vote of the txn sender is retrieved
            get_vote_of_sender,
            # if the vote exists then we continue executing the sequence
            If(get_vote_of_sender.hasValue(), Return(Int(0))),
            # the choice key is accessed and the tally is updated by adding one 
            App.globalPut(choice, choice_tally + Int(1)),
            # records the voter's choice in the voted key of the voter's local state
            App.localPut(Int(0), Bytes("voted"), choice),
            Return(Int(1)),
        ]
    )

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, on_register],
        [Txn.application_args[0] == Bytes("vote"), on_vote],
    )

    return program


def clear_state_program():
    # gets the vote of the voted value from the external app
    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))
    program = Seq(
        [
            get_vote_of_sender,
            # if the vote has not ended, then remove the account's vote
            If(
                And(
                    Global.round() <= App.globalGet(Bytes("VoteEnd")),
                    get_vote_of_sender.hasValue(),
                ),
                App.globalPut(
                    get_vote_of_sender.value(),
                    App.globalGet(get_vote_of_sender.value()) - Int(1),
                ),
            ),
            Return(Int(1)),
        ]
    )

    return program


if __name__ == "__main__":
    with open("vote_approval.teal", "w") as f:
        compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)
        f.write(compiled)

    with open("vote_clear_state.teal", "w") as f:
        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)
        f.write(compiled)

# File: https://github.com/0xBitzz/Algo-Smart-DAO-Encode-Project/blob/4db7b98e9f2f1e60b86ed92849da38c9521f24c9/voting-contract/src/Beaker/voting.py
from pyteal import *
from typing import Final
from beaker import Application, AccountStateValue, ApplicationStateValue, Authorize, bare_external, external, create, opt_in


class Voting(Application):
    proposal: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.bytes
    )
    start_time: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    end_time: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    result: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.bytes
    )
    num_of_yays: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    num_of_nays: Final[ApplicationStateValue] = ApplicationStateValue(
        stack_type=TealType.uint64
    )
    vote_choice: Final[AccountStateValue] = AccountStateValue(
        stack_type=TealType.bytes
    )
    has_vote: Final[AccountStateValue] = AccountStateValue(
        stack_type=TealType.uint64
    )

    @create
    def create(self):
        return self.initialize_application_state()

    @opt_in
    def optin(self):
        return self.initialize_account_state()

    @external(authorize=Authorize.only(Global.creator_address()))
    def create_proposal(self, proposal: abi.String, end_time: abi.Uint64):
        return Seq(
            self.proposal.set(proposal.get()),
            self.start_time.set(Global.latest_timestamp()),
            self.end_time.set(Global.latest_timestamp() + end_time.get())
            # yes no set
        )

    @external(authorize=Authorize.opted_in(Global.current_application_id()))
    def vote(
        self,
        vote_choice: abi.String,
        key: abi.String,
        app: abi.Application # type: ignore[assignment]
    ):
        return Seq(
            (is_staking := App.localGetEx(account=Txn.sender(), app=app.application_id(), key=key.get())),
            Assert(is_staking.hasValue()),
            Assert(
                And(
                    Global.latest_timestamp() >= self.start_time,
                    Global.latest_timestamp() <= self.end_time
                )
            ),
            Assert(is_staking.value() == Int(1)),
            Assert(self.has_vote == Int(0)),
            If(vote_choice.get() == Bytes("yes"))
            .Then(
                self.vote_choice.set(Bytes("yes")),
                self.num_of_yays.increment()
            )
            .ElseIf(vote_choice.get() == Bytes("no"))
            .Then(
                self.vote_choice.set(Bytes("no")),
                self.num_of_nays.increment()
            ),
            self.has_vote.set(Int(1))
        )

    @external(authorize=Authorize.only(Global.creator_address()))
    def get_vote_result(self, *, output: abi.String):
        return Seq(
            Assert(Global.latest_timestamp() > self.end_time),
            If(self.num_of_yays > self.num_of_nays)
            .Then(self.result.set(Bytes("passed")))
            .ElseIf(self.num_of_yays < self.num_of_nays)
            .Then(self.result.set(Bytes("rejected")))
            .Else(self.result.set(Bytes("undecided"))),
            output.set(self.result)
        )

    @bare_external(close_out=CallConfig.CALL, clear_state=CallConfig.CALL)
    def clear_vote(self):
        return Seq(
            Assert(self.has_vote == Int(1)),
            If(self.vote_choice == Bytes("yes"))
            .Then(
                Assert(self.num_of_yays > Int(0)),
                self.num_of_yays.decrement()
            )
            .ElseIf(self.vote_choice == Bytes("no")).
            Then(
                Assert(self.num_of_nays > Int(0)),
                self.num_of_nays.decrement()
            ),
            self.vote_choice.set(Bytes("")),
            self.has_vote.set(Int(0))
        )


Voting().dump()


# File: https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py
# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913
import json
import sys
import os
from pyteal import *
from .abi_types import *
from .inline import InlineAssembly
from assets.abi import ABI_PATH,system_delima



main_contract_abi = json.load(open(ABI_PATH + f"{system_delima}main-contract.json"))
voting_contract_abi = json.load(open(ABI_PATH + f"{system_delima}voting-contract.json"))
smart_assert_errors = json.load(open(ABI_PATH + f"{system_delima}..{system_delima}smart_assert_errors.json"))

# This is not used as it hard codes the costs of a box
# But is kept here as a record of how it is calculated
# The current method is by checking min balances before
# and after the box is created.
# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):
#     # (2500 per box) + (400 * (key size + box size))
#     if key_size_bytes > 64:
#         raise Exception("key size is over 64 bytes")
#     cost = (
#         Int(2500) + Int(400) * 
#         (
#             Int(key_size_bytes) +
#             Int(box_size_bytes)
#         )
#     )
#     return cost

def get_abi_method(method_name,contract:str):
    method_dict = {
        "main": main_contract_abi["methods"],
        "voting": voting_contract_abi["methods"]
    }
    method_list = method_dict[contract]
    for method in method_list:
        if method["name"] == method_name:
            return method
    return None

def get_method_signature(method_name, contract:str):
    method = get_abi_method(method_name,contract)
    if method is None:
        raise RuntimeError
    signature = method_name + "("
    num_args = len(method["args"])
    for index, arg in enumerate(method["args"]):
        signature += arg["type"] 
        if index < num_args - 1:
            signature += ","
        else:
            signature += f'){method["returns"]["type"]}'
            return signature

@ABIReturnSubroutine
def create_source_tuple(
    source_id: Expr, #Int
    source_arg_list: Expr, #Bytes
    max_age: Expr,
    *,
    output: SourceSpec
) -> Expr: #Int
    return Seq([
        (source_id_param := abi.Uint32()).set(source_id),
        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),
        (max_age_param := abi.Uint64()).set(max_age),
        output.set(
            source_id_param,
            source_arg_list_param,
            max_age_param
        ),
    ])

"""
KEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE 
THE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)

SourceSpec: SourceSpec that is already encoded
aggregation: pyteal.Int
user_data: pyteal.Bytes
method_signature: pyteal.Bytes
app_id: pyteal.Int
goracle_main_app_id: pyteal.Int
request_types: pyteal.Int
key: pyteal.Bytes
"""
@Subroutine(TealType.none)
def make_request(
    source_specs: abi.DynamicArray[SourceSpec],
    aggregation: Expr, #Int
    user_data: Expr, #Bytes
    app_id: Expr, #Int
    method_signature: Expr, #Bytes
    goracle_main_app_id: Expr,  #Int
    request_type: Expr,
    key: Expr,
    app_refs: Expr, #static array of uint64
    asset_refs: Expr, #static array of uint64
    account_refs: Expr, #static array of byte[32]
    box_refs: Expr # dynamic array of  (byte[],uint64)
): # Int

    request_tuple = abi.make(RequestSpec)
    destination_tuple = abi.make(DestinationSpec)

    return Seq([
        (user_data_param := abi.DynamicBytes()).set(user_data),
        (agg_param := abi.Uint32()).set(aggregation),
        (app_id_param := abi.Uint64()).set(app_id),
        (request_type_param := abi.Uint64()).set(request_type),
        (method_sig_param := abi.DynamicBytes()).set(method_signature),
        (key_abi := abi.DynamicBytes()).set(key),

        request_tuple.set(
            source_specs,
            agg_param,
            user_data_param
        ),

        destination_tuple.set(
            app_id_param,
            method_sig_param
        ),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("request","main"),
            args=[
                request_tuple.encode(),
                destination_tuple.encode(),
                request_type_param.encode(),
                key_abi.encode(),
                app_refs,
                asset_refs,
                account_refs,
                box_refs
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
KEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE 
THE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)

SourceSpec: SourceSpec that is already encoded
aggregation: pyteal.Int
user_data: pyteal.Bytes
method_signature: pyteal.Bytes
app_id: pyteal.Int
goracle_main_app_id: pyteal.Int
request_types: pyteal.Int
key: pyteal.Bytes
"""
@Subroutine(TealType.none)
def make_request_constructed(
    request_args_encoded: Expr,
    destination_encoded: Expr,
    request_type_encoded: Expr,
    goracle_main_app_id: Expr,
    key: Expr,
    app_refs: Expr,
    asset_refs: Expr,
    account_refs: Expr,
    box_refs: Expr
):
    return Seq([
        (key_abi := abi.DynamicBytes()).set(key),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("request","main"),
            args=[
                request_args_encoded,
                destination_encoded,
                request_type_encoded,
                key_abi.encode(),
                app_refs,
                asset_refs,
                account_refs,
                box_refs
            ]
        ),
        InnerTxnBuilder.Submit(),
    ])

@Subroutine(TealType.none)
def opt_in(goracle_main_app_id):
    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields({
            TxnField.type_enum: TxnType.ApplicationCall,
            TxnField.application_id: goracle_main_app_id,
            TxnField.on_completion: OnComplete.OptIn,
            # TxnField.fee: Int(0)
        }),
        InnerTxnBuilder.Submit(),
    ])

@Subroutine(TealType.none)
def opt_in_asset(asset_id):
    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields({
            TxnField.type_enum: TxnType.AssetTransfer,
            TxnField.xfer_asset: asset_id,
            TxnField.asset_receiver: Global.current_application_address(),
            TxnField.asset_amount: Int(0),
            # TxnField.fee: Int(0)
        }),
        InnerTxnBuilder.Submit()
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def deposit_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_deposit, account_to_deposit_to):
    asset_transfer = \
    {
        TxnField.type_enum: TxnType.AssetTransfer,
        TxnField.asset_amount: amount_to_deposit,
        TxnField.xfer_asset: gora_token_id,
        TxnField.asset_receiver: goracle_main_app_address,
        TxnField.fee: Int(0)
    }

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("deposit_token","main"),
            args=[
                asset_transfer,
                gora_token_id,
                account_to_deposit_to
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def deposit_algo(goracle_main_app_address, goracle_main_app_id, amount_to_deposit, account_to_deposit_to):
    algo_transfer = \
    {
        TxnField.type_enum: TxnType.Payment,
        TxnField.amount: amount_to_deposit,
        TxnField.receiver: goracle_main_app_address,
        TxnField.fee: Int(0)
    }

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("deposit_algo","main"),
            args=[
                algo_transfer,
                account_to_deposit_to
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
new_key: pyteal.Bytes
"""
@Subroutine(TealType.none)
def register_key(goracle_main_app_id, new_key):

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("register_participation_account","main"),
            args=[
                new_key,
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def withdraw_token(goracle_main_app_id, gora_token_id, amount_to_withdraw):
    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("withdraw_token","main"),
            args=[
                amount_to_withdraw,
                gora_token_id,
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

"""
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
amount_to_deposit: pyteal.Int
account_to_deposit_to: pyteal.Bytes
"""
@Subroutine(TealType.none)
def withdraw_algo(goracle_main_app_id, amount_to_withdraw):

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature("withdraw_algo","main"),
            args=[
                amount_to_withdraw
            ],
            extra_fields={
                TxnField.fee: Int(0)
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

'''
goracle_main_app_address: pyteal.Bytes
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_stake: pyteal.Int
'''
@Subroutine(TealType.none)
def stake_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_stake):
    asset_transfer = \
    {
        TxnField.type_enum: TxnType.AssetTransfer,
        TxnField.asset_amount: amount_to_stake,
        TxnField.xfer_asset: gora_token_id,
        TxnField.asset_receiver: goracle_main_app_address,
        TxnField.fee: Global.min_txn_fee()
    }

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature('stake', 'main'),
            args=[
                asset_transfer,
            ],
            extra_fields={
                TxnField.fee: Global.min_txn_fee(),
            }
        ),
        InnerTxnBuilder.Submit(),
    ])

'''
goracle_main_app_id: pyteal.Int
gora_token_id: pyteal.Int
amount_to_stake: pyteal.Int
'''
@Subroutine(TealType.none)
def unstake_token(goracle_main_app_id, gora_token_id, amount_to_unstake):

    return Seq([
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.MethodCall(
            app_id=goracle_main_app_id,
            method_signature=get_method_signature('unstake', 'main'),
            args=[
                amount_to_unstake,
                gora_token_id
            ],
            extra_fields={
                TxnField.fee : Int(2)*Global.min_txn_fee(),
            }
        ),
        InnerTxnBuilder.Submit(),
    ])


"""
Assert with a number to indentify it in API error message. The message will be:
"shr arg too big, (%d)" where in "%d" 6 lowest decinals are the line number and
any above that are the error code. Error types are defined "error_codes.json"
"""
def SmartAssert(cond, err_type = 0):
    if type(err_type) == str:
        err_type = smart_assert_errors.index(err_type) # map mnemonic to code
    err_line = sys._getframe().f_back.f_lineno # calling line number
    return If(Not(cond)).Then(
        InlineAssembly("int 0\nint {}\nshr\n".format(err_type * 1000000 + err_line))
    )

# File: https://github.com/gconnect/voting-dapp-pyteal-react/blob/829a74626f934ebb9778b431ce9d7662e6897f85/venv/bin/pip
#!/Users/glory/projects/pyteal-voting-system/voting-dapp/venv/bin/python3
# -*- coding: utf-8 -*-
import re
import sys
from pip._internal.cli.main import main
if __name__ == '__main__':
    sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
    sys.exit(main())


# File: https://github.com/algorandfoundation/ExtendableDAO/blob/0e8c974683130d681e2cd88c671fede52154e031/contracts.py
#!/usr/bin/env python3

from configparser import NoOptionError
import json

from pyteal import * 

router = Router("ExtendableDAO")


@router.method(no_op=CallConfig.CREATE)
def deploy(name: abi.String, *, output: abi.Bool) -> Expr:
    return Seq(
        App.globalPut(Bytes("uninitialised"), Int(1)),
        output.set(True),
    )


@router.method(no_op=CallConfig.CALL)
def initialise(token: abi.Asset, *, output: abi.Bool) -> Expr:
    return Seq(
        Assert(App.globalGet(Bytes("uninitialised"))),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.asset_receiver: Global.current_application_address(),
                TxnField.xfer_asset: token.asset_id(),
            }
        ),
        InnerTxnBuilder.Submit(),
        App.globalPut(Bytes("asset_id"), token.asset_id()),
        App.globalDel(Bytes("uninitialised")),
        output.set(True),
    )


@router.method(no_op=CallConfig.CALL)
def activate(app: abi.Application, *, output: abi.Uint64) -> Expr:
    proposal_for = Concat(
        Bytes("proposal_"),
        Itob(app.application_id()),
        Bytes("_for"),
    )
    proposal_against = Concat(
        Bytes("proposal_"),
        Itob(app.application_id()),
        Bytes("_against"),
    )
    return Seq(
        votes_for := App.globalGetEx(Global.current_application_id(), proposal_for),
        votes_against := App.globalGetEx(Global.current_application_id(), proposal_against),
        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),
        Assert(Not(voting_allowed.hasValue())),
        Assert(votes_for.hasValue()),
        Assert(votes_against.hasValue()),
        Assert(votes_for.value() > votes_against.value()),
        app_approval := AppParam.approvalProgram(app.application_id()),
        Assert(app_approval.hasValue()),
        app_clearstate := AppParam.clearStateProgram(app.application_id()),
        Assert(app_clearstate.hasValue()),
        app_global_byteslices := AppParam.globalNumByteSlice(app.application_id()),
        app_global_ints := AppParam.globalNumUint(app.application_id()),
        app_local_byteslices := AppParam.localNumByteSlice(app.application_id()),
        app_local_ints := AppParam.localNumUint(app.application_id()),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.ApplicationCall,
                TxnField.application_args: [MethodSignature("deploy()bool")],
                TxnField.approval_program: app_approval.value(),
                TxnField.clear_state_program: app_clearstate.value(),
                TxnField.global_num_byte_slices: app_global_byteslices.value(),
                TxnField.global_num_uints: app_global_ints.value(),
                TxnField.local_num_byte_slices: app_local_byteslices.value(),
                TxnField.local_num_uints: app_local_ints.value(),
                TxnField.fee: Int(0),
            }
        ),
        InnerTxnBuilder.Submit(),
        App.globalDel(proposal_for),
        App.globalDel(proposal_against),
        output.set(InnerTxn.created_application_id()),
    )


@router.method(delete_application=CallConfig.CALL)
def deactivate(*, output: abi.Bool) -> Expr:
    return output.set(True)


@router.method(no_op=CallConfig.CALL,opt_in=CallConfig.CALL)
def vote(
    app: abi.Application, votes: abi.AssetTransferTransaction, for_or_against: abi.Bool, *, output: abi.Bool
) -> Expr:
    prop_for_bytes = Concat(
        Bytes("proposal_"),
        Itob(app.application_id()),
        Bytes("_for"),
    )
    prop_against_bytes = Concat(
        Bytes("proposal_"),
        Itob(app.application_id()),
        Bytes("_against"),
    )
    asset_id = App.globalGet(Bytes("asset_id"))
    return Seq(
        (proposal_for := ScratchVar()).store(prop_for_bytes),
        (proposal_against := ScratchVar()).store(prop_against_bytes),
        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),
        Assert(voting_allowed.hasValue()),
        Assert(votes.get().asset_receiver() == Global.current_application_address()),
        Assert(votes.get().xfer_asset() == asset_id),
        If(for_or_against.get(), Seq(
            App.localPut(Int(0), proposal_for.load(), App.localGet(Int(0), proposal_for.load()) + votes.get().asset_amount()),
            App.globalPut(proposal_for.load(), App.globalGet(proposal_for.load()) + votes.get().asset_amount()),
        ), Seq(
            App.localPut(Int(0), proposal_against.load(), App.localGet(Int(0), proposal_against.load()) + votes.get().asset_amount()),
            App.globalPut(proposal_against.load(), App.globalGet(proposal_against.load()) + votes.get().asset_amount()),
        )),
        output.set(True),
    )


@router.method(no_op=CallConfig.CALL)
def reclaim(app: abi.Application, asset: abi.Asset, *, output: abi.Uint64) -> Expr:
    prop_for_bytes = Concat(
        Bytes("proposal_"),
        Itob(app.application_id()),
        Bytes("_for"),
    )
    prop_against_bytes = Concat(
        Bytes("proposal_"),
        Itob(app.application_id()),
        Bytes("_against"),
    )
    asset_id = App.globalGet(Bytes("asset_id"))
    return Seq(
        Assert(asset_id == asset.asset_id()),
        (total := ScratchVar(TealType.uint64)).store(
            App.localGet(Int(0), prop_for_bytes) + App.localGet(Int(0), prop_against_bytes)
        ),
        Assert(total.load()),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.AssetTransfer,
                TxnField.asset_receiver: Txn.sender(),
                TxnField.xfer_asset: asset_id,
                TxnField.asset_amount: total.load(),
            }
        ),
        InnerTxnBuilder.Submit(),
        votes_for := App.globalGetEx(Global.current_application_id(), prop_for_bytes),
        votes_against := App.globalGetEx(Global.current_application_id(), prop_against_bytes),
        # Reduce global for
        If(votes_for.hasValue()).Then(
            App.globalPut(prop_for_bytes, App.globalGet(prop_for_bytes) - App.localGet(Int(0), prop_for_bytes)),
        ),
        # Reduce global against
        If(votes_against.hasValue()).Then(
            App.globalPut(prop_against_bytes, App.globalGet(prop_against_bytes) - App.localGet(Int(0), prop_against_bytes)),
        ),
        # Delete local amounts
        App.localDel(Int(0), prop_for_bytes),
        App.localDel(Int(0), prop_against_bytes),
        output.set(total.load()),
    )


@router.method(no_op=CallConfig.CALL)
def propose(appl: abi.ApplicationCallTransaction, *, output: abi.Uint64) -> Expr:
    proposal_for = Concat(
        Bytes("proposal_"),
        Itob(appl.get().created_application_id()),
        Bytes("_for"),
    )
    proposal_against = Concat(
        Bytes("proposal_"),
        Itob(appl.get().created_application_id()),
        Bytes("_against"),
    )
    return Seq(
        Assert(appl.get().type_enum() == TxnType.ApplicationCall),
        Assert(Not(appl.get().application_id())),
        Assert(appl.get().on_completion() == OnComplete.NoOp),
        (new_app_pages := AppParam.extraProgramPages(appl.get().created_application_id())),
        Assert(Not(new_app_pages.value())),
        Comment("TODO: Some sort of validation on proposed app"),
        (new_app_approval := AppParam.approvalProgram(appl.get().created_application_id())),
        Assert(Extract(new_app_approval.value(), Int(1), Int(4)) == Bytes("base16", "0x20020100")),
        Comment("TODO: Some sort of validation on proposed app"),
        (new_app_clearstate := AppParam.clearStateProgram(appl.get().created_application_id())),
        Assert(new_app_clearstate.hasValue()),
        App.globalPut(proposal_for, Int(0)),
        App.globalPut(proposal_against, Int(0)),
        App.globalPut(Itob(GeneratedID(appl.index())), Global.round()),
        output.set(appl.get().created_application_id()),
    )


@router.method(no_op=CallConfig.CALL)
def end_voting(app: abi.Application, *, output: abi.Bool) -> Expr:
    return Seq(
        (app_params := AppParam.creator(app.application_id())),
        Assert(Txn.sender() == app_params.value()),
        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),
        Assert(voting_allowed.hasValue()),
        Assert(Global.round() > voting_allowed.value()),
        App.globalDel(Itob(app.application_id())),
        output.set(True),
    )


@router.method(no_op=CallConfig.CALL)
def invoke(app: abi.Application, *, output: abi.Bool) -> Expr:
    i = ScratchVar(TealType.uint64)
    return Seq(
        (app_creator := AppParam.creator(app.application_id())),
        (app_addr := AppParam.address(app.application_id())),
        Assert(app_creator.value() == Global.current_application_address()),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.ApplicationCall,
                TxnField.application_id: app.application_id(),
                TxnField.application_args: [ MethodSignature("invoke()bool") ],
                TxnField.rekey_to: app_addr.value(),
            }
        ),
        Comment("Add all assets"),
        For(i.store(Int(0)), i.load() < Txn.assets.length(), i.store(i.load() + Int(1))).Do(
            InnerTxnBuilder.SetField(TxnField.assets, [Txn.assets[i.load()]]),
        ),
        Comment("Add all apps"),
        For(i.store(Int(2)), i.load() <= Txn.applications.length(), i.store(i.load() + Int(1))).Do(
            InnerTxnBuilder.SetField(TxnField.applications, [Txn.applications[i.load()]]),
        ),
        Comment("Add all accounts"),
        For(i.store(Int(1)), i.load() < Txn.accounts.length(), i.store(i.load() + Int(1))).Do(
            InnerTxnBuilder.SetField(TxnField.accounts, [Txn.accounts[i.load()]]),
        ),
        Comment("Add all args"),
        For(i.store(Int(2)), i.load() < Txn.application_args.length(), i.store(i.load() + Int(1))).Do(
            InnerTxnBuilder.SetField(TxnField.application_args, [Txn.application_args[i.load()]]),
        ),
        InnerTxnBuilder.Submit(),
        Comment("Check we've been rekeyed back to our own account"),
        (acct_auth := AccountParam.authAddr(Global.current_application_address())),
        Assert(acct_auth.value() == Global.zero_address()),
        output.set(True),
    )


@router.method(clear_state=CallConfig.CALL)
def clear_state() -> Expr:
    return Approve()


approval, clearstate, abi = router.compile_program(
    version=7,
    optimize=OptimizeOptions(scratch_slots=True),
)

if __name__ == "__main__":
    with open("dao_approval.teal", "w") as f:
        f.write(approval)
    
    with open("dao_clearstate.teal", "w") as f:
        f.write(clearstate)

    with open("dao_abi.json", "w") as f:
        f.write(json.dumps(abi.dictify()))



# File: https://github.com/0EFB6/blockchain-voting-system/blob/5d3bab077ab260c2e99bb3561a48d7c2b234712d/voting_area_initialisation/voting_area_initialisation.py
from pyteal import *

# init_dun = State seats inforamtion (DUN, DUN number, state)
# init_dun_candidate = State seats candidate information
# 						(candidate name, party)

k_dun = Bytes("dun")
k_dun_no = Bytes("dun_no")
k_parliament = Bytes("parliament")
k_parliament_no = Bytes("parliament_no")
k_state = Bytes("state")
k_c_name = Bytes("c_name")
k_party = Bytes("party")

router = Router(
	"voting_area_initialisation",
	BareCallActions(
		no_op=OnCompleteAction.create_only(Approve()),
		opt_in=OnCompleteAction.call_only(Approve())
	)
)

@router.method
def init_dun(dun: abi.String, n: abi.Uint8, state: abi.String):
	is_valid_dun = And(
		Len(dun.get()) >= Int(0),
		Len(dun.get()) <= Int(20)
	)
	is_valid_dun_no = And(
		n.get() > Int(0),
		n.get() < Int(83)
	)
	is_valid_state = And(
		Len(state.get()) >= Int(0),
		Len(state.get()) <= Int(15)
	)
	check = And(
		is_valid_dun,
		is_valid_dun_no,
		is_valid_state
	)
	ret = If(
		check,
		Seq(
			App.localPut(Txn.sender(), k_dun, dun.get()),
			App.localPut(Txn.sender(), k_dun_no, n.get()),
			App.localPut(Txn.sender(), k_state, state.get())
		)
	)
	return ret

@router.method
def init_parliament(parliamen: abi.String, n: abi.Uint8, state: abi.String):
	is_valid_parliamen = And(
		Len(parliamen.get()) >= Int(0),
		Len(parliamen.get()) <= Int(20)
	)
	is_valid_parliamen_no = And(
		n.get() > Int(0),
		n.get() < Int(223)
	)
	is_valid_state = And(
		Len(state.get()) >= Int(0),
		Len(state.get()) <= Int(15)
	)
	check = And(
		is_valid_parliamen,
		is_valid_parliamen_no,
		is_valid_state
	)
	ret = If(
		check,
		Seq(
			App.localPut(Txn.sender(), k_parliament, parliamen.get()),
			App.localPut(Txn.sender(), k_parliament_no, n.get()),
			App.localPut(Txn.sender(), k_state, state.get())
		)
	)
	return ret

@router.method
def init_candidate(name: abi.String, party: abi.String):
	is_valid_name = And(
		Len(name.get()) >= Int(0),
		Len(name.get()) <= Int(40)
	)
	is_valid_party = And(
		Len(party.get()) >= Int(0),
		Len(party.get()) <= Int(20)
	)
	check = And(
		is_valid_name,
		is_valid_party
	)
	ret = If(
		check,
		Seq(
			App.localPut(Txn.sender(), k_c_name, name.get()),
			App.localPut(Txn.sender(), k_party, party.get())
		)
	)
	return ret

@router.method
def read_dun(*, output: abi.String):
	ret = App.localGet(Txn.sender(), k_dun)
	return output.set(ret)

@router.method
def read_dun_no(*, output: abi.Uint8):
	ret = App.localGet(Txn.sender(), k_dun_no)
	return output.set(ret)

@router.method
def read_parliament(*, output: abi.String):
	ret = App.localGet(Txn.sender(), k_parliament)
	return output.set(ret)

@router.method
def read_parliament_no(*, output: abi.Uint8):
	ret = App.localGet(Txn.sender(), k_parliament_no)
	return output.set(ret)

@router.method
def read_state(*, output: abi.String):
	ret = App.localGet(Txn.sender(), k_state)
	return output.set(ret)

@router.method
def read_c_name(*, output: abi.String):
	ret = App.localGet(Txn.sender(), k_c_name)
	return output.set(ret)

@router.method
def read_party(*, output: abi.String):
	ret = App.localGet(Txn.sender(), k_party)
	return output.set(ret)

if __name__ == "__main__":
	import os
	import json

	path = os.path.dirname(os.path.abspath(__file__))
	approval, clear, contract = router.compile_program(version=8)

	# Write out the approval & clear program
	with open(os.path.join(path, "artifacts/approval.teal"), "w") as f:
		f.write(approval)

	with open(os.path.join(path, "artifacts/clear.teal"), "w") as f:
		f.write(clear)

	# Dump out the contract as JSON to be used by any SDKs
	with open(os.path.join(path, "artifacts/contract.json"), "w") as f:
		f.write(json.dumps(contract.dictify(), indent=2))
