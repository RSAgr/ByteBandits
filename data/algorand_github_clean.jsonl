{"file_path": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/asa/assets/pyteal/5-clear.py", "code": "from pyteal import *\n\ndef clear_state_program():\n    return Return(Int(1))\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(clear_state_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"file_path": "https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/kcoin_vault_pyteal.py", "code": "from typing import Tuple\n\nfrom algosdk.abi import Contract\nfrom pyteal import (\n    App,\n    Approve,\n    Assert,\n    BareCallActions,\n    Bytes,\n    Div,\n    Expr,\n    Global,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Mul,\n    OnCompleteAction,\n    Router,\n    Seq,\n    Subroutine,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n)\nfrom pyteal.compiler.optimizer import optimizer\n\nASSET_TOTAL = 1000000000\nASSET_DECIMALS = 3\nINITIAL_EXCHANGE_RATE = 2000\nSCALING_FACTOR = 1000\n\n# The PyTeal router\nrouter = Router(\n    name=\"K-Coin-Vault\",\n    bare_calls=BareCallActions(\n        no_op=OnCompleteAction.create_only(Approve()),\n        update_application=OnCompleteAction.never(),\n        delete_application=OnCompleteAction.never(),\n        clear_state=OnCompleteAction.never(),\n    ),\n)\n\n\n@router.method\ndef init_asset(*, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Create the K Coin asset\n\n    Can only be executed by the contract's creator\n\n    Returns: created asset id\n\n    \"\"\"\n    return Seq(\n        Assert(Txn.sender() == Global.creator_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(ASSET_TOTAL),\n                TxnField.config_asset_decimals: Int(ASSET_DECIMALS),\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n                TxnField.config_asset_name: Bytes(\"K Coin\"),\n                TxnField.config_asset_unit_name: Bytes(\"microK\"),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(Bytes(\"asset_id\"), InnerTxn.created_asset_id()),\n        App.globalPut(Bytes(\"exchange_rate\"), Int(INITIAL_EXCHANGE_RATE)),\n        output.set(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.uint64)\ndef algos_to_kcoin(algo_amount: Expr) -> Expr:\n    \"\"\"\n    Convert microalgos to microKs:\n\n    microKs = microAlgos * EXCHANGE_RATE / SCALING_FACTOR\n    \"\"\"\n    return Div(Mul(algo_amount, App.globalGet(Bytes(\"exchange_rate\"))), Int(SCALING_FACTOR))\n\n\n@Subroutine(TealType.uint64)\ndef kcoin_to_algos(asset_amount: Expr) -> Expr:\n    \"\"\"\n    Convert microKs to microalgos\n\n    microAlgos = microKs * SCALING_FACTOR / EXCHANGE_RATE\n    \"\"\"\n    return Mul(Div(asset_amount, App.globalGet(Bytes(\"exchange_rate\"))), Int(SCALING_FACTOR))\n\n\n@router.precondition(expr='payment.get().amount() >= Int(10000)')\n@router.precondition(expr='payment.get().amount() <= Int(20000)')\n@router.postcondition(\n    expr=f'output.get() == payment.get().amount() * Int({INITIAL_EXCHANGE_RATE}) / Int({SCALING_FACTOR})'\n)\n@router.hoare_method\n@router.method\ndef mint(payment: abi.PaymentTransaction, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Mint K Coins, issuing an inner asset transfer transaction to sender if successful\n\n    Args:\n        payment: A payment transaction containing the amount of Algos the user wishes to mint with.\n            The receiver of this transaction must be this app's escrow account.\n\n    Returns: minted amount of K Coins that the user gets\n    \"\"\"\n    amount_to_mint = algos_to_kcoin(payment.get().amount())\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        Assert(payment.get().receiver() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset_id,\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: amount_to_mint,\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        output.set(amount_to_mint),\n    )\n\n\n@router.precondition(expr='asset_transfer.get().amount() >= Int(10000)')\n@router.precondition(expr='asset_transfer.get().amount() <= Int(20000)')\n@router.postcondition(\n    expr=f'output.get() == asset_transfer.get().amount() * Int({SCALING_FACTOR}) / Int({INITIAL_EXCHANGE_RATE})'\n)\n@router.hoare_method\n@router.method\ndef burn(asset_transfer: abi.AssetTransferTransaction, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Burn K Coins, issuing an inner payment transaction to sender if successful\n\n    Args:\n        asset_transfer: An asset transfer transaction containing the amount of K Coins (in microKs) the user wishes to burn.\n            The receiver of this transaction must be this app's escrow account.\n\n    Returns: amount of microalgos the users gets\n    \"\"\"\n    microalgos_output = kcoin_to_algos(asset_transfer.get().asset_amount())\n    return Seq(\n        Assert(asset_transfer.get().asset_receiver() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.Payment,\n                TxnField.receiver: Txn.sender(),\n                TxnField.amount: microalgos_output,\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        output.set(microalgos_output),\n    )\n\n\ndef compile_to_teal() -> Tuple[str, str, Contract]:\n    \"\"\"Compile approval and clear programs, and generate the contract description object\"\"\"\n    approval, clear, contract = router.compile_program(\n        version=6, optimize=optimizer.OptimizeOptions(scratch_slots=True)\n    )\n    return approval, clear, contract"}
{"file_path": "https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py", "code": "# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913\nimport json\nimport sys\nimport os\nfrom pyteal import *\nfrom .abi_types import *\nfrom .inline import InlineAssembly\nfrom assets.abi import ABI_PATH,system_delima\n\n\n\nmain_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}main-contract.json\"))\nvoting_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}voting-contract.json\"))\nsmart_assert_errors = json.load(open(ABI_PATH + f\"{system_delima}..{system_delima}smart_assert_errors.json\"))\n\n# This is not used as it hard codes the costs of a box\n# But is kept here as a record of how it is calculated\n# The current method is by checking min balances before\n# and after the box is created.\n# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):\n#     # (2500 per box) + (400 * (key size + box size))\n#     if key_size_bytes > 64:\n#         raise Exception(\"key size is over 64 bytes\")\n#     cost = (\n#         Int(2500) + Int(400) * \n#         (\n#             Int(key_size_bytes) +\n#             Int(box_size_bytes)\n#         )\n#     )\n#     return cost\n\ndef get_abi_method(method_name,contract:str):\n    method_dict = {\n        \"main\": main_contract_abi[\"methods\"],\n        \"voting\": voting_contract_abi[\"methods\"]\n    }\n    method_list = method_dict[contract]\n    for method in method_list:\n        if method[\"name\"] == method_name:\n            return method\n    return None\n\ndef get_method_signature(method_name, contract:str):\n    method = get_abi_method(method_name,contract)\n    if method is None:\n        raise RuntimeError\n    signature = method_name + \"(\"\n    num_args = len(method[\"args\"])\n    for index, arg in enumerate(method[\"args\"]):\n        signature += arg[\"type\"] \n        if index < num_args - 1:\n            signature += \",\"\n        else:\n            signature += f'){method[\"returns\"][\"type\"]}'\n            return signature\n\n@ABIReturnSubroutine\ndef create_source_tuple(\n    source_id: Expr, #Int\n    source_arg_list: Expr, #Bytes\n    max_age: Expr,\n    *,\n    output: SourceSpec\n) -> Expr: #Int\n    return Seq([\n        (source_id_param := abi.Uint32()).set(source_id),\n        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),\n        (max_age_param := abi.Uint64()).set(max_age),\n        output.set(\n            source_id_param,\n            source_arg_list_param,\n            max_age_param\n        ),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request(\n    source_specs: abi.DynamicArray[SourceSpec],\n    aggregation: Expr, #Int\n    user_data: Expr, #Bytes\n    app_id: Expr, #Int\n    method_signature: Expr, #Bytes\n    goracle_main_app_id: Expr,  #Int\n    request_type: Expr,\n    key: Expr,\n    app_refs: Expr, #static array of uint64\n    asset_refs: Expr, #static array of uint64\n    account_refs: Expr, #static array of byte[32]\n    box_refs: Expr # dynamic array of  (byte[],uint64)\n): # Int\n\n    request_tuple = abi.make(RequestSpec)\n    destination_tuple = abi.make(DestinationSpec)\n\n    return Seq([\n        (user_data_param := abi.DynamicBytes()).set(user_data),\n        (agg_param := abi.Uint32()).set(aggregation),\n        (app_id_param := abi.Uint64()).set(app_id),\n        (request_type_param := abi.Uint64()).set(request_type),\n        (method_sig_param := abi.DynamicBytes()).set(method_signature),\n        (key_abi := abi.DynamicBytes()).set(key),\n\n        request_tuple.set(\n            source_specs,\n            agg_param,\n            user_data_param\n        ),\n\n        destination_tuple.set(\n            app_id_param,\n            method_sig_param\n        ),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_tuple.encode(),\n                destination_tuple.encode(),\n                request_type_param.encode(),\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request_constructed(\n    request_args_encoded: Expr,\n    destination_encoded: Expr,\n    request_type_encoded: Expr,\n    goracle_main_app_id: Expr,\n    key: Expr,\n    app_refs: Expr,\n    asset_refs: Expr,\n    account_refs: Expr,\n    box_refs: Expr\n):\n    return Seq([\n        (key_abi := abi.DynamicBytes()).set(key),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_args_encoded,\n                destination_encoded,\n                request_type_encoded,\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ]\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in(goracle_main_app_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.ApplicationCall,\n            TxnField.application_id: goracle_main_app_id,\n            TxnField.on_completion: OnComplete.OptIn,\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in_asset(asset_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: asset_id,\n            TxnField.asset_receiver: Global.current_application_address(),\n            TxnField.asset_amount: Int(0),\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit()\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_deposit, account_to_deposit_to):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_deposit,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_token\",\"main\"),\n            args=[\n                asset_transfer,\n                gora_token_id,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_algo(goracle_main_app_address, goracle_main_app_id, amount_to_deposit, account_to_deposit_to):\n    algo_transfer = \\\n    {\n        TxnField.type_enum: TxnType.Payment,\n        TxnField.amount: amount_to_deposit,\n        TxnField.receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_algo\",\"main\"),\n            args=[\n                algo_transfer,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\nnew_key: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef register_key(goracle_main_app_id, new_key):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"register_participation_account\",\"main\"),\n            args=[\n                new_key,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_token(goracle_main_app_id, gora_token_id, amount_to_withdraw):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_token\",\"main\"),\n            args=[\n                amount_to_withdraw,\n                gora_token_id,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_algo(goracle_main_app_id, amount_to_withdraw):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_algo\",\"main\"),\n            args=[\n                amount_to_withdraw\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef stake_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_stake):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_stake,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Global.min_txn_fee()\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('stake', 'main'),\n            args=[\n                asset_transfer,\n            ],\n            extra_fields={\n                TxnField.fee: Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef unstake_token(goracle_main_app_id, gora_token_id, amount_to_unstake):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('unstake', 'main'),\n            args=[\n                amount_to_unstake,\n                gora_token_id\n            ],\n            extra_fields={\n                TxnField.fee : Int(2)*Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\n\"\"\"\nAssert with a number to indentify it in API error message. The message will be:\n\"shr arg too big, (%d)\" where in \"%d\" 6 lowest decinals are the line number and\nany above that are the error code. Error types are defined \"error_codes.json\"\n\"\"\"\ndef SmartAssert(cond, err_type = 0):\n    if type(err_type) == str:\n        err_type = smart_assert_errors.index(err_type) # map mnemonic to code\n    err_line = sys._getframe().f_back.f_lineno # calling line number\n    return If(Not(cond)).Then(\n        InlineAssembly(\"int 0\\nint {}\\nshr\\n\".format(err_type * 1000000 + err_line))\n    )"}
{"file_path": "https://github.com/runvnc/genpyteal/blob/f4db17ad54c0746f25d28d2ebf5ee2ebe21be961/tstclass5.pyteal.py", "code": "from pyteal import *\n\nglobals().update(TealType.__members__)\n\ndef verbatim(x):\n  return x\n\nclass Senior:\n  \n  @verbatim\n  def __init__(self, name, age):\n    self.age = age\n    self.name = name\n  \n  \n  def isEligible(self):\n    return ( self.age > Int(65) )\n  \n  \n  def evalAndPrint(self):\n    a = ScratchVar(TealType.uint64)\n    return  Seq(\n    \ta.store(Int(10)),\n    \tIf( self.isEligible(), \n          Log(Concat(self.name,Concat(Bytes(\" is eligible. \"),Itob(a.load()))))\n        , \n          Log(Concat(self.name,Bytes(\" is too young.\")))\n       ) )\n  \n  \n  \ndef app():\n    mary = Senior(Bytes('Mary'), Int(62))\n    tom = Senior(Bytes('Tom'), Int(75))\n    return  Seq(\n    \tmary.evalAndPrint(),\n    \ttom.evalAndPrint(),\n    \tReturn( Int(1) ) )\n\n\nif __name__ == \"__main__\":\n    print(compileTeal(app(), mode=Mode.Application, version=7))"}
{"file_path": "https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/lib/iter.py", "code": "from pyteal import Expr, For, Int, ScratchVar\n\n__all__ = [\n    \"Iterate\",\n]\n\n\ndef Iterate(sub: Expr, n: Int, i: ScratchVar | None = None) -> Expr:\n    \"\"\"Iterate provides a convenience method for calling a method n times\n\n    Args:\n        sub: A PyTEAL Expr to call, should not return anything\n        n: The number of times to call the expression\n        i: (Optional) A ScratchVar to use for iteration, passed if the caller wants to access the iterator\n\n    Returns:\n        A Subroutine expression to be passed directly into an Expr tree\n    \"\"\"\n\n    i = i or ScratchVar()\n    init = i.store(Int(0))\n    cond = i.load() < n\n    step = i.store(i.load() + Int(1))\n    return For(init, cond, step).Do(sub)"}
{"file_path": "https://github.com/algorand/pyteal-utils/blob/c4976887ddd959d285894cf7d3e0feddef3821ba/pytealutils/strings/string.py", "code": "from pyteal import (\n    Assert,\n    BitLen,\n    Btoi,\n    Bytes,\n    BytesDiv,\n    BytesGt,\n    BytesMod,\n    Concat,\n    Extract,\n    GetByte,\n    If,\n    Int,\n    Itob,\n    Len,\n    ScratchVar,\n    Seq,\n    Subroutine,\n    Substring,\n    TealType,\n)\n\nfrom pytealutils.math import pow10\n\n# Magic number to convert between ascii chars and integers\n_ascii_zero = 48\n_ascii_nine = _ascii_zero + 9\nascii_zero = Int(_ascii_zero)\nascii_nine = Int(_ascii_nine)\n\n\n@Subroutine(TealType.uint64)\ndef ascii_to_int(arg):\n    \"\"\"ascii_to_int converts the integer representing a character in ascii to the actual integer it represents\n\n    Args:\n        arg: uint64 in the range 48-57 that is to be converted to an integer\n\n    Returns:\n        uint64 that is the value the ascii character passed in represents\n\n    \"\"\"\n    return Seq(Assert(arg >= ascii_zero), Assert(arg <= ascii_nine), arg - ascii_zero)\n\n\n@Subroutine(TealType.bytes)\ndef int_to_ascii(arg):\n    \"\"\"int_to_ascii converts an integer to the ascii byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), arg, Int(1))\n\n\n@Subroutine(TealType.uint64)\ndef atoi(a):\n    \"\"\"atoi converts a byte string representing a number to the integer value it represents\"\"\"\n    return If(\n        Len(a) > Int(0),\n        (ascii_to_int(GetByte(a, Int(0))) * pow10(Len(a) - Int(1)))\n        + atoi(Substring(a, Int(1), Len(a))),\n        Int(0),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i):\n    \"\"\"itoa converts an integer to the ascii byte string it represents\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            int_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef witoa(i):\n    \"\"\"witoa converts an byte string interpreted as an integer to the ascii byte string it represents\"\"\"\n    return If(\n        BitLen(i) == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(\n                BytesGt(BytesDiv(i, Bytes(\"base16\", \"A0\")), Bytes(\"base16\", \"A0\")),\n                witoa(BytesDiv(i, Bytes(\"base16\", \"A0\"))),\n                Bytes(\"\"),\n            ),\n            int_to_ascii(Btoi(BytesMod(i, Bytes(\"base16\", \"A0\")))),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef head(s):\n    \"\"\"head gets the first byte from a bytestring, returns as bytes\"\"\"\n    return Extract(s, Int(0), Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef tail(s):\n    \"\"\"tail returns the string with the first character removed\"\"\"\n    return Substring(s, Int(1), Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef suffix(s, n):\n    \"\"\"suffix returns the last n bytes of a given byte string\"\"\"\n    return Substring(s, Len(s) - n, Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef prefix(s, n):\n    \"\"\"prefix returns the first n bytes of a given byte string\"\"\"\n    return Substring(s, Int(0), n)\n\n\n@Subroutine(TealType.bytes)\ndef rest(s, n):\n    \"\"\"prefix returns the first n bytes of a given byte string\"\"\"\n    return Substring(s, n, Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef encode_uvarint(val, b):\n    \"\"\"\n    Returns the uvarint encoding of an integer\n\n    Useful in the case that the bytecode for a contract is being populated, since\n    integers in a contract are uvarint encoded\n\n    This subroutine is recursive, the first call should include\n    the integer to be encoded and an empty bytestring\n\n    \"\"\"\n    buff = ScratchVar()\n    return Seq(\n        buff.store(b),\n        Concat(\n            buff.load(),\n            If(\n                val >= Int(128),\n                encode_uvarint(\n                    val >> Int(7),\n                    Extract(Itob((val & Int(255)) | Int(128)), Int(7), Int(1)),\n                ),\n                Extract(Itob(val & Int(255)), Int(7), Int(1)),\n            ),\n        ),\n    )"}
{"file_path": "https://github.com/ulamlabs/pytealext/blob/203a5f70e204b8fb8d684bf158c9e2cb734f7d41/pytealext/state.py", "code": "from pyteal import App, Bytes, Concat, Expr, Int, Itob, MaybeValue, Seq, TealType\nfrom pyteal.types import require_type\n\n\nclass State:\n    \"\"\"\n    Wrapper around state vars.\n    \"\"\"\n\n    def __init__(self, name: str | Expr, type_hint: TealType = TealType.anytype):\n        \"\"\"\n        Args:\n            name: a key in the global state, if it's a string it will be converted to Bytes\n            type_hint: a type which is expected to be stored, will be checked with each put()\n        \"\"\"\n        self._name: Expr\n        self.type_hint = type_hint\n        if isinstance(name, str):\n            self._name = Bytes(name)\n        else:\n            self._name = name\n\n    def put(self, value: Expr) -> App:\n        \"\"\"\n        Store a value in state schema\n        \"\"\"\n        raise NotImplementedError\n\n    def get(self) -> App:\n        \"\"\"\n        Get a value from a state schema\n        \"\"\"\n        raise NotImplementedError\n\n    def exists(self) -> Expr:\n        \"\"\"\n        Check if the key of this state variable is present in current app's schema.\n        \"\"\"\n        raise NotImplementedError\n\n    def add_assign(self, value_to_add: Expr) -> App:\n        \"\"\"\n        Replace the stored value with stored_value + value_to_add.\n        Equivalent to:\n            stored_value += value_to_add\n        \"\"\"\n        if not isinstance(value_to_add, Expr):\n            raise ValueError(\"value_to_add must be an instance of Expr or Expr subclass\")\n        return self.put(self.get() + value_to_add)\n\n    def sub_assign(self, value_to_subtract: Expr) -> App:\n        \"\"\"\n        Replace the stored value with stored_value - value_to_subtract.\n        Equivalent to:\n            stored_value -= value_to_subtract\n        \"\"\"\n        if not isinstance(value_to_subtract, Expr):\n            raise ValueError(\"value_to_subtract must be an instance of Expr or Expr subclass\")\n        return self.put(self.get() - value_to_subtract)\n\n\nclass LocalState(State):\n    \"\"\"\n    Wrapper for accessing local state\n    \"\"\"\n\n    def put(self, value: Expr) -> App:\n        require_type(value, self.type_hint)\n        return App.localPut(Int(0), self._name, value)\n\n    def get(self) -> App:\n        return App.localGet(Int(0), self._name)\n\n    def exists(self) -> Expr:\n        ex = App.localGetEx(Int(0), Int(0), self._name)\n        return Seq(ex, ex.hasValue())\n\n\nclass GlobalState(State):\n    \"\"\"\n    Wrapper for accessing global state\n    \"\"\"\n\n    def put(self, value: Expr) -> App:\n        require_type(value, self.type_hint)\n        return App.globalPut(self._name, value)\n\n    def get(self) -> App:\n        return App.globalGet(self._name)\n\n    def exists(self) -> Expr:\n        ex = App.globalGetEx(Int(0), self._name)\n        return Seq(ex, ex.hasValue())\n\n\ndef get_global_state_ex(foreign_id: int, key: str) -> MaybeValue:\n    \"\"\"\n    Wrapper for global state getter.\n    External state variables need to be evaluated before use.\n\n    https://pyteal.readthedocs.io/en/stable/state.html#external-global\n    \"\"\"\n    return App.globalGetEx(Int(foreign_id), Bytes(key))\n\n\nclass StateArray:\n    \"\"\"\n    Wrapper for state access which utilizes multiple slots\n    \"\"\"\n\n    def __init__(self, prefix: str | Expr, type_hint: TealType = TealType.anytype):\n        \"\"\"\n        Args:\n            prefix: a key prefix in the global state, if it's a string it will be converted to Bytes.\n            Prefix should be unique to avoid naming conflicts.\n        \"\"\"\n        self._prefix = prefix\n        self.type_hint = type_hint\n\n    def key_at_index(self, index: int | Expr) -> Expr:\n        \"\"\"\n        Get the actual key (bytes) that will be used to access the state information\n        \"\"\"\n        if isinstance(index, int):  # pylint: disable=no-else-return\n            if isinstance(self._prefix, str):\n                # index: int, prefix: str\n                return Bytes(self._prefix.encode(\"utf-8\") + index.to_bytes(8, \"big\"))\n            # index: int, prefix: Expr\n            return Concat(self._prefix, Bytes(index.to_bytes(8, \"big\")))\n        else:  # isinstance(index, Expr)\n            if isinstance(self._prefix, str):\n                # index: Expr, prefix: str\n                return Concat(Bytes(self._prefix), Itob(index))\n            # index: Expr, prefix: Expr (u64)\n            return Concat(self._prefix, Itob(index))\n\n    def __getitem__(self, index: int | Expr):\n        raise NotImplementedError\n\n\nclass LocalStateArray(StateArray):\n    \"\"\"\n    Wrapper for local state access which utilizes multiple slots in local state\n    \"\"\"\n\n    def __getitem__(self, index: int | Expr):\n        return LocalState(self.key_at_index(index), self.type_hint)\n\n\nclass LocalStateArray2D(StateArray):\n    \"\"\"\n    Wrapper for local state access which utilizes multiple slots in local state organized in 2D array\n    \"\"\"\n\n    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):  # type: ignore\n        length, width = indices\n        return LocalStateArray(self.key_at_index(length), self.type_hint)[width]\n\n\nclass GlobalStateArray(StateArray):\n    \"\"\"\n    Wrapper for global state access which utilizes multiple slots in global state\n    \"\"\"\n\n    def __getitem__(self, index: int | Expr):\n        return GlobalState(self.key_at_index(index), self.type_hint)\n\n\nclass GlobalStateArray2D(StateArray):\n    \"\"\"\n    Wrapper for global state access which utilizes multiple slots in global state organized in 2D array\n    \"\"\"\n\n    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):  # type: ignore\n        length, width = indices\n        return GlobalStateArray(self.key_at_index(length), self.type_hint)[width]"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/examples/printers/cfg.py", "code": "# pylint: disable=undefined-variable\n# type: ignore[name-defined]\nfrom pyteal import *  # pylint: disable=wildcard-import,unused-wildcard-import\n\nrouter = Router(\n    name=\"CFGExample\",\n    bare_calls=BareCallActions(),\n)\n\n\n@router.method(no_op=CallConfig.CREATE)\ndef create() -> Expr:\n    return Return()\n\n\n@router.method(opt_in=CallConfig.CALL)\ndef opt_in() -> Expr:\n    return Return()\n\n\npragma(compiler_version=\"0.22.0\")\napplication_approval_program, _, _ = router.compile_program(version=7)\n\nif __name__ == \"__main__\":\n    print(application_approval_program)"}
{"file_path": "https://github.com/codomposer/pyteal/blob/b196f5b4c48d0ef579c70e53a21dd02a60694ef9/pyteal/types.py", "code": "import re\nfrom enum import Enum\nfrom typing import Any\n\nfrom .errors import TealTypeError, TealInputError\n\n\nclass TealType(Enum):\n    \"\"\"Teal type enum.\"\"\"\n\n    \"\"\"Unsigned 64 bit integer type.\"\"\"\n    uint64 = 0\n\n    \"\"\"Byte string type.\"\"\"\n    bytes = 1\n\n    \"\"\"Any type that is not none.\"\"\"\n    anytype = 2\n\n    \"\"\"Represents no value.\"\"\"\n    none = 3\n\n\nTealType.__module__ = \"pyteal\"\n\n\ndef require_type(input: Any, expected: TealType):\n    try:\n        actual = input.type_of()\n    except AttributeError:\n        raise TypeError(f\"Expected a {expected} object, but got a {type(input)}\")\n\n    if actual != expected and (\n        expected == TealType.none\n        or actual == TealType.none\n        or (actual != TealType.anytype and expected != TealType.anytype)\n    ):\n        raise TealTypeError(actual, expected)\n\n\ndef types_match(type1: TealType, type2: TealType) -> bool:\n    if (type1 == TealType.none or type2 == TealType.none) and type1 != type2:\n        return False\n\n    if type1 == TealType.anytype or type2 == TealType.anytype:\n        return True\n\n    return type1 == type2\n\n\ndef valid_address(address: str):\n    \"\"\"check if address is a valid address with checksum\"\"\"\n    if type(address) is not str:\n        raise TealInputError(\"An address needs to be a string\")\n\n    if len(address) != 58:\n        raise TealInputError(\n            \"Address length is not correct. Should \"\n            + \"be a base 32 string encoded 32 bytes public key + 4 bytes checksum\"\n        )\n\n    valid_base32(address)\n\n\ndef valid_base32(s: str):\n    \"\"\"check if s is a valid base32 encoding string\"\"\"\n    pattern = re.compile(\n        r\"^(?:[A-Z2-7]{8})*(?:([A-Z2-7]{2}([=]{6})?)|([A-Z2-7]{4}([=]{4})?)|([A-Z2-7]{5}([=]{3})?)|([A-Z2-7]{7}([=]{1})?))?\"\n    )\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 32 string\".format(s))\n\n\ndef valid_base64(s: str):\n    \"\"\"check if s is a valid base64 encoding string\"\"\"\n    pattern = re.compile(\n        r\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\"\n    )\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 64 string\".format(s))\n\n\ndef valid_base16(s: str):\n    \"\"\"check if s is a valid hex encoding string\"\"\"\n    pattern = re.compile(r\"[0-9A-Fa-f]*\")\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 16 string\".format(s))\n\n\ndef valid_tmpl(s: str):\n    \"\"\"check if s is valid template name\"\"\"\n    pattern = re.compile(r\"TMPL_[A-Z0-9_]+\")\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid template variable\".format(s))"}
{"file_path": "https://github.com/MarcelloPonzi/TesinaAlgorand-Dev/blob/83f5cfdce3a4f0af4a1a4c125eaa5d8ce4851568/algovenv/Lib/site-packages/pyteal/ast/gload.py", "code": "from typing import cast, Union, TYPE_CHECKING\n\nfrom ..types import TealType, require_type\nfrom ..ir import TealOp, Op, TealBlock\nfrom ..errors import TealInputError, verifyTealVersion\nfrom ..config import MAX_GROUP_SIZE, NUM_SLOTS\nfrom .expr import Expr\nfrom .int import Int\nfrom .leafexpr import LeafExpr\n\nif TYPE_CHECKING:\n    from ..compiler import CompileOptions\n\n\nclass ImportScratchValue(LeafExpr):\n    \"\"\"An expression to load a scratch value created by another transaction in the current group\"\"\"\n\n    def __init__(self, txnIndex: Union[int, Expr], slotId: int) -> None:\n        \"\"\"Create an expression to load a scratch space slot from a transaction in the current group.\n\n        Requires TEAL version 4 or higher. This operation is only permitted in application mode.\n\n        Args:\n            txnIndex: The index of the transaction from which the created ID should be obtained.\n                This index may be a Python int, or it may be a PyTeal expression that evaluates at\n                runtime. If it's an expression, it must evaluate to a uint64. In all cases, the index\n                must be less than the index of the current transaction.\n            slotId: The index of the scratch slot that should be loaded. The index must be a Python int\n                in the range [0-256).\n        \"\"\"\n        super().__init__()\n        if type(txnIndex) is int:\n            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:\n                raise TealInputError(\n                    \"Invalid transaction index {}, shoud be in [0, {})\".format(\n                        txnIndex, MAX_GROUP_SIZE\n                    )\n                )\n        else:\n            require_type(cast(Expr, txnIndex).type_of(), TealType.uint64)\n        if slotId < 0 or slotId >= NUM_SLOTS:\n            raise TealInputError(\n                \"Invalid slot ID {}, shoud be in [0, {})\".format(slotId, NUM_SLOTS)\n            )\n\n        self.txnIndex = txnIndex\n        self.slotId = slotId\n\n    def __str__(self) -> str:\n        return \"(Gload {} {})\".format(self.txnIndex, self.slotId)\n\n    def __teal__(self, options: \"CompileOptions\"):\n        verifyTealVersion(\n            Op.gload.min_version,\n            options.version,\n            \"TEAL version too low to use Gload expression\",\n        )\n\n        if type(self.txnIndex) is int:\n            op = TealOp(self, Op.gload, self.txnIndex, self.slotId)\n            return TealBlock.FromOp(options, op)\n\n        op = TealOp(self, Op.gloads, self.slotId)\n        return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))\n\n    def type_of(self):\n        return TealType.anytype\n\n\nImportScratchValue.__module__ = \"pyteal\""}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py", "code": "#Choice Coin Governance Rewards Code.\n#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nfrom algorand_demo import choice_trade\nimport json\nimport urllib3\nchoice_id  = 42771692\n\nvoter_1_address = \nvoter_1_mnemonic = \nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\n\t# now we will open a file for writing\n\t\tdata_file = open('file.csv', 'w')\n\n\t# create the csv writer object\n\t\tcsv_writer = csv.writer(data_file)\n\n\t# Counter variable used for writing\n\t# headers to the CSV file\n\t\tcount = 0\n\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\n\t\t        # Writing headers of CSV file\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\n\t\t    # Writing data of CSV file\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t    # pass the file object to reader() to get the reader object\n\t\t\t\t\tdata = json.load(json_file)\n\t\t\t\t\ttransaction_data = data['transactions']\n\t\t\t\t\tfor transaction in transaction_data:\n\t\t\t\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\t\t\t\tamount = int(amount)\n\t\t\t\t\t\tamount = amount + amount * 0.12 #Rewards rate hardcoded\n\t\t\t\t\t\taddress = transaction['sender']\n\t\t\t\t\t\tid = transaction['id']\n\t\t\t\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"file_path": "https://github.com/algorand/py-algorand-sdk/blob/a2d610c2f7f7b3b0c19945d0c44ccc88d7bb1888/examples/atc.py", "code": "import base64\nfrom algosdk import transaction, abi\nfrom utils import get_accounts, get_algod_client, deploy_calculator_app\n\nfrom algosdk.atomic_transaction_composer import (\n    AtomicTransactionComposer,\n    AccountTransactionSigner,\n    TransactionWithSigner,\n)\n\n\n# example: ATC_CREATE\natc = AtomicTransactionComposer()\n# example: ATC_CREATE\n\naccts = get_accounts()\nacct = accts.pop()\n\nalgod_client = get_algod_client()\n\n# example: ATC_ADD_TRANSACTION\naddr, sk = acct.address, acct.private_key\n\n# Create signer object\nsigner = AccountTransactionSigner(sk)\n\n# Get suggested params from the client\nsp = algod_client.suggested_params()\n\n# Create a transaction\nptxn = transaction.PaymentTxn(addr, sp, addr, 10000)\n\n# Construct TransactionWithSigner\ntws = TransactionWithSigner(ptxn, signer)\n\n# Pass TransactionWithSigner to ATC\natc.add_transaction(tws)\n# example: ATC_ADD_TRANSACTION\n\n\napp_id = deploy_calculator_app(algod_client, acct)\n\n# example: ATC_CONTRACT_INIT\nwith open(\"calculator/contract.json\") as f:\n    js = f.read()\ncontract = abi.Contract.from_json(js)\n# example: ATC_CONTRACT_INIT\n\n# example: ATC_ADD_METHOD_CALL\n\n# Simple call to the `add` method, method_args can be any type but _must_\n# match those in the method signature of the contract\natc.add_method_call(\n    app_id,\n    contract.get_method_by_name(\"add\"),\n    addr,\n    sp,\n    signer,\n    method_args=[1, 1],\n)\n# example: ATC_ADD_METHOD_CALL\n\n\n# example: ATC_RESULTS\n# Other options:\n# txngroup = atc.build_group()\n# txids = atc.submit(client)\nresult = atc.execute(algod_client, 4)\nfor res in result.abi_results:\n    print(res.return_value)\n# example: ATC_RESULTS\n\n\nmy_method = abi.Method(\n    name=\"box_ref_demo\", args=[], returns=abi.Returns(\"void\")\n)\n# example: ATC_BOX_REF\natc = AtomicTransactionComposer()\natc.add_method_call(\n    app_id,\n    my_method,\n    addr,\n    sp,\n    signer,\n    boxes=[[app_id, b\"key\"]],\n)\n# example: ATC_BOX_REF"}
{"file_path": "https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/tinyman/compat.py", "code": "# flake8: noqa\n\ntry:\n    from algosdk.transaction import (\n        ApplicationClearStateTxn,\n        ApplicationOptInTxn,\n        ApplicationNoOpTxn,\n        AssetTransferTxn,\n        AssetCreateTxn,\n        AssetOptInTxn,\n        assign_group_id,\n        LogicSigAccount,\n        LogicSigTransaction,\n        PaymentTxn,\n        SuggestedParams,\n        Transaction,\n        OnComplete,\n        wait_for_confirmation,\n    )\nexcept ImportError:\n    from algosdk.future.transaction import (\n        ApplicationClearStateTxn,\n        ApplicationOptInTxn,\n        ApplicationNoOpTxn,\n        AssetTransferTxn,\n        AssetCreateTxn,\n        AssetOptInTxn,\n        assign_group_id,\n        LogicSigAccount,\n        LogicSigTransaction,\n        PaymentTxn,\n        SuggestedParams,\n        Transaction,\n        OnComplete,\n        wait_for_confirmation,\n    )"}
{"file_path": "https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/consts.py", "code": "from math import ceil\nfrom typing import Final\n\nfrom algosdk.constants import APP_PAGE_MAX_SIZE\nfrom pyteal import Int\n\n#: number of microalgos in 1 Algo\nalgo: Final[int] = int(1e6)\n#: number of microalgos in 1 MilliAlgo\nmilli_algo: Final[int] = int(1e3)\n\n#: Used for runtime algo calculations `Txn.amount()==Algo`\nAlgo: Final[Int] = Int(algo)\n#: Used for runtime algo calculations `Txn.fee()==MilliAlgo`\nMilliAlgo: Final[Int] = Int(milli_algo)\n\n\n#: Used for shorthand for Int(10*algo) like Algos(10)\ndef Algos(v: int | float) -> Int:  # noqa: N802\n    return Int(int(v * algo))\n\n\n#: Used for shorthand for Int(10*milli_algo) like MilliAlgos(10)\ndef MilliAlgos(v: int | float) -> Int:  # noqa: N802\n    return Int(int(v * milli_algo))\n\n\n#: Max number of inner transactions that may be called\nMAX_INNERS = 255\n#: Single app call opcode budget\nAPP_CALL_BUDGET = 700\n#: Max possible opcode budget\nMAX_OPS = MAX_INNERS * APP_CALL_BUDGET\n\n#: Single app call budget\nAppCallBudget = Int(APP_CALL_BUDGET)\n#: Max app call budget possible\nMaxOps = Int(MAX_OPS)\n\n\n#: TRUE used as an alias for 1\nTRUE: Final[Int] = Int(1)\n#: FALSE used as an alias for 0\nFALSE: Final[Int] = Int(0)\n\n#: The max number of local state values that may be declared\nMAX_LOCAL_STATE = 16\n#: The max number of global state values that may be declared\nMAX_GLOBAL_STATE = 64\n\n#: The maximum number of args that may be included in an lsig\nLSIG_MAX_ARGS = 255\n\n#: The prefix used when hashing bytecode to produce a unique hash\nPROGRAM_DOMAIN_SEPARATOR = \"Program\"\n\n#: The min balance increase per box created\nBOX_FLAT_MIN_BALANCE = 2500\n\n#: The min balance increase per byte of boxes (key included)\nBOX_BYTE_MIN_BALANCE = 400\n\n#: The min balance increase for each asset opted into\nASSET_MIN_BALANCE = 100000\n\n\ndef num_extra_program_pages(approval: bytes, clear: bytes) -> int:\n    return ceil(((len(approval) + len(clear)) - APP_PAGE_MAX_SIZE) / APP_PAGE_MAX_SIZE)"}
{"file_path": "https://github.com/algorand-devrel/demo-abi/blob/3e6985f89c58b5531adb2ac2436ace7d722edb36/py/abi.py", "code": "from algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import (\n    AccountTransactionSigner,\n    AtomicTransactionComposer,\n    TransactionWithSigner,\n)\nfrom algosdk.transaction import PaymentTxn, AssetCreateTxn\nfrom algosdk.abi import Contract\nfrom algosdk.logic import get_application_address\n\nfrom sandbox import get_accounts\n\nclient = AlgodClient(\"a\" * 64, \"http://localhost:4001\")\n\n\naddr, sk = get_accounts()[0]\n\nwith open(\"../contract.json\") as f:\n    js = f.read()\n\nwith open(\"../.app_id\") as f:\n    app_id = int(f.read())\n\napp_addr = get_application_address(app_id)\n\nc = Contract.from_json(js)\n\nsigner = AccountTransactionSigner(sk)\nsp = client.suggested_params()\n\n\nbox_comp = AtomicTransactionComposer()\nbox_name = b\"cool_box\"\nbox_comp.add_transaction(\n    TransactionWithSigner(PaymentTxn(addr, sp, app_addr, 1_000_000_000), signer=signer),\n)\nbox_comp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"box_write\"),\n    addr,\n    sp,\n    signer,\n    method_args=[box_name, (123, 456)],\n    boxes=[(0, box_name)],\n)\nbox_comp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"box_read\"),\n    addr,\n    sp,\n    signer,\n    method_args=[box_name],\n    # technically not needed since we already ref it in\n    # the previous txn in the same group\n    boxes=[(0, box_name)],\n)\nbox_result = box_comp.execute(client, 4)\nprint(f\"box_read returned: {box_result.abi_results[-1].return_value}\")\n\n\ncomp = AtomicTransactionComposer()\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"add\"), addr, sp, signer, method_args=[1, 1]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"sub\"), addr, sp, signer, method_args=[3, 1]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"div\"), addr, sp, signer, method_args=[4, 2]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"mul\"), addr, sp, signer, method_args=[3, 2]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"qrem\"), addr, sp, signer, method_args=[27, 5]\n)\n\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"reverse\"),\n    addr,\n    sp,\n    signer,\n    method_args=[\"desrever yllufsseccus\"],\n)\n\nptxn = TransactionWithSigner(PaymentTxn(addr, sp, addr, 10000), signer)\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"txntest\"),\n    addr,\n    sp,\n    signer,\n    method_args=[10000, ptxn, 1000],\n)\n\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"manyargs\"), addr, sp, signer, method_args=[2] * 20\n)\n\n\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"min_bal\"),\n    addr,\n    sp,\n    signer,\n    method_args=[\"SKCBRBKPIGY5LI2OU63IE5LMNQ5BVVOKPHWTPPWFQOI4NG4TI35SLAA3JQ\"],\n)\n\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"concat_strings\"),\n    addr,\n    sp,\n    signer,\n    method_args=[[\"this\", \"string\", \"is\", \"joined\"]],\n)\n\n# Useable with abi_types.py contract\n# comp.add_method_call(\n#     app_id,\n#     c.get_method_by_name(\"concat_dynamic_arrays\"),\n#     addr,\n#     sp,\n#     signer,\n#     method_args=[[1, 2, 3], [4, 5, 6]],\n# )\n#\n# comp.add_method_call(\n#     app_id,\n#     c.get_method_by_name(\"concat_static_arrays\"),\n#     addr,\n#     sp,\n#     signer,\n#     method_args=[[1, 2, 3], [4, 5, 6]],\n# )\n#\n#\n# comp.add_method_call(\n#     app_id,\n#     c.get_method_by_name(\"concat_dynamic_string_arrays\"),\n#     addr,\n#     sp,\n#     signer,\n#     method_args=[[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]],\n# )\n\n\n# drr = comp.dryrun(client)\n# for txn in drr.trace.txns:\n#    if txn.app_call_rejected():\n#        print(txn.app_trace())\n\nresp = comp.execute(client, 2)\nfor result in resp.abi_results:\n    # print(result.decode_error)\n    # print(result.raw_value.hex())\n    print(f\"{result.method.name} => {result.return_value}\")"}
{"file_path": "https://github.com/Hipo/algojig/blob/71a1bf83204fb70198850024306d91bd041da7d4/algojig/check.py", "code": "from algojig import get_suggested_params, generate_accounts, dump\nfrom algojig.ledger import JigLedger\nfrom algosdk.transaction import PaymentTxn\n\nsecrets, addresses = generate_accounts(2)\n\nsp = get_suggested_params()\n\nledger = JigLedger()\nledger.set_account_balance(addresses[0], 1_000_000)\n\ntransactions = [\n    PaymentTxn(\n        sender=addresses[0],\n        sp=sp,\n        receiver=addresses[1],\n        amt=200_000,\n    ).sign(secrets[0]),\n]\nblock = ledger.eval_transactions(transactions)\nprint(\"Looks like it works!\")"}
{"file_path": "https://github.com/Vilijan/TicTacToe_Algorand/blob/61bfd59696f7fec4f2127cb746d7c5470fff95d8/app.py", "code": "import streamlit as st\nfrom src.blockchain_utils.credentials import get_client, get_account_credentials, get_indexer\nfrom src.services.game_engine_service import GameEngineService\nimport algosdk\n\nclient = get_client()\nindexer = get_indexer()\n\nacc_pk, acc_address = algosdk.account.generate_account()\nplayer_x_pk, player_x_address = algosdk.account.generate_account()\nplayer_o_pk, player_o_address = algosdk.account.generate_account()\n\nif \"submitted_transactions\" not in st.session_state:\n    st.session_state.submitted_transactions = []\n\nif \"player_turn\" not in st.session_state:\n    st.session_state.player_turn = \"X\"\n\nif \"game_state\" not in st.session_state:\n    st.session_state.game_state = ['-'] * 9\n\nif \"x_state\" not in st.session_state:\n    st.session_state.x_state = 0\n\nif \"o_state\" not in st.session_state:\n    st.session_state.o_state = 0\n\nif \"game_state\" not in st.session_state:\n    st.session_state.game_state = ['-'] * 9\n\nif \"game_engine\" not in st.session_state:\n    st.session_state.game_engine = GameEngineService(app_creator_pk=acc_pk,\n                                                     app_creator_address=acc_address,\n                                                     player_x_pk=player_x_pk,\n                                                     player_x_address=player_x_address,\n                                                     player_o_pk=player_o_pk,\n                                                     player_o_address=player_o_address)\n\nif \"game_status\" not in st.session_state:\n    st.session_state.game_status = 0\n\nif \"is_app_deployed\" not in st.session_state:\n    st.session_state.is_app_deployed = False\n\nif \"is_game_started\" not in st.session_state:\n    st.session_state.is_game_started = False\n\nst.title(\"Addresses\")\nst.write(f\"app_creator: {acc_address}\")\nst.write(f\"player_x: {player_x_address}\")\nst.write(f\"player_o: {player_o_address}\")\n\nst.write(\"You need to fund those accounts on the following link: https://bank.testnet.algorand.network/\")\n\n\n# Step 1: App deployment.\n\ndef deploy_application():\n    if st.session_state.is_app_deployed:\n        return\n\n    app_deployment_txn_log = st.session_state.game_engine.deploy_application(client)\n    st.session_state.submitted_transactions.append(app_deployment_txn_log)\n    st.session_state.is_app_deployed = True\n\n\nst.title(\"Step 1: App deployment\")\nst.write(\"In this step we deploy the Tic-Tac-Toe Stateful Smart Contract to the Algorand TestNetwork\")\n\nif st.session_state.is_app_deployed:\n    st.success(f\"The app is deployed on TestNet with the following app_id: {st.session_state.game_engine.app_id}\")\nelse:\n    st.error(f\"The app is not deployed! Press the button below to deploy the application.\")\n    _ = st.button(\"Deploy App\", on_click=deploy_application)\n\n# Step 2: Start of the game\nst.title(\"Step 2: Mark the start of the game\")\nst.write(\"In this step we make atomic transfer of 3 transactions that marks the start of the game.\")\n\n\ndef start_game():\n    if st.session_state.is_game_started:\n        return\n\n    start_game_txn_log = st.session_state.game_engine.start_game(client)\n    st.session_state.submitted_transactions.append(start_game_txn_log)\n    st.session_state.is_game_started = True\n\n\nif st.session_state.is_game_started:\n    st.success(\"The game has started\")\nelse:\n    st.error(f\"The game has not started! Press the button below to start the game.\")\n    _ = st.button(\"Start game\", on_click=start_game)\n\nst.title(\"Step 3: Execute game actions\")\n\nif st.session_state.player_turn == \"X\":\n    st.warning(f\"Current player: {st.session_state.player_turn}\")\nelse:\n    st.success(f\"Current player: {st.session_state.player_turn}\")\n\nmark_position_idx = st.number_input(f'Action position',\n                                    value=0,\n                                    step=1)\n\n\ndef to_binary(integer):\n    return format(integer, 'b').zfill(9)\n\n\ndef get_game_status(indexer, app_id):\n    response = indexer.search_applications(application_id=app_id)\n    game_status_key = \"R2FtZVN0YXRl\"\n\n    for global_variable in response['applications'][0]['params']['global-state']:\n        if global_variable['key'] == game_status_key:\n            return global_variable['value']['uint']\n\n\ndef play_action(action_idx):\n    try:\n        play_action_txn = st.session_state.game_engine.play_action(client,\n                                                                   player_id=st.session_state.player_turn,\n                                                                   action_position=action_idx)\n    except:\n        st.session_state.submitted_transactions.append(f\"Rejected transaction. Tried to put \"\n                                                       f\"{st.session_state.player_turn} at {action_idx}\")\n        return\n\n    st.session_state.game_state[action_idx] = st.session_state.player_turn\n    st.session_state.submitted_transactions.append(play_action_txn)\n    if st.session_state.player_turn == \"X\":\n        st.session_state.x_state = st.session_state.x_state | (1 << action_idx)\n        st.session_state.player_turn = \"O\"\n    else:\n        st.session_state.o_state = st.session_state.o_state | (1 << action_idx)\n        st.session_state.player_turn = \"X\"\n\n\n_ = st.button('Play Action', on_click=play_action,\n              args=(mark_position_idx,))\n\nst.title(\"Game state\")\n\nfor i in range(3):\n    cols = st.columns(3)\n    for j in range(3):\n        idx = i * 3 + j\n        if st.session_state.game_state[idx] == '-':\n            cols[j].info('-')\n        elif st.session_state.game_state[idx] == 'X':\n            cols[j].warning('X')\n        else:\n            cols[j].success('O')\n\nst.subheader(\"Binary states\")\nst.write(f\"x_state: {st.session_state.x_state} == {to_binary(st.session_state.x_state)}\")\nst.write(f\"o_state: {st.session_state.o_state} == {to_binary(st.session_state.o_state)}\")\n\n# Step 4:\n\nst.title(\"Step 4: Withdraw funds\")\n\n\ndef check_game_status():\n    if st.session_state.is_game_started:\n        game_status = get_game_status(indexer, app_id=st.session_state.game_engine.app_id)\n        st.session_state.game_status = game_status\n\n\nst.write(\"Press the button below to use the indexer to query the global state of the application.\")\n_ = st.button(\"Check the game status\", on_click=check_game_status)\n\n\ndef withdraw_funds(winner):\n    if winner is None:\n        try:\n            fund_escrow_txn = st.session_state.game_engine.fund_escrow(client=client)\n            st.session_state.submitted_transactions.append(fund_escrow_txn)\n\n            txn_description = st.session_state.game_engine.tie_money_refund(client)\n            st.session_state.submitted_transactions.append(txn_description)\n        except:\n            st.session_state.submitted_transactions.append(\"Rejected transaction. Unsuccessful withdrawal.\")\n    else:\n        try:\n            fund_escrow_txn = st.session_state.game_engine.fund_escrow(client=client)\n            st.session_state.submitted_transactions.append(fund_escrow_txn)\n\n            txn_description = st.session_state.game_engine.win_money_refund(client, player_id=winner)\n            st.session_state.submitted_transactions.append(txn_description)\n        except:\n            st.session_state.submitted_transactions.append(\"Rejected transaction. Unsuccessful withdrawal.\")\n\n\nif st.session_state.game_status == 0:\n    st.write(\"The game is still active.\")\nelse:\n    winner = None\n    if st.session_state.game_status == 1:\n        st.balloons()\n        st.success(\"Player X won the game.\")\n        winner = \"X\"\n    elif st.session_state.game_status == 2:\n        st.balloons()\n        st.success(\"Player O won the game.\")\n        winner = \"O\"\n    elif st.session_state.game_status == 3:\n        st.warning(\"The game has ended with a tie.\")\n\n    _ = st.button('Withdraw funds', on_click=withdraw_funds,\n                  args=(winner,))\n\nst.title(\"Submitted transactions\")\n\nfor txn in st.session_state.submitted_transactions:\n    if \"Rejected transaction.\" in txn:\n        st.error(txn)\n    else:\n        st.success(txn)"}
{"file_path": "https://github.com/hyplabs/AlgoSwap/blob/4e3f9a977461cd34c246847a0f0d5dbbae5e5ee7/deploy.py", "code": "import os\nimport base64\nimport time\n\nfrom algosdk.v2client import algod, indexer\nfrom algosdk.future import transaction\nfrom algosdk import encoding, account, mnemonic, error\nfrom pyteal import compileTeal, Mode\n\nfrom contracts import manager\n\nALGOD_ENDPOINT = os.environ['ALGOD_ENDPOINT']\nALGOD_TOKEN = os.environ['ALGOD_TOKEN']\nINDEXER_ENDPOINT = os.environ['INDEXER_ENDPOINT']\nINDEXER_TOKEN = os.environ['INDEXER_TOKEN']\n\nDEVELOPER_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(\n    os.environ['DEVELOPER_ACCOUNT_PRIVATE_KEY'])\nDEVELOPER_ACCOUNT_ADDRESS = account.address_from_private_key(\n    DEVELOPER_ACCOUNT_PRIVATE_KEY)\nZERO_ADDRESS = encoding.encode_address(bytes(32))\n\nTEST_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(\n    os.environ['TEST_ACCOUNT_PRIVATE_KEY'])\nTEST_ACCOUNT_ADDRESS = account.address_from_private_key(\n    TEST_ACCOUNT_PRIVATE_KEY)\n\nTOKEN1_UNIT_NAME = \"TOKEN1\"\nTOKEN1_ASSET_NAME = \"AlgoSwap Token 1 Test Asset\"\nTOKEN1_AMOUNT = 2**64 - 1\nTOKEN1_DECIMALS = 6\nTOKEN2_UNIT_NAME = \"TOKEN2\"\nTOKEN2_ASSET_NAME = \"AlgoSwap Token 2 Test Asset\"\nTOKEN2_AMOUNT = 2**64 - 1\nTOKEN2_DECIMALS = 6\nLIQUIDITY_TOKEN_UNIT_NAME = \"T1T2\"\nLIQUIDITY_TOKEN_ASSET_NAME = \"AlgoSwap Token1/Token2\"\nLIQUIDITY_TOKEN_AMOUNT = 2**64 - 1\nLIQUIDITY_TOKEN_DECIMALS = 6\n\n\nalgod_client = algod.AlgodClient(ALGOD_TOKEN, ALGOD_ENDPOINT, headers={\n    \"x-api-key\": ALGOD_TOKEN})\nindexer_client = indexer.IndexerClient(INDEXER_TOKEN, INDEXER_ENDPOINT, headers={\n    \"x-api-key\": INDEXER_TOKEN})\n\n\ndef wait_for_transaction(transaction_id):\n    suggested_params = algod_client.suggested_params()\n    algod_client.status_after_block(suggested_params.first + 4)\n    result = indexer_client.search_transactions(txid=transaction_id)\n    assert len(result['transactions']) == 1, result\n    return result['transactions'][0]\n\n\ndef compile_exchange_validator():\n    from contracts import validator\n\n    print(\"Compiling exchange validator application...\")\n\n    validator_approve_teal_code = compileTeal(\n        validator.approval_program(), Mode.Application)\n    compile_response = algod_client.compile(validator_approve_teal_code)\n    validator_approve_code = base64.b64decode(compile_response['result'])\n    VALIDATOR_APPROVE_BYTECODE_LEN = len(validator_approve_code)\n    VALIDATOR_APPROVE_ADDRESS = compile_response['hash']\n\n    validator_clear_teal_code = compileTeal(\n        validator.clear_program(), Mode.Application)\n    compile_response = algod_client.compile(validator_clear_teal_code)\n    validator_clear_code = base64.b64decode(compile_response['result'])\n    VALIDATOR_CLEAR_BYTECODE_LEN = len(validator_clear_code)\n    VALIDATOR_CLEAR_ADDRESS = compile_response['hash']\n\n    print(\n        f\"Exchange Validator | Approval: {VALIDATOR_APPROVE_BYTECODE_LEN}/1024 bytes ({VALIDATOR_APPROVE_ADDRESS}) | Clear: {VALIDATOR_CLEAR_BYTECODE_LEN}/1024 bytes ({VALIDATOR_CLEAR_ADDRESS})\")\n\n    with open('./build/validator_approval.teal', 'w') as f:\n        f.write(validator_approve_teal_code)\n    with open('./build/validator_clear.teal', 'w') as f:\n        f.write(validator_clear_teal_code)\n\n    print()\n\n    return validator_approve_code, validator_clear_code\n\n\ndef compile_exchange_manager():\n    print(\"Compiling exchange manager application...\")\n\n    manager_approve_teal_code = compileTeal(\n        manager.approval_program(), Mode.Application)\n    compile_response = algod_client.compile(manager_approve_teal_code)\n    manager_approve_code = base64.b64decode(compile_response['result'])\n    MANAGER_APPROVE_BYTECODE_LEN = len(manager_approve_code)\n    MANAGER_APPROVE_ADDRESS = compile_response['hash']\n\n    manager_clear_teal_code = compileTeal(\n        manager.clear_program(), Mode.Application)\n    compile_response = algod_client.compile(manager_clear_teal_code)\n    manager_clear_code = base64.b64decode(compile_response['result'])\n    MANAGER_CLEAR_BYTECODE_LEN = len(manager_clear_code)\n    MANAGER_CLEAR_ADDRESS = compile_response['hash']\n\n    print(\n        f\"Exchange Manager | Approval: {MANAGER_APPROVE_BYTECODE_LEN}/1024 bytes ({MANAGER_APPROVE_ADDRESS}) | Clear: {MANAGER_CLEAR_BYTECODE_LEN}/1024 bytes ({MANAGER_CLEAR_ADDRESS})\")\n\n    with open('./build/manager_approval.teal', 'w') as f:\n        f.write(manager_approve_teal_code)\n    with open('./build/manager_clear.teal', 'w') as f:\n        f.write(manager_clear_teal_code)\n\n    print()\n\n    return manager_approve_code, manager_clear_code\n\n\ndef compile_exchange_escrow():\n    from contracts import escrow\n\n    print(\"Compiling exchange escrow logicsig...\")\n    escrow_logicsig_teal_code = compileTeal(\n        escrow.logicsig(), Mode.Application)\n    compile_response = algod_client.compile(escrow_logicsig_teal_code)\n    escrow_logicsig = compile_response['result']\n    escrow_logicsig_bytes = base64.b64decode(escrow_logicsig)\n    ESCROW_BYTECODE_LEN = len(escrow_logicsig_bytes)\n    ESCROW_ADDRESS = compile_response['hash']\n    print(\n        f\"Exchange Escrow | {ESCROW_BYTECODE_LEN}/1000 bytes ({ESCROW_ADDRESS})\")\n\n    with open('./build/escrow.teal', 'w') as f:\n        f.write(escrow_logicsig_teal_code)\n\n    with open(\"./build/escrow_logicsig\", \"w\") as f:\n        f.write(escrow_logicsig)\n\n    print(f\"Escrow logicsig compiled with address {ESCROW_ADDRESS}\")\n\n    print()\n\n    return escrow_logicsig\n\n\ndef deploy_exchange_validator(validator_approve_code, validator_clear_code):\n    print(\"Deploying exchange validator application...\")\n\n    create_validator_transaction = transaction.ApplicationCreateTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        on_complete=transaction.OnComplete.NoOpOC,\n        approval_program=validator_approve_code,\n        clear_program=validator_clear_code,\n        global_schema=transaction.StateSchema(num_uints=0, num_byte_slices=1),\n        local_schema=None,\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(create_validator_transaction)\n    validator_app_id = wait_for_transaction(tx_id)['created-application-index']\n    print(\n        f\"Exchange Validator deployed with Application ID: {validator_app_id} (Txn ID: https://testnet.algoexplorer.io/tx/{tx_id})\"\n    )\n\n    print()\n\n    return validator_app_id\n\n\ndef deploy_exchange_manager(manager_approve_code, manager_clear_code):\n    print(\"Deploying exchange manager application...\")\n\n    create_manager_transaction = transaction.ApplicationCreateTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        on_complete=transaction.OnComplete.NoOpOC,\n        approval_program=manager_approve_code,\n        clear_program=manager_clear_code,\n        global_schema=transaction.StateSchema(num_uints=0, num_byte_slices=1),\n        local_schema=transaction.StateSchema(num_uints=10, num_byte_slices=0),\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n    tx_id = algod_client.send_transaction(create_manager_transaction)\n    manager_app_id = wait_for_transaction(tx_id)['created-application-index']\n    print(\n        f\"Exchange Manager deployed with Application ID: {manager_app_id} (Txn ID: https://testnet.algoexplorer.io/tx/{tx_id})\"\n    )\n\n    print()\n\n    return manager_app_id\n\n\ndef deploy_token1_token2():\n    print(\n        f\"Deploying tokens {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) and {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME})...\"\n    )\n\n    txn_1 = transaction.AssetConfigTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        total=TOKEN1_AMOUNT,\n        default_frozen=False,\n        unit_name=TOKEN1_UNIT_NAME,\n        asset_name=TOKEN1_ASSET_NAME,\n        manager=DEVELOPER_ACCOUNT_ADDRESS,\n        reserve=DEVELOPER_ACCOUNT_ADDRESS,\n        freeze=DEVELOPER_ACCOUNT_ADDRESS,\n        clawback=DEVELOPER_ACCOUNT_ADDRESS,\n        url=f\"https://algoswap.io/{TOKEN1_UNIT_NAME}\",\n        decimals=TOKEN1_DECIMALS\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    txn_2 = transaction.AssetConfigTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        total=TOKEN2_AMOUNT,\n        default_frozen=False,\n        unit_name=TOKEN2_UNIT_NAME,\n        asset_name=TOKEN2_ASSET_NAME,\n        manager=DEVELOPER_ACCOUNT_ADDRESS,\n        reserve=DEVELOPER_ACCOUNT_ADDRESS,\n        freeze=DEVELOPER_ACCOUNT_ADDRESS,\n        clawback=DEVELOPER_ACCOUNT_ADDRESS,\n        url=f\"https://algoswap.io/{TOKEN2_UNIT_NAME}\",\n        decimals=TOKEN2_DECIMALS\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id_1 = algod_client.send_transaction(txn_1)\n    tx_id_2 = algod_client.send_transaction(txn_2)\n\n    token_1_asset_id = wait_for_transaction(tx_id_1)['created-asset-index']\n    token_2_asset_id = wait_for_transaction(tx_id_2)['created-asset-index']\n\n    print(\n        f\"Deployed {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token_1_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_1}\"\n    )\n    print(\n        f\"Deployed {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token_2_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_2}\"\n    )\n\n    print()\n\n    return token_1_asset_id, token_2_asset_id\n\n\ndef deploy_liquidity_pair_token():\n    print(\n        f\"Deploying token {LIQUIDITY_TOKEN_ASSET_NAME} ({LIQUIDITY_TOKEN_UNIT_NAME})...\"\n    )\n\n    txn = transaction.AssetConfigTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        total=LIQUIDITY_TOKEN_AMOUNT,\n        default_frozen=False,\n        unit_name=LIQUIDITY_TOKEN_UNIT_NAME,\n        asset_name=LIQUIDITY_TOKEN_ASSET_NAME,\n        manager=DEVELOPER_ACCOUNT_ADDRESS,\n        reserve=DEVELOPER_ACCOUNT_ADDRESS,\n        freeze=DEVELOPER_ACCOUNT_ADDRESS,\n        clawback=DEVELOPER_ACCOUNT_ADDRESS,\n        url=f\"https://algoswap.io/{LIQUIDITY_TOKEN_UNIT_NAME}\",\n        decimals=LIQUIDITY_TOKEN_DECIMALS\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    liquidity_token_asset_id = int(\n        wait_for_transaction(tx_id)['created-asset-index'])\n\n    print(\n        f\"Deployed {LIQUIDITY_TOKEN_ASSET_NAME} ({LIQUIDITY_TOKEN_UNIT_NAME}) with Asset ID: {liquidity_token_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n    return liquidity_token_asset_id\n\n\ndef opt_escrow_into_token(escrow_logicsig, token_idx):\n    print(\n        f\"Opting Escrow into Token with Asset ID: {token_idx}...\"\n    )\n    program = base64.b64decode(escrow_logicsig)\n\n    lsig = transaction.LogicSig(program)\n\n    txn = transaction.AssetTransferTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        receiver=lsig.address(),\n        amt=0,\n        index=token_idx,\n    )\n\n    lsig_txn = transaction.LogicSigTransaction(txn, lsig)\n\n    tx_id = algod_client.send_transaction(lsig_txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted Escrow into Token with Asset ID: {token_idx} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef opt_escrow_into_manager(escrow_logicsig, manager_app_id, liquidity_token_asset_id, token1_asset_id, token2_asset_id):\n    print(\"Opting Escrow into Manager contract...\")\n\n    program = base64.b64decode(escrow_logicsig)\n\n    lsig = transaction.LogicSig(program)\n\n    args = [\n        liquidity_token_asset_id.to_bytes(8, 'big'),\n        token1_asset_id.to_bytes(8, 'big'),\n        token2_asset_id.to_bytes(8, 'big')\n    ]\n\n    txn = transaction.ApplicationOptInTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        index=manager_app_id,\n        app_args=args\n    )\n\n    lsig_txn = transaction.LogicSigTransaction(txn, lsig)\n\n    tx_id = algod_client.send_transaction(lsig_txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted Escrow into Manager contract successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef opt_user_into_contract(app_id):\n    print(\n        f\"Opting user into contract with App ID: {app_id}...\"\n    )\n\n    txn = transaction.ApplicationOptInTxn(\n        sender=TEST_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        index=app_id\n    ).sign(TEST_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted user into contract with App ID: {app_id} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef opt_user_into_token(asset_id):\n    print(\n        f\"Opting user into token with Asset ID: {asset_id}...\"\n    )\n\n    txn = transaction.AssetTransferTxn(\n        sender=TEST_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=TEST_ACCOUNT_ADDRESS,\n        amt=0,\n        index=asset_id\n    ).sign(TEST_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted user into token with Asset ID: {asset_id} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef transfer_liquidity_token_to_escrow(liquidity_token_asset_id, escrow_logicsig):\n    print(\n        f\"Transferring {LIQUIDITY_TOKEN_AMOUNT} liquidity token with Asset ID: {liquidity_token_asset_id} to Escrow...\"\n    )\n\n    program = base64.b64decode(escrow_logicsig)\n\n    lsig = transaction.LogicSig(program)\n\n    txn = transaction.AssetTransferTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=lsig.address(),\n        amt=LIQUIDITY_TOKEN_AMOUNT,\n        index=liquidity_token_asset_id\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Transferred {LIQUIDITY_TOKEN_AMOUNT} liquidity token with Asset ID: {liquidity_token_asset_id} to Escrow successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef transfer_token1_token2_to_user(token1_asset_id, token2_asset_id):\n    print(\n        f\"Transferring {int(TOKEN1_AMOUNT/2)} {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token1_asset_id} and {int(TOKEN2_AMOUNT/2)} {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token2_asset_id} to User...\"\n    )\n\n    txn_1 = transaction.AssetTransferTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=TEST_ACCOUNT_ADDRESS,\n        amt=int(TOKEN1_AMOUNT/2),\n        index=token1_asset_id\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    txn_2 = transaction.AssetTransferTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=TEST_ACCOUNT_ADDRESS,\n        amt=int(TOKEN2_AMOUNT/2),\n        index=token2_asset_id\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id_1 = algod_client.send_transaction(txn_1)\n    tx_id_2 = algod_client.send_transaction(txn_2)\n\n    wait_for_transaction(tx_id_1)\n    wait_for_transaction(tx_id_2)\n\n    print(\n        f\"Transferred {int(TOKEN1_AMOUNT/2)} {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token1_asset_id} to User successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_1}\"\n    )\n\n    print(\n        f\"Transferred {int(TOKEN2_AMOUNT/2)} {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token2_asset_id} to User successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_2}\"\n    )   \n\n    print()\n\nif __name__ == \"__main__\":\n    print(\"Starting deployment process...\")\n\n    manager_approve_code, manager_clear_code = compile_exchange_manager()\n\n    manager_app_id = deploy_exchange_manager(\n         manager_approve_code, manager_clear_code)\n\n    input(f\"Update Manager Index in Validator = {manager_app_id}\")\n\n    validator_approve_code, validator_clear_code = compile_exchange_validator()\n\n    validator_app_id = deploy_exchange_validator(\n        validator_approve_code, validator_clear_code)\n\n    token1_asset_id, token2_asset_id = deploy_token1_token2()\n\n    liquidity_token_asset_id = deploy_liquidity_pair_token()\n\n    params = algod_client.suggested_params()\n\n    print(\"Please update the Escrow contract with the following:\")\n    input(f\"Manager App ID = {manager_app_id}\")\n    input(f\"Validator App ID = {validator_app_id}\")\n    input(f\"Token 1 Asset ID = {token1_asset_id}\")\n    input(f\"Token 2 Asset ID = {token2_asset_id}\")\n    input(f\"Liquidity Token Asset ID = {liquidity_token_asset_id}\")\n    input(f\"Last Valid Round = {params.last + 100}\")\n\n    escrow_logicsig = compile_exchange_escrow()\n\n    input(\"Please fund the Escrow account with $ALGO to continue\")\n\n    opt_escrow_into_token(escrow_logicsig, token1_asset_id)\n    opt_escrow_into_token(escrow_logicsig, token2_asset_id)\n    opt_escrow_into_token(escrow_logicsig, liquidity_token_asset_id)\n\n    opt_escrow_into_manager(escrow_logicsig, manager_app_id,\n                            liquidity_token_asset_id, token1_asset_id, token2_asset_id)\n\n    opt_user_into_contract(validator_app_id)\n    opt_user_into_contract(manager_app_id)\n\n    opt_user_into_token(token1_asset_id)\n    opt_user_into_token(token2_asset_id)\n    opt_user_into_token(liquidity_token_asset_id)\n\n    transfer_liquidity_token_to_escrow(liquidity_token_asset_id, escrow_logicsig)\n    transfer_token1_token2_to_user(token1_asset_id, token2_asset_id)\n\n    print(\"Deployment completed successfully!\")"}
{"file_path": "https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/sandbox.py", "code": "import algosdk\n\nKMD_ADDRESS = \"http://localhost:4002\"\nKMD_TOKEN = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\nKMD_WALLET_NAME = \"unencrypted-default-wallet\"\nKMD_WALLET_PASSWORD = \"\"\n\n\ndef get_accounts():\n    kmd = algosdk.kmd.KMDClient(KMD_TOKEN, KMD_ADDRESS)\n    wallets = kmd.list_wallets()\n\n    walletID = None\n    for wallet in wallets:\n        if wallet[\"name\"] == KMD_WALLET_NAME:\n            walletID = wallet[\"id\"]\n            break\n\n    if walletID is None:\n        raise Exception(\"Wallet not found: {}\".format(KMD_WALLET_NAME))\n\n    walletHandle = kmd.init_wallet_handle(walletID, KMD_WALLET_PASSWORD)\n\n    try:\n        addresses = kmd.list_keys(walletHandle)\n        privateKeys = [kmd.export_key(walletHandle, KMD_WALLET_PASSWORD, addr) for addr in addresses]\n        kmdAccounts = [(addresses[i], privateKeys[i]) for i in range(len(privateKeys))]\n    finally:\n        kmd.release_wallet_handle(walletHandle)\n\n    return kmdAccounts"}
{"file_path": "https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/utils.py", "code": "import base64\nfrom collections import namedtuple\nfrom inspect import get_annotations\nfrom typing import Union\nfrom algosdk import constants\nfrom algosdk.future import transaction\nfrom algosdk.v2client import algod\nfrom smart_asa_asc import SmartASAConfig as PyTealSmartASAConfig\n\n\ndef decode_state(state) -> dict[str, Union[int, bytes]]:\n    return {\n        # We are assuming that global space `key` are printable.\n        # If that's not necessarily true, we can change that.\n        base64.b64decode(s[\"key\"]).decode(): base64.b64decode(s[\"value\"][\"bytes\"])\n        if s[\"value\"][\"type\"] == 1\n        else int(s[\"value\"][\"uint\"])\n        for s in state\n    }\n\n\ndef get_global_state(\n    algod_client: algod.AlgodClient, asc_idx: int\n) -> dict[str, Union[bytes, int]]:\n    global_state = algod_client.application_info(asc_idx)[\"params\"][\"global-state\"]\n    global_state = decode_state(global_state)\n    return global_state\n\n\ndef get_local_state(\n    algod_client: algod.AlgodClient, account_address: str, asc_idx: int\n) -> dict[str, Union[bytes, int]]:\n    local_states = algod_client.account_info(account_address)[\"apps-local-state\"]\n    local_state = [s for s in local_states if s[\"id\"] == asc_idx][0].get(\n        \"key-value\", {}\n    )\n    local_state = decode_state(local_state)\n    return local_state\n\n\ndef get_params(\n    algod_client: algod.AlgodClient, fee: int = None\n) -> transaction.SuggestedParams:\n    params = algod_client.suggested_params()\n    params.flat_fee = True\n    params.fee = fee or constants.MIN_TXN_FEE\n    return params\n\n\ndef get_last_round(algod_client: algod.AlgodClient):\n    return algod_client.status()[\"last-round\"]\n\n\ndef get_last_timestamp(algod_client: algod.AlgodClient):\n    return algod_client.block_info(get_last_round(algod_client))[\"block\"][\"ts\"]\n\n\ndef assemble_program(algod_client: algod.AlgodClient, source_code: str) -> bytes:\n    compile_response = algod_client.compile(source_code)\n    return base64.b64decode(compile_response[\"result\"])\n\n\nSmartASAConfig = namedtuple(\n    PyTealSmartASAConfig.__class__.__name__,\n    list(get_annotations(PyTealSmartASAConfig)),\n)\n\n\ndef normalize_getter_params(getter_params: list) -> SmartASAConfig:\n    return SmartASAConfig(*getter_params)"}
{"file_path": "https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py", "code": "#\nimport base64\n\n#\nfrom typing import Optional\nfrom dataclasses import dataclass\n\n#\nfrom algosdk import account, mnemonic, transaction, logic\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import PaymentTxn, SignedTransaction\nfrom algosdk.transaction import ApplicationCreateTxn, ApplicationCallTxn\n\n\n#\n@dataclass\nclass AlgoUser:\n    pk: str\n    address: int\n    mnemonic: float\n\n    def __str__(self):\n        return \"Private Key - {}\\nAddress - {}\\nMnemonic - {}\".format(\n                    self.pk,\n                    self.address,\n                    self.mnemonic\n                )\n\n\n#\nclass Algorand:\n    \"\"\"\n    Algorand object for interacting with algosdk\n    \"\"\"\n\n    # global and local schema parameters\n    GLOBAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)\n    LOCAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)\n\n    #\n    def __init__(self, algo_token: str, algo_address: str) -> None:\n        \"\"\"\n        Constructor\n\n        :param algo_token: token for connecting algorand testnet\n        :param algo_address: algorand testnet address\n\n        :returns: None\n        \"\"\"\n        self.__token = algo_token\n        self.__address = algo_address\n        self.__headers = {\"X-API-Key\": self.token}\n        self.__client = self.__get_client()\n        self.__params = self.client.suggested_params()\n\n    #\n    def __get_client(self) -> Optional[AlgodClient]:\n        \"\"\"\n        create AlgodClient object from given token and address\n\n        :returns: AlgodClient object\n        \"\"\"\n        return AlgodClient(self.token, self.address, self.headers)\n\n    #\n    @property\n    def headers(self) -> dict:\n        \"\"\"\n        Getter for header private field\n\n        :returns: headers field value\n        \"\"\"\n        return self.__headers\n\n    #\n    @property\n    def token(self) -> str:\n        \"\"\"\n        Getter for token private field\n\n        :returns: token field value\n        \"\"\"\n        return self.__token\n\n    #\n    @property\n    def address(self) -> str:\n        \"\"\"\n        Getter for address private field\n\n        :returns: address field value\n        \"\"\"\n        return self.__address\n\n    #\n    @property\n    def params(self) -> str:\n        \"\"\"\n        Getter for params private field\n\n        :returns: params field value\n        \"\"\"\n        return self.__params\n\n    #\n    @property\n    def client(self) -> Optional[AlgodClient]:\n        \"\"\"\n        Getter for client private field\n\n        :returns: client field value\n        \"\"\"\n        return self.__client\n\n    #\n    def get_balance(self, address: str) -> int:\n        \"\"\"\n        Get balance of given account\n\n        :params address: address of account\n\n        :returns: amount balance\n        \"\"\"\n        return self.client.account_info(address).get(\"amount\")\n\n    #\n    def get_transaction_info(self, tx_id: str):\n        \"\"\"\n        Get transaction information\n\n        :param tx_id: transaction id\n\n        :returns: transaction information\n        \"\"\"\n        return self.client.pending_transaction_info(tx_id)\n\n    #\n    def generate_new_account(self) -> dict:\n        \"\"\"\n        Generate new account for algorand testnet\n\n        :returns: new generated account key, address and mnemonic\n        \"\"\"\n        private_key, address = account.generate_account()\n        mnem = mnemonic.from_private_key(private_key)\n\n        return AlgoUser(private_key, address, mnem)\n\n    #\n    def get_application_id(self, tx_id: str) -> int:\n        \"\"\"\n        Get application id from transaction id\n\n        :param tx_id: transaction id\n\n        :returns: application id\n        \"\"\"\n        transaction_info = self.get_transaction_info(tx_id)\n        app_id = transaction_info.get(\"application-index\")\n        return app_id\n\n    #\n    def get_application_address(self, app_id: int) -> str:\n        \"\"\"\n        Get application address from id\n\n        :param app_id: id of application\n\n        :returns: address of application\n        \"\"\"\n        app_address = logic.get_application_address(app_id)\n        return app_address\n\n    #\n    def build_payment_transaction(\n                self,\n                sender: str,\n                receiver: str,\n                amount: int,\n                note: str\n            ) -> Optional[PaymentTxn]:\n        \"\"\"\n        Build payment transaction from sender to receiver\n\n        :param sender: sender address\n        :param receiver: receiver address\n        ;param amount: amount which should be transferred\n        :param note: note for transaction\n\n        :returns: payment transaction\n        \"\"\"\n        txn = transaction.PaymentTxn(\n            sender=sender,\n            sp=self.params,\n            receiver=receiver,\n            amt=amount,\n            note=note,\n        )\n        return txn\n\n    #\n    def create_application_transaction(\n                self,\n                sender: str,\n                approval_teal: bytes,\n                clear_teal: bytes\n            ) -> Optional[ApplicationCreateTxn]:\n        \"\"\"\n        Create transaction that interacts with the application system\n\n        :param sender: address\n        :param approval_teal: transaction smart contract in bytes\n        :param clear_teal: clear smart contract in bytes\n\n        :returns: application transaction\n        \"\"\"\n        app_create_txn = transaction.ApplicationCreateTxn(\n            sender=sender,\n            sp=self.params,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            approval_program=approval_teal,\n            clear_program=clear_teal,\n            global_schema=self.GLOBAL_SCHEMA,\n            local_schema=self.LOCAL_SCHEMA\n        )\n        return app_create_txn\n\n    #\n    def sign_transaction(\n                self,\n                sender: str,\n                txn: Optional[ApplicationCreateTxn]\n            ) -> Optional[SignedTransaction]:\n        \"\"\"\n        Sign created transaction\n\n        :param sender: sender private key\n        :param txn: transaction which should be signed\n\n        :returns: signed transaction\n        \"\"\"\n        signed_txn = txn.sign(sender)\n        return signed_txn\n\n    #\n    def send_transaction(self, signed_txn: Optional[SignedTransaction]) -> str:\n        \"\"\"\n        Send already signed transaction\n\n        :param signed_txn: signed transaction which should be sent\n\n        :returns: transaction id\n        \"\"\"\n        tx_id = self.client.send_transaction(signed_txn)\n        return tx_id\n\n    #\n    def wait_for_confirmation(self, tx_id: str) -> None:\n        \"\"\"\n        Block until a pending transaction is confirmed by the network\n\n        :param tx_id: transaction id\n\n        :returns None\n        \"\"\"\n        return transaction.wait_for_confirmation(self.client, tx_id, 4)\n\n    #\n    def call_application_transaction(\n                self,\n                sender: str,\n                app_id: int,\n                app_args: list,\n                receiver: str=None,\n                asset: int=None\n            ) -> Optional[ApplicationCallTxn]:\n        \"\"\"\n        Create Application call transaction object\n\n        :param sender: sender address\n        :param app_id: application id for which transaction is made\n        :param app_args: arguments for application smart contract\n        :param receiver: receiver address\n\n        :returns: ApplicationCallTxn objects\n        \"\"\"\n\n        accounts = []\n        if receiver:\n            accounts.append(receiver)\n\n        assets = []\n        if asset:\n            assets.append(asset)\n        \n        app_call_txn = transaction.ApplicationCallTxn(\n            sender=sender,\n            sp=self.params,\n            index=app_id,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            app_args=app_args,\n            accounts=accounts,\n            foreign_assets=assets\n        )\n        return app_call_txn\n\n    #\n    def call_application_transaction_foreign_asset(\n                self,\n                sender: str,\n                app_id: int,\n                app_args: list,\n                asset_id: str=None\n            ) -> Optional[ApplicationCallTxn]:\n        \"\"\"\n        Create Application call transaction object\n\n        :param sender: sender address\n        :param app_id: application id for which transaction is made\n        :param app_args: arguments for application smart contract\n        :param receiver: receiver address\n\n        :returns: ApplicationCallTxn objects\n        \"\"\"\n\n        app_call_txn = transaction.ApplicationCallTxn(\n            sender=sender.address,\n            sp=self.params,\n            index=app_id,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            app_args=app_args,\n            foreign_assets=[asset_id]\n        )\n        return app_call_txn\n    #\n    def create_application_no_op_transaction(self, sender, app_id, app_args, receiver=None):\n        accounts = []\n        if receiver:\n            accounts.append(receiver.address)\n        \n        txn = transaction.ApplicationNoOpTxn(\n                sender=sender.address,\n                sp=self.params,\n                index=app_id,\n                app_args=app_args,\n                accounts=accounts\n        )\n\n        return txn\n\n    #\n    def create_asset(self, creator):\n        txn = transaction.AssetConfigTxn(\n                sender=creator.address,\n                sp=self.params,\n                total=1000000,\n                default_frozen=False,\n                unit_name=\"LSCOIN\",\n                asset_name=\"LS Coin\",\n                manager=creator.address,\n                reserve=creator.address,\n                freeze=creator.address,\n                clawback=creator.address,\n                decimals=0\n        )\n        signed_txn = self.sign_transaction(creator.pk, txn)\n        tx_id = self.send_transaction(signed_txn)\n        self.wait_for_confirmation(tx_id)\n        response = self.client.pending_transaction_info(tx_id)\n        return response['asset-index']\n\n    #\n    def opt_in_to_asset(self, sender, asset_id):\n        txn = transaction.AssetTransferTxn(\n                sender=sender.address,\n                sp=self.params,\n                receiver=sender.address,\n                amt=0,\n                index=asset_id\n            )\n        signed_txn = self.sign_transaction(sender.pk, txn)\n        tx_id = self.send_transaction(signed_txn)\n        self.wait_for_confirmation(tx_id)\n\n\n    \n    #\n    def get_application_global_state(self, app_id: int) -> dict:\n        \"\"\"\n        Get application global state info\n\n        :param app_id: application id\n\n        :returns: info about application global state\n        \"\"\"\n        app_info = self.client.application_info(app_id)\n        global_state = app_info['params']['global-state']\n        state = {}\n        for item in global_state:\n            key = base64.b64decode(item['key']).decode('utf-8')\n            value = item['value']\n            state[key] = value\n        return state"}
{"file_path": "https://github.com/khoilr/blockchain-consensus/blob/57eeab4287a05b511b370e2e7258b96687f1f6e8/Algorand.py", "code": "import hashlib\nimport math\nimport time\nimport random\nfrom typing import List\n\nfrom ecdsa import SECP256k1, SigningKey, VerifyingKey\n\nfrom transaction import Transaction\n\n\nclass Block:\n    def __init__(\n        self,\n        txns: List[Transaction],\n        previous_hash: str,\n        vrf_proof,\n        verify_key: VerifyingKey,\n    ):\n        self.txns = txns\n        self.previous_hash = previous_hash\n        self.timestamp = int(time.time())\n        self.vrf_proof = vrf_proof\n        self.verify_key = verify_key\n        self.hash = self.calculate_hash()\n\n    def calculate_hash(self) -> str:\n        block_data = f\"{self.txns}{self.previous_hash}{self.timestamp}{self.vrf_proof}{self.verify_key}\"\n        return hashlib.sha256(block_data.encode()).hexdigest()\n\n    def is_valid(self, previous_hash: str):\n        return (\n            self.hash == self.calculate_hash() and self.previous_hash == previous_hash\n        )\n\n    def __repr__(self):\n        return f\"Block (timestamp={self.timestamp}, hash={self.hash[:8]}, previous_hash={self.previous_hash[:8]}, num_txns={len(self.txns)})\"\n\n\nclass Blockchain:\n    def __init__(self):\n        self.chain: List[Block] = []\n\n        self.create_genesis_block()\n\n    def create_genesis_block(self) -> None:\n        genesis_block = Block([], \"0\", \"0\", \"0\")\n        self.chain.append(genesis_block)\n\n    def add_block(self, block: Block) -> None:\n        if block.is_valid(self.get_last_block().hash):\n            self.chain.append(block)\n\n    def get_last_block(self) -> Block:\n        return self.chain[-1]\n\n    def get_new_block_index(self) -> int:\n        return len(self.chain)\n\n    def is_valid(self) -> bool:\n        return all(\n            self.chain[i].is_valid(\n                target=self.target_from_difficulty(),\n                previous_hash=self.chain[i - 1].hash,\n            )\n            for i in range(1, len(self.chain))\n        )\n\n\nclass Account:\n    def __init__(self, stake):\n        self.signing_key = SigningKey.generate(curve=SECP256k1)\n        self.verify_key = self.signing_key.verifying_key\n        self.stake = stake\n        self.total_rewards = 0\n\n    def generate_key_pair(self):\n        return self.signing_key.to_string().hex(), self.verify_key.to_string().hex()\n\n    def prove(self, message):\n        # Hash the message\n        message_hash = hashlib.sha256(message).digest()\n\n        # Sign the hash\n        signature = self.signing_key.sign(message_hash)\n\n        return signature.hex(), self.verify_key\n\n    def verify(self, message: bytes, signature, verify_key):\n        verify_key = VerifyingKey.from_string(\n            bytes.fromhex(verify_key.to_string().hex()), curve=SECP256k1\n        )\n        message_hash = hashlib.sha256(message).digest()\n        try:\n            return verify_key.verify(bytes.fromhex(signature), message_hash)\n        except Exception:\n            return False\n\n    def __repr__(self):\n        return f\"Account(verify_key={self.verify_key.to_string().hex()})\"\n\n\nclass Algorand(Blockchain):\n    def __init__(\n        self,\n        accounts: List[Account],\n        initial_supply: float,\n        inflation_rate: float,\n    ):\n        super().__init__()\n\n        self.accounts = accounts\n        self.total_supply = initial_supply\n        self.inflation_rate = inflation_rate\n        self.current_round = 0\n        self.base_reward = (self.total_supply * self.inflation_rate) / (\n            365 * 24 * 60\n        )  # Per minute\n\n        # Calculate thresholds after committee and proposers sizes are defined\n        self.proposer_threshold = 20 / len(accounts)\n        self.committee_threshold = self.committee_size / len(accounts)\n\n    @property\n    def total_stake(self):\n        return sum(account.stake for account in self.accounts)\n\n    @property\n    def committee_size(self):\n        return max(math.isqrt(len(self.accounts)), 100)\n\n    @property\n    def proposers_size(self):\n        return max(math.isqrt(len(self.accounts)), 10)\n\n    def select_accounts(\n        self,\n        seed: bytes,\n        threshold: float,\n        is_select_proposers: bool,\n    ) -> List[Account]:\n        weights = [account.stake for account in self.accounts]\n        total_weight = sum(weights)\n\n        # Normalize weights\n        normalized_weights = [w / total_weight for w in weights]\n\n        # Use VRF to determine eligibility\n        eligible_accounts = []\n        for account, weight in zip(self.accounts, normalized_weights):\n            signature, verify_key = account.prove(seed)\n            vrf_output = int(signature, 16)\n            if vrf_output / (2**256) < weight * threshold:\n                eligible_accounts.append(account)\n\n        # If not enough eligible accounts, add more based on stake weight\n        size = self.proposers_size if is_select_proposers else self.committee_size\n        if len(eligible_accounts) < size:\n            additional_accounts = random.choices(\n                self.accounts,\n                weights=weights,\n                k=size - len(eligible_accounts),\n            )\n            eligible_accounts.extend(additional_accounts)\n\n        # If more than needed, randomly select the required number\n        if len(eligible_accounts) > size:\n            eligible_accounts = random.sample(eligible_accounts, size)\n\n        return eligible_accounts\n\n    def propose_block(\n        self,\n        proposer: Account,\n        txns: List[Transaction],\n    ) -> Block:\n        previous_hash = self.get_last_block().hash\n        vrf_proof, verify_key = proposer.prove(previous_hash.encode())\n        return Block(txns, previous_hash, vrf_proof, verify_key)\n\n    def validate_block(\n        self, block: Block, proposer: Account, previous_block: Block\n    ) -> bool:\n        if block.previous_hash != previous_block.hash:\n            return False\n        if not proposer.verify(\n            block.previous_hash.encode(),\n            block.vrf_proof,\n            block.verify_key,\n        ):\n            return False\n\n        return True\n\n    def byzantine_agreement(\n        self,\n        proposed_blocks: List[Block],\n        committee: List[Account],\n    ) -> Block:\n        if not proposed_blocks:\n            return None\n\n        total_stake = sum(member.stake for member in committee)\n        threshold = total_stake * 2 / 3\n\n        # Step 1: Soft Vote\n        votes = {block.hash: 0 for block in proposed_blocks}\n\n        for member in committee:\n            chosen_block = max(\n                proposed_blocks,\n                key=lambda b: hash(b.hash + str(member.stake)),\n            )\n            votes[chosen_block.hash] += member.stake\n\n        winner = max(votes, key=votes.get)\n        winner_stake = 0\n\n        for member in committee:\n            propose = random.choices([True, False], weights=[0.8, 0.2], k=1)[0]\n            if propose:\n                winner_stake += member.stake\n\n        if winner_stake > threshold:\n            return next(block for block in proposed_blocks if block.hash == winner)\n\n        return None\n\n    def distribute_rewards(self, block: Block, committee: List[Account]):\n        total_reward = self.base_reward\n        proposer_reward = total_reward * 0.8  # 80% to proposer\n        committee_reward = total_reward * 0.2  # 20% split among committee\n\n        proposer = next(\n            account\n            for account in self.accounts\n            if account.verify_key == block.verify_key\n        )\n        proposer.stake += proposer_reward\n        proposer.total_rewards += proposer_reward\n\n        for member in committee:\n            reward = committee_reward / len(committee)\n            member.stake += reward\n            member.total_rewards += reward\n\n        self.total_supply += total_reward\n\n    def mine_block(self, transactions: List[Transaction]) -> Block:\n        seed = hashlib.sha256(\n            f\"{self.get_last_block().hash}{self.current_round}\".encode()\n        ).digest()\n\n        proposers = self.select_accounts(\n            seed + b\"proposer\", self.proposer_threshold, True\n        )\n        committee = self.select_accounts(\n            seed + b\"committee\", self.committee_threshold, False\n        )\n\n        proposed_blocks = []\n        for proposer in proposers:\n            block = self.propose_block(proposer, transactions)\n            if self.validate_block(block, proposer, self.get_last_block()):\n                proposed_blocks.append(block)\n\n        self.current_round += 1\n\n        winner = self.byzantine_agreement(proposed_blocks, committee)\n\n        if winner:\n            self.add_block(winner)\n            self.distribute_rewards(winner, committee)\n            return winner\n\n        return None\n\n    def simulate_51_percent_attack(self, attacker: Account):\n        print(\"Simulating 51% attack...\")\n        attacker_stake = attacker.stake\n        honest_stake = self.total_stake - attacker_stake\n\n        if attacker_stake > honest_stake:\n            print(\n                f\"Attacker has {attacker_stake / self.total_stake:.2%} of the total stake.\"\n            )\n\n            proposer_successes = 0\n            committee_controls = 0\n            rounds = 1000\n\n            for _ in range(rounds):\n                seed = hashlib.sha256(str(random.random()).encode()).digest()\n                proposers = self.select_accounts(\n                    seed + b\"proposer\",\n                    self.proposer_threshold,\n                    True,\n                )\n                committee = self.select_accounts(\n                    seed + b\"committee\",\n                    self.committee_threshold,\n                    False,\n                )\n\n                if attacker in proposers:\n                    proposer_successes += 1\n\n                attacker_committee_stake = sum(\n                    member.stake for member in committee if member == attacker\n                )\n                if (\n                    attacker_committee_stake\n                    > sum(member.stake for member in committee) * 2 / 3\n                ):\n                    committee_controls += 1\n\n            print(f\"Probability of being a proposer: {proposer_successes / rounds:.2%}\")\n            print(\n                f\"Probability of controlling committee: {committee_controls / rounds:.2%}\"\n            )\n            print(\n                \"Even with majority stake, the attacker cannot consistently control the protocol.\"\n            )\n        else:\n            print(\"Attacker doesn't have enough stake for a 51% attack.\")\n\n        return False\n\n    def simulate_nothing_at_stake(self, attacker: Account):\n        print(\"Simulating Nothing-at-Stake attack...\")\n\n        seed = hashlib.sha256(str(random.random()).encode()).digest()\n        proposers = self.select_accounts(\n            seed + b\"proposer\",\n            self.proposer_threshold,\n            True,\n        )\n        committee = self.select_accounts(\n            seed + b\"committee\",\n            self.committee_threshold,\n            False,\n        )\n\n        if attacker in proposers:\n            block1 = self.propose_block(attacker, [Transaction(\"main\", \"chain\", 1)])\n            block2 = self.propose_block(attacker, [Transaction(\"fork\", \"chain\", 1)])\n\n            winner = self.byzantine_agreement([block1, block2], committee)\n\n            print(\"In Algorand:\")\n            print(\n                \"1. Only one block can be finalized per round through Byzantine agreement.\"\n            )\n            print(\"2. Proposing multiple blocks doesn't increase chances of reward.\")\n            print(\n                f\"3. Result: {'Two blocks proposed, but only one finalized' if winner else 'No block finalized due to conflicting proposals'}\"\n            )\n        else:\n            print(\"Attacker was not selected as a proposer in this round.\")\n\n        return False\n\n    def simulate_long_range_attack(self, attacker: Account):\n        print(\"Simulating Long-Range attack...\")\n        fork_point = max(0, len(self.chain) - 100)  # Try to fork from 1000 blocks ago\n        honest_chain = self.chain[:]\n        attacker_chain = self.chain[:fork_point]\n\n        if not attacker_chain:\n            print(\"Not enough blocks in the chain to perform a long-range attack.\")\n            return False\n\n        for i in range(fork_point, len(honest_chain)):\n            seed = hashlib.sha256(f\"{attacker_chain[-1].hash}{i}\".encode()).digest()\n            proposers = self.select_accounts(\n                seed + b\"proposer\",\n                self.proposer_threshold,\n                True,\n            )\n            committee = self.select_accounts(\n                seed + b\"committee\",\n                self.committee_threshold,\n                False,\n            )\n\n            if attacker in proposers:\n                fake_block = self.propose_block(\n                    attacker, [Transaction(\"fake\", \"transaction\", 1)]\n                )\n                if self.byzantine_agreement([fake_block], committee):\n                    attacker_chain.append(fake_block)\n                else:\n                    print(f\"Failed to reach consensus on attacker's block at round {i}\")\n                    break\n            else:\n                print(f\"Attacker not selected as proposer for round {i}\")\n                break\n\n        if len(attacker_chain) > len(honest_chain):\n            print(\"In a longest-chain protocol, this attack might succeed.\")\n\n        print(\"In Algorand:\")\n        print(\n            \"1. Blocks are final after Byzantine agreement, preventing reorganization.\"\n        )\n        print(\"2. Attacker can't reconstruct historical committees or proposers.\")\n        print(\"3. State proofs provide additional security against long-range attacks.\")\n\n        return False\n\n    def simulate_sybil_attack(self, attacker: Account):\n        print(\"Simulating Sybil attack...\")\n        original_stake = attacker.stake\n        sybil_accounts = [Account(original_stake / 10) for _ in range(10)]\n\n        def measure_influence(accounts):\n            proposer_selections = 0\n            committee_selections = 0\n            rounds = 1000\n\n            for _ in range(rounds):\n                seed = hashlib.sha256(str(random.random()).encode()).digest()\n                proposers = self.select_accounts(\n                    seed + b\"proposer\",\n                    self.proposer_threshold,\n                    True,\n                )\n                committee = self.select_accounts(\n                    seed + b\"committee\",\n                    self.committee_threshold,\n                    False,\n                )\n\n                proposer_selections += sum(1 for acc in accounts if acc in proposers)\n                committee_selections += sum(1 for acc in accounts if acc in committee)\n\n            return proposer_selections / rounds, committee_selections / rounds\n\n        original_proposer_influence, original_committee_influence = measure_influence(\n            [attacker]\n        )\n        sybil_proposer_influence, sybil_committee_influence = measure_influence(\n            sybil_accounts\n        )\n\n        print(f\"Original proposer influence: {original_proposer_influence:.2%}\")\n        print(f\"Sybil proposer influence: {sybil_proposer_influence:.2%}\")\n        print(f\"Original committee influence: {original_committee_influence:.2%}\")\n        print(f\"Sybil committee influence: {sybil_committee_influence:.2%}\")\n        print(\"In Algorand:\")\n        print(\"1. Influence is directly proportional to stake, not number of accounts.\")\n        print(\n            \"2. Splitting stake across multiple accounts doesn't increase overall influence.\"\n        )\n\n        return False\n\n    def simulate_attacks(self):\n        attacker = max(self.accounts, key=lambda a: a.stake)\n        attacks = [\n            self.simulate_51_percent_attack,\n            self.simulate_nothing_at_stake,\n            self.simulate_long_range_attack,\n            self.simulate_sybil_attack,\n        ]\n        attack = random.choice(attacks)\n        attack(attacker)\n        print()\n\n    def validate_chain(self) -> bool:\n        # Start from the second block (index 1) since the genesis block has no previous hash\n        for i in range(1, len(self.chain)):\n            current_block = self.chain[i]\n            previous_block = self.chain[i - 1]\n\n            # Check if the current block's previous hash matches the hash of the previous block\n            if current_block.previous_hash != previous_block.hash:\n                print(f\"Invalid previous hash in block {i}\")\n                return False\n\n            # Validate the block's integrity\n            proposer = next(\n                (\n                    account\n                    for account in self.accounts\n                    if account.verify_key == current_block.verify_key\n                ),\n                None,\n            )\n            if not proposer:\n                print(f\"Proposer not found for block {i}\")\n                return False\n\n            if not self.validate_block(current_block, proposer, previous_block):\n                print(f\"Block {i} failed validation\")\n                return False\n\n        print(\"Blockchain is valid\")\n        return True\n\n\ndef main():\n    accounts = [Account(random.uniform(100, 10000)) for _ in range(100)]\n    algorand = Algorand(accounts, initial_supply=1000000, inflation_rate=0.05)\n\n    # Mine 100 blocks\n    for i in range(100):\n        transactions = [\n            Transaction(\n                f\"account_{i}\",\n                f\"account_{(i+1)%100}\",\n                random.uniform(1, 100),\n                random.uniform(1, 100),\n            )\n            for i in range(5)\n        ]\n        block = algorand.mine_block(transactions)\n        # print(block)\n        # if i % 10 == 0:\n        #     algorand.simulate_attacks()\n\n    algorand.validate_chain()\n    print(algorand)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"file_path": "https://github.com/zalkikar/AlgoRand_Covid/blob/fe6a060440ec515bfdee2caf35286312d55d833a/py_algorand.py", "code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport algosdk\nimport math\nimport time\n\nclass Algorand_IReportScrape():\n    \n    def __init__(self, api_key):\n        self.purestake_api_key = api_key\n        self.connectMainnet()\n        self.client_check()\n        \n        # For retrieving the real covid data from mainnet\n        self.address = \"COVIDR5MYE757XMDCFOCS5BXFF4SKD5RTOF4RTA67F47YTJSBR5U7TKBNU\"\n        self.fromRound = 5646000\n        self.maxTxnPerCall = 500 # max transactions in a batch\n        self.batchSize = 512 #Read the transactions from the blockchain in 512-block installations\n        self.params = self.algod_client.suggested_params()\n        self.lastRound = self.params['lastRound']\n        #self.lastRound = self.fromRound + 20*self.batchSize # for testing\n        \n        print(\"\\n total rounds:\",self.lastRound - self.fromRound)\n        \n        self.txns = []\n        self.batch_limit = math.ceil((self.lastRound - self.fromRound)/self.maxTxnPerCall)\n        \n        tot_rounds_div = math.floor((self.lastRound - self.fromRound)/self.batchSize)\n        marker_dict = dict(zip([math.floor(tot_rounds_div*(per/10))*self.batchSize + self.fromRound for per in list(range(1,10))],\n                               [per/10 for per in list(range(1,10))]))\n        \n        rnd = self.fromRound\n        while rnd < self.lastRound:\n            toRnd = rnd + self.batchSize\n            if toRnd in marker_dict.keys():\n                print(\"{}% complete\".format(marker_dict[toRnd]*100))\n            if toRnd > self.lastRound:\n                toRnd = self.lastRound\n            self.txns.extend(self.getTransactionBatch(rnd,toRnd)) # Fetch transactions for these rounds \n            rnd += self.batchSize\n            time.sleep(0.1)\n\n        print(\"found {} transactions\".format(len(self.txns)))\n                             \n    def connectMainnet(self):\n        algod_address_mainnet = \"https://mainnet-algorand.api.purestake.io/ps1\"\n        port = \"\"\n        token = {\n            'X-API-key' : self.purestake_api_key,\n        }\n        # Initialize the algod client\n        self.algod_client = algosdk.algod.AlgodClient(port, algod_address_mainnet, token) \n    \n    def client_check(self):\n        try:\n            status = self.algod_client.status()\n        except Exception as e:\n            print(\"Failed to get algod status: {}\".format(e))\n\n        if status:\n            print(\"algod last round: {}\".format(status.get(\"lastRound\")))\n            print(\"algod time since last round: {}\".format(status.get(\"timeSinceLastRound\")))\n            print(\"algod catchup: {}\".format(status.get(\"catchupTime\")))\n            print(\"algod latest version: {}\".format(status.get(\"lastConsensusVersion\")))\n\n        # Retrieve latest block information                                                                                                                                               \n        last_round = self.algod_client.status().get(\"lastRound\")\n        print(\"####################\")\n        block = self.algod_client.block_info(last_round)\n        print(block)\n                             \n    def getTransactionBatch(self,fromRnd,lastRnd):\n        if (fromRnd > lastRnd):# sanity check\n            return []\n        txs = self.algod_client.transactions_by_address(self.address,fromRnd,lastRnd,self.maxTxnPerCall) \n        # make an API call to get the transactions - 500 at a time\n\n        #  A recursive function for getting a batch of transactions, to overcome\n        # the limitation of maxTxnPerCall transaction per call to the API\n        # If we got all the transactions, just return them\n        if ((fromRnd == lastRnd) | (len(txs['transactions']) < self.maxTxnPerCall)):\n            return txs['transactions']\n\n            # FIXME: If a single block contains more than maxTxnPerCall\n            # transactions for the target address, the code above will return\n            # only maxTxnPerCall of them.\n            # This is an unlikely case, and not easy to handle. The only way to\n            # handle it is to call algod.block(round#), then go over all the\n            # transactions in this block and take only the ones corresponding\n            # to the target address.\n\n        else: # recursive call to get them in two smaller chunks\n            midRnd = math.floor((fromRnd+toRnd) / 2)\n            txns1 = getTransactionBatch(fromRnd, midRnd)\n            txns2 = getTransactionBatch(midRnd+1, toRnd)\n            # return the concatenation of the two chunks\n            return txns1.concat(txns2)\n                             \n    def get_txns(self):\n        return self.txns"}
{"file_path": "https://github.com/gitcoinco/web/blob/7c66485f75dbe5ca072892862ff6c9754baf889a/app/grants/utils.py", "code": "# -*- coding: utf-8 -*-\n\"\"\"Define the Grant utilities.\n\nCopyright (C) 2021 Gitcoin Core\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nimport json\nimport logging\nimport math\nimport os\nimport re\nimport urllib.request\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom random import randint, seed\nfrom secrets import token_hex\n\nfrom django.utils import timezone\n\nimport numpy as np\nimport pandas as pd\nfrom app.settings import BASE_URL, MEDIA_URL, NOTION_API_KEY, NOTION_SYBIL_DB\nfrom app.utils import notion_write\nfrom avatar.utils import convert_img\nfrom economy.utils import ConversionRateNotFoundError, convert_amount\nfrom gas.utils import eth_usd_conv_rate\nfrom grants.sync.algorand import sync_algorand_payout\nfrom grants.sync.binance import sync_binance_payout\nfrom grants.sync.celo import sync_celo_payout\nfrom grants.sync.cosmos import sync_cosmos_payout\nfrom grants.sync.harmony import sync_harmony_payout\nfrom grants.sync.polkadot import sync_polkadot_payout\nfrom grants.sync.rsk import sync_rsk_payout\nfrom grants.sync.zcash import sync_zcash_payout\nfrom grants.sync.zil import sync_zil_payout\nfrom perftools.models import StaticJsonEnv\nfrom PIL import Image, ImageDraw, ImageOps\nfrom townsquare.models import SquelchProfile\n\nlogger = logging.getLogger(__name__)\n\nblock_codes = ('\u2596', '\u2597', '\u2598', '\u2599', '\u259a', '\u259b', '\u259c', '\u259d', '\u259e', '\u259f')\nemoji_codes = ('\ud83c\udf89', '\ud83c\udf88', '\ud83c\udf81', '\ud83c\udf8a', '\ud83d\ude4c', '\ud83e\udd42', '\ud83c\udf86', '\ud83d\udd25', '\u26a1', '\ud83d\udc4d')\n\n\ntenant_payout_mapper = {\n    'ZCASH': sync_zcash_payout,\n    'CELO': sync_celo_payout,\n    'ZIL': sync_zil_payout,\n    'HARMONY': sync_harmony_payout,\n    'POLKADOT': sync_polkadot_payout,\n    'BINANCE': sync_binance_payout,\n    'KUSAMA': sync_polkadot_payout,\n    'RSK': sync_rsk_payout,\n    'ALGORAND': sync_algorand_payout,\n    'COSMOS': sync_cosmos_payout\n}\n\ndef get_clr_rounds_metadata():\n    '''\n        Fetches default CLR round metadata for stats/marketing flows.\n        This is configured when multiple rounds are running\n    '''\n    try:\n        CLR_ROUND_DATA = StaticJsonEnv.objects.get(key='CLR_ROUND').data\n\n        clr_round = CLR_ROUND_DATA['round_num']\n        start_date = CLR_ROUND_DATA['round_start']\n        end_date = CLR_ROUND_DATA['round_end']\n        show_round_banner = json.loads(CLR_ROUND_DATA['show_round_banner'])\n        claim_start_date = CLR_ROUND_DATA.get('claim_start_date')\n        claim_end_date = CLR_ROUND_DATA.get('claim_end_date')\n        banner_round_name = CLR_ROUND_DATA.get('banner_round_name')\n\n        # timezones are in UTC (format example: 2021-06-16:15.00.00)\n        round_start_date = datetime.strptime(start_date, '%Y-%m-%d:%H.%M.%S')\n        round_end_date = datetime.strptime(end_date, '%Y-%m-%d:%H.%M.%S')\n\n        now = datetime.now()\n\n        if claim_start_date and claim_end_date:\n            claim_start_date = datetime.strptime(claim_start_date, '%Y-%m-%d:%H.%M.%S')\n            claim_end_date = datetime.strptime(claim_end_date, '%Y-%m-%d:%H.%M.%S')\n\n        if round_start_date > now:\n            round_status = 'upcoming'\n        elif round_start_date <= now <= round_end_date:\n            round_status = 'active'\n        elif claim_start_date and claim_end_date and claim_start_date <= now <= claim_end_date:\n            round_status = 'claim'\n        else:\n            round_status = 'done'\n\n    except:\n        # setting defaults\n        clr_round=1\n        round_start_date = timezone.now()\n        round_end_date = timezone.now() + timezone.timedelta(days=14)\n        show_round_banner = False\n        claim_start_date = None\n        claim_end_date = None\n        round_status = 'done'\n        banner_round_name = ''\n\n    return {\n        'clr_round': clr_round,\n        'round_start_date': round_start_date,\n        'round_end_date': round_end_date,\n        'show_round_banner': show_round_banner,\n        'claim_start_date': claim_start_date,\n        'claim_end_date': claim_end_date,\n        'round_status': round_status,\n        'banner_round_name': banner_round_name\n    }\n\n\ndef get_upload_filename(instance, filename):\n    salt = token_hex(16)\n    file_path = os.path.basename(filename)\n    return f\"grants/{getattr(instance, '_path', '')}/{salt}/{file_path}\"\n\n\ndef is_grant_team_member(grant, profile):\n    \"\"\"Checks to see if profile is a grant team member\n\n    Args:\n        grant (grants.models.Grant): The grant in question.\n        profile (dashboard.models.Profile): The current user's profile.\n\n    \"\"\"\n    if not profile:\n        return False\n    is_team_member = False\n    if grant.admin_profile == profile:\n        is_team_member = True\n    else:\n        for team_member in grant.team_members.all():\n            if team_member.id == profile.id:\n                is_team_member = True\n                break\n    return is_team_member\n\n\ndef amount_in_wei(tokenAddress, amount):\n    from dashboard.tokens import addr_to_token\n    token = addr_to_token(tokenAddress)\n    decimals = token['decimals'] if token else 18\n    return float(amount) * 10**decimals\n\n\ndef get_converted_amount(amount, token_symbol):\n    try:\n        if token_symbol == \"ETH\" or token_symbol == \"WETH\":\n            return Decimal(float(amount) * float(eth_usd_conv_rate()))\n        else:\n            value_token_to_eth = Decimal(convert_amount(\n                amount,\n                token_symbol,\n                \"ETH\")\n            )\n\n        value_eth_to_usdt = Decimal(eth_usd_conv_rate())\n        value_usdt = value_token_to_eth * value_eth_to_usdt\n        return value_usdt\n\n    except ConversionRateNotFoundError as e:\n        try:\n            return Decimal(convert_amount(\n                amount,\n                token_symbol,\n                \"USDT\"))\n        except ConversionRateNotFoundError as no_conversion_e:\n            logger.info(no_conversion_e)\n            return None\n\n\ndef get_user_code(user_id, grant, coding_set=block_codes, length=6):\n    seed(user_id ** grant.id)\n    coding_id = [coding_set[randint(0, 9)] for _ in range(length)]\n\n    return ''.join(coding_id)\n\n\ndef generate_collection_thumbnail(collection, width, heigth):\n    grants = collection.grants.all()\n    profile = collection.profile\n    return generate_img_thumbnail_helper(grants, profile, width, heigth)\n\n\ndef generate_img_thumbnail_helper(grants, profile, width, heigth):\n    MARGIN = int(width / 30)\n    MID_MARGIN = int(width / 90)\n    BG = (111, 63, 245)\n    DISPLAY_GRANTS_LIMIT = 4\n    PROFILE_WIDTH = PROFILE_HEIGHT = int(width / 3.5)\n    GRANT_WIDTH = int(width / 2) - MARGIN - MID_MARGIN\n    GRANT_HEIGHT = int(heigth / 2) - MARGIN - MID_MARGIN\n    IMAGE_BOX = (width, heigth)\n    LOGO_SIZE_DIFF = int(GRANT_WIDTH / 5)\n    HALF_LOGO_SIZE_DIFF = int(LOGO_SIZE_DIFF / 2)\n    PROFILE_BOX = (PROFILE_WIDTH - LOGO_SIZE_DIFF, PROFILE_HEIGHT - LOGO_SIZE_DIFF)\n    GRANT_BOX = (GRANT_WIDTH, GRANT_HEIGHT)\n    media_url = '' if 'media' not in MEDIA_URL else BASE_URL[:-1]\n\n    logos = []\n    for grant in grants:\n        if grant.logo:\n            if len(logos) > DISPLAY_GRANTS_LIMIT:\n                break\n            grant_url = f'{media_url}{grant.logo.url}'\n            print(f'Trying to get: ${grant_url}')\n            fd = urllib.request.urlopen(grant_url)\n            logos.append(fd)\n        else:\n            static_file = f'assets/v2/images/grants/logos/{grant.id % 3}.png'\n            logos.append(static_file)\n\n    for logo in range(len(logos), 4):\n        logos.append(None)\n\n    thumbail = Image.new('RGBA', IMAGE_BOX, color=BG)\n    avatar_url = f'{media_url}{profile.avatar_url}'\n    fd = urllib.request.urlopen(avatar_url)\n\n    # Make rounder profile avatar img\n    mask = Image.new('L', PROFILE_BOX, 0)\n    draw = ImageDraw.Draw(mask)\n    draw.ellipse((0, 0) + PROFILE_BOX, fill=255)\n    profile_thumbnail = Image.open(fd)\n\n    profile_thumbnail.thumbnail(PROFILE_BOX, Image.ANTIALIAS)\n    profile_circle = ImageOps.fit(profile_thumbnail, mask.size, centering=(0.5, 0.5))\n\n    try:\n        applied_mask = profile_circle.copy()\n        applied_mask.putalpha(mask)\n        profile_circle.paste(applied_mask, (0, 0), profile_circle)\n    except ValueError:\n        profile_circle.putalpha(mask)\n\n\n    CORNERS = [\n        [MARGIN, MARGIN],  # Top left grant\n        [width - GRANT_WIDTH - MARGIN, MARGIN],  # Top right grant\n        [MARGIN, heigth - GRANT_HEIGHT - MARGIN],  # bottom left grant\n        [width - GRANT_WIDTH - MARGIN, heigth - GRANT_HEIGHT - MARGIN]  # bottom right grant\n    ]\n\n    for index in range(4):\n        if logos[index] is None:\n            grant_bg = Image.new('RGBA', GRANT_BOX, color='white')\n            thumbail.paste(grant_bg, CORNERS[index], grant_bg)\n            continue\n\n        if type(logos[index]) is not str and re.match(r'.*\\.svg', logos[index].url):\n            grant_img = convert_img(logos[index])\n            grant_thumbail = Image.open(grant_img)\n        else:\n            try:\n                grant_thumbail = Image.open(logos[index])\n            except ValueError:\n                grant_thumbail = Image.open(logos[index]).convert(\"RGBA\")\n\n        grant_thumbail.thumbnail(GRANT_BOX, Image.ANTIALIAS)\n\n        grant_bg = Image.new('RGBA', GRANT_BOX, color='white')\n\n        try:\n            grant_bg.paste(grant_thumbail, (int(GRANT_WIDTH / 2 - grant_thumbail.size[0] / 2),\n                                            int(GRANT_HEIGHT / 2 - grant_thumbail.size[1] / 2)), grant_thumbail)\n        except ValueError:\n            grant_bg.paste(grant_thumbail, (int(GRANT_WIDTH / 2 - grant_thumbail.size[0] / 2),\n                                            int(GRANT_HEIGHT / 2 - grant_thumbail.size[1] / 2)))\n\n        thumbail.paste(grant_bg, CORNERS[index], grant_bg)\n\n    draw_on_thumbnail = ImageDraw.Draw(thumbail)\n    draw_on_thumbnail.ellipse([\n        (int(width / 2 - PROFILE_WIDTH / 2), int(heigth / 2 - PROFILE_HEIGHT / 2)),\n        (int(width / 2 + PROFILE_WIDTH / 2), int(heigth / 2 + PROFILE_HEIGHT / 2))\n    ], fill=\"#6F3FF5\")\n\n    try:\n        thumbail.paste(profile_circle, (int(width / 2 - PROFILE_WIDTH / 2) + HALF_LOGO_SIZE_DIFF, int(heigth / 2 - PROFILE_HEIGHT / 2) + HALF_LOGO_SIZE_DIFF),\n                       profile_circle)\n    except ValueError:\n        thumbail.paste(profile_circle, (int(width / 2 - PROFILE_WIDTH / 2) + HALF_LOGO_SIZE_DIFF, int(heigth / 2 - PROFILE_HEIGHT / 2) + HALF_LOGO_SIZE_DIFF))\n\n    return thumbail\n\n\ndef sync_payout(contribution):\n    if not contribution:\n        return None\n\n    subscription = contribution.subscription\n\n    if not subscription:\n        return None\n\n    tenant_payout_mapper[subscription.tenant](contribution)\n\n\ndef save_grant_to_notion(grant):\n    \"\"\"Post an insert to notions sybil-db table\"\"\"\n    # check for notion credentials before attempting insert\n    if NOTION_SYBIL_DB and NOTION_API_KEY:\n        # fully qualified url\n        fullUrl = BASE_URL.rstrip('/') + grant.url\n        grant_tags = []\n        for tag in grant.tags_requested.all():\n            grant_tags.append(str(tag))\n\n        # write to NOTION_SYBIL_DB following the defined schema (returns dict of new object)\n        return notion_write(NOTION_SYBIL_DB, {\n            \"Platform Status\":{\n                \"id\": \"qwNU\",\n                \"type\": \"select\",\n                \"select\":\n                {\n                    \"id\": \"f38a5236-d1d7-4e63-ada0-e52a4e56d06f\",\n                    \"name\": \"NEEDS REVIEW\",\n                    \"color\": \"default\"\n                }\n            },\n            \"Grant Name\": {\n                \"id\": \"title\",\n                \"type\": \"title\",\n                \"title\": [{\n                    \"type\": \"text\",\n                    \"text\": {\n                        \"content\": fullUrl,\n                        \"link\": {\n                            \"url\": fullUrl\n                        }\n                    },\n                    \"plain_text\": fullUrl,\n                    \"href\": fullUrl\n                }]\n            },\n             \"Requested Rounds\": {\n                \"id\": \"qBXH\",\n                \"type\": \"rich_text\",\n                \"rich_text\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": {\n                            \"content\": \", \".join(grant_tags),\n                            \"link\": None\n                        },\n                        \"annotations\": {\n                            \"bold\": False,\n                            \"italic\": False,\n                            \"strikethrough\": False,\n                            \"underline\": False,\n                            \"code\": False,\n                            \"color\": \"default\"\n                        },\n                        \"plain_text\": \", \".join(grant_tags),\n                        \"href\": None\n                    }\n                ]\n            },\n            \"Eligibility Tag Reasoning\": {\n                \"id\": \"Q]?]\",\n                \"type\": \"rich_text\",\n                \"rich_text\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": {\n                            \"content\": grant.tag_eligibility_reason,\n                            \"link\": None\n                        },\n                        \"annotations\": {\n                            \"bold\": False,\n                            \"italic\": False,\n                            \"strikethrough\": False,\n                            \"underline\": False,\n                            \"code\": False,\n                            \"color\": \"default\"\n                        },\n                        \"plain_text\": grant.tag_eligibility_reason,\n                        \"href\": None\n                    }\n                ]\n            }\n        })\n\n\ndef toggle_user_sybil(sybil_users, non_sybil_users):\n    '''util function which marks users as sybil/not'''\n\n    from dashboard.models import Profile\n\n    squelched_profiles = SquelchProfile.objects.all()\n    if sybil_users:\n        # iterate through users which need to be packed as sybil\n        for user in sybil_users:\n            try:\n                # get user profile. note\n                profile = Profile.objects.filter(handle=user.get('handle')).first()\n                if profile:\n                    label = user.get('label')\n                    comment = user.get('comment')\n\n                    if not comment or comment and isNaN(comment):\n                        comment = 'added by bsci'\n\n                    # check if user has entry in SquelchProfile\n                    if (\n                        not squelched_profiles.filter(profile=profile).first() and\n                        label and comment\n                    ):\n                        # mark user as sybil\n                        SquelchProfile.objects.create(\n                            profile=profile,\n                            label=label,\n                            comments=comment\n                        )\n                else:\n                    print(f\"error: profile not found for {user.get('handle')} as sybil.\")\n            except Exception as e:\n                print(f\"error: unable to mark user {user.get('handle')} as sybil. {e}\")\n\n    if non_sybil_users:\n        # exclude squelches added by manual\n        squelched_profiles = squelched_profiles.exclude(label='Manual')\n        # iterate and remove sybil from user\n        for user in non_sybil_users:\n            try:\n                profile = Profile.objects.filter(handle=user.get('handle')).first()\n                squelched_profiles.filter(profile=profile).delete()\n            except Exception as e:\n                print(f\"error: unable to mark {user.get('handle')} as non sybil. {e}\")\n\n\ndef bsci_script(csv: str) -> tuple:\n    \"\"\"\n    Generate records of sybil / non-sybil users based\n    on the CSV output as provided by BSci detection pipeline.\n    \"\"\"\n\n    # Assumptions\n    RENAME_MAP = {'notes': 'comment'}\n    ML_THRESHOLD = 0.8\n    EVAL_THRESHOLD = 0.8\n    HEURISTIC_THRESHOLD = 0.5\n\ndef bsci_script(csv: str) -> tuple:\n    \"\"\"\n    Generate records of sybil / non-sybil users based\n    on the CSV output as provided by BSci detection pipeline.\n    \"\"\"\n\n    # Assumptions\n    RENAME_MAP = {'notes': 'comment'}\n    ML_THRESHOLD = 0.8\n    EVAL_THRESHOLD = 0.8\n    HEURISTIC_THRESHOLD = 0.5\n\n    # Read CSV\n\n    try:\n        df = (pd.read_csv(csv)\n                .assign(is_sybil=None)\n                .assign(label=None)\n                .rename(columns=RENAME_MAP))\n\n        # Get label domains\n        rows_with_evaluation = ~pd.isnull(df.evaluation_score)\n        rows_with_heuristic = ~pd.isnull(df.heuristic_score)\n        rows_with_prediction = ~pd.isnull(df.prediction_score)\n\n        labels_by_evaluation = rows_with_evaluation\n        labels_by_heuristic = (rows_with_heuristic & (rows_with_heuristic\n                                                    ^ labels_by_evaluation))\n        labels_by_prediction = (rows_with_prediction & (rows_with_prediction\n                                                        ^ (labels_by_heuristic |\n                                                        labels_by_evaluation)))\n\n        # Assign final `is_sybil` markings according to a priorization criteria\n        df.loc[labels_by_evaluation, 'is_sybil'] = df[labels_by_evaluation].evaluation_score > EVAL_THRESHOLD\n        df.loc[labels_by_evaluation, 'label'] = \"Human Evaluation\"\n\n        df.loc[labels_by_heuristic, 'is_sybil'] = df[labels_by_heuristic].heuristic_score > HEURISTIC_THRESHOLD\n        df.loc[labels_by_heuristic, 'label'] = \"Heuristics\"\n\n        df.loc[labels_by_prediction, 'is_sybil'] = df[labels_by_prediction].prediction_score > ML_THRESHOLD\n        df.loc[labels_by_prediction, 'label'] = \"ML Prediction\"\n\n        # Generate dict records\n        sybil_records = df.query('is_sybil == True').to_dict('records')\n        non_sybil_records = df.query('is_sybil == False').to_dict('records')\n\n        # Output\n        return (sybil_records, non_sybil_records)\n    except Exception as e:\n        logger.error(f'error: bsci_sybil_script - {e}')\n        return None\n\n\ndef isNaN(string):\n    return string != string\n\ndef is_valid_eip_1271_signature(web3, address, hash, signature) -> bool:\n    from grants.abi.eip_1271_abi import EIP_1271_ABI\n    try:\n        eip_1271_contract = web3.eth.contract(address=address, abi=EIP_1271_ABI)\n        retval = eip_1271_contract.functions.isValidSignature(hash, signature).call()\n        return web3.toInt(retval) == 0x1626ba7e\n    except Exception as e:\n        return False"}
{"file_path": "https://github.com/VincenzoImp/utils/blob/b797a1d6b71e212e430df3554bf94f9e67cd206d/parser_utils.py", "code": "# deprecated\n\nimport re\nimport numpy as np\nimport pandas as pd\n\n# use only:\n# get_links\n# clear_html\n# get_emails\n# get_addresses \n# get_url_info\n# get_url_df_info\n\ntlds = [\"aaa\", \"aarp\", \"abarth\", \"abb\", \"abbott\", \"abbvie\", \"abc\", \"able\", \"abogado\", \"abudhabi\", \"ac\", \"academy\", \"accenture\", \"accountant\", \"accountants\", \"aco\", \"actor\", \"ad\", \"ads\", \"adult\", \"ae\", \"aeg\", \"aero\", \"aetna\", \"af\", \"afl\", \"africa\", \"ag\", \"agakhan\", \"agency\", \"ai\", \"aig\", \"airbus\", \"airforce\", \"airtel\", \"akdn\", \"al\", \"alfaromeo\", \"alibaba\", \"alipay\", \"allfinanz\", \"allstate\", \"ally\", \"alsace\", \"alstom\", \"am\", \"amazon\", \"americanexpress\", \"americanfamily\", \"amex\", \"amfam\", \"amica\", \"amsterdam\", \"analytics\", \"android\", \"anquan\", \"anz\", \"ao\", \"aol\", \"apartments\", \"app\", \"apple\", \"aq\", \"aquarelle\", \"ar\", \"arab\", \"aramco\", \"archi\", \"army\", \"arpa\", \"art\", \"arte\", \"as\", \"asda\", \"asia\", \"associates\", \"at\", \"athleta\", \"attorney\", \"au\", \"auction\", \"audi\", \"audible\", \"audio\", \"auspost\", \"author\", \"auto\", \"autos\", \"avianca\", \"aw\", \"aws\", \"ax\", \"axa\", \"az\", \"azure\", \"ba\", \"baby\", \"baidu\", \"banamex\", \"bananarepublic\", \"band\", \"bank\", \"bar\", \"barcelona\", \"barclaycard\", \"barclays\", \"barefoot\", \"bargains\", \"baseball\", \"basketball\", \"bauhaus\", \"bayern\", \"bb\", \"bbc\", \"bbt\", \"bbva\", \"bcg\", \"bcn\", \"bd\", \"be\", \"beats\", \"beauty\", \"beer\", \"bentley\", \"berlin\", \"best\", \"bestbuy\", \"bet\", \"bf\", \"bg\", \"bh\", \"bharti\", \"bi\", \"bible\", \"bid\", \"bike\", \"bing\", \"bingo\", \"bio\", \"biz\", \"bj\", \"black\", \"blackfriday\", \"blockbuster\", \"blog\", \"bloomberg\", \"blue\", \"bm\", \"bms\", \"bmw\", \"bn\", \"bnpparibas\", \"bo\", \"boats\", \"boehringer\", \"bofa\", \"bom\", \"bond\", \"boo\", \"book\", \"booking\", \"bosch\", \"bostik\", \"boston\", \"bot\", \"boutique\", \"box\", \"br\", \"bradesco\", \"bridgestone\", \"broadway\", \"broker\", \"brother\", \"brussels\", \"bs\", \"bt\", \"build\", \"builders\", \"business\", \"buy\", \"buzz\", \"bv\", \"bw\", \"by\", \"bz\", \"bzh\", \"ca\", \"cab\", \"cafe\", \"cal\", \"call\", \"calvinklein\", \"cam\", \"camera\", \"camp\", \"canon\", \"capetown\", \"capital\", \"capitalone\", \"car\", \"caravan\", \"cards\", \"care\", \"career\", \"careers\", \"cars\", \"casa\", \"case\", \"cash\", \"casino\", \"cat\", \"catering\", \"catholic\", \"cba\", \"cbn\", \"cbre\", \"cbs\", \"cc\", \"cd\", \"center\", \"ceo\", \"cern\", \"cf\", \"cfa\", \"cfd\", \"cg\", \"ch\", \"chanel\", \"channel\", \"charity\", \"chase\", \"chat\", \"cheap\", \"chintai\", \"christmas\", \"chrome\", \"church\", \"ci\", \"cipriani\", \"circle\", \"cisco\", \"citadel\", \"citi\", \"citic\", \"city\", \"cityeats\", \"ck\", \"cl\", \"claims\", \"cleaning\", \"click\", \"clinic\", \"clinique\", \"clothing\", \"cloud\", \"club\", \"clubmed\", \"cm\", \"cn\", \"co\", \"coach\", \"codes\", \"coffee\", \"college\", \"cologne\", \"com\", \"comcast\", \"commbank\", \"community\", \"company\", \"compare\", \"computer\", \"comsec\", \"condos\", \"construction\", \"consulting\", \"contact\", \"contractors\", \"cooking\", \"cookingchannel\", \"cool\", \"coop\", \"corsica\", \"country\", \"coupon\", \"coupons\", \"courses\", \"cpa\", \"cr\", \"credit\", \"creditcard\", \"creditunion\", \"cricket\", \"crown\", \"crs\", \"cruise\", \"cruises\", \"cu\", \"cuisinella\", \"cv\", \"cw\", \"cx\", \"cy\", \"cymru\", \"cyou\", \"cz\", \"dabur\", \"dad\", \"dance\", \"data\", \"date\", \"dating\", \"datsun\", \"day\", \"dclk\", \"dds\", \"de\", \"deal\", \"dealer\", \"deals\", \"degree\", \"delivery\", \"dell\", \"deloitte\", \"delta\", \"democrat\", \"dental\", \"dentist\", \"desi\", \"design\", \"dev\", \"dhl\", \"diamonds\", \"diet\", \"digital\", \"direct\", \"directory\", \"discount\", \"discover\", \"dish\", \"diy\", \"dj\", \"dk\", \"dm\", \"dnp\", \"do\", \"docs\", \"doctor\", \"dog\", \"domains\", \"dot\", \"download\", \"drive\", \"dtv\", \"dubai\", \"dunlop\", \"dupont\", \"durban\", \"dvag\", \"dvr\", \"dz\", \"earth\", \"eat\", \"ec\", \"eco\", \"edeka\", \"edu\", \"education\", \"ee\", \"eg\", \"email\", \"emerck\", \"energy\", \"engineer\", \"engineering\", \"enterprises\", \"epson\", \"equipment\", \"er\", \"ericsson\", \"erni\", \"es\", \"esq\", \"estate\", \"et\", \"etisalat\", \"eu\", \"eurovision\", \"eus\", \"events\", \"exchange\", \"expert\", \"exposed\", \"express\", \"extraspace\", \"fage\", \"fail\", \"fairwinds\", \"faith\", \"family\", \"fan\", \"fans\", \"farm\", \"farmers\", \"fashion\", \"fast\", \"fedex\", \"feedback\", \"ferrari\", \"ferrero\", \"fi\", \"fiat\", \"fidelity\", \"fido\", \"film\", \"final\", \"finance\", \"financial\", \"fire\", \"firestone\", \"firmdale\", \"fish\", \"fishing\", \"fit\", \"fitness\", \"fj\", \"fk\", \"flickr\", \"flights\", \"flir\", \"florist\", \"flowers\", \"fly\", \"fm\", \"fo\", \"foo\", \"food\", \"foodnetwork\", \"football\", \"ford\", \"forex\", \"forsale\", \"forum\", \"foundation\", \"fox\", \"fr\", \"free\", \"fresenius\", \"frl\", \"frogans\", \"frontdoor\", \"frontier\", \"ftr\", \"fujitsu\", \"fun\", \"fund\", \"furniture\", \"futbol\", \"fyi\", \"ga\", \"gal\", \"gallery\", \"gallo\", \"gallup\", \"game\", \"games\", \"gap\", \"garden\", \"gay\", \"gb\", \"gbiz\", \"gd\", \"gdn\", \"ge\", \"gea\", \"gent\", \"genting\", \"george\", \"gf\", \"gg\", \"ggee\", \"gh\", \"gi\", \"gift\", \"gifts\", \"gives\", \"giving\", \"gl\", \"glass\", \"gle\", \"global\", \"globo\", \"gm\", \"gmail\", \"gmbh\", \"gmo\", \"gmx\", \"gn\", \"godaddy\", \"gold\", \"goldpoint\", \"golf\", \"goo\", \"goodyear\", \"goog\", \"google\", \"gop\", \"got\", \"gov\", \"gp\", \"gq\", \"gr\", \"grainger\", \"graphics\", \"gratis\", \"green\", \"gripe\", \"grocery\", \"group\", \"gs\", \"gt\", \"gu\", \"guardian\", \"gucci\", \"guge\", \"guide\", \"guitars\", \"guru\", \"gw\", \"gy\", \"hair\", \"hamburg\", \"hangout\", \"haus\", \"hbo\", \"hdfc\", \"hdfcbank\", \"health\", \"healthcare\", \"help\", \"helsinki\", \"here\", \"hermes\", \"hgtv\", \"hiphop\", \"hisamitsu\", \"hitachi\", \"hiv\", \"hk\", \"hkt\", \"hm\", \"hn\", \"hockey\", \"holdings\", \"holiday\", \"homedepot\", \"homegoods\", \"homes\", \"homesense\", \"honda\", \"horse\", \"hospital\", \"host\", \"hosting\", \"hot\", \"hoteles\", \"hotels\", \"hotmail\", \"house\", \"how\", \"hr\", \"hsbc\", \"ht\", \"hu\", \"hughes\", \"hyatt\", \"hyundai\", \"ibm\", \"icbc\", \"ice\", \"icu\", \"id\", \"ie\", \"ieee\", \"ifm\", \"ikano\", \"il\", \"im\", \"imamat\", \"imdb\", \"immo\", \"immobilien\", \"in\", \"inc\", \"industries\", \"infiniti\", \"info\", \"ing\", \"ink\", \"institute\", \"insurance\", \"insure\", \"int\", \"international\", \"intuit\", \"investments\", \"io\", \"ipiranga\", \"iq\", \"ir\", \"irish\", \"is\", \"ismaili\", \"ist\", \"istanbul\", \"it\", \"itau\", \"itv\", \"jaguar\", \"java\", \"jcb\", \"je\", \"jeep\", \"jetzt\", \"jewelry\", \"jio\", \"jll\", \"jm\", \"jmp\", \"jnj\", \"jo\", \"jobs\", \"joburg\", \"jot\", \"joy\", \"jp\", \"jpmorgan\", \"jprs\", \"juegos\", \"juniper\", \"kaufen\", \"kddi\", \"ke\", \"kerryhotels\", \"kerrylogistics\", \"kerryproperties\", \"kfh\", \"kg\", \"kh\", \"ki\", \"kia\", \"kids\", \"kim\", \"kinder\", \"kindle\", \"kitchen\", \"kiwi\", \"km\", \"kn\", \"koeln\", \"komatsu\", \"kosher\", \"kp\", \"kpmg\", \"kpn\", \"kr\", \"krd\", \"kred\", \"kuokgroup\", \"kw\", \"ky\", \"kyoto\", \"kz\", \"la\", \"lacaixa\", \"lamborghini\", \"lamer\", \"lancaster\", \"lancia\", \"land\", \"landrover\", \"lanxess\", \"lasalle\", \"lat\", \"latino\", \"latrobe\", \"law\", \"lawyer\", \"lb\", \"lc\", \"lds\", \"lease\", \"leclerc\", \"lefrak\", \"legal\", \"lego\", \"lexus\", \"lgbt\", \"li\", \"lidl\", \"life\", \"lifeinsurance\", \"lifestyle\", \"lighting\", \"like\", \"lilly\", \"limited\", \"limo\", \"lincoln\", \"link\", \"lipsy\", \"live\", \"living\", \"lk\", \"llc\", \"llp\", \"loan\", \"loans\", \"locker\", \"locus\", \"lol\", \"london\", \"lotte\", \"lotto\", \"love\", \"lpl\", \"lplfinancial\", \"lr\", \"ls\", \"lt\", \"ltd\", \"ltda\", \"lu\", \"lundbeck\", \"luxe\", \"luxury\", \"lv\", \"ly\", \"ma\", \"madrid\", \"maif\", \"maison\", \"makeup\", \"man\", \"management\", \"mango\", \"map\", \"market\", \"marketing\", \"markets\", \"marriott\", \"marshalls\", \"maserati\", \"mattel\", \"mba\", \"mc\", \"mckinsey\", \"md\", \"me\", \"med\", \"media\", \"meet\", \"melbourne\", \"meme\", \"memorial\", \"men\", \"menu\", \"merckmsd\", \"mg\", \"mh\", \"miami\", \"microsoft\", \"mil\", \"mini\", \"mint\", \"mit\", \"mitsubishi\", \"mk\", \"ml\", \"mlb\", \"mls\", \"mm\", \"mma\", \"mn\", \"mo\", \"mobi\", \"mobile\", \"moda\", \"moe\", \"moi\", \"mom\", \"monash\", \"money\", \"monster\", \"mormon\", \"mortgage\", \"moscow\", \"moto\", \"motorcycles\", \"mov\", \"movie\", \"mp\", \"mq\", \"mr\", \"ms\", \"msd\", \"mt\", \"mtn\", \"mtr\", \"mu\", \"museum\", \"music\", \"mutual\", \"mv\", \"mw\", \"mx\", \"my\", \"mz\", \"nan\", \"nab\", \"nagoya\", \"name\", \"natura\", \"navy\", \"nba\", \"nc\", \"ne\", \"nec\", \"net\", \"netbank\", \"netflix\", \"network\", \"neustar\", \"new\", \"news\", \"next\", \"nextdirect\", \"nexus\", \"nf\", \"nfl\", \"ng\", \"ngo\", \"nhk\", \"ni\", \"nico\", \"nike\", \"nikon\", \"ninja\", \"nissan\", \"nissay\", \"nl\", \"no\", \"nokia\", \"northwesternmutual\", \"norton\", \"now\", \"nowruz\", \"nowtv\", \"np\", \"nr\", \"nra\", \"nrw\", \"ntt\", \"nu\", \"nyc\", \"nz\", \"obi\", \"observer\", \"office\", \"okinawa\", \"olayan\", \"olayangroup\", \"oldnavy\", \"ollo\", \"om\", \"omega\", \"one\", \"ong\", \"onl\", \"online\", \"ooo\", \"open\", \"oracle\", \"orange\", \"org\", \"organic\", \"origins\", \"osaka\", \"otsuka\", \"ott\", \"ovh\", \"pa\", \"page\", \"panasonic\", \"paris\", \"pars\", \"partners\", \"parts\", \"party\", \"passagens\", \"pay\", \"pccw\", \"pe\", \"pet\", \"pf\", \"pfizer\", \"pg\", \"ph\", \"pharmacy\", \"phd\", \"philips\", \"phone\", \"photo\", \"photography\", \"photos\", \"physio\", \"pics\", \"pictet\", \"pictures\", \"pid\", \"pin\", \"ping\", \"pink\", \"pioneer\", \"pizza\", \"pk\", \"pl\", \"place\", \"play\", \"playstation\", \"plumbing\", \"plus\", \"pm\", \"pn\", \"pnc\", \"pohl\", \"poker\", \"politie\", \"porn\", \"post\", \"pr\", \"pramerica\", \"praxi\", \"press\", \"prime\", \"pro\", \"prod\", \"productions\", \"prof\", \"progressive\", \"promo\", \"properties\", \"property\", \"protection\", \"pru\", \"prudential\", \"ps\", \"pt\", \"pub\", \"pw\", \"pwc\", \"py\", \"qa\", \"qpon\", \"quebec\", \"quest\", \"racing\", \"radio\", \"re\", \"read\", \"realestate\", \"realtor\", \"realty\", \"recipes\", \"red\", \"redstone\", \"redumbrella\", \"rehab\", \"reise\", \"reisen\", \"reit\", \"reliance\", \"ren\", \"rent\", \"rentals\", \"repair\", \"report\", \"republican\", \"rest\", \"restaurant\", \"review\", \"reviews\", \"rexroth\", \"rich\", \"richardli\", \"ricoh\", \"ril\", \"rio\", \"rip\", \"ro\", \"rocher\", \"rocks\", \"rodeo\", \"rogers\", \"room\", \"rs\", \"rsvp\", \"ru\", \"rugby\", \"ruhr\", \"run\", \"rw\", \"rwe\", \"ryukyu\", \"sa\", \"saarland\", \"safe\", \"safety\", \"sakura\", \"sale\", \"salon\", \"samsclub\", \"samsung\", \"sandvik\", \"sandvikcoromant\", \"sanofi\", \"sap\", \"sarl\", \"sas\", \"save\", \"saxo\", \"sb\", \"sbi\", \"sbs\", \"sc\", \"sca\", \"scb\", \"schaeffler\", \"schmidt\", \"scholarships\", \"school\", \"schule\", \"schwarz\", \"science\", \"scot\", \"sd\", \"se\", \"search\", \"seat\", \"secure\", \"security\", \"seek\", \"select\", \"sener\", \"services\", \"seven\", \"sew\", \"sex\", \"sexy\", \"sfr\", \"sg\", \"sh\", \"shangrila\", \"sharp\", \"shaw\", \"shell\", \"shia\", \"shiksha\", \"shoes\", \"shop\", \"shopping\", \"shouji\", \"show\", \"showtime\", \"si\", \"silk\", \"sina\", \"singles\", \"site\", \"sj\", \"sk\", \"ski\", \"skin\", \"sky\", \"skype\", \"sl\", \"sling\", \"sm\", \"smart\", \"smile\", \"sn\", \"sncf\", \"so\", \"soccer\", \"social\", \"softbank\", \"software\", \"sohu\", \"solar\", \"solutions\", \"song\", \"sony\", \"soy\", \"spa\", \"space\", \"sport\", \"spot\", \"sr\", \"srl\", \"ss\", \"st\", \"stada\", \"staples\", \"star\", \"statebank\", \"statefarm\", \"stc\", \"stcgroup\", \"stockholm\", \"storage\", \"store\", \"stream\", \"studio\", \"study\", \"style\", \"su\", \"sucks\", \"supplies\", \"supply\", \"support\", \"surf\", \"surgery\", \"suzuki\", \"sv\", \"swatch\", \"swiss\", \"sx\", \"sy\", \"sydney\", \"systems\", \"sz\", \"tab\", \"taipei\", \"talk\", \"taobao\", \"target\", \"tatamotors\", \"tatar\", \"tattoo\", \"tax\", \"taxi\", \"tc\", \"tci\", \"td\", \"tdk\", \"team\", \"tech\", \"technology\", \"tel\", \"temasek\", \"tennis\", \"teva\", \"tf\", \"tg\", \"th\", \"thd\", \"theater\", \"theatre\", \"tiaa\", \"tickets\", \"tienda\", \"tiffany\", \"tips\", \"tires\", \"tirol\", \"tj\", \"tjmaxx\", \"tjx\", \"tk\", \"tkmaxx\", \"tl\", \"tm\", \"tmall\", \"tn\", \"to\", \"today\", \"tokyo\", \"tools\", \"top\", \"toray\", \"toshiba\", \"total\", \"tours\", \"town\", \"toyota\", \"toys\", \"tr\", \"trade\", \"trading\", \"training\", \"travel\", \"travelchannel\", \"travelers\", \"travelersinsurance\", \"trust\", \"trv\", \"tt\", \"tube\", \"tui\", \"tunes\", \"tushu\", \"tv\", \"tvs\", \"tw\", \"tz\", \"ua\", \"ubank\", \"ubs\", \"ug\", \"uk\", \"unicom\", \"university\", \"uno\", \"uol\", \"ups\", \"us\", \"uy\", \"uz\", \"va\", \"vacations\", \"vana\", \"vanguard\", \"vc\", \"ve\", \"vegas\", \"ventures\", \"verisign\", \"versicherung\", \"vet\", \"vg\", \"vi\", \"viajes\", \"video\", \"vig\", \"viking\", \"villas\", \"vin\", \"vip\", \"virgin\", \"visa\", \"vision\", \"viva\", \"vivo\", \"vlaanderen\", \"vn\", \"vodka\", \"volkswagen\", \"volvo\", \"vote\", \"voting\", \"voto\", \"voyage\", \"vu\", \"vuelos\", \"wales\", \"walmart\", \"walter\", \"wang\", \"wanggou\", \"watch\", \"watches\", \"weather\", \"weatherchannel\", \"webcam\", \"weber\", \"website\", \"wed\", \"wedding\", \"weibo\", \"weir\", \"wf\", \"whoswho\", \"wien\", \"wiki\", \"williamhill\", \"win\", \"windows\", \"wine\", \"winners\", \"wme\", \"wolterskluwer\", \"woodside\", \"work\", \"works\", \"world\", \"wow\", \"ws\", \"wtc\", \"wtf\", \"xbox\", \"xerox\", \"xfinity\", \"xihuan\", \"xin\", \"xn--11b4c3d\", \"xn--1ck2e1b\", \"xn--1qqw23a\", \"xn--2scrj9c\", \"xn--30rr7y\", \"xn--3bst00m\", \"xn--3ds443g\", \"xn--3e0b707e\", \"xn--3hcrj9c\", \"xn--3pxu8k\", \"xn--42c2d9a\", \"xn--45br5cyl\", \"xn--45brj9c\", \"xn--45q11c\", \"xn--4dbrk0ce\", \"xn--4gbrim\", \"xn--54b7fta0cc\", \"xn--55qw42g\", \"xn--55qx5d\", \"xn--5su34j936bgsg\", \"xn--5tzm5g\", \"xn--6frz82g\", \"xn--6qq986b3xl\", \"xn--80adxhks\", \"xn--80ao21a\", \"xn--80aqecdr1a\", \"xn--80asehdb\", \"xn--80aswg\", \"xn--8y0a063a\", \"xn--90a3ac\", \"xn--90ae\", \"xn--90ais\", \"xn--9dbq2a\", \"xn--9et52u\", \"xn--9krt00a\", \"xn--b4w605ferd\", \"xn--bck1b9a5dre4c\", \"xn--c1avg\", \"xn--c2br7g\", \"xn--cck2b3b\", \"xn--cckwcxetd\", \"xn--cg4bki\", \"xn--clchc0ea0b2g2a9gcd\", \"xn--czr694b\", \"xn--czrs0t\", \"xn--czru2d\", \"xn--d1acj3b\", \"xn--d1alf\", \"xn--e1a4c\", \"xn--eckvdtc9d\", \"xn--efvy88h\", \"xn--fct429k\", \"xn--fhbei\", \"xn--fiq228c5hs\", \"xn--fiq64b\", \"xn--fiqs8s\", \"xn--fiqz9s\", \"xn--fjq720a\", \"xn--flw351e\", \"xn--fpcrj9c3d\", \"xn--fzc2c9e2c\", \"xn--fzys8d69uvgm\", \"xn--g2xx48c\", \"xn--gckr3f0f\", \"xn--gecrj9c\", \"xn--gk3at1e\", \"xn--h2breg3eve\", \"xn--h2brj9c\", \"xn--h2brj9c8c\", \"xn--hxt814e\", \"xn--i1b6b1a6a2e\", \"xn--imr513n\", \"xn--io0a7i\", \"xn--j1aef\", \"xn--j1amh\", \"xn--j6w193g\", \"xn--jlq480n2rg\", \"xn--jvr189m\", \"xn--kcrx77d1x4a\", \"xn--kprw13d\", \"xn--kpry57d\", \"xn--kput3i\", \"xn--l1acc\", \"xn--lgbbat1ad8j\", \"xn--mgb9awbf\", \"xn--mgba3a3ejt\", \"xn--mgba3a4f16a\", \"xn--mgba7c0bbn0a\", \"xn--mgbaakc7dvf\", \"xn--mgbaam7a8h\", \"xn--mgbab2bd\", \"xn--mgbah1a3hjkrd\", \"xn--mgbai9azgqp6j\", \"xn--mgbayh7gpa\", \"xn--mgbbh1a\", \"xn--mgbbh1a71e\", \"xn--mgbc0a9azcg\", \"xn--mgbca7dzdo\", \"xn--mgbcpq6gpa1a\", \"xn--mgberp4a5d4ar\", \"xn--mgbgu82a\", \"xn--mgbi4ecexp\", \"xn--mgbpl2fh\", \"xn--mgbt3dhd\", \"xn--mgbtx2b\", \"xn--mgbx4cd0ab\", \"xn--mix891f\", \"xn--mk1bu44c\", \"xn--mxtq1m\", \"xn--ngbc5azd\", \"xn--ngbe9e0a\", \"xn--ngbrx\", \"xn--node\", \"xn--nqv7f\", \"xn--nqv7fs00ema\", \"xn--nyqy26a\", \"xn--o3cw4h\", \"xn--ogbpf8fl\", \"xn--otu796d\", \"xn--p1acf\", \"xn--p1ai\", \"xn--pgbs0dh\", \"xn--pssy2u\", \"xn--q7ce6a\", \"xn--q9jyb4c\", \"xn--qcka1pmc\", \"xn--qxa6a\", \"xn--qxam\", \"xn--rhqv96g\", \"xn--rovu88b\", \"xn--rvc1e0am3e\", \"xn--s9brj9c\", \"xn--ses554g\", \"xn--t60b56a\", \"xn--tckwe\", \"xn--tiq49xqyj\", \"xn--unup4y\", \"xn--vermgensberater-ctb\", \"xn--vermgensberatung-pwb\", \"xn--vhquv\", \"xn--vuq861b\", \"xn--w4r85el8fhu5dnra\", \"xn--w4rs40l\", \"xn--wgbh1c\", \"xn--wgbl6a\", \"xn--xhq521b\", \"xn--xkc2al3hye2a\", \"xn--xkc2dl3a5ee0h\", \"xn--y9a3aq\", \"xn--yfro4i67o\", \"xn--ygbi2ammx\", \"xn--zfr164b\", \"xxx\", \"xyz\", \"yachts\", \"yahoo\", \"yamaxun\", \"yandex\", \"ye\", \"yodobashi\", \"yoga\", \"yokohama\", \"you\", \"youtube\", \"yt\", \"yun\", \"za\", \"zappos\", \"zara\", \"zero\", \"zip\", \"zm\", \"zone\", \"zuerich\", \"zw\", \"onion\"]\n\ndef remove_hastag(url):\n    # Remove 'https://' or 'http://'\n    head = ''\n    if url.startswith('https://'):\n        head = 'https://'\n        url = url[8:]\n    elif url.startswith('http://'):\n        head = 'http://'\n        url = url[7:]\n    index = url.rfind('/')\n    if index != -1:\n        index2 = url.rfind('#')\n        if index2 > index:\n            url = url[:index2]\n    return head + url\n\ndef get_extension(url, extensions):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    index = url.rfind('/')\n    extension = ''\n    if index != -1:\n        index2 = url.rfind('.')\n        if index2 > index:\n            extension = url[index2+1:].lower()\n            for ext in extensions:\n                if extension.startswith(ext):\n                    return ext\n    return np.nan\n\ndef remove_not_isalnum(url):\n    while len(url) > 0 and not url[-1].isalnum():\n        url = url[:-1]\n    while len(url) > 0 and not url[0].isalnum():\n        url = url[1:]\n    return url\ndef is_tld(url):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    index = url.find('/')\n    if index != -1:\n        url = url[:index]\n    if '@' in url:\n        return False\n    index = url.rfind('.')\n    if index != -1:\n        url = url[index+1:]\n        if url.lower() in tlds:\n            return True\n    return False\ndef remove_head(url):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    # remove 'www.'\n    if url.startswith('www.'):\n        url = url[4:]\n    return url\n\ndef is_still_valid(url):\n    # se \u00e8 vuoto ritorna False\n    if url == '':\n        return False\n    # se non ha un punto ritorna False\n    if '.' not in url:\n        return False\n    # se ha due punti consecutivi ritorna False\n    if '..' in url:\n        return False\n    return True\n\ndef get_links(text):\n    # text = 'You can view more details at https://uibakery.io, or just ping via email. You can view more details at uibakery.io or just ping via email.'\n    urls = []\n    # Extract URL from a string\n    url_extract_pattern = \"https?:\\\\/\\\\/(?:www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)\"\n    urls += re.findall(url_extract_pattern, text)\n    for url in urls:\n        text = text.replace(url, ' ')\n    url_extract_pattern = \"[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)\"\n    urls += re.findall(url_extract_pattern, text)\n    urls_cleaned = []\n    for url in urls:\n        if is_tld(url):\n            url = remove_not_isalnum(url)\n            if is_still_valid(url):\n                urls_cleaned.append(url)\n    return urls_cleaned\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef clear_html(html_string):\n    def clear_tag(html_string, tag):\n        if html_string.find(f'<{tag}') == -1 or html_string.find(f'</{tag}>') == -1:\n            return html_string\n        start = html_string.find(f'<{tag}')\n        end = start + html_string[start:].find(f'</{tag}>') + len(tag)+3\n        html_string = html_string[:start] + ' ' + html_string[end:]\n        return html_string\n    tags = ['iframe', 'template', 'script', 'style']\n    for tag in tags:\n        while True:\n            new_html_string = clear_tag(html_string, tag)\n            if new_html_string == html_string:\n                break\n            html_string = new_html_string\n    html_string = re.sub(r'<[^>]*?>', ' ', html_string)\n    html_string = re.sub(r'\\s+', ' ', html_string)\n    html_string = html_string.strip()\n    return html_string\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblockchains = [\n        'bitcoin',\n        'ethereum',\n        'litecoin',\n        'dogecoin',\n        'monero',\n        'dash',\n        'cardano',\n        'cosmos',\n        'iota',\n        'lisk',\n        'polkadot',\n        'ripple',\n        'stellar',\n        'neo',\n        'bitcoin-cash',\n        'ethereum-classic',\n        'binance-smart-chain',\n        'binance-beacon-chain',\n        'solana',\n        'tron',\n        'algorand',\n        'vechain'\n    ]\n\ndef bitcoin(address):\n    def taproot(address):\n        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,89}))$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def segwit(address):\n        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,87}))$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def script(address):\n        schema = '^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def legacy(address):\n        schema = '^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    if taproot(address):\n        return True\n    if segwit(address):\n        return True\n    if script(address):\n        return True\n    if legacy(address):\n        return True\n    return False\n\ndef ethereum(address):\n    schema = '^((0x)([0-9a-fA-F]{40}))$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef litecoin(address):\n    schema = '^([LM3]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}||ltc1[a-z0-9]{39,59})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef dogecoin(address):\n    schema = '^D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}'\n    schema2 = 'D[a-zA-Z0-9_.-]{33}'\n    if re.match(schema, address) is None and re.match(schema2, address) is None:\n        return False\n    return True\n\ndef monero(address):\n    schema = '[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef dash(address):\n    schema = 'X[1-9A-HJ-NP-Za-km-z]{33}'\n    if re.match(schema, address) is None:\n        return False\n    return True  \n\ndef cardano(address):\n    schema = 'addr1[a-z0-9]+'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef cosmos(address):\n    schema = 'cosmos[a-zA-Z0-9_.-]{10,}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef iota(address):\n    schema = 'iota[a-z0-9]{10,}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef lisk(address):\n    schema = '[0-9]{19}L'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef nem(address):\n    schema = '[N][A-Za-z0-9-]{37,52}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef neo(address):\n    schema = 'A[0-9a-zA-Z]{33}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef polkadot(address):\n    schema = '1[0-9a-zA-Z]{47}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef ripple(address):\n    schema = '^([r])([1-9A-HJ-NP-Za-km-z]{24,34})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef stellar(address):\n    schema = 'G[0-9A-Z]{40,60}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef ethereum_classic(address):\n    return ethereum(address)\n\ndef binance_smart_chain(address):\n    return ethereum(address)\n\ndef binance_beacon_chain(address):\n    schema = '^((bnb1)[0-9a-z]{38})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef bitcoin_cash(address):\n    legacy = '[13][a-km-zA-HJ-NP-Z1-9]{33}'\n    cashaddr = '((bitcoincash):)?(q|p)[a-z0-9]{41}'\n    if re.match(legacy, address) is None and re.match(cashaddr, address) is None:\n        return False\n    return True\n\ndef solana(address):\n    schema = '^[1-9A-HJ-NP-Za-km-z]{32,44}$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef tron(address):\n    schema = '^((T)[a-zA-Z0-9]{33})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef algorand(address):\n    schema = '^[A-Z2-7]{58}$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef vechain(address):\n    return ethereum(address)\n\ndef get_addresses(text):\n    foo = {\n        'bitcoin': bitcoin,\n        'ethereum': ethereum,\n        'litecoin': litecoin,\n        'dogecoin': dogecoin,\n        'monero': monero,\n        'dash': dash,\n        'cardano': cardano,\n        'cosmos': cosmos,\n        'iota': iota,\n        'lisk': lisk,\n        'polkadot': polkadot,\n        'ripple': ripple,\n        'stellar': stellar,\n        'neo': neo,\n        'bitcoin-cash': bitcoin_cash,\n        'ethereum-classic': ethereum_classic,\n        'binance-smart-chain': binance_smart_chain,\n        'binance-beacon-chain': binance_beacon_chain,\n        'solana': solana,\n        'tron': tron,\n        'algorand': algorand,\n        'vechain': vechain,\n    }\n    crypto = {key : [] for key in foo.keys()}\n    text = re.sub(r'\\W', ' ', text)\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    for address in text.split():\n        for key in foo.keys():\n            if foo[key](address):\n                crypto[key].append(address)\n    for key in crypto.keys():\n        crypto[key] = list(set(crypto[key]))\n    for key in crypto.copy():\n        if crypto[key] == []:\n            del crypto[key]\n    return crypto\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef email(address):\n    # remove all no alphanumeric char from the beginning and the end\n    address = re.sub(r'^[^a-zA-Z0-9]*', '', address)\n    address = re.sub(r'[^a-zA-Z0-9]*$', '', address)\n    schema = \"^[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*@(?:[A-Z0-9-]+\\.)+[A-Z]{2,6}$\"\n    if re.match(schema, address.upper()) is None:\n        return None\n    return address\n\ndef get_emails(text):\n    emails = []\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    for string in text.split():\n        address = email(string)\n        if address is not None:\n            emails.append(address)\n    return emails\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef foo1(x):\n    if x.startswith('http://www.'):\n        return x[11:]\n    if x.startswith('https://www.'):\n        return x[12:]\n    if x.startswith('http://'):\n        return x[7:]\n    if x.startswith('https://'):\n        return x[8:]\n    return x\n\ndef foo2(x):\n    return x.split('/')[0].lower()\n\ndef foo3(x):\n    return x.split('.')[-1].lower()\n\ndef foo4(x):\n    return '.'.join(x.split('.')[:-1]).lower()\n\ndef foo5(x):\n    x = x.split('/')\n    if len(x) > 1:\n        y = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]\n        x = '/'.join(x[1:-1])+'/'+y\n        return x.strip('/')\n    return np.nan\n\ndef foo6(x):\n    x = x.split('/')\n    if len(x) > 1:\n        x = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]\n        x = x.split('.')\n        if len(x) > 1:\n            return x[-1].lower()\n    return np.nan\n\ndef get_url_info(url):\n    url_df = pd.DataFrame({'url': [url]})\n    url_df = get_url_df_info(url_df)\n    info = {\n        'apex': url_df['apex'][0],\n        'domain': url_df['domain'][0],\n        'tld': url_df['tld'][0],\n        'path': url_df['path'][0],\n        'extention': url_df['extention'][0],\n        'normalized_url': url_df['normalized_url'][0],\n        'normalized_url_lower': url_df['normalized_url_lower'][0],\n    }\n    return info \n\ndef get_url_df_info(df):\n    df['apex'] = df['url'].apply(lambda x: foo2(foo1(x)))\n    df['domain'] = df['url'].apply(lambda x: foo4(foo2(foo1(x))))\n    df['tld'] = df['url'].apply(lambda x: foo3(foo2(foo1(x))))\n    df['path'] = df['url'].apply(lambda x: foo5(foo1(x)))\n    df['extention'] = df['url'].apply(lambda x: foo6(foo1(x)))\n    df['normalized_url'] = df['apex'] + '/' + df['path']\n    df['normalized_url'] = df['normalized_url'].fillna(df['apex'])\n    df['normalized_url_lower'] = df['normalized_url'].str.lower()\n    return df"}
{"file_path": "https://github.com/Argonaut5000/algorand-arc19-python-example/blob/be35e0c5b48b98a74c7ae70e32531502d6a5e37d/algorand_utils.py", "code": "from itsdangerous import json\n\n\nimport json\n\n\"\"\"\nStriaght ripped from https://github.com/algorand/docs Algorand Dev Documentation\n\nThank you for the util functions!\n\"\"\"\n\n#   Utility function used to print asset holding for account and assetid\ndef print_asset_holding(algodclient, account, assetid):\n    # note: if you have an indexer instance available it is easier to just use this\n    # response = myindexer.accounts(asset_id = assetid)\n    # then loop thru the accounts returned and match the account you are looking for\n    account_info = algodclient.account_info(account)\n    idx = 0\n    for my_account_info in account_info['assets']:\n        scrutinized_asset = account_info['assets'][idx]\n        idx = idx + 1        \n        if (scrutinized_asset['asset-id'] == assetid):\n            print(\"Asset ID: {}\".format(scrutinized_asset['asset-id']))\n            print(json.dumps(scrutinized_asset, indent=4))\n            break\n\n# utility for waiting on a transaction confirmation\ndef wait_for_confirmation( algod_client, txid, timeout=2000):\n    start_round = algod_client.status()[\"last-round\"] + 1\n    current_round = start_round\n\n    while current_round < start_round + timeout:\n        try:\n            pending_txn = algod_client.pending_transaction_info(txid)\n        except Exception:\n            return \n        if pending_txn.get(\"confirmed-round\", 0) > 0:\n            return pending_txn\n        elif pending_txn[\"pool-error\"]:  \n            raise Exception(\n                'pool error: {}'.format(pending_txn[\"pool-error\"]))\n        algod_client.status_after_block(current_round)                   \n        current_round += 1\n    raise Exception(\n        'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))"}
{"file_path": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py", "code": "#!/usr/bin/env python3\n\nimport setuptools\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"pyteal\",\n    version=\"0.27.0\",\n    author=\"Algorand\",\n    author_email=\"pypiservice@algorand.com\",\n    description=\"Algorand Smart Contracts in Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/algorand/pyteal\",\n    packages=setuptools.find_packages(\n        include=(\n            \"feature_gates\",\n            \"pyteal\",\n            \"pyteal.*\",\n        )\n    ),\n    install_requires=[\n        # when changing this list, also update docs/requirements.txt\n        \"docstring-parser==0.14.1\",\n        \"executing==2.0.1\",\n        \"py-algorand-sdk>=2.0.0,<3.0.0\",\n        \"semantic-version>=2.9.0,<3.0.0\",\n        \"tabulate>=0.9.0,<0.10.0\",\n    ],\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    package_data={\"pyteal\": [\"*.pyi\", \"py.typed\"]},\n    python_requires=\">=3.10\",\n)"}
{"file_path": "https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/examples/exodus.py", "code": "\"\"\"\nExample of keys derivation for ed25519 or nist256p1 based coins like Exodus wallet.\n\nBasically, Exodus always uses the secp256k1 curve to derive the BIP44 path, even for coins that are not based on secp256k1.\nThen, for coins based on other curves (e.g. Algorand, Solana, Stellar, Neo ...), it uses the last derived private key as a master key to compute the public key and address.\nIt's not the only wallet doing this (Atomic Wallet does the same), because in this way the developers don't have to implement other derivation schemes beside secp256k1.\n\"\"\"\n\nfrom bip_utils import Bip32Slip10Secp256k1, Bip39SeedGenerator, Bip44, Bip44Coins, Bip44ConfGetter\n\n\n# Mnemonic\nmnemonic = \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\n# Generate seed from mnemonic\nseed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n\n# Example with Solana (ed25519-based coin) and Neo (nist256p1-based coin)\nfor coin_type in (Bip44Coins.SOLANA, Bip44Coins.NEO):\n    # Get coin index from configuration\n    coin_idx = Bip44ConfGetter.GetConfig(coin_type).CoinIndex()\n\n    # Derive the standard BIP44 path using secp256k1\n    bip32_ctx = Bip32Slip10Secp256k1.FromSeed(seed_bytes).DerivePath(f\"m/44'/{coin_idx}'/0'/0/0\")\n    priv_key_bytes = bip32_ctx.PrivateKey().Raw().ToBytes()\n\n    # Use the last private key as a master key, we can use Bip44 to simplify the address computation\n    bip44_ctx = Bip44.FromPrivateKey(priv_key_bytes, coin_type)\n    # Same address of Exodus\n    print(f\"Address for {coin_type}: {bip44_ctx.PublicKey().ToAddress()}\")"}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py", "code": "#Choice Coin Governance Rewards Code.\n#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nfrom algorand_demo import choice_trade\nimport json\nimport urllib3\nchoice_id  = 42771692\n\nvoter_1_address = \nvoter_1_mnemonic = \nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\n\t# now we will open a file for writing\n\t\tdata_file = open('file.csv', 'w')\n\n\t# create the csv writer object\n\t\tcsv_writer = csv.writer(data_file)\n\n\t# Counter variable used for writing\n\t# headers to the CSV file\n\t\tcount = 0\n\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\n\t\t        # Writing headers of CSV file\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\n\t\t    # Writing data of CSV file\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t    # pass the file object to reader() to get the reader object\n\t\t\t\t\tdata = json.load(json_file)\n\t\t\t\t\ttransaction_data = data['transactions']\n\t\t\t\t\tfor transaction in transaction_data:\n\t\t\t\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\t\t\t\tamount = int(amount)\n\t\t\t\t\t\tamount = amount + amount * 0.12 #Rewards rate hardcoded\n\t\t\t\t\t\taddress = transaction['sender']\n\t\t\t\t\t\tid = transaction['id']\n\t\t\t\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"file_path": "https://github.com/N3koSempai/searching_algorand/blob/adb01b6981504f6a9df47966cec5b30348cbaca1/search-algorand.py", "code": "from methods import online\n\nimport threading\n\nimport re\nimport conn\nimport con_postg\nimport report\n\n\n\nclass Coinbot():\n\n    def __init__(self, select_coin, select_db):\n        \"\"\"set the initial variable\"\"\"\n        #initialize the database\n        if select_db == 'postgresql':\n            self.db = con_postg.DB()\n        else:\n            self.db = conn.DB()\n        self.db.start()\n        self.report = report.Report()\n        self.online = online.Online_method()\n        if select_coin == \"Algorand\":\n            from generators import algorand\n            self.crypto = algorand.Algobot()\n\n\n\n\n\n    def manager(self, iter, method):\n        \"\"\"The main method managed the iteration ,call other methods and save the result in the BD calling a Bd module\"\"\"\n        #result = self.check_method_online()\n\n        # vaiable for statistics\n        temp_match = 0\n        temp_nf = 0\n        temp_error = 0\n        temp_critical_error = 0\n        #how much iterations\n\n        if method == 'online':\n            for i in range(0,iter):\n                \n                #make call to the api online\n                keys = self.crypto.generate_keypair()\n                if keys[0] == False:\n                    print('critical error')\n                    exit()\n\n                result = self.online.check_method_online(keys)\n                \n                \n                # the answer is ok\n                if result[0] == 'ok':\n\n                    #the answer have amount or assets > 0\n                    print(result[1]['acuracy'])\n                    if result[1]['acuracy'] == 'good':\n                        self.db.added_match(200, result[1]['acuracy'], result[1]['direction'][0],result[1]['direction'][1],result[1]['amount'],result[1]['assets'])\n\n                    elif result[1]['acuracy'] == 'bad':\n                        self.db.added_match(200, result[1]['acuracy'], result[1]['direction'][0],result[1]['direction'][1])\n                    temp_match = temp_match + 1\n                elif result[0] == 'error_not_handler':\n                    try:\n                        self.db.added_error(result[1], result[2])\n                    except Exception as err:\n                        self.db.added_error('999', 'internal error when try to save error not handler: {miss}'.format(miss = err) )\n                    temp_error = temp_error + 1\n                elif result[0] == 'error':\n                    if result[1] == 'not_content':\n                        print('Critical error, not content found in the response of the api online \\n Are you connected to internet?')\n                        print('\\n status code: ', result[2])\n                        temp_critical_error = temp_critical_error + 1\n                        #remove this\n                        self.db.added_error(900, result[2])\n                        \n                    elif result[1] == 'Not Found':\n                        #normal error when the account is new\n                        #100 is for new address\n                        # not make nothing for now\n                        temp_nf = temp_nf + 1\n                        # \n                        self.db.added_error(900, result[2])\n                    \n                    elif result[1] == 'undeterminate for now':\n                        #900 for unidentified error\n\n                        # !!Atention!! . THIS CONDITIONAL WORK WITH ERROR. MAKE THE SAME OF 'NOT FOUND' COINDITIONAL\n                        \n\n                        # disable for make less petition to the database. now dont save the not found results, only stdistics save\n                        #print(self.db.added_error(900, result[2]['message']))\n                        \n                        temp_nf = temp_nf + 1\n\n\n                    # Area for insert new logs\n                    # determine if is the first 100 request (stadistics is save after 100 request)\n                if i == 100:\n\n                    self.db.added_std(False, temp_match,temp_nf,temp_error,temp_critical_error)\n                    self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n\n                    #more that 100 need update the session , not create a new session\n                elif i % 100 == 0 and i > 100:\n\n                    print(self.db.added_std(True, temp_match,temp_nf,temp_error,temp_critical_error))\n                    self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n\n\n            #send stadistics to the database when the loop is finished and iteration < 100\n            if iter < 100:\n                self.db.added_std(False, temp_match,temp_nf,temp_error,temp_critical_error)\n                self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n\n            elif iter > 100 and (iter - 1) % 100 != 0:\n                self.db.added_std(True, temp_match,temp_nf,temp_error,temp_critical_error)\n                self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n            \n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # options for get results in database or\n    options = []\n    print('Select your action \\n 1. search \\n 2. get report \\n 3. get match \\n 4. get_error')\n    x = int(input('write: '))\n    if x == 1:\n        options.append(1)\n    elif x == 2:\n        options.append(2)\n\n    elif x == 3:\n        options.append(3)\n\n    elif x == 4:\n        options.append(4)\n    else:\n        print('error')\n        exit()\n\n    if options[0] == 1:\n        print('Write the number of your objetive blockchain \\n 1. Algorand ')\n        x = int(input('number: '))\n        if x == 1:\n            options.append('Algorand')\n        else:\n            print('error')\n            exit()\n\n        print('Write the number of your database \\n 1. postgresql \\n 2. sqlite3')\n        x = int(input('number: '))\n        if x == 1:\n            options.append('postgresql')\n        elif x == 2:\n            options.append('sqlite')\n        else:\n            print('error')\n            exit()\n\n        print('Write the number of your method \\n 1. Online')\n        x = int(input('number: '))\n        if x == 1:\n            options.append('online')\n        else:\n            print('error')\n            exit()\n\n        print(\"set the iter number\")\n        try:\n            itern = int(input(\"max iter :  \"))\n        except:\n            print(\"write only integer numbers\")\n\n        Coin = Coinbot(options[1],options[2])\n        print(options)\n        Coin.manager(itern, options[3])\n        exit()\n\n\n    Coin = Coinbot('Algorand','postgresql')\n\n\n    if options[0] == 2:\n        print(Coin.db.getter_report())\n        exit()\n    elif options[0] == 3:\n        print(Coin.db.getter_match())\n        exit()\n    elif options[0] == 4:\n        print(Coin.db.getter_error())\n        exit()"}
{"file_path": "https://github.com/major/fedora-rpm-specs/blob/28cd4e4325ce70550cb235b8c2e28beefbf09fe5/specs/python-py-algorand-sdk.spec", "code": "%global pypi_name py-algorand-sdk\nName:           python-%{pypi_name}\nVersion:        2.8.0\nRelease:        1%{?dist}\nSummary:        Algorand Python SDK\nLicense:        MIT\n\nURL:            https://github.com/algorand/py-algorand-sdk\nSource0:        https://github.com/algorand/py-algorand-sdk/archive/v%{version}/py-algorand-sdk-%{version}.tar.gz\nSource1:        https://raw.githubusercontent.com/algorand/py-algorand-sdk/develop/LICENSE\n\nBuildArch:      noarch\n\nBuildRequires:  python3-devel\nBuildRequires:  python3-setuptools\nBuildRequires:  python3-pynacl\nBuildRequires:  python3-pycryptodomex\nBuildRequires:  python3-msgpack\n\n\n%description\nA python library for interacting with the Algorand network.\n\n%package -n python3-%{pypi_name}\nSummary:        %{summary}\n\n%description -n python3-%{pypi_name}\nA python library for interacting with the Algorand network.\n\n%prep\n%setup -q -n %{pypi_name}-%{version}\n\n\n%build\n%py3_build\n\ncp %{SOURCE1} .\n\n%install\n%py3_install\n\n%files -n python3-%{pypi_name}\n%license LICENSE\n%doc README.md\n%{python3_sitelib}/algosdk\n%{python3_sitelib}/py_algorand_sdk-%{version}-py%{python3_version}.egg-info\n\n%changelog\n* Fri Feb 14 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.8.0-1\n- 2.8.0\n\n* Sat Jan 18 2025 Fedora Release Engineering <releng@fedoraproject.org> - 2.7.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_42_Mass_Rebuild\n\n* Wed Jan 15 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.7.0-1\n- 2.7.0\n\n* Fri Jul 19 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.6.1-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_41_Mass_Rebuild\n\n* Wed Jun 12 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.1-1\n- 2.6.1\n\n* Sat Jun 08 2024 Python Maint <python-maint@redhat.com> - 2.6.0-2\n- Rebuilt for Python 3.13\n\n* Wed Jun 05 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.0-1\n- 2.6.0\n\n* Fri Jan 26 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild\n\n* Mon Jan 22 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild\n\n* Wed Sep 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.5.0-1\n- 2.5.0\n\n* Thu Aug 17 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.4.0-1\n- 2.4.0\n\n* Fri Jul 21 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.3.0-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_39_Mass_Rebuild\n\n* Thu Jun 15 2023 Python Maint <python-maint@redhat.com> - 2.3.0-2\n- Rebuilt for Python 3.12\n\n* Wed Jun 14 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.3.0-1\n- 2.3.0\n\n* Mon May 08 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.2.0-1\n- 2.2.0\n\n* Thu Mar 23 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.2-1\n- 2.1.2\n\n* Mon Mar 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.1-1\n- 2.1.1\n\n* Wed Mar 15 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.0-1\n- 2.1.0\n\n* Fri Mar 03 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-3\n- migrated to SPDX license\n\n* Fri Jan 20 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.0.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_38_Mass_Rebuild\n\n* Wed Jan 04 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-1\n- 2.0.0\n\n* Mon Dec 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.2-1\n- 1.20.2\n\n* Thu Nov 10 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.1-1\n- 1.20.1\n\n* Wed Nov 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.0-1\n- 1.20.0\n\n* Wed Oct 12 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.19.0-1\n- 1.19.0\n\n* Mon Sep 19 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.18.0-1\n- 1.18.0\n\n* Thu Aug 18 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.1-1\n- 1.16.1\n\n* Mon Jul 25 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.0-1\n- 1.16.0\n\n* Fri Jul 22 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.15.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_37_Mass_Rebuild\n\n* Wed Jul 06 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.15.0-1\n- 1.15.0\n\n* Mon Jun 13 2022 Python Maint <python-maint@redhat.com> - 1.13.1-2\n- Rebuilt for Python 3.11\n\n* Thu May 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.1-1\n- 1.13.1\n\n* Mon May 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.0-1\n- 1.13.0\n\n* Thu Apr 21 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.12.0-1\n- 1.12.0\n\n* Fri Jan 21 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.8.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_36_Mass_Rebuild\n\n* Wed Oct 06 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.8.0-1\n- 1.8.0\n\n* Wed Aug 04 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.7.0-1\n- 1.7.0\n\n* Fri Jul 23 2021 Fedora Release Engineering <releng@fedoraproject.org> - 1.6.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_35_Mass_Rebuild\n\n* Thu Jun 24 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.6.0-1\n- 1.6.0\n\n* Fri Jun 04 2021 Python Maint <python-maint@redhat.com> - 1.5.0-2\n- Rebuilt for Python 3.10\n\n* Thu Apr 22 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.5.0-1\n- 1.5.0\n\n* Tue Mar 09 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.4.1-1\n- Initial package."}
{"file_path": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py", "code": "#!/usr/bin/env python3\n\nimport setuptools\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"pyteal\",\n    version=\"0.27.0\",\n    author=\"Algorand\",\n    author_email=\"pypiservice@algorand.com\",\n    description=\"Algorand Smart Contracts in Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/algorand/pyteal\",\n    packages=setuptools.find_packages(\n        include=(\n            \"feature_gates\",\n            \"pyteal\",\n            \"pyteal.*\",\n        )\n    ),\n    install_requires=[\n        # when changing this list, also update docs/requirements.txt\n        \"docstring-parser==0.14.1\",\n        \"executing==2.0.1\",\n        \"py-algorand-sdk>=2.0.0,<3.0.0\",\n        \"semantic-version>=2.9.0,<3.0.0\",\n        \"tabulate>=0.9.0,<0.10.0\",\n    ],\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    package_data={\"pyteal\": [\"*.pyi\", \"py.typed\"]},\n    python_requires=\">=3.10\",\n)"}
{"file_path": "https://github.com/algorandfoundation/docs/blob/85a8af923b2377a6037652372caad238f7f26803/scripts/import_examples.py", "code": "#!/usr/bin/env python3\n\nimport os\nimport textwrap\nfrom dataclasses import dataclass\n\nSKIP_DIRS = [\".venv\", \"__pycache__\", \"node_modules\"]\n\n\n@dataclass\nclass ExampleSource:\n    \"\"\"Represents a source for examples\"\"\"\n\n    #: url to the github repo\n    github_url: str\n    #: branch name where examples can be found\n    git_branch: str\n    #: where to find the local repo\n    local_dir: str\n    #: where to find the example files\n    example_dir: str\n    #: full name of language\n    language_name: str\n    #: what to look for as a prefix in source examples\n    src_comment_flag: str\n    #: what file extensions to consider\n    file_extension: str\n    #: name for example source\n    name: str\n\n    def doc_comment_flag(self) -> str:\n        return f\"<!-- ==={self.name}_\"\n\n    def clone_url(self) -> str:\n        return f\"{self.github_url}.git\"\n\n    def file_url(self, file_name: str) -> str:\n        if file_name.startswith(self.example_path()):\n            file_name = file_name[len(self.example_path()) + 1 :]\n\n        return (\n            f\"{self.github_url}/blob/{self.git_branch}/{self.example_dir}/{file_name}\"\n        )\n\n    def example_path(self) -> str:\n        return f\"{self.local_dir}/{self.example_dir}\"\n\n\n@dataclass\nclass Example:\n    \"\"\"Represents a tagged example in source file\"\"\"\n\n    path: str\n    line_start: int\n    lines: list[str]\n    matches: int\n\n\n@dataclass\nclass DocExampleMatch:\n    \"\"\"Represents a match between source and docs\"\"\"\n\n    name: str\n    apply_tabs: bool\n    line_start: int\n    line_stop: int\n\n    @staticmethod\n    def empty() -> \"DocExampleMatch\":\n        return DocExampleMatch(\"\", False, 0, 0)\n\n\n# Example Name => source lines\nSDKExamples = dict[str, Example]\n\nsources: list[ExampleSource] = [\n    ExampleSource(\n        github_url=\"https://github.com/algorand/py-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../py-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"PYSDK\",\n        file_extension=\".py\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/js-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../js-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"javascript\",\n        src_comment_flag=\"// example: \",\n        name=\"JSSDK\",\n        file_extension=\".ts\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/go-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../go/src/github.com/algorand/go-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"go\",\n        src_comment_flag=\"\\t// example: \",\n        name=\"GOSDK\",\n        file_extension=\".go\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/java-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../java-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"java\",\n        src_comment_flag=\"// example: \",\n        name=\"JAVASDK\",\n        file_extension=\".java\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand-devrel/algorand-teal-examples\",\n        git_branch=\"examples\",\n        local_dir=\"../../algorand-teal-examples\",\n        example_dir=\"examples\",\n        language_name=\"teal\",\n        src_comment_flag=\"// example: \",\n        name=\"TEAL\",\n        file_extension=\".teal\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/barnjamin/pyteal\",\n        git_branch=\"examples\",\n        local_dir=\"../../pyteal\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"PYTEAL\",\n        file_extension=\".py\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand-devrel/beaker\",\n        git_branch=\"examples\",\n        local_dir=\"../../beaker\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"BEAKER\",\n        file_extension=\".py\",\n    ),\n]\n\n\ndef find_examples_in_sdk(dir: str, prefix: str, lang: str, ext: str) -> SDKExamples:\n    directory = os.listdir(dir)\n\n    name_to_src: SDKExamples = {}\n    for fname in directory:\n        if fname in SKIP_DIRS:\n            continue\n\n        path = os.path.join(dir, fname)\n        if not os.path.isfile(path):\n            name_to_src |= find_examples_in_sdk(path, prefix, lang, ext)\n        elif os.path.splitext(path)[-1] == ext:\n            local_example: list[str] = []\n            with open(path, \"r\") as f:\n                content = f.read()\n                if prefix not in content:\n                    continue\n\n                lines = content.splitlines()\n                for lno, line in enumerate(lines):\n                    if prefix in line:\n                        name = line.strip(prefix)\n                        formatted_example = textwrap.dedent(\n                            \"\\n\".join(local_example)\n                        ).split(\"\\n\")\n                        name_to_src[name] = Example(\n                            path=path,\n                            line_start=lno - len(local_example),\n                            lines=formatted_example,\n                            matches=0,\n                        )\n                        local_example = []\n                    else:\n                        local_example.append(line)\n\n    return name_to_src\n\n\ndef replace_matches_in_docs(\n    dir: str, prefix: str, examples: SDKExamples, src: ExampleSource\n):\n    \"\"\"recursively search in directory for string prefix\"\"\"\n    directory = os.listdir(dir)\n    for fname in directory:\n        path = os.path.join(dir, fname)\n        if not os.path.isfile(path):\n            # recurse through directories\n            replace_matches_in_docs(path, prefix, examples, src)\n            continue\n        elif path[-2:] != \"md\":\n            continue\n\n        page_lines: list[str] = []\n        matches: list[DocExampleMatch] = []\n        current_match = DocExampleMatch.empty()\n\n        with open(path, \"r\") as f:\n            content = f.read()\n            if prefix not in content:\n                continue\n\n            page_lines = content.splitlines()\n            for lno, line in enumerate(page_lines):\n                if prefix not in line:\n                    continue\n\n                # First time finding this one\n                if current_match.name == \"\":\n                    # Its in the tabbed multilanguage section\n                    if \"===\" in page_lines[lno - 1]:\n                        current_match.apply_tabs = True\n\n                    current_match.name = line.strip()[len(prefix) :].strip(\"= ->_\")\n                    current_match.line_start = lno + 1\n                # Second time finding it, add it to matches and wipe current\n                else:\n                    current_match.line_stop = lno\n                    matches.append(current_match)\n                    current_match = DocExampleMatch.empty()\n\n        if len(matches) == 0:\n            continue\n\n        # Need to track the offset here so we dont write to the\n        # wrong spot in the doc file if the example is longer or shorter\n        # than the current set of lines in the docs\n        offset = 0\n        for match in matches:\n\n            if match.name not in examples:\n                print(\n                    f\"Missing {match.name} in {prefix.strip(' -<!=_')} \"\n                    f\"examples (in {path}:{match.line_start})\"\n                )\n                continue\n\n            src_example = examples[match.name]\n\n            example_link = (\n                src.file_url(src_example.path)\n                + f\"#L{src_example.line_start}-\"\n                + f\"L{src_example.line_start + len(src_example.lines)}\"\n            )\n\n            example_lines = [\n                \"```\" + src.language_name,\n                *src_example.lines,\n                \"```\",\n                f\"[Snippet Source]({example_link})\",\n            ]\n\n            if match.apply_tabs:\n                example_lines = [\"\\t\" + l for l in example_lines]\n\n            page_lines[\n                match.line_start + offset : match.line_stop + offset\n            ] = example_lines\n\n            offset += len(example_lines) - (match.line_stop - match.line_start)\n\n            examples[match.name].matches += 1\n\n        with open(path, \"w\") as f:\n            f.write(\"\\n\".join(page_lines))\n\n    return examples\n\n\ndef ensure_source(src: ExampleSource):\n    import git\n\n    if not os.path.isdir(src.local_dir):\n        git.Repo.clone_from(src.clone_url(), src.local_dir, branch=src.git_branch)\n    else:\n        repo = git.Repo(src.local_dir)\n        repo.git.checkout(src.git_branch)\n\n\nif __name__ == \"__main__\":\n\n    names = [src.name for src in sources]\n\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Gather examples from source repos\")\n    parser.add_argument(\n        \"--src\",\n        metavar=\"name\",\n        type=str,\n        nargs=\"*\",\n        choices=names,\n        help=\"source names to pull (default: all)\",\n    )\n\n    args = parser.parse_args()\n    choices = args.src\n    if choices is None:\n        choices = names\n\n    for src in sources:\n        if src.name not in choices:\n            continue\n\n        ensure_source(src)\n\n        sdk_examples = find_examples_in_sdk(\n            src.example_path(),\n            src.src_comment_flag,\n            src.language_name,\n            src.file_extension,\n        )\n\n        replace_matches_in_docs(\"../docs\", src.doc_comment_flag(), sdk_examples, src)\n\n        for name, example in sdk_examples.items():\n            if example.matches == 0:\n                print(\n                    f\"Missing {name} for {src.language_name} in docs \"\n                    f\"(in: {example.path}:{example.line_start})\"\n                )"}
{"file_path": "https://github.com/demining/CryptoDeepTools/blob/206484942dbcf4b9996fa5bcc14181138c557697/17BTCRecoverCryptoGuide/utilities/algorand_recovery.py", "code": "# A really basic Algorand seed recovery script used in an assisted recovery. (May be incorporated to BTCRecover at some time)\n# Usage: Clone the py-algorand-sdk and place this file in the folder. Edit the test_seed_cut to match your seed.\n# Example below uses a seed with two words missing.\n\nfrom algosdk import mnemonic\n\ntest_seed = (\"dumb essay favorite judge punch hood anger under \"\n             \"talk earn anxiety follow scheme sea future response \"\n             \"asset drum size concert sand loan cupboard above bread\")\n\ntest_seed_cut = (\"dumb essay favorite judge punch hood anger under \"\n            \"talk earn anxiety follow scheme sea future response \"\n            \"asset drum size concert sand loan cupboard\")\n\n\ntest_address = \"LZW5ASZP2DQQGM77EFFUGXUF4DUQPUJEOC5HSQ2TOXKQZQM5H6M2OGK6QY\"\n\n\nif __name__ == \"__main__\":\n    word_list = mnemonic.wordlist.word_list_raw().split(\"\\n\")\n    word_list2 = mnemonic.wordlist.word_list_raw().split(\"\\n\")\n    print(\"Partial Seed: \" + test_seed_cut)\n    print(\"Searching for: \" + test_address)\n    for word in word_list:\n        for word2 in word_list2:\n            try:\n                if(mnemonic.to_public_key(test_seed_cut + \" \" + word + \" \" + word2) == test_address):\n                    print(\"Found At:\")\n                    print(test_seed_cut + \" \" + word + \" \" + word2)\n                    print()\n                    exit()\n            except:\n                pass"}
{"file_path": "https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/bip_utils/algorand/mnemonic/algorand_mnemonic_encoder.py", "code": "# Copyright (c) 2021 Emanuele Bellocchia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\"\"\"\nModule for Algorand mnemonic encoding.\nReference: https://github.com/algorand/py-algorand-sdk\n\"\"\"\n\n# Imports\nfrom typing import List\n\nfrom bip_utils.algorand.mnemonic.algorand_entropy_generator import AlgorandEntropyGenerator\nfrom bip_utils.algorand.mnemonic.algorand_mnemonic import AlgorandLanguages, AlgorandMnemonic\nfrom bip_utils.algorand.mnemonic.algorand_mnemonic_utils import AlgorandMnemonicUtils\nfrom bip_utils.bip.bip39.bip39_mnemonic_utils import Bip39WordsListGetter\nfrom bip_utils.utils.mnemonic import Mnemonic, MnemonicEncoderBase\n\n\nclass AlgorandMnemonicEncoder(MnemonicEncoderBase):\n    \"\"\"\n    Algorand mnemonic encoder class.\n    It encodes bytes to the mnemonic phrase.\n    \"\"\"\n\n    def __init__(self,\n                 lang: AlgorandLanguages = AlgorandLanguages.ENGLISH) -> None:\n        \"\"\"\n        Construct class.\n\n        Args:\n            lang (AlgorandLanguages, optional): Language (default: English)\n\n        Raises:\n            TypeError: If the language is not a AlgorandLanguages enum\n            ValueError: If loaded words list is not valid\n        \"\"\"\n        if not isinstance(lang, AlgorandLanguages):\n            raise TypeError(\"Language is not an enumerative of AlgorandLanguages\")\n        super().__init__(lang.value, Bip39WordsListGetter)\n\n    def Encode(self,\n               entropy_bytes: bytes) -> Mnemonic:\n        \"\"\"\n        Encode bytes to mnemonic phrase.\n\n        Args:\n            entropy_bytes (bytes): Entropy bytes\n\n        Returns:\n            Mnemonic object: Encoded mnemonic\n\n        Raises:\n            ValueError: If bytes length is not valid\n        \"\"\"\n\n        # Check entropy length\n        entropy_byte_len = len(entropy_bytes)\n        if not AlgorandEntropyGenerator.IsValidEntropyByteLen(entropy_byte_len):\n            raise ValueError(f\"Entropy byte length ({entropy_byte_len}) is not valid\")\n\n        # Compute checksum word\n        chksum_word_idx = AlgorandMnemonicUtils.ComputeChecksumWordIndex(entropy_bytes)\n        # Convert entropy bytes to a list of word indexes\n        word_indexes = AlgorandMnemonicUtils.ConvertBits(entropy_bytes, 8, 11)\n        # Cannot be None by converting bytes from 8-bit to 11-bit\n        assert word_indexes is not None\n        # Get mnemonic\n        return AlgorandMnemonic.FromList(self.__IndexesToWords(word_indexes + [chksum_word_idx]))\n\n    def __IndexesToWords(self,\n                         indexes: List[int]) -> List[str]:\n        \"\"\"\n        Get a list of words from a list of indexes.\n\n        Args:\n            indexes (list[int]): List of indexes\n\n        Returns:\n            list[str]: List of words\n        \"\"\"\n        return [self.m_words_list.GetWordAtIdx(idx) for idx in indexes]"}
{"file_path": "https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/algod.py", "code": "import json\nimport logging\nimport os\nfrom base64 import b64encode\nfrom pathlib import Path\nfrom pprint import PrettyPrinter\nfrom typing import Any, Dict, Final, Iterable, List, Optional, cast\n\nimport msgpack\nfrom algosdk import encoding\nfrom algosdk.atomic_transaction_composer import (\n    ABI_RETURN_HASH,\n    ABIResult,\n    AtomicTransactionComposer,\n    AtomicTransactionComposerStatus,\n    AtomicTransactionResponse,\n    abi,\n    base64,\n    error,\n    transaction,\n)\nfrom algosdk.error import AlgodHTTPError\nfrom algosdk.future.transaction import PaymentTxn, Transaction\nfrom algosdk.v2client import algod\nfrom pyk.kore.syntax import Pattern\n\nfrom kavm import constants\nfrom kavm.adaptors.algod_account import KAVMAccount\nfrom kavm.adaptors.algod_transaction import KAVMTransaction\nfrom kavm.kavm import KAVM\nfrom kavm.scenario import KAVMScenario, _sort_dict\n\n_LOGGER: Final = logging.getLogger(__name__)\n\n\ndef msgpack_decode_txn_list(enc: bytes) -> List[Transaction]:\n    \"\"\"\n    Decode a msgpack encoded object from a string.\n    Args:\n        enc (str): string to be decoded\n    Returns:\n        []Transaction, []SignedTransaction, []Multisig, []Bid, or []SignedBid:\\\n            decoded object\n\n    Note: This is the missing list decoder from py-algorand-sdk\n    \"\"\"\n    unpacker = msgpack.Unpacker()\n    unpacker.feed(enc)\n    deserialized = []\n    while unpacker.tell() < len(enc):\n        decoded = encoding.future_msgpack_decode(unpacker.unpack())\n        deserialized.append(decoded)\n    return deserialized\n\n\nclass KAVMClient(algod.AlgodClient):\n    \"\"\"\n    Mock class for algod. Forwards all requests to KAVM\n\n    Instead of establishing a connection with algod:\n    * initialize KAVM,\n    * pretend it is algod.\n    \"\"\"\n\n    def __init__(\n        self,\n        faucet_address: str,\n        algod_token: Optional[str] = None,\n        algod_address: Optional[str] = None,\n        log_level: Optional[int] = None,\n    ) -> None:\n        super().__init__(algod_token, algod_address)\n        self.pretty_printer = PrettyPrinter(width=41, compact=True)\n\n        # self._apps = AppCellMap()\n        self._committed_txns: Dict[str, Dict[str, Any]] = {}\n        self._faucet_address = faucet_address\n        self._accounts: Dict[str, KAVMAccount] = {\n            self._faucet_address: KAVMAccount(address=faucet_address, amount=constants.FAUCET_ALGO_SUPPLY)\n        }\n        self._decompiled_teal_dir_path = Path('./.decompiled-teal').resolve()\n        self._decompiled_teal_dir_path.mkdir(exist_ok=True)\n\n        self._app_creators: Dict[int, str] = {}\n        # Initialize KAVM, fetching the K definition dir from the environment\n        definition_dir = os.environ.get('KAVM_DEFINITION_DIR')\n        if definition_dir is not None:\n            self.kavm = KAVM(definition_dir=Path(definition_dir))\n            self.kavm.definition\n        else:\n            _LOGGER.critical('Cannot initialize KAVM: KAVM_DEFINITION_DIR env variable is not set')\n            exit(1)\n\n    def set_log_level(self, log_level: Any) -> None:\n        \"\"\"\n        Set log level for algod requests\n        \"\"\"\n        _LOGGER.setLevel(log_level)\n\n    def algod_request(\n        self,\n        method: str,\n        requrl: str,\n        params: Optional[List[str]] = None,\n        data: Optional[bytes] = None,\n        headers: Optional[List[str]] = None,\n        response_format: str = 'Json',\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Log requests made to algod, but execute local actions instead\n\n        Need to override this method, and the more specific methods using it can remain the same.\n        \"\"\"\n\n        if method == 'GET':\n            return self._handle_get_requests(requrl)\n        elif method == 'POST':\n            return self._handle_post_requests(requrl, data)\n        else:\n            raise NotImplementedError(f'{method} {requrl}')\n\n    def _handle_get_requests(self, requrl: str) -> Dict[str, Any]:\n        \"\"\"\n        Handle GET requests to algod with KAVM\n        \"\"\"\n        _, endpoint, *params = requrl.split('/')\n\n        if endpoint == 'transactions':\n            if params[0] == 'params':\n                return {\n                    'consensus-version': 31,\n                    'fee': 1000,\n                    'genesis-id': 'pyteal-eval',\n                    'genesis-hash': 'pyteal-evalpyteal-evalpyteal-evalpyteal-eval',\n                    'last-round': 1,\n                    'min-fee': 1000,\n                }\n            elif params[0] == 'pending':\n                if len(params) >= 2:\n                    try:\n                        return self._committed_txns[params[1]]\n                    # hack to temporarily make py-algorand-sdk happy:\n                    # if the txn id is not found, return the last committed txn\n                    except KeyError:\n                        (_, txn) = sorted(self._committed_txns.items())[-1]\n                        return txn\n                else:\n                    raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n            else:\n                raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n        elif endpoint == 'accounts':\n            if len(params) == 1:\n                address = params[0]\n                try:\n                    return self._accounts[address].dictify()\n                except KeyError:\n                    _LOGGER.warning(\n                        f'Account {address} is unknown to KAVM. Returing an account with the requested address and 0 balance to the client'\n                    )\n                    return KAVMAccount(address=address, amount=0).dictify()\n            else:\n                raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n        elif endpoint == 'applications':\n            app_id = int(params[0])\n            try:\n                creator_address = self._app_creators[app_id]\n            except KeyError as e:\n                raise ValueError(f'Cannot find creator of app {app_id}') from e\n            try:\n                result = list(filter(lambda app: app['id'] == app_id, self._accounts[creator_address].created_apps))\n                return result[0]\n            except (KeyError, IndexError) as e:\n                raise ValueError(\n                    f'Cannot find app with id {app_id} in account {self._accounts[creator_address]}'\n                ) from e\n        elif endpoint == 'status':\n            return {\n                'catchup-time': 0,\n                'last-round': 1000000000000000,\n                'last-version': 'kavm',\n                'next-version': 'kavm',\n                'next-version-round': 0,\n                'next-version-supported': True,\n                'stopped-at-unsupported-round': True,\n                'time-since-last-round': 0,\n                'last-catchpoint': 'kavm',\n                'catchpoint': 'kavm',\n                'catchpoint-total-accounts': 0,\n                'catchpoint-processed-accounts': 0,\n                'catchpoint-verified-accounts': 0,\n                'catchpoint-total-blocks': 0,\n                'catchpoint-acquired-blocks': 0,\n            }\n        else:\n            _LOGGER.debug(requrl.split('/'))\n            raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n    def _pending_transaction_info(self, txid: int) -> Dict[str, Any]:\n        \"\"\"\n        Fetch info about a pending transaction from KAVM\n\n        Fow now, we return any transction as confirmed\n\n        returns:\n            PendingTransactionResponse https://github.com/algorand/go-algorand/tree/master/daemon/algod/api/algod.oas2.json#L2600\n\n        \"\"\"\n        return {'confirmed-round': 1}\n\n    def _handle_post_requests(self, requrl: str, data: Optional[bytes]) -> Dict[str, Any]:\n        \"\"\"\n        Handle POST requests to algod with KAVM\n        \"\"\"\n        # handle transaction group submission\n        if requrl == '/transactions':\n            assert data is not None, 'attempt to submit an empty transaction group!'\n            # decode signed transactions from binary into py-algorand-sdk objects\n            txns = [t.transaction for t in msgpack_decode_txn_list(data)]\n            txn_msg = self.pretty_printer.pformat(txns)\n            f'POST {requrl} {txn_msg}'\n            # log decoded transaction as submitted\n\n            return self._eval_transactions(txns)\n\n            # _LOGGER.debug(proc_result.stdout)\n            # assert False\n\n            # return self.kavm.eval_transactions(kavm_txns, known_addresses)\n        elif requrl == '/teal/compile':\n            assert data is not None, 'attempt to compile an empty TEAL program!'\n            # we do not actually compile the program since KAVM needs the source code\n            return {'result': b64encode(data)}\n        else:\n            raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n    def intermediate_k_state(self) -> Pattern:\n        # Construct a json scenario with no transactions and execute just the setup-network stage\n        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=[])\n        final_state, kavm_stderr = self.kavm.run_avm_json(\n            scenario=scenario, existing_decompiled_teal_dir=self._decompiled_teal_dir_path, check=False, output=\"pretty\"\n        )\n        return final_state\n\n    def _eval_transactions(self, txns: List[Transaction]) -> Dict[str, str]:\n        \"\"\"\n        Evaluate a transaction group\n        Parameters\n        ----------\n        txns\n            List[Transaction]\n\n        Construct a simulation scenario, serialize it into JSON and submit to KAVM.\n        Parse KAVM's resulting configuration and update the account state in KAVMClient.\n        \"\"\"\n\n        # we'll need too keep track of all addresses the transactions mention to\n        # make KAVM aware of the new ones, so we preprocess the transactions\n        # to dicover new addresses and initialize them with 0 balance\n        for txn in txns:\n            if not txn.sender in self._accounts.keys():\n                self._accounts[txn.sender] = KAVMAccount(address=txn.sender, amount=0)\n            if hasattr(txn, 'receiver'):\n                txn = cast(PaymentTxn, txn)\n                if not txn.receiver in self._accounts.keys():\n                    self._accounts[txn.receiver] = KAVMAccount(address=txn.receiver, amount=0)\n\n        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=txns)\n        self._last_scenario = scenario\n\n        try:\n            final_state, kavm_stderr = self.kavm.run_avm_json(\n                scenario=scenario,\n                existing_decompiled_teal_dir=self._decompiled_teal_dir_path,\n            )\n        except RuntimeError as e:\n            _LOGGER.critical(\n                f'Transaction group evaluation failed, last generated scenario was: {json.dumps(scenario.dictify(), indent=4)}'\n            )\n            raise AlgodHTTPError(\n                msg='KAVM has failed, rerun witn --log-level=ERROR to see the executed JSON scenario'\n            ) from e\n\n        try:\n            # on succeful execution, the final state will be serialized and prineted to stderr\n            state_dump = json.loads(kavm_stderr)\n            assert type(state_dump) is dict\n        except json.decoder.JSONDecodeError as e:\n            _LOGGER.critical(f'Failed to parse the final state JSON: {e}')\n            raise AlgodHTTPError(msg='KAVM has failed, see logs for reasons') from e\n\n        _LOGGER.debug(f'Successfully parsed final state JSON: {json.dumps(state_dump, indent=4)}')\n        # substitute the tracked accounts by KAVM's state\n        self._accounts = {}\n        for acc_dict in KAVMScenario.sanitize_accounts(state_dump['accounts']):\n            acc_dict_translated = {KAVMAccount.inverted_attribute_map[k]: v for k, v in acc_dict.items()}\n            self._accounts[acc_dict_translated['address']] = KAVMAccount(**acc_dict_translated)\n            # update app creators\n            for addr, acc in self._accounts.items():\n                for app in acc.created_apps:\n                    self._app_creators[app['id']] = addr\n        # merge confirmed transactions with the ones received from KAVM\n        for txn in state_dump['transactions']:\n            self._committed_txns[txn['id']] = txn['params']\n        return {'txId': state_dump['transactions'][0]['id']}\n\n    def _construct_scenario(self, accounts: Iterable[KAVMAccount], transactions: Iterable[Transaction]) -> KAVMScenario:\n        \"\"\"Construct a JSON simulation scenario to run on KAVM\"\"\"\n        scenario = KAVMScenario.from_json(\n            scenario_json_str=json.dumps(\n                {\n                    \"stages\": [\n                        {\"stage-type\": \"setup-network\", \"data\": {\"accounts\": [acc.dictify() for acc in accounts]}},\n                        {\n                            \"stage-type\": \"submit-transactions\",\n                            \"data\": {\n                                \"transactions\": [\n                                    KAVMTransaction.sanitize_byte_fields(_sort_dict(txn.dictify()))\n                                    for txn in transactions\n                                ]\n                            },\n                            \"expected-returncode\": 0,\n                        },\n                    ]\n                }\n            ),\n            teal_sources_dir=self._decompiled_teal_dir_path,\n        )\n        return scenario\n\n\nclass KAVMAtomicTransactionComposer(AtomicTransactionComposer):\n    \"\"\"\n    This class overrides the 'execute' method of the base AtomicTransactionComposer class\n    by only introducing two lines of code which override the transactions IDs with\n    sequential integers (converted to strings). This is a requirement of KAVM's K implementation.\n    However, if a vanilla 'AlgodClient' is passed as 'clinet', the default transctions ids will be used\n    to maintain compatibility with go-algorand.\n    \"\"\"\n\n    def execute(self, client: algod.AlgodClient, wait_rounds: int) -> \"AtomicTransactionResponse\":\n        \"\"\"\n        Send the transaction group to the network and wait until it's committed\n        to a block. An error will be thrown if submission or execution fails.\n        The composer's status must be SUBMITTED or lower before calling this method,\n        since execution is only allowed once. If submission is successful,\n        this composer's status will update to SUBMITTED.\n        If the execution is also successful, this composer's status will update to COMMITTED.\n        Note: a group can only be submitted again if it fails.\n        Args:\n            client (AlgodClient): Algod V2 client\n            wait_rounds (int): maximum number of rounds to wait for transaction confirmation\n        Returns:\n            AtomicTransactionResponse: Object with confirmed round for this transaction,\n                a list of txIDs of the submitted transactions, and an array of\n                results for each method call transaction in this group. If a\n                method has no return value (void), then the method results array\n                will contain None for that method's return value.\n        \"\"\"\n        if self.status > AtomicTransactionComposerStatus.SUBMITTED:  # type: ignore\n            raise error.AtomicTransactionComposerError(\n                \"AtomicTransactionComposerStatus must be submitted or lower to execute a group\"\n            )\n\n        self.submit(client)\n        self.status = AtomicTransactionComposerStatus.SUBMITTED\n\n        # HACK: override the real transaction ids with sequential integers if running with KAVM\n        # leave them as is otherwise\n        if isinstance(client, KAVMClient):\n            self.tx_ids = [str(idx) for idx, _ in enumerate(self.txn_list)]\n\n        resp = transaction.wait_for_confirmation(client, self.tx_ids[0], wait_rounds)\n\n        self.status = AtomicTransactionComposerStatus.COMMITTED\n\n        confirmed_round = resp[\"confirmed-round\"]\n        method_results = []\n\n        for i, tx_id in enumerate(self.tx_ids):\n            raw_value = None\n            return_value = None\n            decode_error = None\n            tx_info = None\n\n            if i not in self.method_dict:\n                continue\n\n            # Parse log for ABI method return value\n            try:\n                tx_info = client.pending_transaction_info(tx_id)\n                if self.method_dict[i].returns.type == abi.Returns.VOID:\n                    method_results.append(\n                        ABIResult(\n                            tx_id=tx_id,\n                            raw_value=raw_value,\n                            return_value=return_value,\n                            decode_error=decode_error,\n                            tx_info=tx_info,\n                            method=self.method_dict[i],\n                        )\n                    )\n                    continue\n\n                logs = tx_info[\"logs\"] if \"logs\" in tx_info else []\n\n                # Look for the last returned value in the log\n                if not logs:\n                    raise error.AtomicTransactionComposerError(\"app call transaction did not log a return value\")\n                result = logs[-1]\n                # Check that the first four bytes is the hash of \"return\"\n                result_bytes = base64.b64decode(result)\n                if len(result_bytes) < 4 or result_bytes[:4] != ABI_RETURN_HASH:\n                    raise error.AtomicTransactionComposerError(\"app call transaction did not log a return value\")\n                raw_value = result_bytes[4:]\n                return_value = self.method_dict[i].returns.type.decode(raw_value)\n            except Exception as e:\n                decode_error = e\n                raise\n\n            abi_result = ABIResult(\n                tx_id=tx_id,\n                raw_value=raw_value,\n                return_value=return_value,\n                decode_error=decode_error,\n                tx_info=tx_info,\n                method=self.method_dict[i],\n            )\n            method_results.append(abi_result)\n\n        return AtomicTransactionResponse(\n            confirmed_round=confirmed_round,\n            tx_ids=self.tx_ids,\n            results=method_results,\n        )"}
{"file_path": "https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/setup.py", "code": "import setuptools\n\n\nwith open(\"README.md\", \"r\") as f:\n    long_description = f.read()\n\nsetuptools.setup(\n    name=\"tinyman-py-sdk\",\n    description=\"Tinyman Python SDK\",\n    author=\"Tinyman\",\n    author_email=\"hello@tinyman.org\",\n    version=\"2.1.1\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n    project_urls={\n        \"Source\": \"https://github.com/tinyman/tinyman-py-sdk\",\n    },\n    install_requires=[\"py-algorand-sdk >= 1.10.0\", \"requests >= 2.0.0\"],\n    packages=setuptools.find_packages(),\n    python_requires=\">=3.8\",\n    package_data={\n        \"tinyman.v1\": [\"asc.json\"],\n        \"tinyman.v2\": [\"amm_approval.map.json\", \"swap_router_approval.map.json\"],\n    },\n    include_package_data=True,\n)"}
{"file_path": "https://github.com/ChoiceCoin/Voting_DApp/blob/1cd5d81c8c6c96fdb542e399e184abe1512a2045/rewards/rewards.py", "code": "# Choice Coin Governance Rewards Code.\n\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nimport json\nimport urllib3\n\nchoice_id  = 297995609\nvoter_1_address = \"\"\nvoter_1_mnemonic = \"\"\nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\nalgod_client = algod.AlgodClient(\n    algod_token=\"\",\n    algod_address=\"https://api.algoexplorer.io\",\n    # see https://github.com/algorand/py-algorand-sdk/issues/169\n    headers={\"User-Agent\": \"DoYouLoveMe?\"}\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\t\tdata_file = open('file.csv', 'w')\n\t\tcsv_writer = csv.writer(data_file)\n\t\tcount = 0\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\t\tfor transaction in transaction_data:\n\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\tamount = int(amount)\n\t\t\tamount = amount + amount * 0.186 #Edit to match percentage\n\t\t\taddress = transaction['sender']\n\t\t\tid = transaction['id']\n\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"file_path": "https://github.com/algorand/indexer/blob/f64303b6b373ac30d57577f056e3dad8e956a009/misc/liveindextest.py", "code": "#!/usr/bin/env python3\n#\n# usage:\n#  python3 misc/liveindextest.py\n#\n# Requires go-algorand to be checked out on GOPATH.\n# Requires local postgresql and `createdb` `dropdb` standard utils.\n# `goal` etc should be built on PATH\n# `algorand-indexer` can be installed on PATH or at its development location from `make` or `go build` at cmd/algorand-indexer/algorand-indexer\n# pip install py-algorand-sdk\n#\n# The Test:\n# Create a local private Algorand network\n# Create a temporary postgres database for indexer\n# Run indexer following the primary algod\n# Submit a txn using py-algorand-sdk\n# Checks that indexer reports that txn by searching for it by txid.\n#\n# Runs in about 30 seconds on my macbook\n\nimport atexit\nimport base64\nimport glob\nimport logging\nimport os\nimport random\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport time\n\nimport algosdk\nimport algosdk.v2client\n\nfrom e2e_common.util import xrun, atexitrun, find_indexer, ensure_test_db\n\nlogger = logging.getLogger(__name__)\n\n\ndef find_go_algorand():\n    gopath = os.getenv(\"GOPATH\")\n    for path in gopath.split(\":\"):\n        goa = os.path.join(path, \"src\", \"github.com\", \"algorand\", \"go-algorand\")\n        if os.path.isdir(goa):\n            return goa\n    return None\n\n\nalready_stopped = False\nalready_deleted = False\n\n\ndef goal_network_stop(netdir, normal_cleanup=False):\n    global already_stopped, already_deleted\n    if already_stopped or already_deleted:\n        return\n\n    logger.info(\"stop network in %s\", netdir)\n    try:\n        xrun([\"goal\", \"network\", \"stop\", \"-r\", netdir], timeout=10)\n    except Exception as e:\n        logger.error(\"error stopping network\", exc_info=True)\n        if normal_cleanup:\n            raise e\n    already_stopped = True\n\n\ndef openkmd(algodata):\n    kmdnetpath = sorted(glob.glob(os.path.join(algodata, \"kmd-*\", \"kmd.net\")))[-1]\n    kmdnet = open(kmdnetpath, \"rt\").read().strip()\n    kmdtokenpath = sorted(glob.glob(os.path.join(algodata, \"kmd-*\", \"kmd.token\")))[-1]\n    kmdtoken = open(kmdtokenpath, \"rt\").read().strip()\n    kmd = algosdk.kmd.KMDClient(kmdtoken, \"http://\" + kmdnet)\n    return kmd\n\n\ndef openalgod(algodata):\n    algodnetpath = os.path.join(algodata, \"algod.net\")\n    algodnet = open(algodnetpath, \"rt\").read().strip()\n    algodtokenpath = os.path.join(algodata, \"algod.token\")\n    algodtoken = open(algodtokenpath, \"rt\").read().strip()\n    algod = algosdk.algod.AlgodClient(algodtoken, \"http://\" + algodnet)\n    return algod\n\n\nclass RunContext:\n    def __init__(self, env):\n        self.env = env\n        self.kmd = None\n        self.algod = None\n        self.lock = threading.Lock()\n        self.pubw = None\n        self.maxpubaddr = None\n\n    def connect(self):\n        with self.lock:\n            self._connect()\n            return self.algod, self.kmd\n\n    def _connect(self):\n        if self.algod and self.kmd:\n            return\n        # should run from inside self.lock\n        xrun([\"goal\", \"kmd\", \"start\", \"-t\", \"200\"], env=self.env, timeout=5)\n        algodata = self.env[\"ALGORAND_DATA\"]\n        self.kmd = openkmd(algodata)\n        self.algod = openalgod(algodata)\n\n    def get_pub_wallet(self):\n        with self.lock:\n            self._connect()\n            if not (self.pubw and self.maxpubaddr):\n                # find private test node public wallet and its richest account\n                wallets = self.kmd.list_wallets()\n                pubwid = None\n                for xw in wallets:\n                    if xw[\"name\"] == \"unencrypted-default-wallet\":\n                        pubwid = xw[\"id\"]\n                pubw = self.kmd.init_wallet_handle(pubwid, \"\")\n                pubaddrs = self.kmd.list_keys(pubw)\n                pubbalances = []\n                maxamount = 0\n                maxpubaddr = None\n                for pa in pubaddrs:\n                    pai = self.algod.account_info(pa)\n                    if pai[\"amount\"] > maxamount:\n                        maxamount = pai[\"amount\"]\n                        maxpubaddr = pai[\"address\"]\n                self.pubw = pubw\n                self.maxpubaddr = maxpubaddr\n            return self.pubw, self.maxpubaddr\n\n    def do_txn(self):\n        pubw, maxpubaddr = self.get_pub_wallet()\n        algod, kmd = self.connect()\n\n        # create a wallet with an addr to send to\n        walletname = base64.b16encode(os.urandom(16)).decode()\n        winfo = kmd.create_wallet(walletname, \"\")\n        handle = kmd.init_wallet_handle(winfo[\"id\"], \"\")\n        addr = kmd.generate_key(handle)\n\n        # send one million Algos to the test wallet's account\n        params = algod.suggested_params()\n        round = params[\"lastRound\"]\n        txn = algosdk.transaction.PaymentTxn(\n            sender=maxpubaddr,\n            fee=params[\"minFee\"],\n            first=round,\n            last=round + 100,\n            gh=params[\"genesishashb64\"],\n            receiver=addr,\n            amt=1000000000000,\n            flat_fee=True,\n        )\n        stxn = kmd.sign_transaction(pubw, \"\", txn)\n        txid = algod.send_transaction(stxn)\n        for i in range(50):\n            txinfo = algod.pending_transaction_info(txid)\n            if txinfo.get(\"round\"):\n                break\n            time.sleep(0.1)\n        return txid, txinfo\n\n\ndef main():\n    start = time.time()\n    import argparse\n\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--go-algorand\", help=\"path to go-algorand checkout\")\n    ap.add_argument(\n        \"--keep-temps\",\n        default=False,\n        action=\"store_true\",\n        help=\"if set, keep all the test files\",\n    )\n    ap.add_argument(\n        \"--indexer-bin\",\n        default=None,\n        help=\"path to algorand-indexer binary, otherwise search PATH\",\n    )\n    ap.add_argument(\n        \"--indexer-port\",\n        default=None,\n        type=int,\n        help=\"port to run indexer on. defaults to random in [4000,30000]\",\n    )\n    ap.add_argument(\n        \"--connection-string\",\n        help=\"Use this connection string instead of attempting to manage a local database.\",\n    )\n    ap.add_argument(\"--verbose\", default=False, action=\"store_true\")\n    args = ap.parse_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        logging.basicConfig(level=logging.INFO)\n\n    indexer_bin = find_indexer(args.indexer_bin)\n    goalgorand = args.go_algorand or find_go_algorand()\n\n    # env for child processes\n    env = dict(os.environ)\n\n    tempdir = os.getenv(\"TEMPDIR\")\n    if not tempdir:\n        tempdir = tempfile.mkdtemp()\n        env[\"TEMPDIR\"] = tempdir\n        logger.info(\"created TEMPDIR %r\", tempdir)\n        if not args.keep_temps:\n            # If we created a tmpdir and we're not keeping it, clean it up.\n            # If an outer process specified $TEMPDIR, let them clean it up.\n            atexit.register(shutil.rmtree, tempdir, onerror=logger.error)\n        else:\n            atexit.register(\n                print, \"keeping temps. to clean up:\\nrm -rf {}\".format(tempdir)\n            )\n\n    netdir = os.path.join(tempdir, \"net\")\n    env[\"NETDIR\"] = netdir\n\n    template = os.path.join(\n        goalgorand, \"test/testdata/nettemplates/TwoNodes50EachFuture.json\"\n    )\n    xrun(\n        [\"goal\", \"network\", \"create\", \"-r\", netdir, \"-n\", \"tbd\", \"-t\", template],\n        timeout=30,\n    )\n    xrun([\"goal\", \"network\", \"start\", \"-r\", netdir], timeout=30)\n    atexit.register(goal_network_stop, netdir)\n\n    algodata = os.path.join(netdir, \"Node\")\n    env[\"ALGORAND_DATA\"] = algodata\n\n    psqlstring = ensure_test_db(args.connection_string, args.keep_temps)\n    primary = os.path.join(netdir, \"Primary\")\n    aiport = args.indexer_port or random.randint(4000, 30000)\n    indexer_token = \"security-theater\"\n    indexerp = subprocess.Popen(\n        [\n            indexer_bin,\n            \"daemon\",\n            \"--algod\",\n            primary,\n            \"--postgres\",\n            psqlstring,\n            \"--dev-mode\",\n            \"--server\",\n            \":{}\".format(aiport),\n            \"--token\",\n            indexer_token,\n        ]\n    )\n    atexit.register(indexerp.kill)\n\n    rc = RunContext(env)\n    txid, txinfo = rc.do_txn()\n    logger.debug(\"submitted txid %s, %r\", txid, txinfo)\n\n    indexer = algosdk.v2client.indexer.IndexerClient(\n        indexer_token, \"http://localhost:{}\".format(aiport)\n    )\n    ok = False\n    retcode = 1\n    for i in range(30):\n        result = indexer.search_transactions(txid=txid)\n        logger.debug(\"seacrh_transactions: %r\", result)\n        they = result.get(\"transactions\")\n        if they and they[0].get(\"confirmed-round\"):\n            logger.info(\"OK: Got txn\")\n            ok = True\n            retcode = 0\n            break\n        time.sleep(1.0)\n\n    dt = time.time() - start\n    ok = (ok and \"OK\") or \"FAIL\"\n    sys.stdout.write(\"indexer live test {} ({:.1f}s)\\n\".format(ok, dt))\n    return retcode\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())"}
{"file_path": "https://github.com/peterkrull/algorand_vanity_farm/blob/16dcbc387892798e1522d3dda39118f990f51ad4/vanity_browse.py", "code": "# vanity_browser.py - lets you browse through the addresses found with vanity_farmer.py\n#\n# Depends on py-algorand-sdk which can be installed with:\n#\n# pip3 install py-algorand-sdk\n#\n# If you don't have pip3 you can install it with:\n#\n# apt install python3-pip\n\nimport json\nimport algosdk\n\ndef program():\n    open_file()\n    present_names()\n    user_input = present_publics()\n    present_privates(user_input)\n\ndef open_file():\n    global file_data\n    file_data = \"\"\n    try:\n        file_data = json.load(open(\"vanity_addresses\",'r'))\n    except FileNotFoundError as e:\n        print(\"No 'vanity_addresses' file found, exiting.\")\n        exit()\n\ndef present_names():\n    print(\"The following vanity addresses were generated.\")\n    print(\"Type the name of a vanity to view the addresses.\")\n    print(\"\")\n    names = []\n    for vanity in file_data:\n        names.append(vanity)\n    for i in range(len(names)):\n        length = []\n        try:\n            length.append(len(file_data[names[i]][\"A\"]))\n        except KeyError:\n            pass\n        try:\n            length.append(len(file_data[names[i]][\"E\"]))\n        except KeyError:\n            pass\n        try:\n            length.append(len(file_data[names[i]][\"B\"]))\n        except KeyError:\n            pass\n\n        sum_is = 0\n        for g in range(len(length)):\n            sum_is += length[g]\n        print(\"Found :\",names[i],sum_is,\"times\")\n\ndef present_publics():\n    user_input = input().upper()\n    names = []\n    print(\"\")\n    if user_input not in file_data:\n        print(\"The vanity '\",user_input,\"' was not an option. Exiting.\",sep=\"\")\n        exit() \n    for vanity in file_data:\n        names.append(vanity)\n        if user_input == vanity:\n            try:\n                temp = file_data[vanity][\"A\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' anywhere.\")\n                for i in range(len(temp)):\n                    print(\"A\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n\n            try:\n                temp = file_data[vanity][\"E\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' at the end.\")\n                for i in range(len(temp)):\n                    print(\"E\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n\n            try:\n                temp = file_data[vanity][\"B\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' at the beginning.\")\n                for i in range(len(temp)):\n                    print(\"B\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n            \n    return user_input\n\ndef present_privates(vanity):\n    print(\"\\nPlease type the letter and number in front your wanted address.\")\n    user_input = input()\n    try:\n        key = file_data[vanity][str(user_input[0]).upper()][str(user_input[1:])][\"private key\"]\n        print(\"\\nThe private mnemonic will now be shown. Make sure noone is watching\")\n        print(\"Press the enter key to continue\")\n        user_input_2 = input()\n        if user_input_2 != None:\n            print(\"--------------------------------------------------------------\")\n            print(algosdk.mnemonic.from_private_key(key))\n            print(\"\\n\",key,sep=\"\")\n            print(\"--------------------------------------------------------------\")\n            print(\"\\nREMEMBER! Keep these safe and private. Anyone with your keys can spend your money.\")\n            print(\"It is advised to write the mnemonic on a piece of paper and hide it somewhere safe.\")\n            print(\"\")\n            print(\"Press the enter key to exit program.\")\n        user_input_2 = input()\n        if user_input_2 != None:\n            pass\n            \n    except KeyError as e:\n        print(\"The input {} was not an option. Exiting.\".format(e))\n    except IndexError as e:\n         print(\"No valid input was given. Exiting.\")\n\nprogram()"}
{"file_path": "https://github.com/AustP/arc72/blob/7e67dd5486a1dd98ffc20b9f1063da7cd9869a1a/arc72.py", "code": "from pathlib import Path\n\nfrom Crypto.Hash import SHA512\nfrom pyteal import *\nfrom pyteal.ast.expr import Expr\nfrom pyteal.ir import TealSimpleBlock\n\nversion = \"v0.5.0\"\n\n################################################################################\n# Constants\n################################################################################\n\n\nHI4GE = Addr(\"HI4GEV4ZU32TGWUPKC5FKNCK6DZOLX2RRX4BVB3QG6WUHQ2UAS4GM3CN5U\")\nLAUNCH = Addr(\"LAUNCHPHD5NWWTDNVHOCFORJRFQYSY7UJWRF6A35LYMIDG4QHSHLGTMIEY\")\n\nBOOL_FALSE = Bytes(\"base16\", \"0x00\")\nBOOL_TRUE = Bytes(\"base16\", \"0x80\")\n\nBYTES_ONE = Bytes(\"base16\", \"0x01\")\nBYTES_ZERO = Bytes(\"base16\", \"0x00\")\n\nEVENT_APPROVAL = \"arc72_Approval(address,address,uint256)\"\nEVENT_APPROVAL_FOR_ALL = \"arc72_ApprovalForAll(address,address,bool)\"\nEVENT_MINT = \"highforge_Mint(address,uint256,uint64,uint64,uint64)\"\nEVENT_REVEAL = \"highforge_Reveal(uint256,byte[256])\"\nEVENT_TRANSFER = \"arc72_Transfer(address,address,uint256)\"\nEVENT_UPDATE_URI = \"highforge_UpdateURI(uint256,byte[256])\"\n\nINTERFACE_ARC72_CORE = Bytes(\"base16\", \"0x53f02a40\")\nINTERFACE_ARC72_ENUMERATION = Bytes(\"base16\", \"0xa57d4679\")\nINTERFACE_ARC72_MANAGEMENT = Bytes(\"base16\", \"0xb9c6f696\")\nINTERFACE_ARC72_METADATA = Bytes(\"base16\", \"0xc3c1fc00\")\nINTERFACE_MASK = Bytes(\"base16\", \"0xffffffff\")\nINTERFACE_SUPPORTS_INTERFACE = Bytes(\"base16\", \"0x4e22a3ba\")\n\nPREFIX_RETURN = Bytes(\"base16\", \"0x151f7c75\")\n\nLENGTH_ADDRESS = Int(32)\nLENGTH_BALANCE_BOX = Int(32)\nLENGTH_BOOL = Int(1)\nLENGTH_INDEX_BOX = Int(32)\nLENGTH_METADATA_URI = Int(256)\nLENGTH_NFT_BOX = Int(320)\nLENGTH_UINT256 = Int(32)\nLENGTH_UINT64 = Int(8)\nLENGTH_UINT8 = Int(1)\n\nMIN_BALANCE_APPROVAL_BOX = Int(2500 + (((2 * 32) + 1) * 400))\nMIN_BALANCE_INDEX_BOX = Int(2500 + (((1 + 32) + 32) * 400))\nMIN_BALANCE_NFT_BOX = Int(2500 + (((1 + 32) + 320) * 400))\nMIN_BALANCE_BALANCE_BOX = Int(2500 + (((1 + 32) + 32) * 400))\n\nLAUNCH_FEES = Global.min_txn_fee()\n\n################################################################################\n# Helper Functions\n################################################################################\n\n\nclass ABI_Method:\n    def __init__(self, abi, handler):\n        self._abi = abi\n        self._handler = handler\n\n        self._signature = (\n            abi[\"name\"]\n            + \"(\"\n            + \",\".join([arg[\"type\"] for arg in abi[\"args\"]])\n            + \")\"\n            + abi[\"returns\"][\"type\"]\n        )\n        self.selector = abi_method(self._signature)\n\n        print(abi[\"name\"], self.selector)\n\n    def handler(self):\n        args = {}\n        commands = []\n\n        length_map = {\n            \"account\": LENGTH_UINT8,\n            \"address\": LENGTH_ADDRESS,\n            \"asset\": LENGTH_UINT8,\n            \"bool\": LENGTH_BOOL,\n            \"byte[4]\": Int(4),\n            \"byte[256]\": Int(256),\n            \"uint256\": LENGTH_UINT256,\n            \"uint64\": LENGTH_UINT64,\n        }\n\n        for i, arg in enumerate(self._abi[\"args\"]):\n            args[arg[\"name\"]] = ScratchVar(\n                TealType.uint64 if arg[\"type\"] == \"asset\" else TealType.bytes\n            )\n\n            commands.append(\n                Assert(Len(Txn.application_args[i + 1]) == length_map[arg[\"type\"]])\n            )\n            commands.append(\n                args[arg[\"name\"]].store(\n                    Txn.accounts[Btoi(Txn.application_args[i + 1])]\n                    if arg[\"type\"] == \"account\"\n                    else (\n                        Txn.assets[Btoi(Txn.application_args[i + 1])]\n                        if arg[\"type\"] == \"asset\"\n                        else Txn.application_args[i + 1]\n                    )\n                )\n            )\n\n        return Seq(\n            *commands,\n            self._handler(args),\n        )\n\n\nclass EmptyExpr(Expr):\n    def __str__(self):\n        return \"\"\n\n    def __teal__(self, _):\n        start = TealSimpleBlock([])\n        end = start\n        return start, end\n\n    def has_return(self):\n        return False\n\n    def type_of(self):\n        return TealType.none\n\n\nclass NFT(EmptyExpr):\n    # NFT Box Structure\n    # owner - 32 bytes\n    # operator - 32 bytes\n    # metadata_uri - 256 bytes\n    box_length = LENGTH_NFT_BOX\n\n    field_indices = {\n        \"owner\": Int(0),\n        \"operator\": Int(32),\n        \"metadata_uri\": Int(64),\n    }\n\n    field_lengths = {\n        \"owner\": LENGTH_ADDRESS,\n        \"operator\": LENGTH_ADDRESS,\n        \"metadata_uri\": LENGTH_METADATA_URI,\n    }\n\n    def __init__(self, token_id):\n        self.box_name = Concat(Bytes(\"n\"), token_id)\n        self.token_id = token_id\n\n    def _emit(self, event, bytes):\n        return abi_event(event, bytes)\n\n    def approve(self, operator):\n        return Seq(\n            self.set(\"operator\", operator),\n            self.emit_approval(self.get(\"owner\"), operator),\n        )\n\n    def burn(self):\n        owner = ScratchVar(TealType.bytes)\n\n        return Seq(\n            owner.store(self.get(\"owner\")),\n            self.transfer(owner.load(), Global.zero_address()),\n            Assert(App.box_delete(self.box_name)),\n            send_algo(MIN_BALANCE_NFT_BOX, owner.load()),\n        )\n\n    def create(self, owner):\n        return Seq(\n            # create the NFT\n            Assert(Not(self.exists())),\n            Assert(App.box_create(self.box_name, self.box_length)),\n            self.transfer(Global.zero_address(), owner),\n        )\n\n    def emit_approval(self, owner, approved):\n        return self._emit(EVENT_APPROVAL, Concat(owner, approved, self.token_id))\n\n    def emit_transfer(self, from_, to):\n        return self._emit(\n            EVENT_TRANSFER,\n            Concat(\n                from_,\n                to,\n                self.token_id,\n            ),\n        )\n\n    def exists(self):\n        return Seq(length := App.box_length(self.box_name), length.hasValue())\n\n    def get(self, key):\n        return App.box_extract(\n            self.box_name, self.field_indices[key], self.field_lengths[key]\n        )\n\n    def is_revealed(self):\n        return self.get(\"metadata_uri\") != BytesZero(LENGTH_METADATA_URI)\n\n    def set(self, key, value):\n        return Seq(\n            Assert(Len(value) == self.field_lengths[key]),\n            App.box_replace(self.box_name, self.field_indices[key], value),\n        )\n\n    def transfer(self, from_, to):\n        return Seq(\n            self.set(\"owner\", to),\n            self.set(\"operator\", Global.zero_address()),\n            If(\n                from_ != Global.zero_address(),\n                Seq(\n                    contents := App.box_get(Concat(Bytes(\"b\"), from_)),\n                    Assert(contents.hasValue()),\n                    App.box_put(\n                        Concat(Bytes(\"b\"), from_),\n                        Btou256(BytesMinus(contents.value(), BYTES_ONE)),\n                    ),\n                ),\n            ),\n            Seq(\n                contents := App.box_get(Concat(Bytes(\"b\"), to)),\n                App.box_put(\n                    Concat(Bytes(\"b\"), to),\n                    Btou256(\n                        BytesAdd(\n                            If(contents.hasValue(), contents.value(), BYTES_ZERO),\n                            BYTES_ONE,\n                        )\n                    ),\n                ),\n            ),\n            self.emit_transfer(from_, to),\n        )\n\n\ndef Btou256(bytes):\n    return Concat(BytesZero(LENGTH_UINT256 - Len(bytes)), bytes)\n\n\ndef Itou256(int):\n    return Concat(BytesZero(LENGTH_UINT256 - LENGTH_UINT64), Itob(int))\n\n\ndef U256toi(bytes):\n    return Btoi(Extract(bytes, LENGTH_UINT256 - LENGTH_UINT64, LENGTH_UINT64))\n\n\ndef abi_event(signature, bytes):\n    return Log(Concat(abi_method(signature), bytes))\n\n\ndef abi_method(signature):\n    hash = SHA512.new(truncate=\"256\")\n    hash.update(signature.encode(\"utf-8\"))\n    selector = hash.hexdigest()[0:8]\n    return Bytes(\"base16\", \"0x\" + selector)\n\n\ndef abi_return(bytes=None):\n    return (\n        Seq(\n            Log(Concat(PREFIX_RETURN, bytes)),\n            Approve(),\n        )\n        if bytes is not None\n        else Approve()\n    )\n\n\ndef assert_is_creator():\n    return Assert(Txn.sender() == Global.creator_address())\n\n\ndef assert_is_launch():\n    return Assert(Txn.sender() == LAUNCH)\n\n\n@Subroutine(TealType.none)\ndef assert_mint_funding(index):\n    return Assert(\n        is_algo_txn(\n            index,\n            MIN_BALANCE_NFT_BOX  # for NFT storage\n            + MIN_BALANCE_INDEX_BOX  # for NFT lookup by index\n            + LAUNCH_FEES,  # to pay for LAUNCH's txn fees\n            Global.current_application_address(),\n        )\n    )\n\n\n@Subroutine(TealType.none)\ndef build_send_asset(assetID, amount, receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, assetID),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, receiver),\n    )\n\n\ndef closeout_algo(receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.amount, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.close_remainder_to, receiver),\n        InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef closeout_asset_to_creator(assetID):\n    assetCreator = AssetParam.creator(assetID)\n\n    return Seq(\n        assetCreator,\n        build_send_asset(assetID, Int(0), assetCreator.value()),\n        InnerTxnBuilder.SetField(TxnField.asset_close_to, assetCreator.value()),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef closeout_asset(assetID, receiver):\n    return Seq(\n        build_send_asset(assetID, Int(0), receiver),\n        InnerTxnBuilder.SetField(TxnField.asset_close_to, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef create_asset(assetName, unitName, total, assetURL, hash, manager, reserve):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetConfig),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.config_asset_total, total),\n        InnerTxnBuilder.SetField(TxnField.config_asset_decimals, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.config_asset_name, assetName),\n        InnerTxnBuilder.SetField(\n            TxnField.config_asset_unit_name,\n            unitName,\n        ),\n        InnerTxnBuilder.SetField(TxnField.config_asset_url, assetURL),\n        InnerTxnBuilder.SetField(TxnField.config_asset_metadata_hash, hash),\n        InnerTxnBuilder.SetField(TxnField.config_asset_manager, manager),\n        InnerTxnBuilder.SetField(TxnField.config_asset_reserve, reserve),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef distribute_payments(assetID, total):\n    artistAmount = ScratchVar(TealType.uint64)\n    charityAmount = ScratchVar(TealType.uint64)\n    launchpadAmount = ScratchVar(TealType.uint64)\n\n    return Seq(\n        # figure out how much charity gets\n        charityAmount.store(\n            If(\n                And(\n                    App.globalGet(Bytes(\"charityAddress\"))\n                    != Global.current_application_address(),\n                    App.globalGet(Bytes(\"charityPoints\")) > Int(0),\n                ),\n                get_cut(total, App.globalGet(Bytes(\"charityPoints\"))),\n                Int(0),\n            )\n        ),\n        # figure out how much the launchpad gets\n        launchpadAmount.store(get_cut(total, App.globalGet(Bytes(\"launchpadFee\")))),\n        artistAmount.store(total - launchpadAmount.load()),\n        If(\n            assetID == Int(0),\n            Seq(\n                # only payout to charity if it doesn't cause any errors\n                If(\n                    And(\n                        charityAmount.load(),\n                        artistAmount.load() >= charityAmount.load(),\n                        Or(\n                            charityAmount.load() >= Global.min_balance(),\n                            Balance(App.globalGet(Bytes(\"charityAddress\")))\n                            >= Global.min_balance(),\n                        ),\n                    ),\n                    Seq(\n                        artistAmount.store(artistAmount.load() - charityAmount.load()),\n                        send_algo(\n                            charityAmount.load(), App.globalGet(Bytes(\"charityAddress\"))\n                        ),\n                    ),\n                ),\n                send_algo(artistAmount.load(), Global.creator_address()),\n                send_algo(launchpadAmount.load(), HI4GE),\n            ),\n            Seq(\n                # only payout to charity if it doesn't cause any errors\n                If(\n                    And(\n                        charityAmount.load(),\n                        artistAmount.load() >= charityAmount.load(),\n                        Seq(\n                            opted_in := AssetHolding.balance(\n                                App.globalGet(Bytes(\"charityAddress\")),\n                                assetID,\n                            ),\n                            opted_in.hasValue(),\n                        ),\n                    ),\n                    Seq(\n                        artistAmount.store(artistAmount.load() - charityAmount.load()),\n                        send_asset(\n                            assetID,\n                            charityAmount.load(),\n                            App.globalGet(Bytes(\"charityAddress\")),\n                        ),\n                    ),\n                ),\n                send_asset(\n                    assetID,\n                    artistAmount.load(),\n                    Global.creator_address(),\n                ),\n                send_asset(assetID, launchpadAmount.load(), HI4GE),\n            ),\n        ),\n    )\n\n\n@Subroutine(TealType.uint64)\ndef get_cut(total, points):\n    return Btoi(BytesDiv(BytesMul(Itob(total), Itob(points)), Itob(Int(10000))))\n\n\n@Subroutine(TealType.uint64)\ndef is_algo_txn(index, amount, receiver):\n    return And(\n        Gtxn[index].type_enum() == TxnType.Payment,\n        Gtxn[index].close_remainder_to() == Global.zero_address(),\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].amount() == amount,\n        Gtxn[index].receiver() == receiver,\n    )\n\n\n@Subroutine(TealType.uint64)\ndef is_asset_txn(index, assetID, amount, receiver):\n    return And(\n        Gtxn[index].type_enum() == TxnType.AssetTransfer,\n        Gtxn[index].asset_close_to() == Global.zero_address(),\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].xfer_asset() == assetID,\n        Gtxn[index].asset_amount() == amount,\n        Gtxn[index].asset_receiver() == receiver,\n    )\n\n\ndef is_noop_txn(index, appID, method):\n    return And(\n        Gtxn[index].type_enum() == TxnType.ApplicationCall,\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].application_id() == appID,\n        Gtxn[index].on_completion() == OnComplete.NoOp,\n        Gtxn[index].application_args[0] == method,\n    )\n\n\n@Subroutine(TealType.bytes)\ndef nibble_to_ascii(nibble):\n    return Extract(\n        Itob(If(nibble < Int(10), Int(48) + nibble, Int(87) + nibble)), Int(7), Int(1)\n    )\n\n\ndef optin_asset(assetID):\n    return Seq(\n        build_send_asset(assetID, Int(0), Global.current_application_address()),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef send_algo(amount, receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.amount, amount),\n        InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef send_algo_cover_fee(amount, receiver):\n    return If(\n        And(\n            amount > Global.min_txn_fee(),\n            Balance(receiver) + amount - Global.min_txn_fee() >= Global.min_balance(),\n        ),\n        Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n            InnerTxnBuilder.SetField(TxnField.amount, amount - Global.min_txn_fee()),\n            InnerTxnBuilder.SetField(TxnField.fee, Global.min_txn_fee()),\n            InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n            InnerTxnBuilder.Submit(),\n        ),\n    )\n\n\ndef send_asset(assetID, amount, receiver):\n    return Seq(build_send_asset(assetID, amount, receiver), InnerTxnBuilder.Submit())\n\n\ndef sha_to_token_id(sha256):\n    byte = ScratchVar(TealType.uint64)\n    i = ScratchVar(TealType.uint64)\n    value = ScratchVar(TealType.bytes)\n\n    # todo:\n    # for each byte,\n    # mod it by 10\n    # convert that to ascii\n    # should be 32 bytes long\n    return Seq(\n        value.store(Bytes(\"\")),\n        i.store(Int(0)),\n        While(i.load() < Int(16)).Do(\n            Seq(\n                byte.store(GetByte(sha256, i.load())),\n                value.store(\n                    Concat(\n                        value.load(),\n                        nibble_to_ascii(byte.load() / Int(16)),\n                        nibble_to_ascii(byte.load() & Int(15)),\n                    )\n                ),\n                i.store(i.load() + Int(1)),\n            )\n        ),\n        value.load(),\n    )\n\n\n################################################################################\n# NoOp Branches\n################################################################################\n\n\ndef on_claim_algo():\n    claimableAlgo = Balance(Global.current_application_address()) - MinBalance(\n        Global.current_application_address()\n    )\n\n    return Seq(\n        assert_is_creator(),\n        send_algo(claimableAlgo, Global.creator_address()),\n        Approve(),\n    )\n\n\ndef on_claim_asset(assetID):\n    amount = AssetHolding.balance(Global.current_application_address(), assetID)\n\n    return Seq(\n        assert_is_creator(),\n        amount,\n        send_asset(\n            assetID,\n            amount.value(),\n            Global.creator_address(),\n        ),\n        Approve(),\n    )\n\n\ndef on_claim_wl_alt():\n    return on_claim_asset(App.globalGet(Bytes(\"wlAltID\")))\n\n\ndef on_claim_wl_token():\n    return on_claim_asset(App.globalGet(Bytes(\"wlTokenID\")))\n\n\ndef on_disable_whitelist():\n    return Seq(\n        assert_is_creator(),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            closeout_asset_to_creator(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        App.globalPut(Bytes(\"wlLaunchStart\"), Int(0)),\n        App.globalPut(Bytes(\"wlTokenID\"), Int(0)),\n        App.globalPut(Bytes(\"wlPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltID\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltPrice\"), Int(0)),\n        Approve(),\n    )\n\n\ndef on_enable_whitelist():\n    hash = ScratchVar(TealType.bytes)\n    i = ScratchVar(TealType.uint64)\n    name = ScratchVar(TealType.bytes)\n\n    return Seq(\n        assert_is_creator(),\n        Assert(Btoi(Txn.application_args[1]) < App.globalGet(Bytes(\"launchStart\"))),\n        App.globalPut(Bytes(\"wlLaunchStart\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"wlPrice\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"wlAltID\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"wlAltPrice\"), Btoi(Txn.application_args[4])),\n        App.globalPut(Bytes(\"wlMax\"), Btoi(Txn.application_args[5])),\n        hash.store(Sha256(Itob(Global.current_application_id()))),\n        name.store(Bytes(\"High Forge EA Token: 12345678901\")),\n        For(i.store(Int(0)), i.load() < Int(11), i.store(i.load() + Int(1))).Do(\n            name.store(\n                SetByte(\n                    name.load(),\n                    i.load() + Int(21),\n                    (GetByte(hash.load(), i.load()) % Int(26)) + Int(65),\n                ),\n            )\n        ),\n        create_asset(\n            name.load(),\n            Bytes(\"EARLY\"),\n            App.globalGet(Bytes(\"maxSupply\")) * Int(10),\n            Bytes(\"https://highforge.io\"),\n            Global.zero_address(),\n            Global.current_application_address(),\n            Global.current_application_address(),\n        ),\n        App.globalPut(Bytes(\"wlTokenID\"), InnerTxn.created_asset_id()),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            optin_asset(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        Approve(),\n    )\n\n\ndef on_set_charity():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"charityAddress\"), Txn.application_args[1]),\n        App.globalPut(Bytes(\"charityPoints\"), Btoi(Txn.application_args[2])),\n        Approve(),\n    )\n\n\ndef on_set_launch_dates():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"launchStart\"), Btoi(Txn.application_args[1])),\n        If(\n            Txn.application_args.length() == Int(3),\n            Seq(\n                Assert(App.globalGet(Bytes(\"wlTokenID\"))),\n                Assert(Btoi(Txn.application_args[2]) < Btoi(Txn.application_args[1])),\n                App.globalPut(Bytes(\"wlLaunchStart\"), Btoi(Txn.application_args[2])),\n            ),\n        ),\n        Approve(),\n    )\n\n\ndef on_set_launch_details():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"price\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"maxSupply\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"launchStart\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"launchEnd\"), Int(0)),  # for now, don't allow end date\n        # App.globalPut(Bytes(\"launchEnd\"), Btoi(Txn.application_args[4])),\n        Approve(),\n    )\n\n\ndef on_set_launch_paused():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"launchPaused\"), Btoi(Txn.application_args[1])),\n        Approve(),\n    )\n\n\ndef on_set_launchpad_fee():\n    return Seq(\n        assert_is_launch(),\n        App.globalPut(Bytes(\"launchpadFee\"), Btoi(Txn.application_args[1])),\n        Approve(),\n    )\n\n\ndef approveHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(Txn.sender() == nft.get(\"owner\")),\n        nft.approve(args[\"approved\"].load()),\n        abi_return(),\n    )\n\n\napprove = ABI_Method(\n    {\n        \"name\": \"arc72_approve\",\n        \"desc\": \"Approve a controller for a single NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"address\",\n                \"name\": \"approved\",\n                \"desc\": \"Approved controller address\",\n            },\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    approveHandler,\n)\n\n\ndef balanceOfHandler(args):\n    return Seq(\n        contents := App.box_get(Concat(Bytes(\"b\"), args[\"owner\"].load())),\n        abi_return(\n            If(contents.hasValue(), contents.value(), BytesZero(LENGTH_UINT256))\n        ),\n    )\n\n\nbalanceOf = ABI_Method(\n    {\n        \"name\": \"arc72_balanceOf\",\n        \"desc\": \"Returns the number of NFTs owned by an address\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"owner\"},\n        ],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    balanceOfHandler,\n)\n\n\ndef burnHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(Txn.sender() == nft.get(\"owner\")),\n        nft.burn(),\n        abi_return(),\n    )\n\n\nburn = ABI_Method(\n    {\n        \"name\": \"burn\",\n        \"desc\": \"Burns the specified NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    burnHandler,\n)\n\n\ndef getApprovedHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        abi_return(nft.get(\"operator\")),\n    )\n\n\ngetApproved = ABI_Method(\n    {\n        \"name\": \"arc72_getApproved\",\n        \"desc\": \"Get the current approved address for a single NFT\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"address\", \"desc\": \"address of approved user or zero\"},\n    },\n    getApprovedHandler,\n)\n\n\ndef isApprovedForAllHandler(args):\n    return Seq(\n        isOperator := App.box_length(\n            Concat(args[\"owner\"].load(), args[\"operator\"].load())\n        ),\n        abi_return(Itob(isOperator.hasValue())),\n    )\n\n\nisApprovedForAll = ABI_Method(\n    {\n        \"name\": \"arc72_isApprovedForAll\",\n        \"desc\": \"Query if an address is an authorized operator for another address\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"owner\"},\n            {\"type\": \"address\", \"name\": \"operator\"},\n        ],\n        \"returns\": {\n            \"type\": \"bool\",\n            \"desc\": \"whether operator is authorized for all NFTs of owner\",\n        },\n    },\n    isApprovedForAllHandler,\n)\n\n\ndef mintHandler(args):\n    assetID = ScratchVar(TealType.uint64)\n    paidAmount = ScratchVar(TealType.uint64)\n    receiptBox = ScratchVar(TealType.bytes)\n    receiptContent = ScratchVar(TealType.bytes)\n\n    return Seq(\n        # make sure the max supply has not been reached\n        Assert(App.globalGet(Bytes(\"totalMinted\")) < App.globalGet(Bytes(\"maxSupply\"))),\n        If(\n            # if creator is calling, ignore price, period, and paused status\n            Txn.sender() == Global.creator_address(),\n            Seq(\n                assetID.store(Int(0)),\n                paidAmount.store(Int(0)),\n                assert_mint_funding(Txn.group_index() - Int(1)),\n            ),\n            Seq(\n                # make sure the launch is not paused\n                Assert(App.globalGet(Bytes(\"launchPaused\")) == Int(0)),\n                # make sure the mint is not over. launchEnd == 0 means it never ends\n                Assert(\n                    Or(\n                        App.globalGet(Bytes(\"launchEnd\")) == Int(0),\n                        Global.latest_timestamp() < App.globalGet(Bytes(\"launchEnd\")),\n                    )\n                ),\n                If(\n                    # if the time is after the launch start, it's a normal mint\n                    Global.latest_timestamp() >= App.globalGet(Bytes(\"launchStart\")),\n                    Seq(\n                        # make sure they pay the mint price\n                        If(\n                            is_algo_txn(\n                                Txn.group_index() - Int(1),\n                                App.globalGet(Bytes(\"price\")),\n                                Global.current_application_address(),\n                            ),\n                            Seq(\n                                assetID.store(Int(0)),\n                                paidAmount.store(App.globalGet(Bytes(\"price\"))),\n                            ),\n                            Reject(),\n                        ),\n                        assert_mint_funding(Txn.group_index() - Int(2)),\n                    ),\n                    Seq(\n                        # make sure whitelist is enabled\n                        Assert(App.globalGet(Bytes(\"wlTokenID\"))),\n                        # make sure we are in the whitelist window\n                        Assert(\n                            Global.latest_timestamp()\n                            >= App.globalGet(Bytes(\"wlLaunchStart\"))\n                        ),\n                        # make sure white list is not maxed out\n                        Assert(\n                            Or(\n                                # wlMax == 0 means no limit\n                                App.globalGet(Bytes(\"wlMax\")) == Int(0),\n                                App.globalGet(Bytes(\"wlMinted\"))\n                                < App.globalGet(Bytes(\"wlMax\")),\n                            )\n                        ),\n                        # make sure they pay the whitelist token\n                        Assert(\n                            is_asset_txn(\n                                Txn.group_index() - Int(2),\n                                App.globalGet(Bytes(\"wlTokenID\")),\n                                Int(1),\n                                Global.current_application_address(),\n                            )\n                        ),\n                        # make sure they pay the mint price\n                        If(\n                            is_algo_txn(\n                                Txn.group_index() - Int(1),\n                                App.globalGet(Bytes(\"wlPrice\")),\n                                Global.current_application_address(),\n                            ),\n                            Seq(\n                                assetID.store(Int(0)),\n                                paidAmount.store(App.globalGet(Bytes(\"wlPrice\"))),\n                            ),\n                            If(\n                                And(\n                                    App.globalGet(Bytes(\"wlAltID\")),\n                                    is_asset_txn(\n                                        Txn.group_index() - Int(1),\n                                        App.globalGet(Bytes(\"wlAltID\")),\n                                        App.globalGet(Bytes(\"wlAltPrice\")),\n                                        Global.current_application_address(),\n                                    ),\n                                ),\n                                Seq(\n                                    assetID.store(App.globalGet(Bytes(\"wlAltID\"))),\n                                    paidAmount.store(\n                                        App.globalGet(Bytes(\"wlAltPrice\"))\n                                    ),\n                                ),\n                                Reject(),\n                            ),\n                        ),\n                        assert_mint_funding(Txn.group_index() - Int(3)),\n                        App.globalPut(\n                            Bytes(\"wlMinted\"), App.globalGet(Bytes(\"wlMinted\")) + Int(1)\n                        ),\n                    ),\n                ),\n            ),\n        ),\n        # send out everyone's cuts\n        distribute_payments(assetID.load(), paidAmount.load()),\n        # send algo to cover the revealing of the NFT\n        send_algo(LAUNCH_FEES, LAUNCH),\n        # create the receipt box and make sure it doesn't already exist\n        receiptBox.store(Concat(Bytes(\"r\"), args[\"tempTokenId\"].load())),\n        length := App.box_length(receiptBox.load()),\n        Assert(Not(length.hasValue())),\n        # we make the receipt box the same size as an NFT box\n        # that way the user covers the min-balance cost\n        # and during the reveal we can just replace the receipt box with the NFT box\n        Assert(App.box_create(receiptBox.load(), LENGTH_NFT_BOX)),\n        Assert(\n            App.box_create(\n                Concat(Bytes(\"t\"), args[\"tempTokenId\"].load()), LENGTH_INDEX_BOX\n            )\n        ),\n        receiptContent.store(\n            Concat(\n                Txn.sender(),\n                Itou256(App.globalGet(Bytes(\"nextMintID\"))),\n                Itob(assetID.load()),\n                Itob(paidAmount.load()),\n                Itob(Global.latest_timestamp()),\n            )\n        ),\n        App.box_replace(\n            receiptBox.load(),\n            Int(0),\n            receiptContent.load(),\n        ),\n        # emit the mint event\n        abi_event(EVENT_MINT, receiptContent.load()),\n        # update variables for next mint\n        App.globalPut(Bytes(\"nextMintID\"), App.globalGet(Bytes(\"nextMintID\")) + Int(1)),\n        App.globalPut(\n            Bytes(\"totalMinted\"), App.globalGet(Bytes(\"totalMinted\")) + Int(1)\n        ),\n        abi_return(Itou256(App.globalGet(Bytes(\"nextMintID\")) - Int(1))),\n    )\n\n\nmint = ABI_Method(\n    {\n        \"name\": \"highforge_mint\",\n        \"desc\": \"Attempts to mint an NFT for the user\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tempTokenId\",\n                \"desc\": \"A unique temporary token ID for the NFT\",\n            },\n        ],\n        \"returns\": {\n            \"type\": \"uint256\",\n            \"desc\": \"tokenId - The ID of the NFT that was minted\",\n        },\n    },\n    mintHandler,\n)\n\n\ndef ownerOfHandler(args):\n    nft = NFT(args[\"tokenId\"].load())\n\n    return abi_return(\n        If(\n            nft.exists(),\n            nft.get(\"owner\"),\n            Global.zero_address(),\n        )\n    )\n\n\nownerOf = ABI_Method(\n    {\n        \"name\": \"arc72_ownerOf\",\n        \"desc\": \"Returns the address of the current owner of the NFT with the given tokenId\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"address\", \"desc\": \"The current owner of the NFT.\"},\n    },\n    ownerOfHandler,\n)\n\n\ndef revealHandler(args):\n    receiptBox = ScratchVar(TealType.bytes)\n    sender = ScratchVar(TealType.bytes)\n    tokenId = ScratchVar(TealType.bytes)\n    collectionIndex = ScratchVar(TealType.bytes)\n\n    return Seq(\n        assert_is_launch(),\n        # load the receipt\n        receiptBox.store(Concat(Bytes(\"r\"), args[\"tempTokenId\"].load())),\n        length := App.box_length(receiptBox.load()),\n        Assert(length.hasValue()),\n        sender.store(App.box_extract(receiptBox.load(), Int(0), LENGTH_ADDRESS)),\n        tokenId.store(\n            App.box_extract(receiptBox.load(), LENGTH_ADDRESS, LENGTH_UINT256)\n        ),\n        # verify against the receipt\n        Assert(args[\"tokenId\"].load() == tokenId.load()),\n        # delete the receipt box\n        Assert(App.box_delete(receiptBox.load())),\n        Assert(App.box_delete(Concat(Bytes(\"t\"), args[\"tempTokenId\"].load()))),\n        # create the NFT\n        nft := NFT(args[\"tokenId\"].load()),\n        nft.create(sender.load()),\n        nft.set(\"metadata_uri\", args[\"tokenURI\"].load()),\n        # create the index lookup box\n        collectionIndex.store(\n            Itou256(U256toi(args[\"tokenId\"].load()) - Int(1)),\n        ),\n        length := App.box_length(Concat(Bytes(\"i\"), collectionIndex.load())),\n        Assert(Not(length.hasValue())),\n        App.box_put(Concat(Bytes(\"i\"), collectionIndex.load()), args[\"tokenId\"].load()),\n        # emit event and return\n        abi_event(\n            EVENT_REVEAL, Concat(args[\"tokenId\"].load(), args[\"tokenURI\"].load())\n        ),\n        abi_return(),\n    )\n\n\nreveal = ABI_Method(\n    {\n        \"name\": \"highforge_reveal\",\n        \"desc\": \"Reveals the NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tempTokenId\",\n                \"desc\": \"The temporary token ID\",\n            },\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tokenId\",\n                \"desc\": \"The actual token ID\",\n            },\n            {\n                \"type\": \"byte[256]\",\n                \"name\": \"tokenURI\",\n                \"desc\": \"The metadata URI for the token\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    revealHandler,\n)\n\n\ndef setApprovalForAllHandler(args):\n    return Seq(\n        If(\n            args[\"approved\"].load() == BOOL_TRUE,\n            Assert(\n                App.box_create(Concat(Txn.sender(), args[\"operator\"].load()), Int(1))\n            ),\n            If(\n                args[\"approved\"].load() == BOOL_FALSE,\n                Assert(App.box_delete(Concat(Txn.sender(), args[\"operator\"].load()))),\n                Reject(),\n            ),\n        ),\n        abi_event(\n            EVENT_APPROVAL_FOR_ALL,\n            Concat(\n                Txn.sender(),\n                args[\"operator\"].load(),\n                args[\"approved\"].load(),\n            ),\n        ),\n        abi_return(),\n    )\n\n\nsetApprovalForAll = ABI_Method(\n    {\n        \"name\": \"arc72_setApprovalForAll\",\n        \"desc\": \"Approve an operator for all NFTs for a user\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"address\",\n                \"name\": \"operator\",\n                \"desc\": \"Approved operator address\",\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"approved\",\n                \"desc\": \"true to give approval, false to revoke\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    setApprovalForAllHandler,\n)\n\n\ndef setupBalanceHandler(args):\n    return Seq(\n        Assert(\n            is_algo_txn(\n                Txn.group_index() - Int(1),\n                MIN_BALANCE_BALANCE_BOX,\n                Global.current_application_address(),\n            )\n        ),\n        length := App.box_length(Concat(Bytes(\"b\"), Txn.sender())),\n        If(\n            length.hasValue(),\n            send_algo_cover_fee(\n                MIN_BALANCE_BALANCE_BOX,\n                Gtxn[Txn.group_index() - Int(1)].sender(),\n            ),\n            Assert(\n                App.box_create(Concat(Bytes(\"b\"), Txn.sender()), LENGTH_BALANCE_BOX)\n            ),\n        ),\n        abi_return(),\n    )\n\n\nsetupBalance = ABI_Method(\n    {\n        \"name\": \"highforge_setupBalance\",\n        \"desc\": \"Makes sure that the balance box for the sender is set up\",\n        \"readonly\": False,\n        \"args\": [],\n        \"returns\": {\"type\": \"void\"},\n    },\n    setupBalanceHandler,\n)\n\n\ndef supportsInterfaceHandler(args):\n    return Seq(\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_SUPPORTS_INTERFACE,\n            abi_return(BOOL_TRUE),\n        ),\n        If(args[\"interfaceID\"].load() == INTERFACE_MASK, abi_return(BOOL_FALSE)),\n        If(args[\"interfaceID\"].load() == INTERFACE_ARC72_CORE, abi_return(BOOL_TRUE)),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_ENUMERATION,\n            abi_return(BOOL_TRUE),\n        ),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_MANAGEMENT,\n            abi_return(BOOL_TRUE),\n        ),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_METADATA,\n            abi_return(BOOL_TRUE),\n        ),\n        abi_return(BOOL_FALSE),\n    )\n\n\nsupportsInterface = ABI_Method(\n    {\n        \"name\": \"supportsInterface\",\n        \"desc\": \"Detects support for an interface specified by selector.\",\n        \"readonly\": True,\n        \"args\": [\n            {\n                \"type\": \"byte[4]\",\n                \"name\": \"interfaceID\",\n                \"desc\": \"The selector of the interface to detect.\",\n            },\n        ],\n        \"returns\": {\n            \"type\": \"bool\",\n            \"desc\": \"Whether the contract supports the interface.\",\n        },\n    },\n    supportsInterfaceHandler,\n)\n\n\ndef tokenByIndexHandler(args):\n    return Seq(\n        Assert(U256toi(args[\"index\"].load()) < App.globalGet(Bytes(\"totalMinted\"))),\n        contents := App.box_get(Concat(Bytes(\"i\"), args[\"index\"].load())),\n        Assert(contents.hasValue()),\n        abi_return(contents.value()),\n    )\n\n\ntokenByIndex = ABI_Method(\n    {\n        \"name\": \"arc72_tokenByIndex\",\n        \"desc\": \"Returns the token ID of the token with the given index among all NFTs defined by the contract\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"index\"},\n        ],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    tokenByIndexHandler,\n)\n\n\ndef tokenURIHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        abi_return(nft.get(\"metadata_uri\")),\n    )\n\n\ntokenURI = ABI_Method(\n    {\n        \"name\": \"arc72_tokenURI\",\n        \"desc\": \"Returns a URI pointing to the NFT metadata\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"byte[256]\", \"desc\": \"URI to token metadata.\"},\n    },\n    tokenURIHandler,\n)\n\n\ndef totalSupplyHandler(_):\n    return abi_return(Itou256(App.globalGet(Bytes(\"totalMinted\"))))\n\n\ntotalSupply = ABI_Method(\n    {\n        \"name\": \"arc72_totalSupply\",\n        \"desc\": \"Returns the number of NFTs currently defined by this contract\",\n        \"readonly\": True,\n        \"args\": [],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    totalSupplyHandler,\n)\n\n\ndef transferFromHandler(args):\n    owner = ScratchVar(TealType.bytes)\n\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        owner.store(nft.get(\"owner\")),\n        isOperator := App.box_length(Concat(owner.load(), Txn.sender())),\n        Assert(args[\"from\"].load() == owner.load()),\n        Assert(\n            Or(\n                Txn.sender() == nft.get(\"operator\"),\n                Txn.sender() == owner.load(),\n                isOperator.hasValue(),\n            )\n        ),\n        # we allow an optional txn before this one that covers the min balance\n        # cost for the balance box. if it already exists, we will refund it\n        If(\n            Txn.group_index() > Int(0),\n            If(\n                is_algo_txn(\n                    Txn.group_index() - Int(1),\n                    MIN_BALANCE_BALANCE_BOX,\n                    Global.current_application_address(),\n                ),\n                Seq(\n                    length := App.box_length(Concat(Bytes(\"b\"), args[\"to\"].load())),\n                    If(\n                        length.hasValue(),\n                        send_algo_cover_fee(\n                            MIN_BALANCE_BALANCE_BOX,\n                            Gtxn[Txn.group_index() - Int(1)].sender(),\n                        ),\n                    ),\n                ),\n            ),\n        ),\n        nft.transfer(owner.load(), args[\"to\"].load()),\n        abi_return(),\n    )\n\n\ntransferFrom = ABI_Method(\n    {\n        \"name\": \"arc72_transferFrom\",\n        \"desc\": \"Transfers ownership of an NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"from\"},\n            {\"type\": \"address\", \"name\": \"to\"},\n            {\"type\": \"uint256\", \"name\": \"tokenId\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    transferFromHandler,\n)\n\n\ndef updateTokenURIHandler(args):\n    return Seq(\n        assert_is_creator(),\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(nft.is_revealed()),\n        nft.set(\"metadata_uri\", args[\"tokenURI\"].load()),\n        abi_event(\n            EVENT_UPDATE_URI,\n            Concat(\n                args[\"tokenId\"].load(),\n                args[\"tokenURI\"].load(),\n            ),\n        ),\n        abi_return(),\n    )\n\n\nupdateTokenURI = ABI_Method(\n    {\n        \"name\": \"highforge_updateTokenURI\",\n        \"desc\": \"Allows the creator to update the token URI for a token\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n            {\n                \"type\": \"byte[256]\",\n                \"name\": \"tokenURI\",\n                \"desc\": \"The metadata URI for the token\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    updateTokenURIHandler,\n)\n\n\n################################################################################\n# OnComplete Branches\n################################################################################\n\n\ndef on_creation():\n    return Seq(\n        App.globalPut(Bytes(\"price\"), Int(0)),\n        # launch will be available when time >= launchStart\n        # it will go until maxSupply is reached OR time > launchEnd\n        App.globalPut(Bytes(\"maxSupply\"), Int(0)),\n        # (wl)launchStart and launchEnd are given in seconds since epoch\n        App.globalPut(Bytes(\"launchStart\"), Int(0)),\n        App.globalPut(Bytes(\"launchEnd\"), Int(0)),\n        App.globalPut(Bytes(\"launchPaused\"), Int(0)),\n        # whitelist will start when time > wlLaunchStart\n        # whitelist will end when time >= launchStart\n        App.globalPut(Bytes(\"wlLaunchStart\"), Int(0)),\n        App.globalPut(Bytes(\"wlTokenID\"), Int(0)),\n        App.globalPut(Bytes(\"wlPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltID\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlMax\"), Int(0)),\n        App.globalPut(Bytes(\"wlMinted\"), Int(0)),\n        # launchpad fee is in basis points (defaults to 2.5%)\n        App.globalPut(Bytes(\"launchpadFee\"), Int(250)),\n        App.globalPut(Bytes(\"nextMintID\"), Int(1)),\n        App.globalPut(Bytes(\"totalMinted\"), Int(0)),\n        App.globalPut(Bytes(\"charityAddress\"), Global.current_application_address()),\n        App.globalPut(Bytes(\"charityPoints\"), Int(0)),\n        Approve(),\n    )\n\n\ndef on_closeout():\n    return Reject()\n\n\ndef on_delete():\n    return Seq(\n        assert_is_creator(),\n        Assert(App.globalGet(Bytes(\"totalMinted\")) == Int(0)),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            closeout_asset_to_creator(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        closeout_algo(Global.creator_address()),\n        Approve(),\n    )\n\n\ndef on_noop():\n    return Cond(\n        [Txn.application_args[0] == Bytes(\"claimAlgo\"), on_claim_algo()],\n        [Txn.application_args[0] == Bytes(\"claimWLAlt\"), on_claim_wl_alt()],\n        [Txn.application_args[0] == Bytes(\"claimWLToken\"), on_claim_wl_token()],\n        [Txn.application_args[0] == Bytes(\"disableWL\"), on_disable_whitelist()],\n        [Txn.application_args[0] == Bytes(\"enableWL\"), on_enable_whitelist()],\n        [Txn.application_args[0] == Bytes(\"setCharity\"), on_set_charity()],\n        [Txn.application_args[0] == Bytes(\"setLaunchDates\"), on_set_launch_dates()],\n        [Txn.application_args[0] == Bytes(\"setLaunchDetails\"), on_set_launch_details()],\n        [Txn.application_args[0] == Bytes(\"setLaunchPaused\"), on_set_launch_paused()],\n        [Txn.application_args[0] == Bytes(\"setLaunchpadFee\"), on_set_launchpad_fee()],\n        [Txn.application_args[0] == approve.selector, approve.handler()],\n        [Txn.application_args[0] == balanceOf.selector, balanceOf.handler()],\n        [Txn.application_args[0] == burn.selector, burn.handler()],\n        [Txn.application_args[0] == getApproved.selector, getApproved.handler()],\n        [\n            Txn.application_args[0] == isApprovedForAll.selector,\n            isApprovedForAll.handler(),\n        ],\n        [Txn.application_args[0] == mint.selector, mint.handler()],\n        [Txn.application_args[0] == ownerOf.selector, ownerOf.handler()],\n        [Txn.application_args[0] == reveal.selector, reveal.handler()],\n        [\n            Txn.application_args[0] == setApprovalForAll.selector,\n            setApprovalForAll.handler(),\n        ],\n        [Txn.application_args[0] == setupBalance.selector, setupBalance.handler()],\n        [\n            Txn.application_args[0] == supportsInterface.selector,\n            supportsInterface.handler(),\n        ],\n        [Txn.application_args[0] == tokenByIndex.selector, tokenByIndex.handler()],\n        [Txn.application_args[0] == tokenURI.selector, tokenURI.handler()],\n        [Txn.application_args[0] == totalSupply.selector, totalSupply.handler()],\n        [Txn.application_args[0] == transferFrom.selector, transferFrom.handler()],\n    )\n\n\ndef on_optin():\n    return Reject()\n\n\ndef on_update():\n    return Seq(assert_is_launch(), Approve())\n\n\n################################################################################\n# Program Construction\n################################################################################\n\n\ndef approval_program():\n    program = Seq(\n        Assert(Txn.rekey_to() == Global.zero_address()),\n        Cond(\n            [Txn.application_id() == Int(0), on_creation()],\n            [Txn.on_completion() == OnComplete.CloseOut, on_closeout()],\n            [Txn.on_completion() == OnComplete.DeleteApplication, on_delete()],\n            [Txn.on_completion() == OnComplete.NoOp, on_noop()],\n            [Txn.on_completion() == OnComplete.OptIn, on_optin()],\n            [Txn.on_completion() == OnComplete.UpdateApplication, on_update()],\n        ),\n    )\n\n    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)\n\n\ndef clear_program():\n    program = on_closeout()\n    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)\n\n\np = Path(__file__).parent.absolute()\n(p / f\"arc72/{version}\").mkdir(exist_ok=True)\n\n\nwith open(f\"arc72/{version}/approval.teal\", \"w\") as f:\n    f.write(approval_program())\n\nwith open(f\"arc72/{version}/clear.teal\", \"w\") as f:\n    f.write(clear_program())\n\n\nimport base64, hashlib, subprocess\n\nsubprocess.run(\n    [\n        \"goal\",\n        \"clerk\",\n        \"compile\",\n        f\"arc72/{version}/approval.teal\",\n        \"-o\",\n        f\"arc72/{version}/approval.bin\",\n    ]\n)\nsubprocess.run(\n    [\n        \"goal\",\n        \"clerk\",\n        \"compile\",\n        f\"arc72/{version}/clear.teal\",\n        \"-o\",\n        f\"arc72/{version}/clear.bin\",\n    ]\n)\n\nwith open(f\"arc72/{version}/approval.bin\", \"rb\") as f:\n    contents = f.read()\n    print(\"approvalHash\", base64.b64encode(hashlib.sha256(contents).digest()).decode())\n    with open(f\"arc72/{version}/approval.b64\", \"w\") as f:\n        f.write(base64.b64encode(contents).decode())\n\nwith open(f\"arc72/{version}/clear.bin\", \"rb\") as f:\n    contents = f.read()\n    print(\"clearHash\", base64.b64encode(hashlib.sha256(contents).digest()).decode())\n    with open(f\"arc72/{version}/clear.b64\", \"w\") as f:\n        f.write(base64.b64encode(contents).decode())\n\nprint(\"\")\nprint(\"Copy approval.b64 and clear.b64 to algoseas-libs!!!\")"}
{"file_path": "https://github.com/cloud-travelx/workshop-labitconf-22/blob/4d4ddddeaafd6d59947202b7199f6684714d54a9/assets/nfticket/NFTicketManager.py", "code": "from typing import Final\n\nimport beaker as bkr\nfrom pyteal import *\n\n\nclass NFTicketManager(bkr.Application):\n    protocol: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.bytes,\n        static=True,\n        descr=\"Protocol fee account\",\n    )\n\n    protocol_fee: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.uint64,\n        default=Int(10),  # 1%\n        descr=\"Protocol Fee Percentage\",\n    )\n\n    supplier: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.bytes,\n        descr=\"Supplier account\",\n        static=True\n    )\n\n    supplier_share: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.uint64,\n        default=Int(1),\n        descr=\"Share of supplier on resale\"\n    )\n\n    @bkr.create\n    def create(self, protocol: abi.Account, supplier: abi.Account):\n        return Seq(\n            self.initialize_application_state(),\n            self.protocol.set(Txn.accounts[1]),\n            self.supplier.set(Txn.accounts[2])\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(protocol))\n    def set_up_asset(self, asset: abi.Asset):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset.asset_id(),\n                TxnField.asset_receiver: self.address,\n                TxnField.asset_amount: Int(0),\n                TxnField.fee: Int(0)\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(protocol))\n    def set_up_fee(self, supplier_share: abi.Uint64, protocol: abi.Uint64):\n        return Seq(\n            self.supplier_share.set(supplier_share.get()),\n            self.protocol_fee.set(protocol.get())\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def mint(self, name: abi.String, meta_url: abi.String, meta_hash: abi.String, *, output: abi.Uint64):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(0),\n                TxnField.config_asset_name: Concat(Bytes(\"NFTicket\"), name.get()),\n                TxnField.config_asset_unit_name: Bytes(\"NFTicket\"),\n                TxnField.config_asset_url: meta_url.get(),\n                TxnField.config_asset_metadata_hash: meta_hash.get(),\n                TxnField.config_asset_default_frozen: Int(1),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.fee: Int(0),\n            }),\n            InnerTxnBuilder.Submit(),\n\n            output.set(Gitxn[0].created_asset_id())\n        )\n\n    @bkr.internal(TealType.none)\n    def move_asset(self, asset, owner, to):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset,\n                TxnField.asset_sender: owner,\n                TxnField.asset_receiver: to,\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0),\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.internal(TealType.none)\n    def pay_share(self, asset, to, amount):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset,\n                TxnField.asset_receiver: to,\n                TxnField.asset_amount: amount,\n                TxnField.fee: Int(0)\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def redeem(self, asset: abi.Asset):\n        return self.move_asset(asset.asset_id(), self.address, Txn.sender())\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def withdraw(self, asset: abi.Asset, amount: abi.Uint64, to: abi.Account):\n        return self.pay_share(asset.asset_id(), to.address(), amount.get())\n\n    @bkr.external\n    def sell(self,\n             price: abi.Uint64,\n             nfticket: abi.Asset,\n             buyer: abi.Account,\n             protocol: abi.Account,\n             pay_asset: abi.Asset,\n             payment: abi.AssetTransferTransaction):\n        payment = payment.get()\n        return Seq(\n            # Payment to contract\n            #  (implicit) Payment asset\n            Assert(payment.asset_receiver() == self.address),\n            Assert(payment.xfer_asset() == pay_asset.asset_id()),\n\n            # Payment amount is sell price\n            Assert(payment.asset_amount() >= price.get()),\n\n            # Protocol Fee\n            Assert(self.protocol.get() == protocol.address()),\n            # (protocol_fee := ScratchVar(TealType.uint64)).store(price.get() * (self.protocol_fee.get() / Int(1000))),\n            (protocol_fee := abi.Uint64()).set(price.get() * self.protocol_fee.get() / Int(1000)),\n            # Pay to Protocol\n            self.pay_share(payment.xfer_asset(), protocol.address(), protocol_fee.get()),\n\n            # Seller profit\n            (sell_worth := abi.Uint64()).set(price.get() - protocol_fee.get()),\n            (supplier_share := abi.Uint64()).set(sell_worth.get() * self.supplier_share.get() / Int(1000)),\n            # Pay to seller\n            self.pay_share(payment.xfer_asset(), Txn.sender(), price.get() - supplier_share.get()),\n\n            # Move asset\n            #  (implicit check) Seller is owner\n            self.move_asset(nfticket.asset_id(), Txn.sender(), buyer.address())\n        )\n\n\nif __name__ == '__main__':\n    import sys\n    import json\n    import collections\n    from os import path\n\n    app = NFTicketManager()\n\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"--artifacts\":\n            app.dump(f\"{path.dirname(__file__)}/artifacts\")\n            exit(0)\n        if sys.argv[1] == \"--spec\":\n            spec = app.application_spec()\n\n\n            def cost(declared) -> collections.Counter:\n                return collections.Counter(map(lambda e: e[\"type\"], declared.values()))\n\n\n            print(cost(spec[\"schema\"][\"local\"][\"declared\"]))\n            print(cost(spec[\"schema\"][\"global\"][\"declared\"]))\n\n            sys.exit(0)\n        if sys.argv[1] == \"--abi\":\n            with open(__file__.replace(\".py\", \".abi.json\"), \"w\") as abi_fp:\n                json.dump(app.contract.dictify(), abi_fp, indent=2)\n\n    print(app.approval_program)"}
{"file_path": "https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/dao.py", "code": "from pathlib import Path\n\nfrom typing import Literal\n\n\n\nfrom beaker import *\n\nfrom beaker.lib.storage import BoxMapping\n\nfrom pyteal import *\n\n\n\n\n\nclass NFTProposal(abi.NamedTuple):\n\n    url: abi.Field[abi.String]\n\n    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]\n\n    name: abi.Field[abi.String]\n\n    unit_name: abi.Field[abi.String]\n\n    reserve: abi.Field[abi.Address]\n\n\n\n###############\n\n# DAO Contract\n\n###############\n\n\n\nclass DAOState:\n\n    # Global Storage\n\n    winning_proposal_votes = GlobalStateValue(\n\n        stack_type=TealType.uint64, default=Int(0)\n\n    )\n\n\n\n    winning_proposal = GlobalStateValue(stack_type=TealType.bytes, default=Bytes(\"\"))\n\n\n\n    # Box Storage\n\n    has_voted = BoxMapping(key_type=abi.Address, value_type=abi.Bool)\n\n    \n\n    proposals = BoxMapping(\n\n        key_type=abi.Tuple2[abi.Address, abi.Uint64],\n\n        value_type=NFTProposal,\n\n        prefix=Bytes(\"p-\"),\n\n    )\n\n\n\n    votes = BoxMapping(\n\n        key_type=abi.Tuple2[abi.Address, abi.Uint64],\n\n        value_type=abi.Uint64,\n\n        prefix=Bytes(\"v-\"),\n\n    )\n\n\n\ndao = Application(\"DAO\", state=DAOState)\n\n\n\n\n\n@dao.create(bare=True)\n\ndef create() -> Expr:\n\n    return dao.initialize_global_state()\n\n\n\n\n\n@dao.external\n\ndef add_proposal(\n\n    proposal: NFTProposal, proposal_id: abi.Uint64, mbr_payment: abi.PaymentTransaction\n\n) -> Expr:\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n    addr = abi.Address()\n\n\n\n    return Seq(\n\n        # Assert MBR payment is going to the contract\n\n        Assert(mbr_payment.get().receiver() == Global.current_application_address()),\n\n        # Get current MBR before adding proposal\n\n        pre_mbr := AccountParam.minBalance(Global.current_application_address()),\n\n        # Set proposal key\n\n        addr.set(Txn.sender()),\n\n        proposal_key.set(addr, proposal_id),\n\n        # Check if the proposal already exists\n\n        Assert(dao.state.proposals[proposal_key].exists() == Int(0)),\n\n        # Not using .get() here because desc is already a abi.String\n\n        dao.state.proposals[proposal_key].set(proposal),\n\n        # Verify payment covers MBR difference\n\n        current_mbr := AccountParam.minBalance(Global.current_application_address()),\n\n        Assert(mbr_payment.get().amount() >= current_mbr.value() - pre_mbr.value()),\n\n    )\n\n\n\n\n\n@dao.external\n\ndef vote(proposer: abi.Address, proposal_id: abi.Uint64) -> Expr:\n\n    total_votes = abi.Uint64()\n\n    current_votes = abi.Uint64()\n\n    true_value = abi.Bool()\n\n    zero_val = abi.Uint64()\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n\n\n    return Seq(\n\n        zero_val.set(Int(0)),\n\n        proposal_key.set(proposer, proposal_id),\n\n        # Make sure we haven't voted yet\n\n        Assert(dao.state.has_voted[Txn.sender()].exists() == Int(0)),\n\n        # Get current vote count\n\n        If(dao.state.votes[proposal_key].exists() == Int(0)).Then(\n\n            dao.state.votes[proposal_key].set(zero_val)\n\n        ),\n\n        dao.state.votes[proposal_key].store_into(current_votes),\n\n        # Increment and save total vote count\n\n        total_votes.set(current_votes.get() + Int(1)),\n\n        dao.state.votes[proposal_key].set(total_votes),\n\n        # Check if this proposal is now winning\n\n        If(total_votes.get() > dao.state.winning_proposal_votes.get()).Then(\n\n            dao.state.winning_proposal_votes.set(total_votes.get()),\n\n            dao.state.winning_proposal.set(proposal_key.encode()),\n\n        ),\n\n        # Set has_voted to true\n\n        true_value.set(value=True),\n\n        dao.state.has_voted[Txn.sender()].set(true_value),\n\n    )\n\n\n\n\n\n@dao.external\n\ndef mint(minter_app: abi.Application, *, output: abi.Uint64) -> Expr:\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n    proposal = NFTProposal()\n\n\n\n    return Seq(\n\n        # Get the winning proposal key\n\n        proposal_key.decode(dao.state.winning_proposal.get()),\n\n        # Get the winning proposal\n\n        dao.state.proposals[proposal_key].store_into(proposal),\n\n        # Call NFT minter\n\n        InnerTxnBuilder.ExecuteMethodCall(\n\n            app_id=Tmpl.Int(\"TMPL_MINTER_APP\"),\n\n            method_signature=f\"mint_nft({NFTProposal().type_spec()})uint64\",\n\n            args=[proposal],\n\n        ),\n\n        # Return created asset\n\n        output.set(Btoi(Suffix(InnerTxn.last_log(), Int(4)))),\n\n    )\n\n\n\n\n\n#####################\n\n# NFT Minter Contract\n\n#####################\n\n\n\nminter = Application(\"Minter\")\n\n\n\n\n\n@minter.external\n\ndef mint_nft(proposal: NFTProposal, *, output: abi.Uint64) -> Expr:\n\n    name = abi.String()\n\n    unit_name = abi.String()\n\n    reserve = abi.Address()\n\n    url = abi.String()\n\n    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])\n\n    abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n\n\n    return Seq(\n\n        # Get properties from proposal and mint NFT\n\n        proposal.name.store_into(name),\n\n        proposal.unit_name.store_into(unit_name),\n\n        proposal.reserve.store_into(reserve),\n\n        proposal.url.store_into(url),\n\n        proposal.metadata_hash.store_into(metadata_hash),\n\n        InnerTxnBuilder.Execute(\n\n            {\n\n                TxnField.type_enum: TxnType.AssetConfig,\n\n                TxnField.config_asset_name: name.get(),\n\n                TxnField.config_asset_unit_name: unit_name.get(),\n\n                TxnField.config_asset_reserve: reserve.get(),\n\n                TxnField.config_asset_url: url.get(),\n\n                TxnField.config_asset_metadata_hash: metadata_hash.encode(),\n\n                TxnField.config_asset_total: Int(1),\n\n                TxnField.fee: Int(0),\n\n            }\n\n        ),\n\n        # Return created asset\n\n        output.set(InnerTxn.created_asset_id()),\n\n    )\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    dao.build().export(Path(__file__).resolve().parent / f\"./artifacts/{dao.name}\")\n\n    minter.build().export(\n\n        Path(__file__).resolve().parent / f\"./artifacts/{minter.name}\"\n\n    )"}
{"file_path": "https://github.com/Sam2much96/algorand_python_Scripts/blob/8c9356be983ffb4b3d0f3221d33eaf4a7d118b6a/contracts/escrow/Box_storage_escrow_3.py", "code": "#!/usr/bin/env python3\n# *************************************************\n# godot3-Dystopia-game by INhumanity_arts\n# Released under MIT License\n# *************************************************\n# Box Storage Escrow Smart Contract\n#\n# An ARC 4 Abi Smart Contract\n# THe Entire SmartContract Logic in one File.\n# \n# Features:\n# (1) Box Storage\n# (2) Withdrawals\n# (3) Deposit\n# (4) NFT minting\n\n# To Do:\n# (1) Onchain Method Call \n# (2) Box Storage isn't yet supported in Algonaut Rust Crate, rewrite to use Global Storage\n\nfrom pyteal import *\nfrom beaker import *\n\nimport base64\nimport hashlib\nfrom base64 import b64encode, b64decode\n\nfrom typing import Final\n\n#from beaker.lib.storage import Mapping\n\n\n#beaker documentation : https://algorand-devrel.github.io/beaker/html/application_client.html\n\n\nfrom algosdk.v2client import algod\nfrom algosdk import mnemonic\nfrom beaker.client.application_client import ApplicationClient\nfrom beaker.client.logic_error import LogicException\nfrom beaker.consts import Algos\n\nfrom beaker.lib.storage import Mapping\n\nimport json\nfrom simple_smart_contract import create_app, compile_program, call_app, delete_app, pay, call_app_method, pay_construct, get_application_address, update_app\n\nfrom algosdk.future import transaction\nfrom algosdk.abi import Contract\n\nfrom algosdk.encoding import decode_address , encode_address\n\n# For running Teal inspector\nimport subprocess\n\n# Arc 4 Smart Contract\n\nclass BoxEscrow(Application):\n\n    #uses nonce https://www.investopedia.com/terms/n/nonce.asp\n    hashed_secret: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes,\n        descr=\"A scratch for saving secret nonce to application state\",\n    )\n    \n    #store transaction details to  boxes\n    \n \n    \n    #Bare app calls https://pyteal.readthedocs.io/en/stable/abi.html?highlight=registrable%20methods#registering-bare-app-calls\n    @Subroutine(TealType.none)  \n    def assert_sender_is_creator() -> Expr:\n        return Seq(\n            If(Txn.sender() == Global.creator_address())\n            .Then (\n\n                # If box Storage Exists, delete them\n                Pop(App.box_delete(Bytes(\"BoxA\"))),\n                Pop(App.box_delete(Bytes(\"BoxB\"))),\n                Pop(App.box_delete(Bytes(\"BoxC\")))    \n\n\n                )\n\n            )\n\n\n\n    # move any balance that the user has into the \"lost\" amount when they close out or clear state\n    transfer_balance_to_lost = App.globalPut(\n        Bytes(\"lost\"),\n        App.globalGet(Bytes(\"lost\")) + App.localGet(Txn.sender(), Bytes(\"balance\")),\n    )\n\n\n    \n                \n                \n                \n    \"\"\"\n    Docs:\n        https://pyteal.readthedocs.io/en/stable/abi.html?highlight=call_config#registering-methods\n \n    \"\"\"\n    \n    my_router = Router(\n    name=\"AlgoBank\",\n    bare_calls=BareCallActions(\n        # approve a creation no-op call \n        #no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),\n        no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),\n        # approve opt-in calls during normal usage, and during creation as a convenience for the creator\n        opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL),\n        # move any balance that the user has into the \"lost\" amount when they close out or clear state\n        close_out=OnCompleteAction(\n            action=transfer_balance_to_lost, call_config=CallConfig.CALL\n        ),\n        clear_state=OnCompleteAction(\n            action=transfer_balance_to_lost, call_config=CallConfig.CALL\n        ),\n        # only the creator can update or delete the app\n        update_application=OnCompleteAction(\n            action=assert_sender_is_creator, call_config=CallConfig.CALL\n        ),\n        delete_application=OnCompleteAction(\n            action=assert_sender_is_creator, call_config=CallConfig.CALL\n            ),\n        ),\n    )\n\n    @my_router.method(no_op=CallConfig.CALL, opt_in=CallConfig.CALL)\n    def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:\n        \"\"\"This method receives a payment from an account opted into this app and records it as a deposit.\n\n        The caller may opt into this app during this call.\n\n        Args:\n            payment: A payment transaction containing the amount of Algos the user wishes to deposit.\n                The receiver of this transaction must be this app's escrow account.\n            sender: An account that is opted into this app (or will opt in during this method call).\n                The deposited funds will be recorded in this account's local state. This account must\n                be the same as the sender of the `payment` transaction.\n        \"\"\"\n        return Seq(\n            Assert(payment.get().sender() == sender.address()),\n            Assert(payment.get().receiver() == Global.current_application_address()),\n\n\n        #Global Storage\n        App.globalPut(Bytes(\"Depositors\"), sender.address()),\n                \n\n        # Disabling Box Storage Until it's implemented in Algonaut\n\n        # write to box `A` with new value\n        # Deposit Address\n        #Pop(App.box_create(Bytes(\"BoxA\"), Int(10))),\n        #App.box_put(Bytes(\"BoxA\"), sender.address())\n\n        )\n\n\n    @my_router.method\n    def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:\n        \"\"\"Lookup the balance of a user held by this app.\n\n        Args:\n            user: The user whose balance you wish to look up. This user must be opted into this app.\n\n        Returns:\n            The balance corresponding to the given user, in microAlgos.\n        \"\"\"\n\n\n        return output.set(App.localGet(user.address(), Bytes(\"balance\")))\n\n\n    @my_router.method\n    def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:\n        \"\"\"Withdraw an amount of Algos held by this app.\n\n        The sender of this method call will be the source of the Algos, and the destination will be\n        the `recipient` argument.\n\n        The Algos will be transferred to the recipient using an inner transaction whose fee is set\n        to 0, meaning the caller's transaction must include a surplus fee to cover the inner\n        transaction.\n\n        Args:\n            amount: The amount of Algos requested to be withdraw, in microAlgos. This method will fail\n                if this amount exceeds the amount of Algos held by this app for the method call sender.\n            recipient: An account who will receive the withdrawn Algos. This may or may not be the same\n                as the method call sender.\n        \"\"\"\n        return Seq(\n\n            If(Txn.sender() != Global.creator_address()) \n\n            .Then( \n\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields(\n                    {\n                        TxnField.type_enum: TxnType.Payment,\n                        TxnField.receiver: recipient.address(),\n                        TxnField.amount: amount.get(),\n                        TxnField.fee: Int(0),\n                    }\n                ),\n                InnerTxnBuilder.Submit(),\n\n                #Global Storage\n                App.globalPut(Bytes(\"Withdrwl\"), amount.get()),\n                \n                App.globalPut(Bytes(\"Receipient\"), recipient.address()),\n                \n                \n                # Disabling Box Storages until it'simplemented in Algonaut\n\n                # write to box `B` with new value \"Withdrawal Amount\"\n                # converted from an Integer to a Byte\n                # App.box_put(Bytes(\"BoxB\"), Itob(amount.get())),\n                \n                # write to box `C` with new value \"Withdrawal To Address\"\n                #App.box_put(Bytes(\"BoxC\"), recipient.address())\n                )\n            .ElseIf( Txn.sender() == Global.creator_address())\n            .Then(Approve())\n        )\n\n\n    \n    #    \"\"\"\n    #    Triggers an Abi method call via smartcontracts\n\n\n    #    Args:\n    #        Abi Arguments to this method via BareApp calls\n\n    #    Docs: https://pyteal.readthedocs.io/en/stable/api.html?highlight=MethodCall#pyteal.InnerTxnBuilder.MethodCall\n\n    #    \"\"\"\n\n\n\n\n    @my_router.method\n    def mint(recipient : abi.Account, payment: abi.PaymentTransaction) -> Expr:\n        \"\"\"Mints an Asset Token To a Recipient Wallet Address\n            the caller's transaction must include a surplus fee to cover the inner\n            transaction\n\n        Args:\n            recipient: An account who will receive the withdrawn Algos. This may or may not be the same \n            as the method call sender.\n\n        Docs: https://pyteal.readthedocs.io/en/stable/api.html#pyteal.TxnExpr\n\n        \"\"\"\n\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(1),\n                TxnField.config_asset_unit_name: Bytes(\"PUNK 001\"),\n                TxnField.config_asset_name: Bytes(\"CryptoPunk\"),\n                TxnField.config_asset_url: Bytes(\"ipfs://QmXYApu5uDsfQHMx149LWJy3x5XRssUeiPzvqPJyLV2ABx\"), #CryptoPunk Asset CID\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n            }),\n            InnerTxnBuilder.Submit(),\n\n            #Bug for Testing debug state\n\n            #InnerTxnBuilder.Begin(),\n            #InnerTxnBuilder.SetFields({\n            #    TxnField.type_enum: TxnType.AssetTransfer,\n            #   TxnField.asset_receiver: recipient.address(),\n            #    TxnField.asset_amount: Int(1),\n            #    TxnField.xfer_asset: Txn.assets[0], # Must be in the assets array sent as part of the application call\n            #}),\n            #InnerTxnBuilder.Submit(),\n\n        )\n\n\n\n    approval_program, clear_state_program, contract = my_router.compile_program(\n        version=8, optimize=OptimizeOptions(scratch_slots=True)\n    )\n\n\n\n\n\n    \"\"\"\n    Write Out the Approval and Clear Programs. \n    Dump the Contract's method to a .json file.\n\n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"w\") as f:\n        f.write(approval_program)\n\n    with open(\"algobank_clear_state.teal\", \"w\") as f:\n        f.write(clear_state_program)\n        \n    with open(\"algobank.json\", \"w\") as f:\n        f.write(json.dumps(contract.dictify(), indent=4))\n\n\n\n\n\n\n\n\n\n    \n\n# Sha 265 Hashes a String\ndef sha256b64(s: str) -> str:\n    return base64.b64encode(hashlib.sha256(str(s).encode(\"utf-8\")).digest()).decode(\"utf-8\")\n\n#Configured to Testnet\n#\n#\ndef create_algorand_node_and_acct(command: str):\n    \n    # test-net\n    algod_address = \"https://node.testnet.algoexplorerapi.io\"\n    algod_token = \"\"\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n\n\n    _params = algod_client.suggested_params()\n\n    __mnemonic : str = \"tank game arrive train bring taxi tackle popular bacon gasp tell pigeon error step leaf zone suit chest next swim luggage oblige opinion about execute\"\n\n    __mnemonic_2 : str = \"degree feature waste gospel screen near subject boost wreck proof caution hen adapt fiber fault level blind entry also embark oval board bunker absorb garage\"\n\n    __mnemonic_3 : str = \"scrub garment fashion column property obscure agree mobile maple stage pass boat snow diary canyon lesson under curtain impact earn calm maximum song ability together\"\n\n\n    #For Sandbox\n    #client = sandbox.get_algod_client()\n\n    #accts = sandbox.get_accounts()\n\n    accts = {}\n    accts[1] = {}\n    accts[1]['pk'] = mnemonic.to_public_key(__mnemonic) #saves the new account's address\n    accts[1]['sk'] = mnemonic.to_private_key(__mnemonic) #saves the new account's mnemonic\n    \n    mnemonic_obj_a1 = mnemonic.to_private_key(__mnemonic)\n    mnemonic_obj_a2 = mnemonic.to_public_key(__mnemonic)\n    \n    #acct = accts.pop()\n\n    print('Algod Client Status: ',algod_client.status())\n\n    print (accts[1])\n\n    #other accounts\n    accts[2] = {}\n    accts[2]['pk'] = mnemonic.to_public_key(__mnemonic_2)\n    accts[2]['sk'] = mnemonic.to_private_key(__mnemonic_2)\n\n    accts[3] = {}\n    accts[3]['pk'] = mnemonic.to_public_key(__mnemonic_3)\n    accts[3]['sk'] = mnemonic.to_private_key(__mnemonic_3)\n\n\n\n    mnemonic_obj_b1 = mnemonic.to_private_key(__mnemonic_2)\n    mnemonic_obj_b2 = mnemonic.to_public_key(__mnemonic_2)\n    \n\n\n    # Create an Application client containing both an algod client and my app\n    \n    app_client = algod.AlgodClient(algod_token, algod_address,headers={'User-Agent': 'DoYouLoveMe?'})\n\n    \n\n    _app_id : int = 157718578  \n\n    escrow_address =get_application_address(_app_id)\n\n    pc :int = 79\n\n    print('Algod Client Status: ',algod_client.status())\n\n    command = input(\"Enter command  [deploy,pay,withdraw,deposit,mint,fetch, fetch2, balance, delete, update ,debug ]  \")\n    \n    \"*****************Perform Transactions Operations**********************\"\n\n    match command:\n        case \"deploy\":\n\n            \n\n\n\n            \"Deploy Smart Contract\"\n            deploy(_params, accts[1]['sk'],algod_client, 2500)\n        case \"delete\":\n    \n            \"Delete Smart Contract\"\n            delete_app(algod_client, accts[1]['sk'], _app_id)\n        case \"pay\" :\n        \n            \n\n            \"Pay to Account\"\n            pay(algod_client, accts[1]['sk'], escrow_address, 1101101)\n\n        case \"withdraw\":\n    \n            \n            call_app_method(app_client,accts[3]['sk'],_app_id, 2500,get_method(\"withdraw\"), 10_000,accts[3]['pk'] )\n\n        case \"deposit\":\n\n        \n\n            print (\"depositing 101100 MicroAlgos to Escrow Address \", escrow_address)\n\n            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)\n\n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"deposit\"), txn ,accts[2]['pk'] )\n        case \"update\":\n\n\n            update_(app_client, _app_id, _params,accts[1]['sk'])\n\n\n        case \"mint\":\n\n            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)            \n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"mint\"), accts[2]['pk'] ,txn )\n            \n\n        case \"fetch\" :\n            \n            #Prints Withdrawal & Deposit Information from box storage as Raw Bytes\n            \n\n            print(\"Withdrawal Amounts: \",app_client.application_box_by_name(_app_id,bytes(\"BoxB\".encode('utf-8', 'strict'))))\n\n            print(\"Withdrawal recipients: \",app_client.application_box_by_name(_app_id,bytes(\"BoxC\".encode('utf-8', 'strict'))))\n  \n            print(\"Depositors Address: \", app_client.application_box_by_name(_app_id,bytes(\"BoxA\".encode('utf-8', 'strict'))))\n\n        case \"fetch2\" :\n            #Prints Withdrawal & Deposit Information from box storage Decoded to Int and String\n            #Documentation: https://developer.algorand.org/docs/get-details/encoding/\n            \n            result2 = app_client.application_box_by_name(_app_id,bytes(\"BoxC\".encode('utf-8', 'strict')))\n            q =encode_address(base64.b64decode(result2[\"value\"]))\n            print (\"Withdrawal recipients: \",q)\n\n\n            result3 = app_client.application_box_by_name(_app_id,bytes(\"BoxA\".encode('utf-8', 'strict')))\n            g =encode_address(base64.b64decode(result3[\"value\"]))\n            print (\"Depositors Addresses: \",g)\n\n\n\n            result =app_client.application_box_by_name(_app_id,bytes(\"BoxB\".encode('utf-8', 'strict')))\n            \n            p = int.from_bytes(base64.b64decode(result[\"value\"]), byteorder=\"big\")\n            print(\"Withdrawal Amount: \",p)\n\n            \n\n        case \"balance\":\n\n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"balance\"),accts[2]['pk'] )\n\n        case \"debug\":\n            pc =input (\"enter program counter\")\n            # Using system() method  and Teal Inspector to\n            # execute shell commands\n            subprocess.Popen('tealinspector --network testnet --application_id {} --program_counter {}'.format(_app_id, pc), shell=True)\n\n        case other:\n            print (\"No Match Found, Please Pass a Valid command to this Method in ln 309\")\n\n\n# Utility function to get the Method object for a given method name\ndef get_method(name: str) :\n    with open(\"algobank.json\") as f:\n        js = f.read()\n    c = Contract.from_json(js)\n    for m in c.methods:\n        if m.name == name:\n            print (\"M: \",m.name)\n            return m\n    raise Exception(\"No method with the name {}\".format(name))\n\n\ndef update_(algod_client, app_id, params, private_key):\n\n    #Docs: https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/transaction.html?highlight=ApplicationUpdateTxn#algosdk.transaction.ApplicationUpdateTxn\n\n\n    # Read the compiled approvl & clear programs Teal files \n    \n    \"\"\"\n   \n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"r\") as f:\n        approval_program = f.read()\n\n    with open(\"algobank_clear_state.teal\", \"r\") as f:\n        clear_state_program= f.read()\n   \n\n    # compile program to binary\n    approval_program_compiled = compile_program(algod_client, approval_program)\n\n    # compile program to binary\n    clear_state_program_compiled = compile_program(algod_client, clear_state_program)\n\n    update_app(algod_client, app_id, params ,private_key, approval_program_compiled,clear_state_program_compiled)\n\n\n\ndef deploy(_params, mnemonic_ ,algod_client, fee):\n\n    _params.flat_fee = True\n    _params.fee = fee\n\n\n    # declare application state storage (immutable)\n    local_ints = 0\n    local_bytes = 0\n    global_ints = 1\n    global_bytes = 1\n    global_schema = transaction.StateSchema(global_ints, global_bytes)\n    local_schema = transaction.StateSchema(local_ints, local_bytes)\n\n\n    # Read the compiled approvl & clear programs Teal files \n    \n    \"\"\"\n   \n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"r\") as f:\n        approval_program = f.read()\n\n    with open(\"algobank_clear_state.teal\", \"r\") as f:\n        clear_state_program= f.read()\n   \n\n\n    \n\n\n\n    response = algod_client.compile(approval_program)\n    print (\"Raw Response =\",response )\n    print(\"Response Result = \",response['result'])\n    print(\"Response Hash = \",response['hash'])\n\n\n    # compile program to binary\n    approval_program_compiled = compile_program(algod_client, approval_program)\n\n    # compile program to binary\n    clear_state_program_compiled = compile_program(algod_client, clear_state_program)\n\n\n    app_id = create_app(algod_client,_params ,mnemonic_, approval_program_compiled, clear_state_program_compiled, global_schema, local_schema)\n\n    # Create the applicatiion on chain, set the app id for the app client & store app secret\n    print(f\"Created App with id: {app_id} \")\n\n\n\"\"\"\nTHE MAIN METHOD\n\"\"\"\n\nif __name__ == \"__main__\":\n    \n    #Builds the progam and deploys\n    ca = BoxEscrow()\n    \n\n    # Application State Machine\n    create_algorand_node_and_acct(\"\")"}
{"file_path": "https://github.com/Sotatek-NguyenNguyen/gs-sc-algo/blob/04452faf44e9472fd718b9a50c13a5c4b83a564a/contract/nftContracts.py", "code": "from pyteal import *\n\n\ndef approval_program():\n    # Global\n    asset_name = Bytes(\"asset_name\")\n\n    # @Subroutine(TealType.uint64)\n    # def executeAssetCreationTxn(txn_index: TealType.uint64) -> TxnExpr:\n    #     \"\"\"\n    #     returns the ID of the generated asset or fails\n    #     \"\"\"\n    #     call_parameters = Gtxn[txn_index].application_args\n    #     asset_total = Btoi(call_parameters[3])\n    #     decimals = Btoi(call_parameters[4])\n    #     return Seq([\n    #         InnerTxnBuilder.Begin(),\n    #         InnerTxnBuilder.SetFields({\n    #             TxnField.type_enum: TxnType.AssetConfig,\n    #             # TxnField.config_asset_name: call_parameters[1],\n    #             # TxnField.config_asset_unit_name: call_parameters[2],\n    #             # TxnField.config_asset_total: asset_total,\n    #             # TxnField.config_asset_decimals: decimals,\n    #             # TxnField.config_asset_url: call_parameters[5],\n\n    #             # TxnField.config_asset_default_frozen: Int(1),\n    #             # TxnField.config_asset_metadata_hash: call_parameters[0],\n\n    #             TxnField.config_asset_manager: Global.current_application_address(),\n    #             TxnField.config_asset_reserve: Global.current_application_address(),\n    #             TxnField.config_asset_freeze: Global.current_application_address(),\n    #             TxnField.config_asset_clawback: Global.current_application_address(),\n    #         }),\n    #         InnerTxnBuilder.Submit(),\n    #         Log(Itob(InnerTxn.created_asset_id())),\n    #         # InnerTxn.created_asset_id()\n    #     ])\n\n    @Subroutine(TealType.none)\n    def executeAssetCreationTxn() -> TxnExpr:\n        return Seq([\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_name: App.globalGet(asset_name),\n                TxnField.config_asset_unit_name: Txn.application_args[1],\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(0),\n                TxnField.config_asset_url: Txn.application_args[2],\n\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n            }),\n            InnerTxnBuilder.Submit(),\n            Log(Itob(InnerTxn.created_asset_id())),\n        ])\n\n    @Subroutine(TealType.none)\n    def executeAssetTransferTxn() -> TxnExpr:\n        return Seq([\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: Txn.assets[0],\n                    TxnField.asset_receiver: Txn.accounts[1],\n                    # TxnField.asset_close_to:Txn.accounts[1],\n                    TxnField.asset_amount: Int(1),\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        ])\n\n    @Subroutine(TealType.none)\n    def executeAssetDestroyTxn() -> TxnExpr:\n        return Seq([\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.type_enum: TxnType.AssetConfig,\n                    # TxnField.xfer_asset: Txn.assets[0],\n                    TxnField.config_asset: Txn.assets[0]\n\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        ])\n\n    on_create = Seq(\n        App.globalPut(asset_name, Txn.application_args[0]),\n        Approve(),\n    )\n    on_mint = Seq(\n        executeAssetCreationTxn(),\n        Approve(),\n    )\n    on_withdraw = Seq(\n        executeAssetTransferTxn(),\n        Approve(),\n    )\n    on_deposit = Seq(\n        executeAssetDestroyTxn(),\n        Approve(),\n    )\n\n    on_call_method = Txn.application_args[0]\n    on_call = Cond(\n        [on_call_method == Bytes(\"mint\"), on_mint],\n        [on_call_method == Bytes(\"withdraw\"), on_withdraw],\n        [on_call_method == Bytes(\"deposit\"), on_deposit],\n\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, on_call],\n        [\n            Or(\n                Txn.on_completion() == OnComplete.OptIn,\n                Txn.on_completion() == OnComplete.CloseOut,\n                Txn.on_completion() == OnComplete.UpdateApplication,\n            ),\n            Reject(),\n        ],\n    )\n\n    return program\n\n\ndef clear_state_program():\n    return Approve()\n\n\nwith open(\"teal/nft/auction_approval.teal\", \"w\") as f:\n    compiled = compileTeal(\n        approval_program(), mode=Mode.Application, version=5)\n    f.write(compiled)\n\nwith open(\"teal/nft/auction_clear_state.teal\", \"w\") as f:\n    compiled = compileTeal(clear_state_program(),\n                           mode=Mode.Application, version=5)\n    f.write(compiled)"}
{"file_path": "https://github.com/CupStakes/cupstakes-smart-contracts/blob/2155155985eb525f111458e0c237b0aaed642c39/draw/sc.py", "code": "from pyteal import *\nfrom assets import ticket_price, burn_ticket_price, storage_app_id, oracle_app_id, rewards_pool_address, super_admin_address\n\n# Of the above:\n# - immutable:\n#   - rewards_pool_address: hardcoded\n#   - storage_app_id: hardcoded\n# - mutable / just initial values, stored in global storage:\n#   - ticket_price\n#   - burn_ticket_price\n#   - oracle_app_id\n\nstorage_app_id_int = Int(storage_app_id)\n\nmax_randomness_range = 1000\n\n# Define Byte sequences used\n# Numbers and special symbols\nbytes_empty = Bytes('')\nbytes_151f7c75 = Bytes('base16', '151f7c75') # successful return from ABI call header\n\n# global storage lookup keys\n# kill switch: leave only \"collect\" action available\nkill_switch_key = Bytes('kill')\n# free draw NFT ID + implicit availability \nfree_draw_nft_id_key = Bytes('free_draw_nft')\n# ticket price in mAlgo\nticket_key = Bytes('ticket')\nburn_ticket_key = Bytes('burn_ticket')\n# oracle app id\noracle_app_id_key = Bytes('oracle_app_id')\n# sum or all odds of team NFTs. MUST BE POWER OF TWO\nmax_odds_key = Bytes('max_odds')\n# randomness oracle maximum range\nmax_randomness_range_key = Bytes('max_randomness_range')\n\n# local (user) storage lookup keys\n# NFT slots, available to collect\nslot1_key = Bytes(\"slot1\")\nslot2_key = Bytes(\"slot2\")\nslot3_key = Bytes(\"slot3\")\n# queued draw action. valid after round\ndraw_round_key = Bytes(\"draw_round\")\n# queued draw action. amount to draw\ndraw_amount_key = Bytes(\"draw_amount\")\ndraw_amount_paid_key = Bytes(\"draw_amount_paid\")\n\n# Log and misc\nbytes_rand = Bytes('rand')\nbytes_ret = Bytes('ret')\nbytes_default = Bytes('default')\nbytes_rand_mapped = Bytes(\"Rand mapped\")\n\n# extra_fields{} for zero fees\nzero_fee_extra_fields={}\nzero_fee_extra_fields[TxnField.fee]=Int(0)\n\n# error strings end up in algod error messages <3\nerr_contract_killed = \"CONTRACT KILLED\"\nerr_validation = \"VALIDATION FAIL\"\nerr_payment_incorrect = \"PAYMENT FAIL\"\nerr_payment_amount_invalid = \"PAYMENT AMT FAIL\"\nerr_wait_for_randomness = \"WAIT FOR RANDOMNESS\"\nerr_oracle_invalid = \"ORACLE INVALID\"\nerr_randomness_fail = \"RANDOMNESS FAIL\"\nerr_drawing_failed = \"DRAWING FAILED\"\nerr_drawing_disabled = \"DRAWING DISABLED\"\nerr_slot_not_empty = \"MUST COLLECT\"\nerr_no_free_slot = \"NO FREE SLOT\"\nerr_no_slots_full = \"NO NFTs IN SLOTS\"\nerr_unauthorized = \"UNAUTH\"\nerr_draw_queued = \"ERR DRAW QUEUED ALREADY\"\nerr_no_draw_queued = \"ERR NO DRAW QUEUED\"\nerr_randomness_expired = \"ERR RANDOMNESS EXPIRED\"\nerr_randomness_not_expired = \"ERR RANDOMNESS NOT EXPIRED\"\nerr_no_burn_available = \"ERR BURN NOT AVAILABLE\"\nerr_invalid_slot = \"ERR INVALID SLOT\"\nerr_no_burn_hacking = \"ERR NO BURN HACKING\"\n\nopup = OpUp(OpUpMode.Explicit, storage_app_id_int)\n\n# my greatest invention\n# assert that fails with an error string attached\n# Example error message: logic eval error: assert failed pc=2330. Details: pc=2330, opcodes=pushbytes 0x45525220445241572051554555454420414c5245414459 // \"ERR DRAW QUEUED ALREADY\"\ndef custom_assert(cond, str):\n    return If(Not(cond)).Then(Assert(Bytes('') == Bytes(str)))\n\n# same as above, but inversed - skips a Not()\n# not sure if it saves opcode costs\ndef fail_if(cond, str):\n    return If(cond).Then(Assert(Bytes('') == Bytes(str)))\n\n# as above but without condition\ndef fail(str):\n    return Assert(bytes_empty == Bytes(str))\n\n# helper function to get the draw amount of a user\n# called with 0 for txn sender (draw/freedraw) or 1 (first Txn.accounts entry) for executing the draw \ndef user_draw_amount(acctIdx):\n    return App.localGet(acctIdx, draw_amount_key)\n\n# return whether draw_round randomness has expired for user $acct\n# called with 1 (first Txn.accounts entry) for executing the draw or refund\ndef randomness_expired(addrIdx):\n    return Global.round() > App.globalGet(max_randomness_range_key) + App.localGet(addrIdx, draw_round_key)\n\n# reset user draw state to initial (no draw)\n# called with 0 when opting in or 1 (first Txn.accounts entry) for executing the draw \ndef reset_user_draw_state(addrIdx):\n    return Seq(\n        App.localPut(addrIdx, draw_amount_key, Int(0)),\n        App.localPut(addrIdx, draw_amount_paid_key, Int(0)),\n        App.localPut(addrIdx, draw_round_key, Int(0))\n    )\n\n# Set up default values upon creation; convenience operation, all of these are updatable\nhandle_creation = Seq(\n    App.globalPut(kill_switch_key, Int(0)), # kill-switch when 1 - only allow collecting and emptying NFTs\n    App.globalPut(free_draw_nft_id_key, Int(0)), # free draw NFT ID\n    App.globalPut(ticket_key, Int(ticket_price)), # ticket price in mAlgo\n    App.globalPut(burn_ticket_key, Int(burn_ticket_price)), # burn ticket price in mAlgo\n    App.globalPut(max_odds_key, Int(1048576)), # max odds for modulo op. MUST BE POWER OF TWO\n    App.globalPut(oracle_app_id_key, Int(oracle_app_id)), # randomness oracle app id - mutable in case of permanent beacon failure\n    App.globalPut(max_randomness_range_key, Int(max_randomness_range)), # range after which to refund ticket price\n    Approve()\n)\n\n# User opting in: Set up 3 local storage slots representing drawn NFT ID load slots,\n# and the \"draw queue\" entries: amount of draws and round to draw at\nhandle_optin = Seq(\n    App.localPut(Int(0), slot1_key, Int(0)),\n    App.localPut(Int(0), slot2_key, Int(0)),\n    App.localPut(Int(0), slot3_key, Int(0)),\n    reset_user_draw_state(Int(0)),\n)\n\n# Collect available NFTs\n# Assumes we have \"infinite\" NFTs available - will mint 10M per for CupStakes\n@Subroutine(TealType.none)\ndef sub_collect():\n    return Seq(\n        # check that at least some NFT slots are full\n        custom_assert(Or(\n            App.localGet(Int(0), slot1_key) != Int(0),\n            App.localGet(Int(0), slot2_key) != Int(0),\n            App.localGet(Int(0), slot3_key) != Int(0)\n        ), err_no_slots_full),\n        If(App.localGet(Int(0), slot1_key) != Int(0)).Then(Seq(\n            # send slot 1\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.localGet(Int(0), slot1_key),\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0)\n            }),\n            # clear slot 1\n            App.localPut(Int(0), slot1_key, Int(0))\n        )),\n        If(App.localGet(Int(0), slot2_key) != Int(0)).Then(Seq(\n            # send slot 2\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.localGet(Int(0), slot2_key),\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0)\n            }),\n            # clear slot 2\n            App.localPut(Int(0), slot2_key, Int(0))\n        )),\n        If(App.localGet(Int(0), slot3_key) != Int(0)).Then(Seq(\n            # send slot 3\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.localGet(Int(0), slot3_key),\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0)\n            }),\n            # clear slot 3\n            App.localPut(Int(0), slot3_key, Int(0))\n        )),\n    )\n\n# validate that the contract is not killswitched\n@Subroutine(TealType.none)\ndef not_killed():\n    return custom_assert(App.globalGet(kill_switch_key) == Int(0), err_contract_killed)\n\n# validate caller is the super_admin_address\n@Subroutine(TealType.none)\ndef super_admin_only():\n    return fail_if(Gtxn[0].sender() != Addr(super_admin_address), err_unauthorized)\n\n# validate called is admin/creator\n@Subroutine(TealType.none)\ndef admin_only():\n    return fail_if(Gtxn[0].sender() != Global.creator_address(), err_unauthorized)\n\n# Handles deleting the contract\n# Will send all ALGO And remaining NFTs to the rewards wallet\nhandle_delete_app = Seq(\n    admin_only(),\n    InnerTxnBuilder.Execute({\n        TxnField.type_enum: TxnType.Payment,\n        TxnField.close_remainder_to: Global.creator_address(),\n        TxnField.fee: Int(0),\n    })\n)\n\n# handle user's app close-out and clear-out\n# If we have NFTs available in slots and user requests close-out\n# we opt into them in the group txn if necessary\n# so here we send them\n# and then delete local state (likely not needed)\n# close-out may fail if not opted in, clear-out will not\nhandle_close_out = Seq(\n    If(Or(\n        App.localGet(Int(0), slot1_key) != Int(0),\n        App.localGet(Int(0), slot2_key) != Int(0),\n        App.localGet(Int(0), slot3_key) != Int(0)\n    )).Then(\n        sub_collect()\n    ),\n    App.localDel(Int(0), slot1_key),\n    App.localDel(Int(0), slot2_key),\n    App.localDel(Int(0), slot3_key),\n)\n\n# Main router class\nrouter = Router(\n    # Name of the contract\n    \"draw\",\n    # What to do for each on-complete type when no arguments are passed (bare call)\n    BareCallActions(\n        # On create only, just approve\n        no_op=OnCompleteAction.create_only(handle_creation),\n        # Always let creator update/delete but only by the creator of this contract\n        update_application=OnCompleteAction.call_only(super_admin_only), # super admin = 2/2 multisig:nullun+D13\n        delete_application=OnCompleteAction.call_only(handle_delete_app), # admin = D13\n        opt_in=OnCompleteAction.always(handle_optin), # user opt-in - set up user local state\n        close_out=OnCompleteAction.call_only(handle_close_out), # send stored NFTs before closing out state (will fail if user is not opted in)\n        clear_state=OnCompleteAction.call_only(handle_close_out) # attempt to send NFTs before clearing state (won't fail)\n    ),\n)\n\n# admin method to close out all held NFTs to creator address\n# intentionally allowed when contract is killed\n@router.method\ndef closeout_nft():\n    i = ScratchVar(TealType.uint64)\n    return Seq(\n        # creator is calling us or fail\n        admin_only(),\n        # iterate all foreign assets in Txn, close out\n        For(i.store(Int(0)), i.load() < Txn.assets.length(),  i.store(i.load() + Int(1))).Do(Seq(\n            # close out remaining NFT balances to creator address\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: Txn.assets[i.load()],\n                TxnField.asset_close_to: Global.creator_address(),\n            })\n        ))\n    )\n\n# admin method to opt contract in to NFTs\n# opts in to all txn's foreign assets\n@router.method\ndef optin():\n    i = ScratchVar(TealType.uint64)\n    return Seq(\n        # creator is calling us or fail\n        admin_only(),\n        # disabled when contract is killed\n        not_killed(),\n        # iterate all foreign assets in Txn, opt in\n        For(i.store(Int(0)), i.load() < Txn.assets.length(),  i.store(i.load() + Int(1))).Do(\n            # send opt-in to NFT txn\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: Txn.assets[i.load()],\n                TxnField.asset_receiver: Global.current_application_address(),\n            })\n        )\n    )\n\n# admin method to change global state (8x)\n@router.method\ndef update_state_int(key1: abi.DynamicBytes, val1: abi.Uint64,\n                     key2: abi.DynamicBytes, val2: abi.Uint64,\n                     key3: abi.DynamicBytes, val3: abi.Uint64,\n                     key4: abi.DynamicBytes, val4: abi.Uint64,\n                     key5: abi.DynamicBytes, val5: abi.Uint64,\n                     key6: abi.DynamicBytes, val6: abi.Uint64,\n                     key7: abi.DynamicBytes, val7: abi.Uint64,\n                     key8: abi.DynamicBytes, val8: abi.Uint64):\n    return Seq(\n        # only admin/creator can call update global state\n        admin_only(),\n        # disabled when contract is killed\n        not_killed(),\n        If(key1.get() != bytes_empty).Then(App.globalPut(key1.get(), val1.get())),\n        If(key2.get() != bytes_empty).Then(App.globalPut(key2.get(), val2.get())),\n        If(key3.get() != bytes_empty).Then(App.globalPut(key3.get(), val3.get())),\n        If(key4.get() != bytes_empty).Then(App.globalPut(key4.get(), val4.get())),\n        If(key5.get() != bytes_empty).Then(App.globalPut(key5.get(), val5.get())),\n        If(key6.get() != bytes_empty).Then(App.globalPut(key6.get(), val6.get())),\n        If(key7.get() != bytes_empty).Then(App.globalPut(key7.get(), val7.get())),\n        If(key8.get() != bytes_empty).Then(App.globalPut(key8.get(), val8.get())),\n    )\n\n# mint \"free draw\" nft that is accepted in lieu of ticket by free_draw entry point\n# admin only; admin must pay the ticket price into the rewards pool\n@router.method\ndef get_free_draw_nft(num: abi.Uint64):\n    return Seq(\n        # only creator can make free_draw nfts\n        admin_only(),\n        # disabled when contract is killed\n        not_killed(),\n        # drawing enabled check. is this pointless?\n        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),\n        # first group txn type == algo payment\n        fail_if(Gtxn[0].type_enum() != TxnType.Payment, err_payment_incorrect),\n        # multisig rewards should receive the funds\n        fail_if(Gtxn[0].receiver() != Addr(rewards_pool_address), err_payment_incorrect),\n        # validate enough paid\n        fail_if(Gtxn[0].amount() != num.get() * App.globalGet(ticket_key), err_payment_amount_invalid),\n        # send NFT \n        InnerTxnBuilder.Execute({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: App.globalGet(free_draw_nft_id_key),\n            # hardcoded to creator address\n            TxnField.asset_receiver: Global.creator_address(),\n            TxnField.asset_amount: num.get(),\n            # user pays fees\n            TxnField.fee: Int(0)\n        })\n    )\n\n# function to validate ALGO payments for 1/3 draws or 1/2/3 burns\n# fails is drawing is disabled (ticket price == 0)\n# ticket_key will be 'ticket' or 'burn_ticket'\n@Subroutine(TealType.none)\ndef validate_payment(multiplier, ticket_key):\n    return Seq(\n        # multiplier is 1 or 3\n        # validate first payment: (algo) payment type\n        fail_if(Gtxn[0].type_enum() != TxnType.Payment, err_payment_incorrect),\n        # validate first payment: multiplier times ticket price\n        fail_if(Gtxn[0].amount() != multiplier * App.globalGet(ticket_key), err_payment_amount_invalid),\n        # receiver must be rewards pool address\n        fail_if(Gtxn[0].receiver() != Addr(rewards_pool_address), err_payment_incorrect),\n    )\n\n# function to validate Free Draw NFT payments for 1x Free Draw\n# fails is drawing is disabled (ticket price == 0)\n@Subroutine(TealType.none)\ndef validate_free_draw_payment(multiplier):\n    return Seq(\n        # drawing enabled check. redundant as we check in queue_draw but we deployed it like this, so :)\n        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),\n        # validate free draw payment with free draw nft\n        fail_if(Gtxn[0].type_enum() != TxnType.AssetTransfer, err_payment_incorrect),\n        # multiplier will be = 1\n        fail_if(Gtxn[0].asset_amount() != multiplier, err_payment_amount_invalid),\n        # free draw NFTs should be sent to the application address\n        fail_if(Gtxn[0].asset_receiver() != Global.current_application_address(), err_payment_incorrect),\n        # confirm NFT ID matches\n        fail_if(Gtxn[0].xfer_asset() != App.globalGet(free_draw_nft_id_key), err_payment_incorrect)\n    )\n\n# get random bytes from randomness oracle for $acct, round $rand_count - $cur\n# going before $rand_count is safe because rounds [$seed-7 -> $seed] are seeded by $seed round\n# returns random 32 byte / 256 bit sequence\n# account here is BYTES, not index like in other calls\n@Subroutine(TealType.bytes)\ndef get_random_bytes(acct, rand_round, cur):\n    res = abi.DynamicBytes()\n    return Seq(\n        # call the randomness contract\n        # passing round-$i (i in 0,1,2) and user address as user_bytes\n        # for multiple calls we prefer to call 3x for transparency w/ end users\n        InnerTxnBuilder.ExecuteMethodCall(\n            app_id=App.globalGet(oracle_app_id_key),\n            method_signature=\"get(uint64,byte[])byte[]\", # using get instead of must_get intentionally, handling zero byte return further down when randomness isn't ready (pretty error message)\n            args=[Itob(Minus(rand_round, cur)), acct],\n            extra_fields=zero_fee_extra_fields, # user pays fees\n        ),\n        # last_log is the encoded ABI return value\n        # It must begin with hex 151f7c75\n        fail_if(Len(InnerTxn.last_log()) < Int(6), err_oracle_invalid),\n        fail_if(Substring(InnerTxn.last_log(), Int(0), Int(4)) != bytes_151f7c75, err_randomness_fail),\n        # decode the ABI return value into res scratch slot\n        abi.DynamicBytes.decode(res, Substring(InnerTxn.last_log(), Int(4), Len(InnerTxn.last_log()))),\n        # check that it isn't zero (eg when randomness was not ready yet)\n        fail_if(res.get() == bytes_empty, err_randomness_fail),\n        Log(bytes_rand),\n        Log(res.get()),\n        Return(res.get())\n    )\n\n# helper to get int value from storage contract's global storage\n@Subroutine(TealType.uint64)\ndef get_ext_storage(keynum):\n    extvalue = App.globalGetEx(storage_app_id_int, Itob(keynum))\n    return Seq(\n        extvalue, # must include this or pyteal compilation fails\n        Return(extvalue.value())\n    )\n\n# pick next round as a draw target\n# if we are at round mod 8 == 0 it is safe to use current round\n# as the randomness seed is based on this current block's signature\n# so it can't be known yet\n# otherwise choose the next multiple of 8\n@Subroutine(TealType.uint64)\ndef get_next_rand_round():\n    return Return(Cond( # I don't know why this isn't an If() statement. Don't ask. Still, effectively the same.\n        [Mod(Global.round(), Int(8)) == Int(0), Global.round()],\n        [Int(1), Add(Global.round(), Minus(Int(8), Mod(Global.round(), Int(8))))],\n    ))\n\n# map a 256 bit random value into one of the NFTs according to their rarity\n# team NFT IDs and odds are stored like so:\n# 1: TEAM_1_NFT_ID\n# 2: TEAM_1_ODDS\n# 3: TEAM_2_NFT_ID\n# 4: TEAM_2_ODDS + TEAM_1_ODDS\n# ...\n# 63: TEAM_32_NFT_ID\n# 64: SUM(TEAM_ODDS) ~ aka max_odds **MUST BE POWER OF 2 for mapping from 256 bits to be uniform**\n# We get a 256 bit random value and do modulo SUM(TEAM_ODDS) (stored in global storage max_odds_key)\n# this goes into rand_val and is in [0, max_odds)\n# then iterate for(i=2; i<=64; i+=2)\n# first nft odds value which is larger than $rand_val is the NFT to return\n# the ID is one index before the currently iterated idx\n@Subroutine(TealType.uint64)\ndef get_random_nft_id(acct, rnd, iter):\n    i = ScratchVar(TealType.uint64)\n    rand_val = ScratchVar(TealType.uint64)\n    return Seq(\n        # random(256bit) modulo (max_odds) -> to_integer() -> $rand_val\n        rand_val.store(Btoi(\n            BytesMod( # BytesMod is expensive - could have sliced a few bytes off the rnd tail, Btoi and do int mod so save op costs\n                get_random_bytes(acct, rnd, iter), # 256 bit\n                Itob(App.globalGet(max_odds_key)) # Must be power of 2\n            )\n        )),\n        Log(bytes_rand_mapped), # debug/log label & mapped rand value\n        Log(Itob(rand_val.load())),\n        # for all possible NFT values\n        For(i.store(Int(2)),\n            Le(i.load(), Int(64)),\n            i.store(Add(i.load(), Int(2)))\n        ).Do(Seq(\n            # described in function header doc\n            If (get_ext_storage(i.load()) > rand_val.load()).Then(Seq(\n                # switch to using i as results storage\n                # ID to return is one before the odds that just won\n                i.store(get_ext_storage(Minus(i.load(), Int(1)))),\n                # assert that the value is not zero\n                fail_if(i.load() == Int(0), err_drawing_failed), # Needed?\n                Return(i.load())\n            ))\n        )),\n        # failsafe\n        fail_if(Int(1), err_drawing_failed),\n        # never reached, but pyteal like this\n        Return(Int(1))\n    )\n\n# translate int(1,2,3) -> slot1_key slot2_key slot3_key or fail the program  \n# used by burn entry points to map slot idx to slot name\n@Subroutine(TealType.bytes)\ndef slot_int_to_key(slot_int):\n    return Cond(\n        [slot_int == Int(1), slot1_key],\n        [slot_int == Int(2), slot2_key],\n        [slot_int == Int(3), slot3_key],\n        [Int(1), Seq(fail(err_invalid_slot), bytes_empty)] # The seq, bytes dance is to satisfy pyteal\n    )\n\n# utility to get the first available free NFT slot in user storage\n# empty bytes is all slots filled\n@Subroutine(TealType.bytes)\ndef get_free_slot_for(addrIdx):\n    return Cond(\n        [App.localGet(addrIdx, slot1_key) == Int(0), slot1_key],\n        [App.localGet(addrIdx, slot2_key) == Int(0), slot2_key],\n        [App.localGet(addrIdx, slot3_key) == Int(0), slot3_key],\n        [Int(1), bytes_empty]\n    )\n\n# validate (num) 1 or 3 free slots are available in user storage\n# used before a draw is queued\n@Subroutine(TealType.none)\ndef validate_free_slots(num, acctIdx):\n    return Cond(\n        # validating 1 slot available: is there is any free slot we're good\n        [num == Int(1), fail_if(get_free_slot_for(acctIdx) == bytes_empty, err_no_free_slot)], # NO FREE SLOT\n        # validating all slots are available\n        [Int(1), custom_assert(And(\n            App.localGet(acctIdx, slot1_key) == Int(0),\n            App.localGet(acctIdx, slot2_key) == Int(0),\n            App.localGet(acctIdx, slot3_key) == Int(0)\n        ), err_slot_not_empty)] # \"MUST_COLLECT\"\n    )\n\n# internal method to queue a draw action into user local storage\n@Subroutine(TealType.uint64)\ndef queue_draw(num, paid_num, ticket_key):\n    return Seq(\n        # drawing is enabled\n        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),\n        # already a draw in queue? fail\n        fail_if(user_draw_amount(Int(0)) != Int(0), err_draw_queued),\n        # save amount of draws in key\n        App.localPut(Int(0), draw_amount_key, num),\n        # save amount paid for refund in case of randomness expiry\n        App.localPut(Int(0), draw_amount_paid_key, App.globalGet(ticket_key) * paid_num),\n        # get next safe randomness round and save it in key\n        App.localPut(Int(0), draw_round_key, get_next_rand_round()),\n        # return the round so the user knows how long to wait (+2 in practice for the VRF oracle to be seeded by off-chain service)\n        Return(App.localGet(Gtxn[0].sender(), draw_round_key))\n    );\n\n\n# DRAW/BURN_DRAW/FREE_DRAW methods\n# these all return the randomness round commitment\n\n# entry point to queue a 1x draw paying with a free draw NFT\n@router.method\ndef free_draw(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 1x Free Draw NFTs sent or fail\n        validate_free_draw_payment(Int(1)),\n        # validate there are 1x free NFT slots in user storage or fail\n        validate_free_slots(Int(1), Int(0)),\n        # add a 1x draw \"queue\" to user storage and return the round\n        # paid == 0 - no refunds for free drawers, sorry\n        output.set(queue_draw(Int(1), Int(0), ticket_key))\n    )\n\n# entry point to queue a 1x draw paying with ALGO\n@router.method\ndef draw(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 1x ALGO payments are sent or fail\n        validate_payment(Int(1), ticket_key),\n        # validate there is 1x free slot available to draw into, or fail\n        validate_free_slots(Int(1), Int(0)),\n        # add a 1x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(1), Int(1), ticket_key))\n    )\n\n# entry point to queue a 3x draw paying with ALGO\n@router.method\ndef draw3(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 3x ALGO ticket price is sent or fail\n        validate_payment(Int(3), ticket_key),\n        # validate there are 3x free NFT slots in user storage or fail\n        validate_free_slots(Int(3), Gtxn[0].sender()),\n        # add a 3x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(3), Int(3), ticket_key))\n    )\n\n@router.method\ndef burn_draw(slot: abi.Uint64, *, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate passed slot is burnable\n        fail_if(App.localGet(Int(0), slot_int_to_key(slot.get())) == Int(0), err_no_burn_available),\n        # \"burn\" NFT - zero out slot$n\n        App.localPut(Int(0), slot_int_to_key(slot.get()), Int(0)),\n        # validate burn payment sent\n        validate_payment(Int(1), burn_ticket_key),\n        # skip validate free slot, we just created one\n        # add a 1x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(1), Int(1), burn_ticket_key))\n    )\n\n@router.method\ndef burn_draw2(slot1: abi.Uint64, slot2: abi.Uint64, *, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate passed slots are burnable\n        fail_if(slot1.get() == slot2.get(), err_no_burn_hacking), # if sneaky user tries to burn the same slot twice, amuse them with an error message\n        fail_if(App.localGet(Int(0), slot_int_to_key(slot1.get())) == Int(0), err_no_burn_available),\n        fail_if(App.localGet(Int(0), slot_int_to_key(slot2.get())) == Int(0), err_no_burn_available),\n        # \"burn\" NFTs - zero out slots\n        App.localPut(Int(0), slot_int_to_key(slot1.get()), Int(0)),\n        App.localPut(Int(0), slot_int_to_key(slot2.get()), Int(0)),\n        # validate burn payment sent\n        validate_payment(Int(2), burn_ticket_key),\n        # skip validate free slot, we just created two\n        # add a 1x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(2), Int(2), burn_ticket_key))\n    )\n\n@router.method\ndef burn_draw3(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 3 NFTs are in user storage to burn\n        custom_assert(get_free_slot_for(Int(0)) == bytes_empty, err_no_burn_available),\n        # validate 3x ALGO ticket price is sent or fail\n        validate_payment(Int(3), burn_ticket_key),\n        App.localPut(Int(0), slot_int_to_key(Int(1)), Int(0)),\n        App.localPut(Int(0), slot_int_to_key(Int(2)), Int(0)),\n        App.localPut(Int(0), slot_int_to_key(Int(3)), Int(0)),\n        # add a 3x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(3), Int(3), burn_ticket_key))\n    )\n\n# does the actual drawing\n# meant to be called by (our) backend to make the UX nicer but isn't restricted as such\n# we have exposed a fallback to end users in the frontend if our redundant backends fail\n# note we are using \"1\" as the account index - meaning first foreign account\n@router.method\ndef exec_draw():\n    i = ScratchVar(TealType.uint64) # draw number iterator\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # Otherwise do store(txn.accounts.last())\n        # if no draw queued, fail\n        fail_if(Eq(user_draw_amount(Int(1)), Int(0)), err_no_draw_queued),\n        # if round is not past yet, fail\n        fail_if(Lt(Global.round(), App.localGet(Int(1), draw_round_key)), err_wait_for_randomness),\n        fail_if(randomness_expired(Int(1)), err_randomness_expired),\n        # auto-inner TXN to storage app to increase budget - triggers when 3x draw\n        opup.ensure_budget(Int(450) * user_draw_amount(Int(1))),\n        # for i=0; i<user.draw_amount; i++\n        For(i.store(Int(0)), Lt(i.load(), user_draw_amount(Int(1))), i.store(Add(i.load(), Int(1)))).Do(Seq(\n            App.localPut(\n                Int(1),\n                # get free NFT slot for user\n                get_free_slot_for(Int(1)),\n                # save a random NFT ID\n                get_random_nft_id(\n                    Txn.accounts[Int(1)],\n                    App.localGet(Int(1), draw_round_key), # agreed upon round\n                    i.load() # draw number in [0, 1, 2]\n                 )\n            )\n        )),\n        # reset queued draw user storage keys\n        reset_user_draw_state(Int(1))\n    )\n\n# collect all available NFTs from user storage slots\n# intentionally left enabled when contract is killed\n@router.method\ndef collect():\n    return sub_collect()\n\n# refund in case randomness has expired\n# this should never happen, but has to be factored in anyhow\n# free draw users are SOL\n# paying users get their money back & a digital apology\n# intentionally left available when contract is killed\n@router.method\ndef refund(*, output: abi.Uint64):\n    amount = ScratchVar(TealType.uint64) # draw amount to refund\n    addr = ScratchVar(TealType.bytes) # address to refund\n    return Seq(\n        # Otherwise do store(txn.accounts.last())\n        # if no draw queued, fail\n        addr.store(Txn.accounts[Int(1)]),\n        fail_if(user_draw_amount(Int(1)) == Int(0), err_no_draw_queued),\n        # if round is not past yet, fail\n        custom_assert(randomness_expired(Int(1)), err_randomness_not_expired),\n        amount.store(App.localGet(Int(1), draw_amount_paid_key)),\n        # for i=0; i<user.draw_amount; i++\n        # reset queued draw user storage keys\n        reset_user_draw_state(Int(1)),\n        InnerTxnBuilder.Execute({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.sender(),\n            TxnField.amount: amount.load(),\n            TxnField.fee: Int(0),\n        }),\n        output.set(amount.load()),\n    )\n\ndef get_contracts():\n    return router.compile_program(version=6)"}
{"file_path": "https://github.com/summitbajaj/AlDonate/blob/1a0fd9ad0b0a036508c40a10d2432f0213f17f61/donate.py", "code": "import base64\nfrom typing import Tuple\nfrom algosdk import mnemonic, transaction, account\nfrom algosdk.v2client import algod\nfrom pyteal import *\n\nprint(\"\u2588\u2591\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2588\u2003 \u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\")\nprint(\"\u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2584\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\")\n\ntxn_history = {}\n\n\ndef donation_escrow(benefactor):\n\n    # Getting AppID\n    # AppID = AppParamObject\n    # Getting Minimum Allowed Fee\n    Fee = Global.min_txn_fee()\n\n    program = And(\n        Global.group_size() == Int(1),\n        Txn.rekey_to() == Global.zero_address(),\n        Txn.fee() <= Fee,\n        Or(\n            And(\n                Txn.type_enum() == TxnType.Payment,\n                Txn.receiver() == Addr(benefactor),\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetConfig,\n                Txn.config_asset_total() == Int(1),\n                Txn.config_asset_unit_name() == Bytes(\"AlD\")\n                # ensure nft is the logo of the charity\n                # Txn.config_asset_url()\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetTransfer,\n\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetFreeze,\n            )\n        )\n    )\n\n    return compileTeal(program, Mode.Signature, version=5)\n\n\n# user declared account mnemonics\nbenefactor_mnemonic = \"mom lottery uniform olive visa occur garlic artefact minimum reward custom legend suit stock install leg doctor favorite retreat cart all exact camp able cute\"\nsender_mnemonic = \"shoe onion turkey shallow belt drop owner merit eager reflect radio gravity stone eyebrow busy dolphin verb bonus load unit engage young decrease ability fame\"\n\n\n# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config\nalgod_address = \"http://localhost:4001\"\nalgod_token = \"a\" * 64\n\n# helper function to compile program source\n\n\ndef compile_smart_signature(\n    client: algod.AlgodClient, source_code: str\n) -> Tuple[str, str]:\n    compile_response = client.compile(source_code)\n    return compile_response[\"result\"], compile_response[\"hash\"]\n\n\ndef payment_transaction(\n    creator_mnemonic: str, amt: int, rcv: str, algod_client: algod.AlgodClient\n) -> dict:\n    creator_pk = mnemonic.to_private_key(creator_mnemonic)\n    creator_address = account.address_from_private_key(creator_pk)\n\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(creator_address, params, rcv, amt)\n    signed = unsigned_txn.sign(creator_pk)\n\n    txid = algod_client.send_transaction(signed)\n    pmtx = transaction.wait_for_confirmation(algod_client, txid, 5)\n    return txid, pmtx[\"txn\"][\"txn\"]\n\n\n# for minting nft\ndef mint_nft(encoded_program: str, algod_client: algod.AlgodClient):\n    sp = algod_client.suggested_params()\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # define NFT asset parameters\n    txn = transaction.AssetConfigTxn(\n        sender=lsig.address(),\n        sp=sp,\n        default_frozen=False,\n        unit_name=\"AlD\",\n        asset_name=\"AlDonate NFT\",\n        manager=lsig.address(),\n        reserve=lsig.address(),\n        freeze=lsig.address(),\n        clawback=lsig.address(),\n        url=\"https://tinyurl.com/mt3yzhz4\",\n        total=1,\n        decimals=0,\n    )\n\n    # sign the transaction using the logic signature\n    stxn = transaction.LogicSigTransaction(txn, lsig)\n\n    # send the transaction to the network\n    tx_id = algod_client.send_transaction(stxn)\n    print(\"\")\n    print(f\"Minting Transaction ID: {tx_id}\")\n    print(\"\")\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 5)\n\n    return pmtx\n\n# perform opt in transaction for minted NFT\n\n\ndef opt_in_nft(\n    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str\n):\n    sp = algod_client.suggested_params()\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n    optin_txn = transaction.AssetOptInTxn(\n        sender=receiver_address, sp=sp, index=asset_id\n    )\n    signed_optin_txn = optin_txn.sign(receiver_pk)\n    txid = algod_client.send_transaction(signed_optin_txn)\n    print(\"\")\n    print(f\"Opting in your wallet to receive NFT: {txid}\")\n\n    # Wait for the transaction to be confirmed\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n    print(\"\")\n\n\ndef transfer_nft_to_donor(\n        encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str, id, txn):\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n    opt_in_nft(encoded_program, asset_id, algod_client, receiver_mnemonic)\n\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n    note = f\"Transaction: {id}, Amount: {txn['amt']}, Fee: {txn['fee']}\".encode(\n    )\n    # Transfer the newly created NFT from escrow to donor\n    txn = transaction.AssetTransferTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        receiver=receiver_address,\n        amt=1,\n        index=asset_id,\n        note=note\n    )\n    stxn = transaction.LogicSigTransaction(txn, lsig)\n    txid = algod_client.send_transaction(stxn)\n\n    print(f\"Sent asset transfer transaction with txid: {txid}\")\n    # Wait for the transaction to be confirmed\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n\n\ndef freeze_donor_nft(\n    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str\n):\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # Create freeze transaction to freeze the asset in acct2 balance\n    freeze_txn = transaction.AssetFreezeTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        target=receiver_address,\n        index=asset_id,\n        new_freeze_state=True,\n    )\n\n    stxn = transaction.LogicSigTransaction(freeze_txn, lsig)\n    txid = algod_client.send_transaction(stxn)\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(\"\")\n    print(f\"Sent freeze transaction with txid: {txid}\")\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n    print(\"\")\n    print(\"Congrats! NFT has been transferred to you! Note: You will not be able to transfer this asset\")\n\n\ndef lsig_payment_txn(\n    encoded_program: str, amt: int, rcv: str, algod_client: algod.AlgodClient\n):\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # Create transaction with the lsig address as the sender\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(lsig.address(), params, rcv, amt)\n\n    # sign the transaction using the logic\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\ndef main():\n    # initialize an algodClient\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n    # define private keys\n    private_key = mnemonic.to_private_key(benefactor_mnemonic)\n    # receiver_public_key = account.address_from_private_key(private_key)\n\n    print(\"\")\n    print(\"\")\n    print(\"\")\n    print(\"Thank you for your donation! Which charity will you like to send the donation to? Key in the number:\")\n    print(\"\")\n    print(\"\")\n\n    choice = 0\n\n    while (choice != 3):\n\n        print(\"1: NKF  || Onboarded suppliers: - Penny Appeal(Turkey Food Donation), - Ikea Foundation(Turkey Shelters)\")\n        print(\"2: WWF  || Onboarded suppliers: - Ghana Stores(Ghana Food Donation)\")\n        print(\"3: To exit this application\")\n        print(\"4: View your Donations\")\n        choice = int(input())\n        charity = \"\"\n\n        if choice == 1:\n            print(\"sending donation to NKF\")\n            charity = \"NKF\"\n            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'\n\n        elif choice == 2:\n            print(\"sending donation to WWF\")\n            charity = \"WWF\"\n            receiver_public_key = 'XHT4KIAFOP4626AFLA6GMOMST4QO3AO2XADMIJJOACMFEGT5GLA6LOCLWQ'\n\n        elif choice == 3:\n            break\n\n        elif choice == 4:\n            for charity, transactions_list in txn_history.items():\n                print(f\"Transactions for {charity}:\")\n                for txn in transactions_list:\n                    print(f\"\\tTransaction ID: {txn['txn_id']}\")\n                    print(f\"\\tAmount Donated: {txn['amount_donated']}\")\n                    print(f\"\\tCertificate ID: {txn['certificate_id']}\\n\")\n\n            continue\n\n        else:\n            print(\"Sending donation to NKF\")\n            charity = \"NKF\"\n            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'\n\n        print(\"\")\n        print(\"Compiling Donation Smart Signature......\")\n        print(\"\")\n        stateless_program_teal = donation_escrow(receiver_public_key)\n        escrow_result, escrow_address = compile_smart_signature(\n            algod_client, stateless_program_teal\n        )\n\n        print(\"Program:\", escrow_result)\n        print(\"LSig Address: \", escrow_address)\n        print(\"\")\n        print(\"Activating Donation Smart Signature......\")\n\n        # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator\n        amt = 100000\n        id, txn = payment_transaction(\n            sender_mnemonic, amt, escrow_address, algod_client)\n\n        if charity not in txn_history.keys():\n            txn_history[charity] = []\n\n        # Mint NFT using the escrow address\n        print(\"Thank you for your donation, Minting NFT......\")\n        pmtx = mint_nft(escrow_result, algod_client)\n        created_asset = pmtx[\"asset-index\"]\n\n        txn_history[charity].append(\n            {\"txn_id\": id, \"amount_donated\": amt, \"certificate_id\": created_asset})\n\n        print(\"\")\n        print(\"Withdrawing from Donation Smart Signature......\")\n        print(f\"NFT Address: {created_asset}\")\n\n        # Withdraws 1 ALGO from smart signature using logic signature.\n        withdrawal_amt = 10000\n        lsig_payment_txn(escrow_result, withdrawal_amt,\n                         receiver_public_key, algod_client)\n\n        transfer_nft_to_donor(escrow_result, created_asset,\n                              algod_client, sender_mnemonic, id, txn)\n        freeze_donor_nft(escrow_result, created_asset,\n                         algod_client, sender_mnemonic)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"file_path": "https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/mint_nfts.py", "code": "from pathlib import Path\nfrom typing import Literal\nfrom beaker import *\nfrom pyteal import *\n\n\nclass NFTs(abi.NamedTuple):\n    url: abi.Field[abi.String]\n    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]\n    name: abi.Field[abi.String]\n    unitName: abi.Field[abi.String]\n    reserve: abi.Field[abi.Address]\n\n    asa = LocalStateValue(stack_type=TealType.uint64, default=Int(0))\n    burn_address = LocalStateValue(stack_type= TealType.bytes, default=Bytes(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ\"))\n    burntId = LocalStateValue(stack_type= TealType.uint64, default=Int(0))\n\n\napp = Application(\"MintNFTs\", state=NFTs)\n\n@app.create(bare=True)\ndef create() -> Expr:\n    return app.initialize_global_state()\n\n\n@app.external(authorize= Authorize.only(Global.creator_address()))\ndef mintNFTs(requestMint: NFTs, *, output: abi.Uint64) -> Expr:\n    name = abi.String()\n    unitName = abi.String()\n    reserve = abi.Address()\n    url = abi.String()\n    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])\n\n    return Seq(\n        requestMint.name.store_into(name),\n        requestMint.unitName.store_into(unitName),\n        requestMint.reserve.store_into(reserve),\n        requestMint.url.store_into(url),\n        requestMint.metadata_hash.store_into(metadata_hash),\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_name: name.get(),\n                TxnField.config_asset_unit_name: unitName.get(),\n                TxnField.config_asset_reserve: reserve.get(),\n                TxnField.config_asset_url: url.get(),\n                TxnField.config_asset_metadata_hash: metadata_hash.encode(),\n                TxnField.config_asset_total: Int(1),\n                TxnField.fee: Int(0),\n            }\n        ),\n        output.set(InnerTxn.created_asset_id()),\n        app.state.asa.set(InnerTxn.created_asset_id())\n    )\n\n\n@app.external(authorize= Authorize.only(Global.creator_address()))\ndef transferNFTs(assetId: abi.Uint64, receiver: abi.Address) -> Expr:\n    assetId= app.state.asa.get()\n    receiver= abi.Address()\n    return Seq(\n\n        Assert(app.state.asa == assetId),\n        Assert(app.state.burntId != assetId),\n\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: receiver.get(),\n                TxnField.xfer_asset: assetId,\n                TxnField.asset_amount: Int(1),\n            }\n    )\n)\n\n@app.external(authorize= Authorize.only(Global.creator_address()))\ndef burn(Id: abi.Uint64) -> Expr:\n    burntAddress= app.state.burn_address.get()\n    Id= abi.Uint64()\n    return Seq(\n        Assert(app.state.asa == Id.get()),\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: burntAddress,\n                TxnField.xfer_asset: Id.get(),\n                TxnField.asset_amount: Int(1),\n            }\n        ),\n        app.state.burntId.set(Id.get())\n)\n\n\nif __name__ == \"__main__\":\n    app.build().export(\n        Path(__file__).resolve().parent / f\"./artifacts/{app.name}\"\n    )"}
{"file_path": "https://github.com/sagaranand015/algorand-smart-asa/blob/68eb9b7f07b93c5fd52ddcd29a73633f82e2f520/contracts/emission_control.py", "code": "from typing import Final\n\nfrom pyteal import *\nfrom beaker import *\n\n\nclass EmissionRuleResult(abi.NamedTuple):\n    emission: abi.Field[abi.String]\n    max: abi.Field[abi.Uint64]\n    min: abi.Field[abi.Uint64]\n\n\nCOMPLIANCE_ASA_APP_BINDING = \"https://compliance.app/\"\n\nUNDERLYING_COMPLIANCE_NFT_DECIMALS = Int(0)\nUNDERLYING_COMPLIANCE_NFT_DEFAULT_FROZEN = Int(0)\nUNDERLYING_COMPLIANCE_NFT_UNIT_NAME = Bytes(\"COM-ASA\")\nUNDERLYING_COMPLIANCE_NFT_NAME = Bytes(\"COMPLIANCE-ASA\")\nUNDERLYING_COMPLIANCE_NFT_URL = Bytes(COMPLIANCE_ASA_APP_BINDING)\nUNDERLYING_COMPLIANCE_NFT_METADATA_HASH = Bytes(\"Comliance NFT Metadata\")\nUNDERLYING_COMPLIANCE_NFT_MANAGER_ADDR = Global.current_application_address()\nUNDERLYING_COMPLIANCE_NFT_RESERVE_ADDR = Global.current_application_address()\nUNDERLYING_COMPLIANCE_NFT_FREEZE_ADDR = Global.current_application_address()\nUNDERLYING_COMPLIANCE_NFT_CLAWBACK_ADDR = Global.current_application_address()\n\n\nclass EmissionControl(Application):\n    \"\"\"\n    Emission Control(aka Smart Contract App) for storing business' compliance analysis on chain\n    and creating/minting NFTs for businesses based on the rules defined by the regulators.\n    \"\"\"\n\n    regulator: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.bytes,\n        descr=\"Regulator acting as the owner of the Emission Control\",\n    )\n    emission_parameter: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.bytes, descr=\"Emission Parameter to keep track of\"\n    )\n    emission_max: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.uint64, descr=\"Max value of the emission control parameter\"\n    )\n    emission_min: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.uint64, descr=\"Min value of the emission control parameter\"\n    )\n\n    @external\n    def get_emission_rule(self, *, output: EmissionRuleResult):\n        \"\"\"\n        Returns the rules defined by the regulator for the given emission SC\n        \"\"\"\n        return Seq(\n            (max := abi.Uint64()).set(self.emission_max.get()),\n            (min := abi.Uint64()).set(self.emission_min.get()),\n            (parameter := abi.String()).set(self.emission_parameter.get()),\n            output.set(parameter, max, min),\n        )\n\n    @external\n    def set_emission_rule(\n        self,\n        emission_parameter: abi.String,\n        emission_max: abi.Uint64,\n        emission_min: abi.Uint64,\n        *,\n        output: abi.Bool,\n    ):\n        \"\"\"\n        Sets the rules defined by the regulator for the given emission\n        \"\"\"\n        return Seq(\n            self.emission_parameter.set(emission_parameter.get()),\n            self.emission_max.set(emission_max.get()),\n            self.emission_min.set(emission_min.get()),\n            output.set(True),\n        )\n\n    @external\n    def is_business_compliant(\n        self,\n        emission_parameter: abi.String,\n        emission_value: abi.Uint64,\n        *,\n        output: abi.Bool,\n    ):\n        \"\"\"\n        Returns true/false based on whether the business is compliant to the emissions value or not\n        \"\"\"\n        return Seq(\n            Assert(\n                self.emission_parameter == emission_parameter.get(),\n                comment=\"Emission Parameter given is not correct for the app being used!\",\n            ),\n            Assert(\n                emission_value.get() >= self.emission_min,\n                comment=\"Emission value is lesser than min configured\",\n            ),\n            If(emission_value.get() <= self.emission_max)\n            .Then(output.set(True))\n            .Else(output.set(False)),\n        )\n\n    @internal(TealType.uint64)\n    def create_compliance_nft_internal(self):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetConfig,\n                    TxnField.config_asset_total: Int(1),\n                    TxnField.config_asset_decimals: UNDERLYING_COMPLIANCE_NFT_DECIMALS,\n                    TxnField.config_asset_unit_name: UNDERLYING_COMPLIANCE_NFT_UNIT_NAME,\n                    TxnField.config_asset_name: UNDERLYING_COMPLIANCE_NFT_NAME,\n                    TxnField.config_asset_url: UNDERLYING_COMPLIANCE_NFT_URL,\n                    TxnField.config_asset_manager: UNDERLYING_COMPLIANCE_NFT_MANAGER_ADDR,\n                    TxnField.config_asset_reserve: UNDERLYING_COMPLIANCE_NFT_RESERVE_ADDR,\n                    TxnField.config_asset_freeze: UNDERLYING_COMPLIANCE_NFT_FREEZE_ADDR,\n                    TxnField.config_asset_clawback: UNDERLYING_COMPLIANCE_NFT_CLAWBACK_ADDR,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n            Return(InnerTxn.created_asset_id()),\n        )\n\n    @internal(TealType.none)\n    def app_opt_into_asset(self, asset_id: Expr):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: asset_id,\n                    TxnField.asset_amount: Int(0),\n                    TxnField.sender: Global.current_application_address(),\n                    # TxnField.asset_sender: Global.current_application_address(),\n                    TxnField.asset_receiver: Global.current_application_address(),\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @internal(TealType.none)\n    def opt_into_asset_for_business(\n        self, business_address: Expr, asset_id: Expr\n    ):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: asset_id,\n                    TxnField.asset_amount: Int(0),\n                    TxnField.sender: business_address,\n                    # TxnField.asset_sender: Global.current_application_address(),\n                    TxnField.asset_receiver: business_address,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @internal(TealType.none)\n    def transfer_compliance_nft_to_business(\n        self, business_address: Expr, asset_id: Expr\n    ):\n        # TODO: Add the check for business' emission control before actually transferring the token!\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: asset_id,\n                    TxnField.asset_amount: Int(1),\n                    TxnField.sender: Global.current_application_address(),\n                    # TxnField.asset_sender: Global.current_application_address(),\n                    TxnField.asset_receiver: business_address,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @external\n    def create_compliance_nft(self, *, output: abi.Uint64):\n        \"\"\"\n        Creates the compliance NFT for the business via the Algorand SC\n        \"\"\"\n        return Seq(\n            (asset_id := abi.Uint64()).set(\n                self.create_compliance_nft_internal()\n            ),\n            self.app_opt_into_asset(asset_id.get()),\n            output.set(asset_id),\n        )\n\n    @external\n    def allocate_compliance_nft_to_business(\n        self,\n        business_address: abi.Address,\n        asset_id: abi.Uint64,\n        *,\n        output: abi.Uint64,\n    ):\n        \"\"\"\n        Creates the compliance NFT for the business via the Algorand SC\n        \"\"\"\n        return Seq(\n            self.transfer_compliance_nft_to_business(\n                business_address.get(), asset_id.get()\n            ),\n            output.set(asset_id),\n        )\n\n    @external\n    def business_opt_into_asset(\n        self,\n        business_address: abi.Address,\n        asset_id: abi.Uint64,\n        *,\n        output: abi.Uint64,\n    ):\n        \"\"\"\n        Business Account opting into the Compliance NFT\n        \"\"\"\n        return Seq(\n            self.opt_into_asset_for_business(\n                business_address.get(), asset_id.get()\n            ),\n            output.set(asset_id),\n        )\n\n    @create\n    def create(self):\n        return self.initialize_application_state()\n\n    @update(authorize=Authorize.only(Global.creator_address()))\n    def update(self):\n        return Approve()\n\n    @opt_in\n    def opt_in(self):\n        return Approve()\n\n\nif __name__ == \"__main__\":\n    EmissionControl().dump(\"./artifacts\")"}
{"file_path": "https://github.com/bytesdruid/Pure-NFT/blob/03143e8f897f930c481ec640d142087d8ed30a4c/asset_contract/asset.py", "code": "from pyteal import *\n\ndef approval():\n    on_creation = Seq(\n        [\n            # g byteslice - asset name is Bloom Token\n            App.globalPut(Bytes(\"AssetName\"), Bytes(\"Pure NFT\")),\n            # g byteslice - unit name is BLT\n            App.globalPut(Bytes(\"UnitName\"), Bytes(\"NFP1023\")),\n            # g int - decimals\n            App.globalPut(Bytes(\"Decimals\"), Int(0)),\n            # g Int - total supply \n            App.globalPut(Bytes(\"Total\"), Int(1)),\n            # g Int - reserve is total amount not sitting in local balance\n            App.globalPut(Bytes(\"GlobalReserve\"), Int(1)),\n            # approve sequence\n            Return(Int(1)),\n        ]\n    )\n\n    opt_in = Seq([\n        # l int - local balance\n        App.localPut(Int(0), Bytes(\"LocalBalance\"), Int(0)),\n        Return(Int(1))\n    ])\n\n    init_admin = Seq([\n        # make sure account opting in is the contract creator address\n        Assert(Txn.sender() == Global.creator_address()),\n        # set the txn sender address to manager\n        App.localPut(Int(0), Bytes(\"Admin\"), Int(1)),\n        Return(Int(1))\n    ])\n\n    is_admin = App.localGet(Int(0), Bytes(\"Admin\"))\n\n    set_admin = Seq(\n        [\n            Assert(And(is_admin, Txn.application_args.length() == Int(1))),\n            App.localPut(Int(1), Bytes(\"Admin\"), Int(1)),\n            Return(Int(1)),\n        ]\n    )\n\n    on_closeout = Seq(\n        [\n            App.globalPut(\n                Bytes(\"GlobalReserve\"),\n                App.globalGet(Bytes(\"GlobalReserve\"))\n                + App.localGet(Int(0), Bytes(\"LocalBalance\")),\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    mint = Seq(\n        [\n            Assert(Txn.application_args.length() == Int(2)),\n            Assert(Btoi(Txn.application_args[1]) <= App.globalGet(Bytes(\"GlobalReserve\"))),\n            App.globalPut(\n                Bytes(\"GlobalReserve\"), App.globalGet(Bytes(\"GlobalReserve\")) - Btoi(Txn.application_args[1]),\n            ),\n            App.localPut(\n                Int(0),\n                Bytes(\"LocalBalance\"),\n                App.localGet(Int(0), Bytes(\"LocalBalance\")) + Btoi(Txn.application_args[1]),\n            ),\n            Return(is_admin),\n        ]\n    )\n\n    transfer_amount = Btoi(Txn.application_args[1])    \n    transfer = Seq(\n        [\n            Assert(Txn.application_args.length() == Int(2)),\n            Assert(transfer_amount <= App.localGet(Int(0), Bytes(\"LocalBalance\"))),\n            App.localPut(\n                Int(0),\n                Bytes(\"LocalBalance\"),\n                App.localGet(Int(0), Bytes(\"LocalBalance\")) - transfer_amount,\n            ),\n            App.localPut(\n                Int(1),                 \n                Bytes(\"LocalBalance\"),\n                App.localGet(Int(1), Bytes(\"LocalBalance\")) + transfer_amount,\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, opt_in],\n        [Txn.application_args[0] == Bytes(\"Init_Admin\"), init_admin],\n        [Txn.application_args[0] == Bytes(\"Set_Admin\"), set_admin],\n        [Txn.application_args[0] == Bytes(\"Mint\"), mint],\n        [Txn.application_args[0] == Bytes(\"Transfer\"), transfer],\n    )\n\n    return program\n\ndef clear():\n    program = Seq(\n        [\n            App.globalPut(\n                Bytes(\"GlobalReserve\"),\n                App.globalGet(Bytes(\"GlobalReserve\"))\n                + App.localGet(Int(0), Bytes(\"LocalBalance\")),\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    return program\n\n\nif __name__ == \"__main__\":\n    with open(\"approval.teal\", \"w\") as f:\n        compiled = compileTeal(approval(), mode=Mode.Application, version=6)\n        f.write(compiled)\n\n    with open(\"clear.teal\", \"w\") as f:\n        compiled = compileTeal(clear(), mode=Mode.Application, version=6)\n        f.write(compiled)"}
{"file_path": "https://github.com/algorandfoundation/puya/blob/6d27f657ce8fddaedc33e778daa8799546778d1b/stubs/algopy-stubs/_contract.pyi", "code": "import abc\nimport typing\n\nfrom algopy import UInt64, urange\n\n@typing.final\nclass StateTotals:\n    \"\"\"\n    Options class to manually define the total amount of global and local state contract will use,\n    used by [`Contract.__init_subclass__`](#algopy.Contract.__init_subclass__).\n\n    This is not required when all state is assigned to `self.`, but is required if a\n    contract dynamically interacts with state via `AppGlobal.get_bytes` etc, or if you want\n    to reserve additional state storage for future contract updates, since the Algorand protocol\n    doesn't allow increasing them after creation.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        global_uints: int = ...,\n        global_bytes: int = ...,\n        local_uints: int = ...,\n        local_bytes: int = ...,\n    ) -> None:\n        \"\"\"Specify the totals for both global and local, and for each type. Any arguments not\n        specified default to their automatically calculated values.\n\n        Values are validated against the known totals assigned through `self.`, a warning is\n        produced if the total specified is insufficient to accommodate all `self.` state values\n        at once.\n        \"\"\"\n\nclass Contract(abc.ABC):\n    \"\"\"Base class for an Algorand Smart Contract\"\"\"\n\n    def __init_subclass__(\n        cls,\n        *,\n        name: str = ...,\n        scratch_slots: urange | tuple[int | urange, ...] | list[int | urange] = ...,\n        state_totals: StateTotals = ...,\n        avm_version: int = ...,\n    ):\n        \"\"\"\n        When declaring a Contract subclass, options and configuration are passed in\n        the base class list:\n\n        ```python\n        class MyContract(algopy.Contract, name=\"CustomName\"):\n            ...\n        ```\n\n        :param name:\n         Will affect the output TEAL file name if there are multiple non-abstract contracts\n         in the same file.\n\n         If the contract is a subclass of algopy.ARC4Contract, `name` will also be used as the\n         contract name in the ARC-32 application.json, instead of the class name.\n\n        :param scratch_slots:\n         Allows you to mark a slot ID or range of slot IDs as \"off limits\" to Puya.\n         These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.\n         This is particularly useful in combination with `algopy.op.gload_bytes` / `algopy.op.gload_uint64`\n         which lets a contract in a group transaction read from the scratch slots of another contract\n         that occurs earlier in the transaction group.\n\n         In the case of inheritance, scratch slots reserved become cumulative. It is not an error\n         to have overlapping ranges or values either, so if a base class contract reserves slots\n         0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived\n         contract all slots 0-10 will be marked as reserved.\n\n        :param state_totals:\n         Allows defining what values should be used for global and local uint and bytes storage\n         values when creating a contract. Used when outputting ARC-32 application.json schemas.\n\n         If let unspecified, the totals will be determined by the compiler based on state\n         variables assigned to `self`.\n\n         This setting is not inherited, and only applies to the exact `Contract` it is specified\n         on. If a base class does specify this setting, and a derived class does not, a warning\n         will be emitted for the derived class. To resolve this warning, `state_totals` must be\n         specified. Note that it is valid to not provide any arguments to the `StateTotals`\n         constructor, like so `state_totals=StateTotals()`, in which case all values will be\n         automatically calculated.\n        :param avm_version:\n         Determines which AVM version to use, this affects what operations are supported.\n         Defaults to value provided supplied on command line (which defaults to current mainnet version)\n        \"\"\"\n\n    @abc.abstractmethod\n    def approval_program(self) -> UInt64 | bool:\n        \"\"\"Represents the program called for all transactions\n        where `OnCompletion` != `ClearState`\"\"\"\n\n    @abc.abstractmethod\n    def clear_state_program(self) -> UInt64 | bool:\n        \"\"\"Represents the program called when `OnCompletion` == `ClearState`\"\"\""}
{"file_path": "https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py", "code": "#\nimport base64\n\n#\nfrom typing import Optional\nfrom dataclasses import dataclass\n\n#\nfrom algosdk import account, mnemonic, transaction, logic\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import PaymentTxn, SignedTransaction\nfrom algosdk.transaction import ApplicationCreateTxn, ApplicationCallTxn\n\n\n#\n@dataclass\nclass AlgoUser:\n    pk: str\n    address: int\n    mnemonic: float\n\n    def __str__(self):\n        return \"Private Key - {}\\nAddress - {}\\nMnemonic - {}\".format(\n                    self.pk,\n                    self.address,\n                    self.mnemonic\n                )\n\n\n#\nclass Algorand:\n    \"\"\"\n    Algorand object for interacting with algosdk\n    \"\"\"\n\n    # global and local schema parameters\n    GLOBAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)\n    LOCAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)\n\n    #\n    def __init__(self, algo_token: str, algo_address: str) -> None:\n        \"\"\"\n        Constructor\n\n        :param algo_token: token for connecting algorand testnet\n        :param algo_address: algorand testnet address\n\n        :returns: None\n        \"\"\"\n        self.__token = algo_token\n        self.__address = algo_address\n        self.__headers = {\"X-API-Key\": self.token}\n        self.__client = self.__get_client()\n        self.__params = self.client.suggested_params()\n\n    #\n    def __get_client(self) -> Optional[AlgodClient]:\n        \"\"\"\n        create AlgodClient object from given token and address\n\n        :returns: AlgodClient object\n        \"\"\"\n        return AlgodClient(self.token, self.address, self.headers)\n\n    #\n    @property\n    def headers(self) -> dict:\n        \"\"\"\n        Getter for header private field\n\n        :returns: headers field value\n        \"\"\"\n        return self.__headers\n\n    #\n    @property\n    def token(self) -> str:\n        \"\"\"\n        Getter for token private field\n\n        :returns: token field value\n        \"\"\"\n        return self.__token\n\n    #\n    @property\n    def address(self) -> str:\n        \"\"\"\n        Getter for address private field\n\n        :returns: address field value\n        \"\"\"\n        return self.__address\n\n    #\n    @property\n    def params(self) -> str:\n        \"\"\"\n        Getter for params private field\n\n        :returns: params field value\n        \"\"\"\n        return self.__params\n\n    #\n    @property\n    def client(self) -> Optional[AlgodClient]:\n        \"\"\"\n        Getter for client private field\n\n        :returns: client field value\n        \"\"\"\n        return self.__client\n\n    #\n    def get_balance(self, address: str) -> int:\n        \"\"\"\n        Get balance of given account\n\n        :params address: address of account\n\n        :returns: amount balance\n        \"\"\"\n        return self.client.account_info(address).get(\"amount\")\n\n    #\n    def get_transaction_info(self, tx_id: str):\n        \"\"\"\n        Get transaction information\n\n        :param tx_id: transaction id\n\n        :returns: transaction information\n        \"\"\"\n        return self.client.pending_transaction_info(tx_id)\n\n    #\n    def generate_new_account(self) -> dict:\n        \"\"\"\n        Generate new account for algorand testnet\n\n        :returns: new generated account key, address and mnemonic\n        \"\"\"\n        private_key, address = account.generate_account()\n        mnem = mnemonic.from_private_key(private_key)\n\n        return AlgoUser(private_key, address, mnem)\n\n    #\n    def get_application_id(self, tx_id: str) -> int:\n        \"\"\"\n        Get application id from transaction id\n\n        :param tx_id: transaction id\n\n        :returns: application id\n        \"\"\"\n        transaction_info = self.get_transaction_info(tx_id)\n        app_id = transaction_info.get(\"application-index\")\n        return app_id\n\n    #\n    def get_application_address(self, app_id: int) -> str:\n        \"\"\"\n        Get application address from id\n\n        :param app_id: id of application\n\n        :returns: address of application\n        \"\"\"\n        app_address = logic.get_application_address(app_id)\n        return app_address\n\n    #\n    def build_payment_transaction(\n                self,\n                sender: str,\n                receiver: str,\n                amount: int,\n                note: str\n            ) -> Optional[PaymentTxn]:\n        \"\"\"\n        Build payment transaction from sender to receiver\n\n        :param sender: sender address\n        :param receiver: receiver address\n        ;param amount: amount which should be transferred\n        :param note: note for transaction\n\n        :returns: payment transaction\n        \"\"\"\n        txn = transaction.PaymentTxn(\n            sender=sender,\n            sp=self.params,\n            receiver=receiver,\n            amt=amount,\n            note=note,\n        )\n        return txn\n\n    #\n    def create_application_transaction(\n                self,\n                sender: str,\n                approval_teal: bytes,\n                clear_teal: bytes\n            ) -> Optional[ApplicationCreateTxn]:\n        \"\"\"\n        Create transaction that interacts with the application system\n\n        :param sender: address\n        :param approval_teal: transaction smart contract in bytes\n        :param clear_teal: clear smart contract in bytes\n\n        :returns: application transaction\n        \"\"\"\n        app_create_txn = transaction.ApplicationCreateTxn(\n            sender=sender,\n            sp=self.params,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            approval_program=approval_teal,\n            clear_program=clear_teal,\n            global_schema=self.GLOBAL_SCHEMA,\n            local_schema=self.LOCAL_SCHEMA\n        )\n        return app_create_txn\n\n    #\n    def sign_transaction(\n                self,\n                sender: str,\n                txn: Optional[ApplicationCreateTxn]\n            ) -> Optional[SignedTransaction]:\n        \"\"\"\n        Sign created transaction\n\n        :param sender: sender private key\n        :param txn: transaction which should be signed\n\n        :returns: signed transaction\n        \"\"\"\n        signed_txn = txn.sign(sender)\n        return signed_txn\n\n    #\n    def send_transaction(self, signed_txn: Optional[SignedTransaction]) -> str:\n        \"\"\"\n        Send already signed transaction\n\n        :param signed_txn: signed transaction which should be sent\n\n        :returns: transaction id\n        \"\"\"\n        tx_id = self.client.send_transaction(signed_txn)\n        return tx_id\n\n    #\n    def wait_for_confirmation(self, tx_id: str) -> None:\n        \"\"\"\n        Block until a pending transaction is confirmed by the network\n\n        :param tx_id: transaction id\n\n        :returns None\n        \"\"\"\n        return transaction.wait_for_confirmation(self.client, tx_id, 4)\n\n    #\n    def call_application_transaction(\n                self,\n                sender: str,\n                app_id: int,\n                app_args: list,\n                receiver: str=None,\n                asset: int=None\n            ) -> Optional[ApplicationCallTxn]:\n        \"\"\"\n        Create Application call transaction object\n\n        :param sender: sender address\n        :param app_id: application id for which transaction is made\n        :param app_args: arguments for application smart contract\n        :param receiver: receiver address\n\n        :returns: ApplicationCallTxn objects\n        \"\"\"\n\n        accounts = []\n        if receiver:\n            accounts.append(receiver)\n\n        assets = []\n        if asset:\n            assets.append(asset)\n        \n        app_call_txn = transaction.ApplicationCallTxn(\n            sender=sender,\n            sp=self.params,\n            index=app_id,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            app_args=app_args,\n            accounts=accounts,\n            foreign_assets=assets\n        )\n        return app_call_txn\n\n    #\n    def call_application_transaction_foreign_asset(\n                self,\n                sender: str,\n                app_id: int,\n                app_args: list,\n                asset_id: str=None\n            ) -> Optional[ApplicationCallTxn]:\n        \"\"\"\n        Create Application call transaction object\n\n        :param sender: sender address\n        :param app_id: application id for which transaction is made\n        :param app_args: arguments for application smart contract\n        :param receiver: receiver address\n\n        :returns: ApplicationCallTxn objects\n        \"\"\"\n\n        app_call_txn = transaction.ApplicationCallTxn(\n            sender=sender.address,\n            sp=self.params,\n            index=app_id,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            app_args=app_args,\n            foreign_assets=[asset_id]\n        )\n        return app_call_txn\n    #\n    def create_application_no_op_transaction(self, sender, app_id, app_args, receiver=None):\n        accounts = []\n        if receiver:\n            accounts.append(receiver.address)\n        \n        txn = transaction.ApplicationNoOpTxn(\n                sender=sender.address,\n                sp=self.params,\n                index=app_id,\n                app_args=app_args,\n                accounts=accounts\n        )\n\n        return txn\n\n    #\n    def create_asset(self, creator):\n        txn = transaction.AssetConfigTxn(\n                sender=creator.address,\n                sp=self.params,\n                total=1000000,\n                default_frozen=False,\n                unit_name=\"LSCOIN\",\n                asset_name=\"LS Coin\",\n                manager=creator.address,\n                reserve=creator.address,\n                freeze=creator.address,\n                clawback=creator.address,\n                decimals=0\n        )\n        signed_txn = self.sign_transaction(creator.pk, txn)\n        tx_id = self.send_transaction(signed_txn)\n        self.wait_for_confirmation(tx_id)\n        response = self.client.pending_transaction_info(tx_id)\n        return response['asset-index']\n\n    #\n    def opt_in_to_asset(self, sender, asset_id):\n        txn = transaction.AssetTransferTxn(\n                sender=sender.address,\n                sp=self.params,\n                receiver=sender.address,\n                amt=0,\n                index=asset_id\n            )\n        signed_txn = self.sign_transaction(sender.pk, txn)\n        tx_id = self.send_transaction(signed_txn)\n        self.wait_for_confirmation(tx_id)\n\n\n    \n    #\n    def get_application_global_state(self, app_id: int) -> dict:\n        \"\"\"\n        Get application global state info\n\n        :param app_id: application id\n\n        :returns: info about application global state\n        \"\"\"\n        app_info = self.client.application_info(app_id)\n        global_state = app_info['params']['global-state']\n        state = {}\n        for item in global_state:\n            key = base64.b64decode(item['key']).decode('utf-8')\n            value = item['value']\n            state[key] = value\n        return state"}
{"file_path": "https://github.com/KOSASIH/pi-nexus-autonomous-banking-network/blob/aad37ae96f34f3088f33692b3eaae503e53ee1eb/projects/piguardian/smart_contracts/incident_response_contract.py", "code": "from algosdk import constants\nfrom algosdk.encoding import encode_address, is_valid_address\nfrom algosdk.future import transaction\n\nclass IncidentResponseContract:\n    def __init__(self, creator_address, incident_response_fee):\n        self.creator_address = creator_address\n        self.incident_response_fee = incident_response_fee\n\n    def create_contract(self):\n        # Create a new Algorand transaction\n        txn = transaction.PaymentTxn(\n            self.creator_address,\n            constants.ZERO_ADDRESS,\n            self.incident_response_fee,\n            \"incident response contract\"\n        )\n\n        # Compile the contract code\n        contract_code = self.compile_contract_code()\n\n        # Create a new Algorand smart contract\n        contract = transaction.LogicSig(contract_code)\n\n        # Return the contract\n        return contract\n\n    def compile_contract_code(self):\n        # Compile the contract code using the Algorand SDK\n        # This code will be executed on the Algorand blockchain\n        # It will handle incident response logic\n        contract_code = \"\"\"\n        pragma solidity ^0.6.0;\n\n        contract IncidentResponseContract {\n            address private creator;\n            uint public incidentResponseFee;\n\n            constructor() public {\n                creator = msg.sender;\n                incidentResponseFee = 1000000; // 1 Algo\n            }\n\n            function respondToIncident(address incidentAddress) public {\n                // Check if the incident address is valid\n                require(isValidAddress(incidentAddress), \"Invalid incident address\");\n\n                // Check if the caller is the creator of the contract\n                require(msg.sender == creator, \"Only the creator can respond to incidents\");\n\n                // Respond to the incident\n                // This will trigger a payment to the incident address\n                // with the incident response fee\n                payable(incidentAddress).transfer(incidentResponseFee);\n            }\n\n            function isValidAddress(address addr) internal view returns (bool) {\n                return addr != address(0);\n            }\n        }\n        \"\"\"\n        return contract_code\n\n    def deploy_contract(self, contract):\n        # Deploy the contract to the Algorand blockchain\n        # This will create a new smart contract on the blockchain\n        # with the incident response logic\n        txn_id = transaction.send_transaction(contract)\n        return txn_id\n\n    def call_contract(self, contract, incident_address):\n        # Call the contract to respond to an incident\n        # This will trigger the incident response logic\n        # and send the incident response fee to the incident address\n        txn_id = transaction.call_contract(contract, incident_address)\n        return txn_id"}
{"file_path": "https://github.com/marotipatre/Escrow-Mechanism-on-Algorand/blob/0ed1b564a678a60028558082832e3bec46afdc61/projects/escrow_mechanism/smart_contracts/artifacts/escrow_contract/escrow_client.py", "code": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": []}, \"methods\": [{\"actions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"args\": [{\"type\": \"uint64\", \"name\": \"value\"}, {\"type\": \"account\", \"name\": \"seller\"}, {\"type\": \"account\", \"name\": \"buyer\"}, {\"type\": \"account\", \"name\": \"arbitrator\"}, {\"type\": \"uint64\", \"name\": \"escrow_duration\"}], \"name\": \"create_application\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"pay\", \"name\": \"payment\"}], \"name\": \"deposit_funds\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"release_funds_to_seller\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"refund_funds_to_buyer\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"raise_dispute\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"string\", \"name\": \"decision\"}], \"name\": \"resolve_dispute\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"expire_escrow\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"DeleteApplication\"], \"create\": []}, \"args\": [], \"name\": \"delete_application\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}], \"name\": \"Escrow\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"seller\": {\"key\": \"c2VsbGVy\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}, \"buyer\": {\"key\": \"YnV5ZXI=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}, \"arbitrator\": {\"key\": \"YXJiaXRyYXRvcg==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}, \"amount\": {\"key\": \"YW1vdW50\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"escrow_expiry\": {\"key\": \"ZXNjcm93X2V4cGlyeQ==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"is_disputed\": {\"key\": \"aXNfZGlzcHV0ZWQ=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"is_settled\": {\"key\": \"aXNfc2V0dGxlZA==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"value\": {\"key\": \"dmFsdWU=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}}, \"local\": {}}, \"maps\": {\"box\": {}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 3, \"ints\": 5}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {}, \"byteCode\": {\"approval\": \"CiADAAHoByYHCmlzX3NldHRsZWQFYnV5ZXIFdmFsdWUGc2VsbGVyCmFyYml0cmF0b3ILaXNfZGlzcHV0ZWQNZXNjcm93X2V4cGlyeTEbQQA/gggEP+TTmgT9xpXCBDHOdZcENMl5yQRDmCZdBJG0UyoEUSH3QQQzs0meNhoAjggAaABSAEYAOgAuABwAEAACIkMxGYEFEkQxGESIAekjQzEZFEQxGESIAcojQzEZFEQxGEQ2GgFXAgCIAWUjQzEZFEQxGESIASQjQzEZFEQxGESIANYjQzEZFEQxGESIAIgjQzEZFEQxGEQxFiMJSTgQIxJEiABOI0MxGRREMRgURDYaARc2GgIXwBw2GgMXwBw2GgQXwBw2GgUXiAACI0OKBQAqi/tnK4v8ZymL/WcnBIv+ZzIHi/8IJwZMZycFImcoImeJigEAMQAiKWVEEkSL/zgHMgoSRIv/OAgiKmVEEkQiKGVEFESJigAAMQBJIillRCInBGVMTgNEEkAACIsAiwESQQAgI0QiKGVEFESxIitlRCIqZUSyCLIHI7IQJLIBsygjZ4kiQv/digAAMQBJIitlRCInBGVMTgNEEkAACIsAiwESQQAgI0QiKGVEFESxIillRCIqZUSyCLIHI7IQJLIBsygjZ4kiQv/digAAMQBJIillRCIrZUxOA0QSQAAIiwCLARJBABQjRCInBWVEFEQiKGVEFEQnBSNniSJC/+mKAQAxACInBGVEEkQiJwVlREQiKGVEFESL/4ARcmVsZWFzZV90b19zZWxsZXISQQAHiP8TKCNniYv/gA9yZWZ1bmRfdG9fYnV5ZXISRIj/OUL/4TIHIicGZUQPRCIoZUQURIj/JIkiKGVERDEAMgkSRIk=\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 4}}, \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTAwMAogICAgYnl0ZWNibG9jayAiaXNfc2V0dGxlZCIgImJ1eWVyIiAidmFsdWUiICJzZWxsZXIiICJhcmJpdHJhdG9yIiAiaXNfZGlzcHV0ZWQiICJlc2Nyb3dfZXhwaXJ5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2FmdGVyX2lmX2Vsc2VAMTQKICAgIHB1c2hieXRlc3MgMHgzZmU0ZDM5YSAweGZkYzY5NWMyIDB4MzFjZTc1OTcgMHgzNGM5NzljOSAweDQzOTgyNjVkIDB4OTFiNDUzMmEgMHg1MTIxZjc0MSAweDMzYjM0OTllIC8vIG1ldGhvZCAiY3JlYXRlX2FwcGxpY2F0aW9uKHVpbnQ2NCxhY2NvdW50LGFjY291bnQsYWNjb3VudCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVwb3NpdF9mdW5kcyhwYXkpdm9pZCIsIG1ldGhvZCAicmVsZWFzZV9mdW5kc190b19zZWxsZXIoKXZvaWQiLCBtZXRob2QgInJlZnVuZF9mdW5kc190b19idXllcigpdm9pZCIsIG1ldGhvZCAicmFpc2VfZGlzcHV0ZSgpdm9pZCIsIG1ldGhvZCAicmVzb2x2ZV9kaXNwdXRlKHN0cmluZyl2b2lkIiwgbWV0aG9kICJleHBpcmVfZXNjcm93KCl2b2lkIiwgbWV0aG9kICJkZWxldGVfYXBwbGljYXRpb24oKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NyZWF0ZV9hcHBsaWNhdGlvbl9yb3V0ZUAzIG1haW5fZGVwb3NpdF9mdW5kc19yb3V0ZUA0IG1haW5fcmVsZWFzZV9mdW5kc190b19zZWxsZXJfcm91dGVANSBtYWluX3JlZnVuZF9mdW5kc190b19idXllcl9yb3V0ZUA2IG1haW5fcmFpc2VfZGlzcHV0ZV9yb3V0ZUA3IG1haW5fcmVzb2x2ZV9kaXNwdXRlX3JvdXRlQDggbWFpbl9leHBpcmVfZXNjcm93X3JvdXRlQDkgbWFpbl9kZWxldGVfYXBwbGljYXRpb25fcm91dGVAMTAKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NQogICAgLy8gY2xhc3MgRXNjcm93KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9hcHBsaWNhdGlvbl9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTA5LTExMAogICAgLy8gIyBEZWxldGUgdGhlIGFwcGxpY2F0aW9uIChvbmx5IGFmdGVyIHNldHRsZW1lbnQpCiAgICAvLyBAYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJEZWxldGVBcHBsaWNhdGlvbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZXhwaXJlX2VzY3Jvd19yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyAjIFRpbWUtbG9jazogQXV0b21hdGljYWxseSByZWZ1bmQgYnV5ZXIgaWYgZXNjcm93IGV4cGlyZXMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGV4cGlyZV9lc2Nyb3cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVzb2x2ZV9kaXNwdXRlX3JvdXRlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg0CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg0CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgcmVzb2x2ZV9kaXNwdXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3JhaXNlX2Rpc3B1dGVfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzQtNzUKICAgIC8vICMgUmFpc2UgYSBkaXNwdXRlIChjYWxsZWQgYnkgYnV5ZXIgb3Igc2VsbGVyKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmFpc2VfZGlzcHV0ZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9yZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NTgtNTkKICAgIC8vICMgUmVmdW5kIGZ1bmRzIHRvIGJ1eWVyIChjYWxsZWQgYnkgc2VsbGVyIG9yIGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVsZWFzZV9mdW5kc190b19zZWxsZXJfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NDItNDMKICAgIC8vICMgUmVsZWFzZSBmdW5kcyB0byBzZWxsZXIgKGNhbGxlZCBieSBidXllciBvciBhcmJpdHJhdG9yKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmVsZWFzZV9mdW5kc190b19zZWxsZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVwb3NpdF9mdW5kc19yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNC0zNQogICAgLy8gIyBEZXBvc2l0IGZ1bmRzIGludG8gZXNjcm93IChjYWxsZWQgYnkgYnV5ZXIpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNC0zNQogICAgLy8gIyBEZXBvc2l0IGZ1bmRzIGludG8gZXNjcm93IChjYWxsZWQgYnkgYnV5ZXIpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZGVwb3NpdF9mdW5kcwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfYXBwbGljYXRpb25fcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTcKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwgY3JlYXRlPSJyZXF1aXJlIikKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUKICAgIC8vIGNsYXNzIEVzY3JvdyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxNwogICAgLy8gQGFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiTm9PcCJdLCBjcmVhdGU9InJlcXVpcmUiKQogICAgY2FsbHN1YiBjcmVhdGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5jcmVhdGVfYXBwbGljYXRpb24odmFsdWU6IHVpbnQ2NCwgc2VsbGVyOiBieXRlcywgYnV5ZXI6IGJ5dGVzLCBhcmJpdHJhdG9yOiBieXRlcywgZXNjcm93X2R1cmF0aW9uOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZV9hcHBsaWNhdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTctMjUKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwgY3JlYXRlPSJyZXF1aXJlIikKICAgIC8vIGRlZiBjcmVhdGVfYXBwbGljYXRpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWx1ZTogVUludDY0LAogICAgLy8gICAgIHNlbGxlcjogQWNjb3VudCwKICAgIC8vICAgICBidXllcjogQWNjb3VudCwKICAgIC8vICAgICBhcmJpdHJhdG9yOiBBY2NvdW50LAogICAgLy8gICAgIGVzY3Jvd19kdXJhdGlvbjogVUludDY0LCAgIyBEdXJhdGlvbiBpbiBzZWNvbmRzCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA1IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MjYKICAgIC8vIHNlbGYudmFsdWUgPSB2YWx1ZQogICAgYnl0ZWNfMiAvLyAidmFsdWUiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3CiAgICAvLyBzZWxmLnNlbGxlciA9IHNlbGxlcgogICAgYnl0ZWNfMyAvLyAic2VsbGVyIgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToyOAogICAgLy8gc2VsZi5idXllciA9IGJ1eWVyCiAgICBieXRlY18xIC8vICJidXllciIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MjkKICAgIC8vIHNlbGYuYXJiaXRyYXRvciA9IGFyYml0cmF0b3IKICAgIGJ5dGVjIDQgLy8gImFyYml0cmF0b3IiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwCiAgICAvLyBzZWxmLmVzY3Jvd19leHBpcnkgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGVzY3Jvd19kdXJhdGlvbgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBieXRlYyA2IC8vICJlc2Nyb3dfZXhwaXJ5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzEKICAgIC8vIHNlbGYuaXNfZGlzcHV0ZWQgPSBGYWxzZQogICAgYnl0ZWMgNSAvLyAiaXNfZGlzcHV0ZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzIKICAgIC8vIHNlbGYuaXNfc2V0dGxlZCA9IEZhbHNlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5kZXBvc2l0X2Z1bmRzKHBheW1lbnQ6IHVpbnQ2NCkgLT4gdm9pZDoKZGVwb3NpdF9mdW5kczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzQtMzYKICAgIC8vICMgRGVwb3NpdCBmdW5kcyBpbnRvIGVzY3JvdyAoY2FsbGVkIGJ5IGJ1eWVyKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGVwb3NpdF9mdW5kcyhzZWxmLCBwYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbikgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5idXllciwgIk9ubHkgdGhlIGJ1eWVyIGNhbiBkZXBvc2l0IGZ1bmRzIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBidXllciBjYW4gZGVwb3NpdCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozOAogICAgLy8gYXNzZXJ0IHBheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgIlBheW1lbnQgbXVzdCBiZSBzZW50IHRvIHRoZSBlc2Nyb3ciCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byB0aGUgZXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyBhc3NlcnQgcGF5bWVudC5hbW91bnQgPT0gc2VsZi52YWx1ZSwgIlBheW1lbnQgbXVzdCBtYXRjaCB0aGUgYXNzZXQgcHJpY2UiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbHVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbHVlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgbWF0Y2ggdGhlIGFzc2V0IHByaWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcigpIC0+IHZvaWQ6CnJlbGVhc2VfZnVuZHNfdG9fc2VsbGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo0Mi00NAogICAgLy8gIyBSZWxlYXNlIGZ1bmRzIHRvIHNlbGxlciAoY2FsbGVkIGJ5IGJ1eWVyIG9yIGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcihzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciBpbiAoc2VsZi5idXllciwgc2VsZi5hcmJpdHJhdG9yKSwgIk9ubHkgYnV5ZXIgb3IgYXJiaXRyYXRvciBjYW4gcmVsZWFzZSBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gImFyYml0cmF0b3IiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXJiaXRyYXRvciBleGlzdHMKICAgID09CiAgICBibnogcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgPT0KICAgIGJ6IHJlbGVhc2VfZnVuZHNfdG9fc2VsbGVyX2Jvb2xfZmFsc2VAMwoKcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo0NQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuYnV5ZXIsIHNlbGYuYXJiaXRyYXRvciksICJPbmx5IGJ1eWVyIG9yIGFyYml0cmF0b3IgY2FuIHJlbGVhc2UgZnVuZHMiCiAgICBhc3NlcnQgLy8gT25seSBidXllciBvciBhcmJpdHJhdG9yIGNhbiByZWxlYXNlIGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ2CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTUzCiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgLy8gICAgIGFtb3VudD1zZWxmLnZhbHVlLAogICAgLy8gICAgIGZlZT0xXzAwMCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NTAKICAgIC8vIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInNlbGxlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zZWxsZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUxCiAgICAvLyBhbW91bnQ9c2VsZi52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWx1ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWx1ZSBleGlzdHMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTQ5CiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1MgogICAgLy8gZmVlPTFfMDAwLAogICAgaW50Y18yIC8vIDEwMDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTUzCiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgLy8gICAgIGFtb3VudD1zZWxmLnZhbHVlLAogICAgLy8gICAgIGZlZT0xXzAwMCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU1LTU2CiAgICAvLyAjIE1hcmsgYXMgc2V0dGxlZAogICAgLy8gc2VsZi5pc19zZXR0bGVkID0gVHJ1ZQogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpyZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcl9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZWZ1bmRfZnVuZHNfdG9fYnV5ZXIoKSAtPiB2b2lkOgpyZWZ1bmRfZnVuZHNfdG9fYnV5ZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4LTYwCiAgICAvLyAjIFJlZnVuZCBmdW5kcyB0byBidXllciAoY2FsbGVkIGJ5IHNlbGxlciBvciBhcmJpdHJhdG9yKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgcmVmdW5kX2Z1bmRzX3RvX2J1eWVyKHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NjEKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIChzZWxmLnNlbGxlciwgc2VsZi5hcmJpdHJhdG9yKSwgIk9ubHkgc2VsbGVyIG9yIGFyYml0cmF0b3IgY2FuIHJlZnVuZCBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInNlbGxlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zZWxsZXIgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiYXJiaXRyYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAzCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hcmJpdHJhdG9yIGV4aXN0cwogICAgPT0KICAgIGJueiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgPT0KICAgIGJ6IHJlZnVuZF9mdW5kc190b19idXllcl9ib29sX2ZhbHNlQDMKCnJlZnVuZF9mdW5kc190b19idXllcl9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpyZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuc2VsbGVyLCBzZWxmLmFyYml0cmF0b3IpLCAiT25seSBzZWxsZXIgb3IgYXJiaXRyYXRvciBjYW4gcmVmdW5kIGZ1bmRzIgogICAgYXNzZXJ0IC8vIE9ubHkgc2VsbGVyIG9yIGFyYml0cmF0b3IgY2FuIHJlZnVuZCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2MgogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NC02OQogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyBiYWNrIHRvIGJ1eWVyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5idXllciwKICAgIC8vICAgICBhbW91bnQ9c2VsZi52YWx1ZSwKICAgIC8vICAgICBmZWU9MV8wMDAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2CiAgICAvLyByZWNlaXZlcj1zZWxmLmJ1eWVyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NwogICAgLy8gYW1vdW50PXNlbGYudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidmFsdWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsdWUgZXhpc3RzCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NC02NQogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyBiYWNrIHRvIGJ1eWVyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBmZWU9MV8wMDAsCiAgICBpbnRjXzIgLy8gMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NjQtNjkKICAgIC8vICMgVHJhbnNmZXIgZnVuZHMgYmFjayB0byBidXllcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuYnV5ZXIsCiAgICAvLyAgICAgYW1vdW50PXNlbGYudmFsdWUsCiAgICAvLyAgICAgZmVlPTFfMDAwLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzEtNzIKICAgIC8vICMgTWFyayBhcyBzZXR0bGVkCiAgICAvLyBzZWxmLmlzX3NldHRsZWQgPSBUcnVlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJlZnVuZF9mdW5kc190b19idXllcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cucmFpc2VfZGlzcHV0ZSgpIC0+IHZvaWQ6CnJhaXNlX2Rpc3B1dGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyAjIFJhaXNlIGEgZGlzcHV0ZSAoY2FsbGVkIGJ5IGJ1eWVyIG9yIHNlbGxlcikKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIHJhaXNlX2Rpc3B1dGUoc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo3NwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuYnV5ZXIsIHNlbGYuc2VsbGVyKSwgIk9ubHkgYnV5ZXIgb3Igc2VsbGVyIGNhbiByYWlzZSBhIGRpc3B1dGUiCiAgICB0eG4gU2VuZGVyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJidXllciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5idXllciBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJzZWxsZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc2VsbGVyIGV4aXN0cwogICAgPT0KICAgIGJueiByYWlzZV9kaXNwdXRlX2Jvb2xfdHJ1ZUAyCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDEKICAgID09CiAgICBieiByYWlzZV9kaXNwdXRlX2Jvb2xfZmFsc2VAMwoKcmFpc2VfZGlzcHV0ZV9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpyYWlzZV9kaXNwdXRlX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIChzZWxmLmJ1eWVyLCBzZWxmLnNlbGxlciksICJPbmx5IGJ1eWVyIG9yIHNlbGxlciBjYW4gcmFpc2UgYSBkaXNwdXRlIgogICAgYXNzZXJ0IC8vIE9ubHkgYnV5ZXIgb3Igc2VsbGVyIGNhbiByYWlzZSBhIGRpc3B1dGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzgKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5pc19kaXNwdXRlZCwgIkRpc3B1dGUgYWxyZWFkeSByYWlzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiaXNfZGlzcHV0ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfZGlzcHV0ZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gRGlzcHV0ZSBhbHJlYWR5IHJhaXNlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo3OQogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4MQogICAgLy8gc2VsZi5pc19kaXNwdXRlZCA9IFRydWUKICAgIGJ5dGVjIDUgLy8gImlzX2Rpc3B1dGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJhaXNlX2Rpc3B1dGVfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgcmFpc2VfZGlzcHV0ZV9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZXNvbHZlX2Rpc3B1dGUoZGVjaXNpb246IGJ5dGVzKSAtPiB2b2lkOgpyZXNvbHZlX2Rpc3B1dGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg1CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiByZXNvbHZlX2Rpc3B1dGUoc2VsZiwgZGVjaXNpb246IFN0cmluZykgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4NgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5hcmJpdHJhdG9yLCAiT25seSB0aGUgYXJiaXRyYXRvciBjYW4gcmVzb2x2ZSBkaXNwdXRlcyIKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJhcmJpdHJhdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFyYml0cmF0b3IgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIGFyYml0cmF0b3IgY2FuIHJlc29sdmUgZGlzcHV0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6ODcKICAgIC8vIGFzc2VydCBzZWxmLmlzX2Rpc3B1dGVkLCAiTm8gZGlzcHV0ZSB0byByZXNvbHZlIgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImlzX2Rpc3B1dGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2Rpc3B1dGVkIGV4aXN0cwogICAgYXNzZXJ0IC8vIE5vIGRpc3B1dGUgdG8gcmVzb2x2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4OAogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo5MAogICAgLy8gaWYgZGVjaXNpb24gPT0gInJlbGVhc2VfdG9fc2VsbGVyIjoKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGJ5dGVzICJyZWxlYXNlX3RvX3NlbGxlciIKICAgID09CiAgICBieiByZXNvbHZlX2Rpc3B1dGVfZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTEKICAgIC8vIHNlbGYucmVsZWFzZV9mdW5kc190b19zZWxsZXIoKQogICAgY2FsbHN1YiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcgoKcmVzb2x2ZV9kaXNwdXRlX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTctOTgKICAgIC8vICMgTWFyayBhcyBzZXR0bGVkCiAgICAvLyBzZWxmLmlzX3NldHRsZWQgPSBUcnVlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJlc29sdmVfZGlzcHV0ZV9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTIKICAgIC8vIGVsaWYgZGVjaXNpb24gPT0gInJlZnVuZF90b19idXllciI6CiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hieXRlcyAicmVmdW5kX3RvX2J1eWVyIgogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGRlY2lzaW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzCiAgICAvLyBzZWxmLnJlZnVuZF9mdW5kc190b19idXllcigpCiAgICBjYWxsc3ViIHJlZnVuZF9mdW5kc190b19idXllcgogICAgYiByZXNvbHZlX2Rpc3B1dGVfYWZ0ZXJfaWZfZWxzZUA2CgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cuZXhwaXJlX2VzY3JvdygpIC0+IHZvaWQ6CmV4cGlyZV9lc2Nyb3c6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gYXNzZXJ0IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wID49IHNlbGYuZXNjcm93X2V4cGlyeSwgIkVzY3JvdyBoYXMgbm90IGV4cGlyZWQgeWV0IgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImVzY3Jvd19leHBpcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZXNjcm93X2V4cGlyeSBleGlzdHMKICAgID49CiAgICBhc3NlcnQgLy8gRXNjcm93IGhhcyBub3QgZXhwaXJlZCB5ZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTA0CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNi0xMDcKICAgIC8vICMgUmVmdW5kIGJ1eWVyCiAgICAvLyBzZWxmLnJlZnVuZF9mdW5kc190b19idXllcigpCiAgICBjYWxsc3ViIHJlZnVuZF9mdW5kc190b19idXllcgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cuZGVsZXRlX2FwcGxpY2F0aW9uKCkgLT4gdm9pZDoKZGVsZXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxMTIKICAgIC8vIGFzc2VydCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBtdXN0IGJlIHNldHRsZWQgYmVmb3JlIGRlbGV0aW5nIgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX3NldHRsZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfc2V0dGxlZCBleGlzdHMKICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHNldHRsZWQgYmVmb3JlIGRlbGV0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExMwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIk9ubHkgdGhlIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgYXBwbGljYXRpb24iCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSBhcHBsaWNhdGlvbgogICAgcmV0c3ViCg==\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [529], \"errorMessage\": \"Dispute already raised\"}, {\"pc\": [636], \"errorMessage\": \"Escrow has not expired yet\"}, {\"pc\": [621], \"errorMessage\": \"Invalid decision\"}, {\"pc\": [562], \"errorMessage\": \"No dispute to resolve\"}, {\"pc\": [151], \"errorMessage\": \"OnCompletion is not DeleteApplication\"}, {\"pc\": [163, 175, 193, 205, 217, 229, 251], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [391], \"errorMessage\": \"Only buyer or arbitrator can release funds\"}, {\"pc\": [522], \"errorMessage\": \"Only buyer or seller can raise a dispute\"}, {\"pc\": [457], \"errorMessage\": \"Only seller or arbitrator can refund funds\"}, {\"pc\": [556], \"errorMessage\": \"Only the arbitrator can resolve disputes\"}, {\"pc\": [334], \"errorMessage\": \"Only the buyer can deposit funds\"}, {\"pc\": [657], \"errorMessage\": \"Only the creator can delete the application\"}, {\"pc\": [342], \"errorMessage\": \"Payment must be sent to the escrow\"}, {\"pc\": [352], \"errorMessage\": \"Payment must match the asset price\"}, {\"pc\": [358, 397, 463, 535, 568, 642], \"errorMessage\": \"Transaction is already settled\"}, {\"pc\": [651], \"errorMessage\": \"Transaction must be settled before deleting\"}, {\"pc\": [255], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [154, 166, 178, 196, 208, 220, 232], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [377, 443, 554], \"errorMessage\": \"check self.arbitrator exists\"}, {\"pc\": [332, 369, 468, 501], \"errorMessage\": \"check self.buyer exists\"}, {\"pc\": [634], \"errorMessage\": \"check self.escrow_expiry exists\"}, {\"pc\": [527, 561], \"errorMessage\": \"check self.is_disputed exists\"}, {\"pc\": [356, 395, 461, 533, 566, 640, 650], \"errorMessage\": \"check self.is_settled exists\"}, {\"pc\": [402, 435, 508], \"errorMessage\": \"check self.seller exists\"}, {\"pc\": [350, 406, 472], \"errorMessage\": \"check self.value exists\"}, {\"pc\": [242], \"errorMessage\": \"transaction type is pay\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass DepositFundsArgs:\n    \"\"\"Dataclass for deposit_funds arguments\"\"\"\n    payment: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"deposit_funds(pay)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ResolveDisputeArgs:\n    \"\"\"Dataclass for resolve_dispute arguments\"\"\"\n    decision: str\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"resolve_dispute(string)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass CreateApplicationArgs:\n    \"\"\"Dataclass for create_application arguments\"\"\"\n    value: int\n    seller: str | bytes\n    buyer: str | bytes\n    arbitrator: str | bytes\n    escrow_duration: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"create_application(uint64,account,account,account,uint64)void\"\n\n\nclass _EscrowDelete:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppDeleteMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass EscrowParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_EscrowDelete\":\n        return _EscrowDelete(self.app_client)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"deposit_funds(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"release_funds_to_seller()void\",\n        }))\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"refund_funds_to_buyer()void\",\n        }))\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"raise_dispute()void\",\n        }))\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"resolve_dispute(string)void\",\n            \"args\": method_args,\n        }))\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"expire_escrow()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _EscrowDeleteTransaction:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass EscrowCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_EscrowDeleteTransaction\":\n        return _EscrowDeleteTransaction(self.app_client)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"deposit_funds(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"release_funds_to_seller()void\",\n        }))\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"refund_funds_to_buyer()void\",\n        }))\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"raise_dispute()void\",\n        }))\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"resolve_dispute(string)void\",\n            \"args\": method_args,\n        }))\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"expire_escrow()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _EscrowDeleteSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n\nclass EscrowSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_EscrowDeleteSend\":\n        return _EscrowDeleteSend(self.app_client)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"deposit_funds(pay)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"release_funds_to_seller()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"refund_funds_to_buyer()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"raise_dispute()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"resolve_dispute(string)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"expire_escrow()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    seller: bytes\n    buyer: bytes\n    arbitrator: bytes\n    amount: int\n    escrow_expiry: int\n    is_disputed: int\n    is_settled: int\n    value: int\n\nclass EscrowState:\n    \"\"\"Methods to access state for the current Escrow app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def seller(self) -> bytes:\n        \"\"\"Get the current value of the seller key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"seller\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\n    @property\n    def buyer(self) -> bytes:\n        \"\"\"Get the current value of the buyer key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"buyer\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\n    @property\n    def arbitrator(self) -> bytes:\n        \"\"\"Get the current value of the arbitrator key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"arbitrator\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\n    @property\n    def amount(self) -> int:\n        \"\"\"Get the current value of the amount key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"amount\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def escrow_expiry(self) -> int:\n        \"\"\"Get the current value of the escrow_expiry key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"escrow_expiry\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def is_disputed(self) -> int:\n        \"\"\"Get the current value of the is_disputed key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"is_disputed\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def is_settled(self) -> int:\n        \"\"\"Get the current value of the is_settled key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"is_settled\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def value(self) -> int:\n        \"\"\"Get the current value of the value key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"value\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\nclass EscrowClient:\n    \"\"\"Client for interacting with Escrow smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = EscrowParams(self.app_client)\n        self.create_transaction = EscrowCreateTransactionParams(self.app_client)\n        self.send = EscrowSend(self.app_client)\n        self.state = EscrowState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"EscrowClient\":\n        return EscrowClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"EscrowClient\":\n        return EscrowClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"EscrowClient\":\n        return EscrowClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"EscrowComposer\":\n        return EscrowComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"deposit_funds(pay)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"release_funds_to_seller()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"refund_funds_to_buyer()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"raise_dispute()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"resolve_dispute(string)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"expire_escrow()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"create_application(uint64,account,account,account,uint64)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"delete_application()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass EscrowMethodCallCreateParams(\n    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[\n        CreateApplicationArgs,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for creating Escrow contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallCreateParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\n@dataclasses.dataclass(frozen=True)\nclass EscrowMethodCallDeleteParams(\n    algokit_utils.BaseAppClientMethodCallParams[\n        typing.Any,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for calling Escrow contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\nclass EscrowFactory(algokit_utils.TypedAppFactoryProtocol[EscrowMethodCallCreateParams, None, EscrowMethodCallDeleteParams]):\n    \"\"\"Factory for deploying and managing EscrowClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = EscrowFactoryParams(self.app_factory)\n        self.create_transaction = EscrowFactoryCreateTransaction(self.app_factory)\n        self.send = EscrowFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: EscrowMethodCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: EscrowMethodCallDeleteParams | None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[EscrowClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return EscrowClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> EscrowClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return EscrowClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> EscrowClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return EscrowClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass EscrowFactoryParams:\n    \"\"\"Parameters for creating transactions for Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = EscrowFactoryCreateParams(app_factory)\n        self.update = EscrowFactoryUpdateParams(app_factory)\n        self.delete = EscrowFactoryDeleteParams(app_factory)\n\nclass EscrowFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the deposit_funds(pay)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"deposit_funds(pay)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def release_funds_to_seller(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the release_funds_to_seller()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"release_funds_to_seller()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def refund_funds_to_buyer(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the refund_funds_to_buyer()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"refund_funds_to_buyer()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def raise_dispute(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the raise_dispute()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"raise_dispute()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the resolve_dispute(string)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"resolve_dispute(string)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def expire_escrow(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the expire_escrow()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"expire_escrow()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the create_application(uint64,account,account,account,uint64)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def delete_application(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the delete_application()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"delete_application()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass EscrowFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass EscrowFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass EscrowFactoryCreateTransaction:\n    \"\"\"Create transactions for Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = EscrowFactoryCreateTransactionCreate(app_factory)\n\n\nclass EscrowFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass EscrowFactorySend:\n    \"\"\"Send calls to Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = EscrowFactorySendCreate(app_factory)\n\n\nclass EscrowFactorySendCreate:\n    \"\"\"Send create calls to Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[EscrowClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return EscrowClient(result[0]), result[1]\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> tuple[EscrowClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:\n            \"\"\"Creates and sends a transaction using the create_application(uint64,account,account,account,uint64)void ABI method\"\"\"\n            params = params or algokit_utils.CommonAppCallCreateParams()\n            client, result = self.app_factory.send.create(\n                algokit_utils.AppFactoryCreateMethodCallParams(\n                    **{\n                    **dataclasses.asdict(params),\n                    \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n                    \"args\": _parse_abi_args(args),\n                    }\n                ),\n                send_params=send_params,\n                compilation_params=compilation_params\n            )\n            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)\n    \n            return EscrowClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](\n                **{\n                    **result.__dict__,\n                    \"app_id\": result.app_id,\n                    \"abi_return\": return_value,\n                    \"transaction\": result.transaction,\n                    \"confirmation\": result.confirmation,\n                    \"group_id\": result.group_id,\n                    \"tx_ids\": result.tx_ids,\n                    \"transactions\": result.transactions,\n                    \"confirmations\": result.confirmations,\n                    \"app_address\": result.app_address,\n                }\n            )\n\n\nclass _EscrowDeleteComposer:\n    def __init__(self, composer: \"EscrowComposer\"):\n        self.composer = composer\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self.composer._composer.add_app_delete_method_call(\n            self.composer.client.params.delete.delete_application(\n                \n                params=params,\n                \n            )\n        )\n        self.composer._result_mappers.append(\n            lambda v: self.composer.client.decode_return_value(\n                \"delete_application()void\", v\n            )\n        )\n        return self.composer\n\n\nclass EscrowComposer:\n    \"\"\"Composer for creating transaction groups for Escrow contract calls\"\"\"\n\n    def __init__(self, client: \"EscrowClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    @property\n    def delete(self) -> \"_EscrowDeleteComposer\":\n        return _EscrowDeleteComposer(self)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.deposit_funds(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"deposit_funds(pay)void\", v\n            )\n        )\n        return self\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.release_funds_to_seller(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"release_funds_to_seller()void\", v\n            )\n        )\n        return self\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.refund_funds_to_buyer(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"refund_funds_to_buyer()void\", v\n            )\n        )\n        return self\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.raise_dispute(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"raise_dispute()void\", v\n            )\n        )\n        return self\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.resolve_dispute(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"resolve_dispute(string)void\", v\n            )\n        )\n        return self\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.expire_escrow(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"expire_escrow()void\", v\n            )\n        )\n        return self\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.create_application(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"create_application(uint64,account,account,account,uint64)void\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"EscrowComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"file_path": "https://github.com/algorandfoundation/ARCs/blob/2f3df5821265291f49710f58e53324ac4405d0e9/assets/arc-0062/smart_contracts/artifacts/circulating_supply/circulating_supply_client.py", "code": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"methods\": [{\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"uint64\", \"desc\": \"ASA ID of the circulating supply\", \"name\": \"asset_id\"}], \"name\": \"set_asset\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Set the ASA ID for the circulating supply - Authorization: ASA Manager Address\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"address\", \"desc\": \"Address to assign to the label to\", \"name\": \"address\"}, {\"type\": \"string\", \"desc\": \"Not-circulating label selector\", \"name\": \"label\"}], \"name\": \"set_not_circulating_address\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Set non-circulating supply addresses - Authorization: ASA Manager Address\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"uint64\", \"desc\": \"ASA ID of the circulating supply\", \"name\": \"asset_id\"}], \"name\": \"arc62_get_circulating_supply\", \"returns\": {\"type\": \"uint64\", \"desc\": \"ASA circulating supply\"}, \"desc\": \"Get ASA circulating supply\", \"events\": [], \"readonly\": true, \"recommendations\": {}}], \"name\": \"CirculatingSupply\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"asset_id\": {\"key\": \"YXNzZXRfaWQ=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"not_circulating_label_1\": {\"key\": \"YnVybmVk\", \"keyType\": \"AVMString\", \"valueType\": \"address\"}, \"not_circulating_label_2\": {\"key\": \"bG9ja2Vk\", \"keyType\": \"AVMString\", \"valueType\": \"address\"}, \"not_circulating_label_3\": {\"key\": \"Z2VuZXJpYw==\", \"keyType\": \"AVMString\", \"valueType\": \"address\"}}, \"local\": {}}, \"maps\": {\"box\": {}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 3, \"ints\": 1}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {}, \"byteCode\": {\"approval\": \"CiADAAEgJgQIYXNzZXRfaWQGYnVybmVkBmxvY2tlZAdnZW5lcmljMRhAAA8oImcpMgNnKjIDZysyA2cxG0EAXYIDBHCbgKgEC2LHKARcwsU1NhoAjgMAMQAcAAIiQzEZFEQxGEQ2GgEXiACXFoAEFR98dUxQsCNDMRkURDEYRDYaATYaAlcCAIgAPSNDMRkURDEYRDYaAReIAA0jQzEZQP+6MRgURCNDigEAMQCL/3EHRBJBAA4iKGVEQAAHI0Qoi/9niSJC//aKAgAiKGVEMQBLAXEHRBJEi/4VJBJEi/5McABFAUQpKiuL/44DAAsABgABACuL/meJKov+Z4kpi/5niYoBAYAARwIiKWVMSU8CRBUkEkQiKmVMSU8CRBUkEkQiK2VMSU8CRBUkEkQiKGVEi/8SRIv/cQhEMgMSQAAOi/9xCESL/3AARQFAAHgijAKLAzIDEkAAC4sDi/9wAEUBQABWIowAiwQyAxJAAAuLBIv/cABFAUAANCKMAYsFMgMSQAALiwWL/3AARQFAABQii/9xAESLAgmLAAmLAQlMCYwAiYsFi/9wAERC/+OLBIv/cABEjAFC/8OLA4v/cABEjABC/6GL/3EIRIv/cABEjAJC/3w=\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 0}}, \"desc\": \"ARC-62 Reference Implementation\", \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMuY2lyY3VsYXRpbmdfc3VwcGx5LmNvbnRyYWN0LkNpcmN1bGF0aW5nU3VwcGx5Ll9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDAgMSAzMgogICAgYnl0ZWNibG9jayAiYXNzZXRfaWQiICJidXJuZWQiICJsb2NrZWQiICJnZW5lcmljIgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyNC0yNQogICAgLy8gIyBHbG9iYWwgU3RhdGUKICAgIC8vIHNlbGYuYXNzZXRfaWQgPSBVSW50NjQoKQogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjcKICAgIC8vIEFkZHJlc3MoKSwga2V5PWNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMQogICAgYnl0ZWNfMSAvLyAiYnVybmVkIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjI2LTI4CiAgICAvLyBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8xID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgQWRkcmVzcygpLCBrZXk9Y2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8xCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozMAogICAgLy8gQWRkcmVzcygpLCBrZXk9Y2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8yCiAgICBieXRlY18yIC8vICJsb2NrZWQiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjktMzEKICAgIC8vIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzIgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzIKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjMzCiAgICAvLyBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzMKICAgIGJ5dGVjXzMgLy8gImdlbmVyaWMiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MzItMzQKICAgIC8vIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzMKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAKICAgIC8vIGNsYXNzIENpcmN1bGF0aW5nU3VwcGx5KEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9iYXJlX3JvdXRpbmdAOAogICAgcHVzaGJ5dGVzcyAweDcwOWI4MGE4IDB4MGI2MmM3MjggMHg1Y2MyYzUzNSAvLyBtZXRob2QgInNldF9hc3NldCh1aW50NjQpdm9pZCIsIG1ldGhvZCAic2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKGFkZHJlc3Msc3RyaW5nKXZvaWQiLCBtZXRob2QgImFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHkodWludDY0KXVpbnQ2NCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fc2V0X2Fzc2V0X3JvdXRlQDUgbWFpbl9zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfcm91dGVANiBtYWluX2FyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfcm91dGVANwoKbWFpbl9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIwCiAgICAvLyBjbGFzcyBDaXJjdWxhdGluZ1N1cHBseShBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5CiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3NldF9hc3NldF9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozNgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAKICAgIC8vIGNsYXNzIENpcmN1bGF0aW5nU3VwcGx5KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjM2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X2Fzc2V0CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JhcmVfcm91dGluZ0A4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMTAKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfYXNzZXQoYXNzZXRfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc2V0X2Fzc2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozNi0zNwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X2Fzc2V0KHNlbGYsIGFzc2V0X2lkOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NDUtNDYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlciBhbmQgbm90IHNlbGYuYXNzZXRfaWQsIGVyci5VTkFVVEhPUklaRUQKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgID09CiAgICBieiBzZXRfYXNzZXRfYm9vbF9mYWxzZUAzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzZXRfaWQgZXhpc3RzCiAgICBibnogc2V0X2Fzc2V0X2Jvb2xfZmFsc2VAMwogICAgaW50Y18xIC8vIDEKCnNldF9hc3NldF9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjQ1LTQ2CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IGFzc2V0Lm1hbmFnZXIgYW5kIG5vdCBzZWxmLmFzc2V0X2lkLCBlcnIuVU5BVVRIT1JJWkVECiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjQ3LTQ4CiAgICAvLyAjIEVmZmVjdHMKICAgIC8vIHNlbGYuYXNzZXRfaWQgPSBhc3NldF9pZAogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnNldF9hc3NldF9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzZXRfYXNzZXRfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3MoYWRkcmVzczogYnl0ZXMsIGxhYmVsOiBieXRlcykgLT4gdm9pZDoKc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo1MC01MQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKHNlbGYsIGFkZHJlc3M6IEFkZHJlc3MsIGxhYmVsOiBTdHJpbmcpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NTkKICAgIC8vIGFzc2V0ID0gQXNzZXQoc2VsZi5hc3NldF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJhc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc3NldF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjAtNjEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlciwgZXJyLlVOQVVUSE9SSVpFRAogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2MgogICAgLy8gYXNzZXJ0IEFjY291bnQoYWRkcmVzcy5ieXRlcykuaXNfb3B0ZWRfaW4oYXNzZXQpLCBlcnIuTk9UX09QVEVEX0lOCiAgICBmcmFtZV9kaWcgLTIKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIEFkZHJlc3MgbGVuZ3RoIGlzIDMyIGJ5dGVzCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTm90IE9wdGVkLUluCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjY1CiAgICAvLyBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMToKICAgIGJ5dGVjXzEgLy8gImJ1cm5lZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjcKICAgIC8vIGNhc2UgY2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8yOgogICAgYnl0ZWNfMiAvLyAibG9ja2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2OQogICAgLy8gY2FzZSBjZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzM6CiAgICBieXRlY18zIC8vICJnZW5lcmljIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2My03MgogICAgLy8gIyBFZmZlY3RzCiAgICAvLyBtYXRjaCBsYWJlbDoKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMToKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMjoKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMi52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMzoKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMy52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIF86CiAgICAvLyAgICAgICAgIGFzc2VydCBGYWxzZSwgZXJyLklOVkFMSURfTEFCRUwKICAgIGZyYW1lX2RpZyAtMQogICAgbWF0Y2ggc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3N3aXRjaF9jYXNlXzBAMSBzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMUAyIHNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8yQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NzIKICAgIC8vIGFzc2VydCBGYWxzZSwgZXJyLklOVkFMSURfTEFCRUwKICAgIGVyciAvLyBJbnZhbGlkIExhYmVsCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMkAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3MAogICAgLy8gc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMy52YWx1ZSA9IGFkZHJlc3MKICAgIGJ5dGVjXzMgLy8gImdlbmVyaWMiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8xQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8yLnZhbHVlID0gYWRkcmVzcwogICAgYnl0ZWNfMiAvLyAibG9ja2VkIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMEAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2NgogICAgLy8gc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZSA9IGFkZHJlc3MKICAgIGJ5dGVjXzEgLy8gImJ1cm5lZCIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXJjdWxhdGluZ19zdXBwbHkuY29udHJhY3QuQ2lyY3VsYXRpbmdTdXBwbHkuYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseShhc3NldF9pZDogdWludDY0KSAtPiB1aW50NjQ6CmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojc0LTc1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseShzZWxmLCBhc3NldF9pZDogVUludDY0KSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBub3RfY2lyY3VsYXRpbmdfMSA9IEFjY291bnQoc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZS5ieXRlcykKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJidXJuZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8xIGV4aXN0cwogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gQWRkcmVzcyBsZW5ndGggaXMgMzIgYnl0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6ODcKICAgIC8vIG5vdF9jaXJjdWxhdGluZ18yID0gQWNjb3VudChzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8yLnZhbHVlLmJ5dGVzKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImxvY2tlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzIgZXhpc3RzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo4OAogICAgLy8gbm90X2NpcmN1bGF0aW5nXzMgPSBBY2NvdW50KHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMudmFsdWUuYnl0ZXMpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiZ2VuZXJpYyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMgZXhpc3RzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo4OS05MAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgYXNzZXRfaWQgPT0gc2VsZi5hc3NldF9pZCwgZXJyLklOVkFMSURfQVNTRVRfSUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJhc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc3NldF9pZCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIEFTQSBJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5NAogICAgLy8gaWYgYXNzZXQucmVzZXJ2ZSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRSZXNlcnZlCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojk0LTk1CiAgICAvLyBpZiBhc3NldC5yZXNlcnZlID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIG9yIG5vdCBhc3NldC5yZXNlcnZlLmlzX29wdGVkX2luKGFzc2V0KQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTUKICAgIC8vIG9yIG5vdCBhc3NldC5yZXNlcnZlLmlzX29wdGVkX2luKGFzc2V0KQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0UmVzZXJ2ZQogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAzCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5MwogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAyCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTAwCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzEuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVANgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDEKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMS5pc19vcHRlZF9pbihhc3NldCkKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDcKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDYKICAgIC8vIGlmIG5vdF9jaXJjdWxhdGluZ18yID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGZyYW1lX2RpZyA0CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjEwNi0xMDcKICAgIC8vIGlmIG5vdF9jaXJjdWxhdGluZ18yID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMi5pc19vcHRlZF9pbihhc3NldCkKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDcKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMi5pc19vcHRlZF9pbihhc3NldCkKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDExCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA1CiAgICAvLyBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDEKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTEyCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMyA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgNQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTItMTEzCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMyA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzMuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTEzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzMuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxNQoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExMQogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X21lcmdlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTcKICAgIC8vIGFzc2V0LnRvdGFsCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRUb3RhbAogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTE4CiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIGZyYW1lX2RpZyAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExNy0xMTkKICAgIC8vIGFzc2V0LnRvdGFsCiAgICAvLyAtIHJlc2VydmVfYmFsYW5jZQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8xCiAgICBmcmFtZV9kaWcgMAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTIwCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gbm90X2NpcmN1bGF0aW5nX2JhbGFuY2VfMQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICBmcmFtZV9kaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTIxCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gbm90X2NpcmN1bGF0aW5nX2JhbGFuY2VfMQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICAvLyAtIG5vdF9jaXJjdWxhdGluZ19iYWxhbmNlXzMKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTE2LTEyMgogICAgLy8gcmV0dXJuICgKICAgIC8vICAgICBhc3NldC50b3RhbAogICAgLy8gICAgIC0gcmVzZXJ2ZV9iYWxhbmNlCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8xCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8zCiAgICAvLyApCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTQKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShub3RfY2lyY3VsYXRpbmdfMykKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTYKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA4CiAgICAvLyBlbHNlIGFzc2V0LmJhbGFuY2Uobm90X2NpcmN1bGF0aW5nXzIpCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGZyYW1lX2J1cnkgMQogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTIKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDIKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShub3RfY2lyY3VsYXRpbmdfMSkKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgZnJhbWVfYnVyeSAwCiAgICBiIGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUA4CgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfZmFsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTYKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShhc3NldC5yZXNlcnZlKQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0UmVzZXJ2ZQogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGZyYW1lX2J1cnkgMgogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANAo=\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [221, 277, 289, 301], \"errorMessage\": \"Address length is 32 bytes\"}, {\"pc\": [309], \"errorMessage\": \"Invalid ASA ID\"}, {\"pc\": [243], \"errorMessage\": \"Invalid Label\"}, {\"pc\": [229], \"errorMessage\": \"Not Opted-In\"}, {\"pc\": [97, 123, 144], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [190, 215], \"errorMessage\": \"Unauthorized\"}, {\"pc\": [427, 437, 449, 464], \"errorMessage\": \"account opted into asset\"}, {\"pc\": [177, 213, 314, 325, 406, 459], \"errorMessage\": \"asset exists\"}, {\"pc\": [165], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [100, 126, 147], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [185, 206, 305], \"errorMessage\": \"check self.asset_id exists\"}, {\"pc\": [273], \"errorMessage\": \"check self.not_circulating_label_1 exists\"}, {\"pc\": [285], \"errorMessage\": \"check self.not_circulating_label_2 exists\"}, {\"pc\": [297], \"errorMessage\": \"check self.not_circulating_label_3 exists\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass SetAssetArgs:\n    \"\"\"Dataclass for set_asset arguments\"\"\"\n    asset_id: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"set_asset(uint64)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass SetNotCirculatingAddressArgs:\n    \"\"\"Dataclass for set_not_circulating_address arguments\"\"\"\n    address: str\n    label: str\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"set_not_circulating_address(address,string)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass Arc62GetCirculatingSupplyArgs:\n    \"\"\"Dataclass for arc62_get_circulating_supply arguments\"\"\"\n    asset_id: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"arc62_get_circulating_supply(uint64)uint64\"\n\n\nclass CirculatingSupplyParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_asset(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_not_circulating_address(address,string)void\",\n            \"args\": method_args,\n        }))\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass CirculatingSupplyCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_asset(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_not_circulating_address(address,string)void\",\n            \"args\": method_args,\n        }))\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass CirculatingSupplySend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_asset(uint64)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_not_circulating_address(address,string)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[int]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    asset_id: int\n    not_circulating_label_1: str\n    not_circulating_label_2: str\n    not_circulating_label_3: str\n\nclass CirculatingSupplyState:\n    \"\"\"Methods to access state for the current CirculatingSupply app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def asset_id(self) -> int:\n        \"\"\"Get the current value of the asset_id key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"asset_id\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def not_circulating_label_1(self) -> str:\n        \"\"\"Get the current value of the not_circulating_label_1 key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"not_circulating_label_1\")\n        if isinstance(value, dict) and \"address\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"address\"], value)  # type: ignore\n        return typing.cast(str, value)\n\n    @property\n    def not_circulating_label_2(self) -> str:\n        \"\"\"Get the current value of the not_circulating_label_2 key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"not_circulating_label_2\")\n        if isinstance(value, dict) and \"address\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"address\"], value)  # type: ignore\n        return typing.cast(str, value)\n\n    @property\n    def not_circulating_label_3(self) -> str:\n        \"\"\"Get the current value of the not_circulating_label_3 key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"not_circulating_label_3\")\n        if isinstance(value, dict) and \"address\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"address\"], value)  # type: ignore\n        return typing.cast(str, value)\n\nclass CirculatingSupplyClient:\n    \"\"\"Client for interacting with CirculatingSupply smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = CirculatingSupplyParams(self.app_client)\n        self.create_transaction = CirculatingSupplyCreateTransactionParams(self.app_client)\n        self.send = CirculatingSupplySend(self.app_client)\n        self.state = CirculatingSupplyState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"CirculatingSupplyClient\":\n        return CirculatingSupplyClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"CirculatingSupplyClient\":\n        return CirculatingSupplyClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"CirculatingSupplyClient\":\n        return CirculatingSupplyClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"CirculatingSupplyComposer\":\n        return CirculatingSupplyComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"set_asset(uint64)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"set_not_circulating_address(address,string)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"arc62_get_circulating_supply(uint64)uint64\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> int | None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass CirculatingSupplyBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):\n    \"\"\"Parameters for creating CirculatingSupply contract with bare calls\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:\n        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)\n\nclass CirculatingSupplyFactory(algokit_utils.TypedAppFactoryProtocol[CirculatingSupplyBareCallCreateParams, None, None]):\n    \"\"\"Factory for deploying and managing CirculatingSupplyClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = CirculatingSupplyFactoryParams(self.app_factory)\n        self.create_transaction = CirculatingSupplyFactoryCreateTransaction(self.app_factory)\n        self.send = CirculatingSupplyFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: CirculatingSupplyBareCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[CirculatingSupplyClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return CirculatingSupplyClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> CirculatingSupplyClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return CirculatingSupplyClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> CirculatingSupplyClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return CirculatingSupplyClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass CirculatingSupplyFactoryParams:\n    \"\"\"Parameters for creating transactions for CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = CirculatingSupplyFactoryCreateParams(app_factory)\n        self.update = CirculatingSupplyFactoryUpdateParams(app_factory)\n        self.delete = CirculatingSupplyFactoryDeleteParams(app_factory)\n\nclass CirculatingSupplyFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the set_asset(uint64)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"set_asset(uint64)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the set_not_circulating_address(address,string)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"set_not_circulating_address(address,string)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the arc62_get_circulating_supply(uint64)uint64 ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass CirculatingSupplyFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass CirculatingSupplyFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass CirculatingSupplyFactoryCreateTransaction:\n    \"\"\"Create transactions for CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = CirculatingSupplyFactoryCreateTransactionCreate(app_factory)\n\n\nclass CirculatingSupplyFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass CirculatingSupplyFactorySend:\n    \"\"\"Send calls to CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = CirculatingSupplyFactorySendCreate(app_factory)\n\n\nclass CirculatingSupplyFactorySendCreate:\n    \"\"\"Send create calls to CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[CirculatingSupplyClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return CirculatingSupplyClient(result[0]), result[1]\n\n\nclass CirculatingSupplyComposer:\n    \"\"\"Composer for creating transaction groups for CirculatingSupply contract calls\"\"\"\n\n    def __init__(self, client: \"CirculatingSupplyClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.set_asset(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"set_asset(uint64)void\", v\n            )\n        )\n        return self\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.set_not_circulating_address(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"set_not_circulating_address(address,string)void\", v\n            )\n        )\n        return self\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.arc62_get_circulating_supply(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"arc62_get_circulating_supply(uint64)uint64\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"CirculatingSupplyComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"file_path": "https://github.com/Keshabkjha/LotteryContract/blob/964bd66aa545308c496198cd32b56e5a2907fd61/smart_contracts/artifacts/lottery/lottery_client.py", "code": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": []}, \"methods\": [{\"actions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"args\": [{\"type\": \"uint64\", \"name\": \"entry_fee\"}], \"name\": \"create_application\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Initialize the lottery contract with an entry fee.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"pay\", \"name\": \"payment_txn\"}], \"name\": \"enter_lottery\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Allow users to enter the lottery by sending the entry fee.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"pick_winner\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Allows the contract creator to randomly pick a winner.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"DeleteApplication\"], \"create\": []}, \"args\": [], \"name\": \"delete_application\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Allows the creator to delete the application.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}], \"name\": \"Lottery\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"entry_fee\": {\"key\": \"ZW50cnlfZmVl\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"total_entries\": {\"key\": \"dG90YWxfZW50cmllcw==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"creator_address\": {\"key\": \"Y3JlYXRvcl9hZGRyZXNz\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}}, \"local\": {}}, \"maps\": {\"box\": {}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 1, \"ints\": 2}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {}, \"byteCode\": {\"approval\": \"CiADAAHoByYDD2NyZWF0b3JfYWRkcmVzcw10b3RhbF9lbnRyaWVzCWVudHJ5X2ZlZTEbQQAjggQEoDuB0gSH6knXBL4L3r8EM7NJnjYaAI4EADIAHAAQAAIiQzEZgQUSRDEYRIgAlyNDMRkURDEYRIgAVyNDMRkURDEYRDEWIwlJOBAjEkSIACIjQzEZFEQxGBRENhoBF4gAAiNDigEAKov/ZygyCWcpImeJigEAi/84BzIKEkSL/zgIIiplRBJEIillRCMIKUxniTEAIihlRBJEIillREQyBjIEIillRE8CTBhMGDgAsTIKcwBEgcCEPQmyCLIHI7IQJLIBs4kxACIoZUQSRLEiKGVEIihlRLIJIrIIsgcjshAksgGziQ==\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 1}}, \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTAwMAogICAgYnl0ZWNibG9jayAiY3JlYXRvcl9hZGRyZXNzIiAidG90YWxfZW50cmllcyIgImVudHJ5X2ZlZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjEyLTEzCiAgICAvLyAjIFdlIHdhbnQgdGhlIG1ldGhvZHMgaW4gb3VyIGNvbnRyYWN0IHRvIGZvbGxvdyB0aGUgQVJDNCBzdGFuZGFyZAogICAgLy8gY2xhc3MgTG90dGVyeShBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYWZ0ZXJfaWZfZWxzZUAxMAogICAgcHVzaGJ5dGVzcyAweGEwM2I4MWQyIDB4ODdlYTQ5ZDcgMHhiZTBiZGViZiAweDMzYjM0OTllIC8vIG1ldGhvZCAiY3JlYXRlX2FwcGxpY2F0aW9uKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJlbnRlcl9sb3R0ZXJ5KHBheSl2b2lkIiwgbWV0aG9kICJwaWNrX3dpbm5lcigpdm9pZCIsIG1ldGhvZCAiZGVsZXRlX2FwcGxpY2F0aW9uKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9jcmVhdGVfYXBwbGljYXRpb25fcm91dGVAMyBtYWluX2VudGVyX2xvdHRlcnlfcm91dGVANCBtYWluX3BpY2tfd2lubmVyX3JvdXRlQDUgbWFpbl9kZWxldGVfYXBwbGljYXRpb25fcm91dGVANgoKbWFpbl9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MTItMTMKICAgIC8vICMgV2Ugd2FudCB0aGUgbWV0aG9kcyBpbiBvdXIgY29udHJhY3QgdG8gZm9sbG93IHRoZSBBUkM0IHN0YW5kYXJkCiAgICAvLyBjbGFzcyBMb3R0ZXJ5KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9hcHBsaWNhdGlvbl9yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6ODItODQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgKICAgIC8vICAgICBhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXQogICAgLy8gKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcGlja193aW5uZXJfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjUyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBwaWNrX3dpbm5lcgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9lbnRlcl9sb3R0ZXJ5X3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjEyLTEzCiAgICAvLyAjIFdlIHdhbnQgdGhlIG1ldGhvZHMgaW4gb3VyIGNvbnRyYWN0IHRvIGZvbGxvdyB0aGUgQVJDNCBzdGFuZGFyZAogICAgLy8gY2xhc3MgTG90dGVyeShBUkM0Q29udHJhY3QpOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGVudGVyX2xvdHRlcnkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2FwcGxpY2F0aW9uX3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weToyMy0yNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKAogICAgLy8gICAgIGFsbG93X2FjdGlvbnM9WyJOb09wIl0sCiAgICAvLyAgICAgY3JlYXRlPSJyZXF1aXJlIiwKICAgIC8vICkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weToxMi0xMwogICAgLy8gIyBXZSB3YW50IHRoZSBtZXRob2RzIGluIG91ciBjb250cmFjdCB0byBmb2xsb3cgdGhlIEFSQzQgc3RhbmRhcmQKICAgIC8vIGNsYXNzIExvdHRlcnkoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjIzLTI2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoCiAgICAvLyAgICAgYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwKICAgIC8vICAgICBjcmVhdGU9InJlcXVpcmUiLAogICAgLy8gKQogICAgY2FsbHN1YiBjcmVhdGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMubG90dGVyeS5jb250cmFjdC5Mb3R0ZXJ5LmNyZWF0ZV9hcHBsaWNhdGlvbihlbnRyeV9mZWU6IHVpbnQ2NCkgLT4gdm9pZDoKY3JlYXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MjMtMzAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgKICAgIC8vICAgICBhbGxvd19hY3Rpb25zPVsiTm9PcCJdLAogICAgLy8gICAgIGNyZWF0ZT0icmVxdWlyZSIsCiAgICAvLyApCiAgICAvLyBkZWYgY3JlYXRlX2FwcGxpY2F0aW9uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZW50cnlfZmVlOiBVSW50NjQsICAjIFRoZSBlbnRyeSBmZWUgcmVxdWlyZWQgdG8gcGFydGljaXBhdGUgaW4gdGhlIGxvdHRlcnkKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MzQtMzUKICAgIC8vICMgSW5pdGlhbGl6ZSB0aGUgZW50cnkgZmVlIGFuZCBjcmVhdG9yIGFkZHJlc3MgaW4gdGhlIGNvbnRyYWN0J3Mgc3RhdGUKICAgIC8vIHNlbGYuZW50cnlfZmVlID0gZW50cnlfZmVlCiAgICBieXRlY18yIC8vICJlbnRyeV9mZWUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozNgogICAgLy8gc2VsZi5jcmVhdG9yX2FkZHJlc3MgPSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzCiAgICBieXRlY18wIC8vICJjcmVhdG9yX2FkZHJlc3MiCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozNwogICAgLy8gc2VsZi50b3RhbF9lbnRyaWVzID0gVUludDY0KDApICAjIEluaXRpYWxpemUgdGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIHRvIDAKICAgIGJ5dGVjXzEgLy8gInRvdGFsX2VudHJpZXMiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5sb3R0ZXJ5LmNvbnRyYWN0LkxvdHRlcnkuZW50ZXJfbG90dGVyeShwYXltZW50X3R4bjogdWludDY0KSAtPiB2b2lkOgplbnRlcl9sb3R0ZXJ5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MzktNDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIGVudGVyX2xvdHRlcnkoc2VsZiwgcGF5bWVudF90eG46IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo0NC00NQogICAgLy8gIyBFbnN1cmUgdGhhdCB0aGUgcGF5bWVudCBpcyBzZW50IHRvIHRoZSBhcHBsaWNhdGlvbiBhZGRyZXNzCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4ucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjQ3LTQ4CiAgICAvLyAjICMgRW5zdXJlIHRoYXQgdGhlIHBheW1lbnQgYW1vdW50KG1pY3JvYWxnbykgaXMgZXF1YWwgdG8gdGhlIGVudHJ5IGZlZQogICAgLy8gYXNzZXJ0IHBheW1lbnRfdHhuLmFtb3VudCA9PSBzZWxmLmVudHJ5X2ZlZQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJlbnRyeV9mZWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZW50cnlfZmVlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NTAKICAgIC8vIHNlbGYudG90YWxfZW50cmllcyArPSBVSW50NjQoMSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJ0b3RhbF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2VudHJpZXMgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWNfMSAvLyAidG90YWxfZW50cmllcyIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubG90dGVyeS5jb250cmFjdC5Mb3R0ZXJ5LnBpY2tfd2lubmVyKCkgLT4gdm9pZDoKcGlja193aW5uZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo1Ny01OAogICAgLy8gIyAjIEVuc3VyZSB0aGF0IG9ubHkgdGhlIGNyZWF0b3IgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJjcmVhdG9yX2FkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY3JlYXRvcl9hZGRyZXNzIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NjAtNjEKICAgIC8vICMgRW5zdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwYXJ0aWNpcGFudAogICAgLy8gYXNzZXJ0IHNlbGYudG90YWxfZW50cmllcyA+IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInRvdGFsX2VudHJpZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudG90YWxfZW50cmllcyBleGlzdHMKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NjMtNjQKICAgIC8vICMgU2ltcGxlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB1c2luZyByb3VuZCBhbmQgaW5kZXgKICAgIC8vIHJvdW5kX251bWJlciA9IEdsb2JhbC5yb3VuZAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo2NQogICAgLy8gZ3JvdXBfc2l6ZSA9IEdsb2JhbC5ncm91cF9zaXplCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo2Ny02OAogICAgLy8gIyBDYWxjdWxhdGUgcHNldWRvLXJhbmRvbSBpbmRleCBiYXNlZCBvbiByb3VuZCBudW1iZXIgYW5kIGdyb3VwIHNpemUKICAgIC8vIHJhbmRvbV9udW1iZXIgPSByb3VuZF9udW1iZXIgJSBzZWxmLnRvdGFsX2VudHJpZXMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJ0b3RhbF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2VudHJpZXMgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjcwLTcxCiAgICAvLyAjIEdldCB0aGUgd2lubmVyJ3MgYWRkcmVzcyBmcm9tIHRoZSB0cmFuc2FjdGlvbiBhdCB0aGUgY2FsY3VsYXRlZCBpbmRleAogICAgLy8gd2lubmVyX2luZGV4ID0gcmFuZG9tX251bWJlciAlIGdyb3VwX3NpemUKICAgIHN3YXAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjcyCiAgICAvLyB3aW5uZXJfYWRkcmVzcyA9IGd0eG4uVHJhbnNhY3Rpb24od2lubmVyX2luZGV4KS5zZW5kZXIKICAgIGd0eG5zIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzQtODAKICAgIC8vICMgaXR4bi5mZWUoVUludDY0KDEwMDApKQogICAgLy8gIyBUcmFuc2ZlciBhbGwgQUxHT3MgY29sbGVjdGVkIHRvIHRoZSB3aW5uZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlIC0gVUludDY0KDEwMF8wMF8wMCksICMgMSBBbGdvID0gMTAwMDAwMCBtaWNyb2FsZ29zCiAgICAvLyAgICAgcmVjZWl2ZXI9d2lubmVyX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzcKICAgIC8vIGFtb3VudD1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBVSW50NjQoMTAwXzAwXzAwKSwgIyAxIEFsZ28gPSAxMDAwMDAwIG1pY3JvYWxnb3MKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgcHVzaGludCAxMDAwMDAwIC8vIDEwMDAwMDAKICAgIC0KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gIyBpdHhuLmZlZShVSW50NjQoMTAwMCkpCiAgICAvLyAjIFRyYW5zZmVyIGFsbCBBTEdPcyBjb2xsZWN0ZWQgdG8gdGhlIHdpbm5lcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzkKICAgIC8vIGZlZT1VSW50NjQoMTAwMCkKICAgIGludGNfMiAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzQtODAKICAgIC8vICMgaXR4bi5mZWUoVUludDY0KDEwMDApKQogICAgLy8gIyBUcmFuc2ZlciBhbGwgQUxHT3MgY29sbGVjdGVkIHRvIHRoZSB3aW5uZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlIC0gVUludDY0KDEwMF8wMF8wMCksICMgMSBBbGdvID0gMTAwMDAwMCBtaWNyb2FsZ29zCiAgICAvLyAgICAgcmVjZWl2ZXI9d2lubmVyX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5sb3R0ZXJ5LmNvbnRyYWN0LkxvdHRlcnkuZGVsZXRlX2FwcGxpY2F0aW9uKCkgLT4gdm9pZDoKZGVsZXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6ODktOTAKICAgIC8vICMgT25seSBhbGxvdyB0aGUgY3JlYXRvciB0byBkZWxldGUgdGhlIGFwcGxpY2F0aW9uCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBzZWxmLmNyZWF0b3JfYWRkcmVzcwogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImNyZWF0b3JfYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jcmVhdG9yX2FkZHJlc3MgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5Mi05OAogICAgLy8gIyBTZW5kIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0byB0aGUgY3JlYXRvcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gICAgIGNsb3NlX3JlbWFpbmRlcl90bz1zZWxmLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBmZWU9VUludDY0KDEwMDApCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5NAogICAgLy8gcmVjZWl2ZXI9c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiY3JlYXRvcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNyZWF0b3JfYWRkcmVzcyBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5Ojk2CiAgICAvLyBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiY3JlYXRvcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNyZWF0b3JfYWRkcmVzcyBleGlzdHMKICAgIGl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTUKICAgIC8vIGFtb3VudD0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5Mi05MwogICAgLy8gIyBTZW5kIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0byB0aGUgY3JlYXRvcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTcKICAgIC8vIGZlZT1VSW50NjQoMTAwMCkKICAgIGludGNfMiAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTItOTgKICAgIC8vICMgU2VuZCB0aGUgcmVtYWluaW5nIGJhbGFuY2UgdG8gdGhlIGNyZWF0b3IKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1Ygo=\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [96], \"errorMessage\": \"OnCompletion is not DeleteApplication\"}, {\"pc\": [108, 120, 142], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [236], \"errorMessage\": \"account funded\"}, {\"pc\": [146], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [99, 111, 123], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [207, 259, 266, 270], \"errorMessage\": \"check self.creator_address exists\"}, {\"pc\": [189], \"errorMessage\": \"check self.entry_fee exists\"}, {\"pc\": [195, 213, 222], \"errorMessage\": \"check self.total_entries exists\"}, {\"pc\": [133], \"errorMessage\": \"transaction type is pay\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass EnterLotteryArgs:\n    \"\"\"Dataclass for enter_lottery arguments\"\"\"\n    payment_txn: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"enter_lottery(pay)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass CreateApplicationArgs:\n    \"\"\"Dataclass for create_application arguments\"\"\"\n    entry_fee: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"create_application(uint64)void\"\n\n\nclass _LotteryDelete:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppDeleteMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass LotteryParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_LotteryDelete\":\n        return _LotteryDelete(self.app_client)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"enter_lottery(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"pick_winner()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _LotteryDeleteTransaction:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass LotteryCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_LotteryDeleteTransaction\":\n        return _LotteryDeleteTransaction(self.app_client)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"enter_lottery(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"pick_winner()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _LotteryDeleteSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n\nclass LotterySend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_LotteryDeleteSend\":\n        return _LotteryDeleteSend(self.app_client)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"enter_lottery(pay)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"pick_winner()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    entry_fee: int\n    total_entries: int\n    creator_address: bytes\n\nclass LotteryState:\n    \"\"\"Methods to access state for the current Lottery app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def entry_fee(self) -> int:\n        \"\"\"Get the current value of the entry_fee key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"entry_fee\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def total_entries(self) -> int:\n        \"\"\"Get the current value of the total_entries key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"total_entries\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def creator_address(self) -> bytes:\n        \"\"\"Get the current value of the creator_address key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"creator_address\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\nclass LotteryClient:\n    \"\"\"Client for interacting with Lottery smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = LotteryParams(self.app_client)\n        self.create_transaction = LotteryCreateTransactionParams(self.app_client)\n        self.send = LotterySend(self.app_client)\n        self.state = LotteryState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"LotteryClient\":\n        return LotteryClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"LotteryClient\":\n        return LotteryClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"LotteryClient\":\n        return LotteryClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"LotteryComposer\":\n        return LotteryComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"enter_lottery(pay)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"pick_winner()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"create_application(uint64)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"delete_application()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass LotteryMethodCallCreateParams(\n    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[\n        CreateApplicationArgs,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for creating Lottery contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallCreateParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\n@dataclasses.dataclass(frozen=True)\nclass LotteryMethodCallDeleteParams(\n    algokit_utils.BaseAppClientMethodCallParams[\n        typing.Any,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for calling Lottery contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\nclass LotteryFactory(algokit_utils.TypedAppFactoryProtocol[LotteryMethodCallCreateParams, None, LotteryMethodCallDeleteParams]):\n    \"\"\"Factory for deploying and managing LotteryClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = LotteryFactoryParams(self.app_factory)\n        self.create_transaction = LotteryFactoryCreateTransaction(self.app_factory)\n        self.send = LotteryFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: LotteryMethodCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: LotteryMethodCallDeleteParams | None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[LotteryClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return LotteryClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> LotteryClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return LotteryClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> LotteryClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return LotteryClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass LotteryFactoryParams:\n    \"\"\"Parameters for creating transactions for Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = LotteryFactoryCreateParams(app_factory)\n        self.update = LotteryFactoryUpdateParams(app_factory)\n        self.delete = LotteryFactoryDeleteParams(app_factory)\n\nclass LotteryFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the enter_lottery(pay)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"enter_lottery(pay)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def pick_winner(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the pick_winner()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"pick_winner()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the create_application(uint64)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"create_application(uint64)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def delete_application(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the delete_application()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"delete_application()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass LotteryFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass LotteryFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass LotteryFactoryCreateTransaction:\n    \"\"\"Create transactions for Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = LotteryFactoryCreateTransactionCreate(app_factory)\n\n\nclass LotteryFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass LotteryFactorySend:\n    \"\"\"Send calls to Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = LotteryFactorySendCreate(app_factory)\n\n\nclass LotteryFactorySendCreate:\n    \"\"\"Send create calls to Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[LotteryClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return LotteryClient(result[0]), result[1]\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> tuple[LotteryClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:\n            \"\"\"Creates and sends a transaction using the create_application(uint64)void ABI method\"\"\"\n            params = params or algokit_utils.CommonAppCallCreateParams()\n            client, result = self.app_factory.send.create(\n                algokit_utils.AppFactoryCreateMethodCallParams(\n                    **{\n                    **dataclasses.asdict(params),\n                    \"method\": \"create_application(uint64)void\",\n                    \"args\": _parse_abi_args(args),\n                    }\n                ),\n                send_params=send_params,\n                compilation_params=compilation_params\n            )\n            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)\n    \n            return LotteryClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](\n                **{\n                    **result.__dict__,\n                    \"app_id\": result.app_id,\n                    \"abi_return\": return_value,\n                    \"transaction\": result.transaction,\n                    \"confirmation\": result.confirmation,\n                    \"group_id\": result.group_id,\n                    \"tx_ids\": result.tx_ids,\n                    \"transactions\": result.transactions,\n                    \"confirmations\": result.confirmations,\n                    \"app_address\": result.app_address,\n                }\n            )\n\n\nclass _LotteryDeleteComposer:\n    def __init__(self, composer: \"LotteryComposer\"):\n        self.composer = composer\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self.composer._composer.add_app_delete_method_call(\n            self.composer.client.params.delete.delete_application(\n                \n                params=params,\n                \n            )\n        )\n        self.composer._result_mappers.append(\n            lambda v: self.composer.client.decode_return_value(\n                \"delete_application()void\", v\n            )\n        )\n        return self.composer\n\n\nclass LotteryComposer:\n    \"\"\"Composer for creating transaction groups for Lottery contract calls\"\"\"\n\n    def __init__(self, client: \"LotteryClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    @property\n    def delete(self) -> \"_LotteryDeleteComposer\":\n        return _LotteryDeleteComposer(self)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.enter_lottery(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"enter_lottery(pay)void\", v\n            )\n        )\n        return self\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.pick_winner(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"pick_winner()void\", v\n            )\n        )\n        return self\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.create_application(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"create_application(uint64)void\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"LotteryComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"file_path": "https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/smart_asa_asc.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nSmart ASA PyTEAL reference implementation based on ARC-20\n\"\"\"\n\n__author__ = \"Cosimo Bassi, Stefano De Angelis\"\n__email__ = \"<cosimo.bassi@algorand.com>, <stefano.deangelis@algorand.com>\"\n\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    AssetHolding,\n    AssetParam,\n    BareCallActions,\n    Bytes,\n    CallConfig,\n    Concat,\n    Expr,\n    Extract,\n    Global,\n    Gtxn,\n    If,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Len,\n    Mode,\n    Not,\n    OnCompleteAction,\n    OptimizeOptions,\n    Or,\n    Reject,\n    Return,\n    Router,\n    Seq,\n    Subroutine,\n    Suffix,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n    compileTeal,\n)\nfrom algosdk.future.transaction import StateSchema\nfrom algosdk.constants import key_len_bytes\n\n\n# / --- CONSTANTS\nTEAL_VERSION = 7\n\n# Descriptive field for the binding of Smart ASA App ID into the Underlying ASA url.\nSMART_ASA_APP_BINDING = \"smart-asa-app-id:\"\n\n# NOTE: The following costs could change over time with protocol upgrades.\nOPTIN_COST = 100_000\nUINTS_COST = 28_500\nBYTES_COST = 50_000\n\n\ndef static_attrs(cls):\n    return [k for k in cls.__dict__ if not k.startswith(\"__\")]\n\n\n# / --- SMART ASA ASC\n# / --- --- ERRORS\nclass Error:\n    address_length = \"Invalid Address length (must be 32 bytes)\"\n    missing_smart_asa_id = \"Smart ASA ID does not exist\"\n    invalid_smart_asa_id = \"Invalid Smart ASA ID\"\n    not_creator_addr = \"Caller not authorized (must be: App Creator Address)\"\n    not_manager_addr = \"Caller not authorized (must be: Manager Address)\"\n    not_reserve_addr = \"Caller not authorized (must be: Reserve Address)\"\n    not_freeze_addr = \"Caller not authorized (must be: Freeze Address)\"\n    not_clawback_addr = \"Caller not authorized (must be: Clawback Address)\"\n    asset_frozen = \"Smart ASA is frozen\"\n    sender_frozen = \"Sender is frozen\"\n    receiver_frozen = \"Receiver is frozen\"\n\n\n# / --- --- GLOBAL STATE\nclass GlobalInts:\n    total = Bytes(\"total\")\n    decimals = Bytes(\"decimals\")\n    default_frozen = Bytes(\"default_frozen\")\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass GlobalBytes:\n    unit_name = Bytes(\"unit_name\")\n    name = Bytes(\"name\")\n    url = Bytes(\"url\")\n    metadata_hash = Bytes(\"metadata_hash\")\n    manager_addr = Bytes(\"manager_addr\")\n    reserve_addr = Bytes(\"reserve_addr\")\n    freeze_addr = Bytes(\"freeze_addr\")\n    clawback_addr = Bytes(\"clawback_addr\")\n\n\nclass GlobalState(GlobalInts, GlobalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(GlobalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(GlobalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\nclass SmartASAConfig(abi.NamedTuple):\n    total: abi.Field[abi.Uint64]\n    decimals: abi.Field[abi.Uint32]\n    default_frozen: abi.Field[abi.Bool]\n    unit_name: abi.Field[abi.String]\n    name: abi.Field[abi.String]\n    url: abi.Field[abi.String]\n    metadata_hash: abi.Field[abi.DynamicArray[abi.Byte]]\n    manager_addr: abi.Field[abi.Address]\n    reserve_addr: abi.Field[abi.Address]\n    freeze_addr: abi.Field[abi.Address]\n    clawback_addr: abi.Field[abi.Address]\n\n\n# / --- --- LOCAL STATE\n# NOTE: Local State is needed only if the Smart ASA has `account_frozen`.\n# Local State is not needed in case Smart ASA has just \"global\" `asset_freeze`.\nclass LocalInts:\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass LocalBytes:\n    ...\n\n\nclass LocalState(LocalInts, LocalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(LocalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(LocalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\n# / --- --- SUBROUTINES\n@Subroutine(TealType.none)\ndef init_global_state() -> Expr:\n    return Seq(\n        App.globalPut(GlobalState.smart_asa_id, Int(0)),\n        App.globalPut(GlobalState.total, Int(0)),\n        App.globalPut(GlobalState.decimals, Int(0)),\n        App.globalPut(GlobalState.default_frozen, Int(0)),\n        # NOTE: ASA behaves excluding `unit_name` field if not declared:\n        App.globalPut(GlobalState.unit_name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `name` field if not declared:\n        App.globalPut(GlobalState.name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `url` field if not declared:\n        App.globalPut(GlobalState.url, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `metadata_hash` field if not declared:\n        App.globalPut(GlobalState.metadata_hash, Bytes(\"\")),\n        App.globalPut(GlobalState.manager_addr, Global.zero_address()),\n        App.globalPut(GlobalState.reserve_addr, Global.zero_address()),\n        App.globalPut(GlobalState.freeze_addr, Global.zero_address()),\n        App.globalPut(GlobalState.clawback_addr, Global.zero_address()),\n        # Special Smart ASA fields\n        App.globalPut(GlobalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.none)\ndef init_local_state() -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    return Seq(\n        App.localPut(Txn.sender(), LocalState.smart_asa_id, smart_asa_id),\n        App.localPut(Txn.sender(), LocalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef digit_to_ascii(i: Expr) -> Expr:\n    \"\"\"digit_to_ascii converts an integer < 10 to the ASCII byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), i, Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i: Expr) -> Expr:\n    \"\"\"itoa converts an integer to the ASCII byte string it represents.\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            digit_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef strip_len_prefix(abi_encoded: Expr) -> Expr:\n    return Suffix(abi_encoded, Int(abi.Uint16TypeSpec().byte_length_static()))\n\n\n# / --- --- UNDERLYING ASA CONFIG\nUNDERLYING_ASA_TOTAL = Int(2**64 - 1)\nUNDERLYING_ASA_DECIMALS = Int(0)\nUNDERLYING_ASA_DEFAULT_FROZEN = Int(1)\nUNDERLYING_ASA_UNIT_NAME = Bytes(\"S-ASA\")\nUNDERLYING_ASA_NAME = Bytes(\"SMART-ASA\")\nUNDERLYING_ASA_URL = Concat(\n    Bytes(SMART_ASA_APP_BINDING), itoa(Global.current_application_id())\n)\nUNDERLYING_ASA_METADATA_HASH = Bytes(\"\")\nUNDERLYING_ASA_MANAGER_ADDR = Global.current_application_address()\nUNDERLYING_ASA_RESERVE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_FREEZE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_CLAWBACK_ADDR = Global.current_application_address()\n\n\n@Subroutine(TealType.uint64)\ndef underlying_asa_create_inner_tx() -> Expr:\n    return Seq(\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: UNDERLYING_ASA_TOTAL,\n                TxnField.config_asset_decimals: UNDERLYING_ASA_DECIMALS,\n                TxnField.config_asset_default_frozen: UNDERLYING_ASA_DEFAULT_FROZEN,\n                TxnField.config_asset_unit_name: UNDERLYING_ASA_UNIT_NAME,\n                TxnField.config_asset_name: UNDERLYING_ASA_NAME,\n                TxnField.config_asset_url: UNDERLYING_ASA_URL,\n                TxnField.config_asset_manager: UNDERLYING_ASA_MANAGER_ADDR,\n                TxnField.config_asset_reserve: UNDERLYING_ASA_RESERVE_ADDR,\n                TxnField.config_asset_freeze: UNDERLYING_ASA_FREEZE_ADDR,\n                TxnField.config_asset_clawback: UNDERLYING_ASA_CLAWBACK_ADDR,\n            }\n        ),\n        Return(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_transfer_inner_txn(\n    smart_asa_id: Expr,\n    asset_amount: Expr,\n    asset_sender: Expr,\n    asset_receiver: Expr,\n) -> Expr:\n    return InnerTxnBuilder.Execute(\n        {\n            TxnField.fee: Int(0),\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: smart_asa_id,\n            TxnField.asset_amount: asset_amount,\n            TxnField.asset_sender: asset_sender,\n            TxnField.asset_receiver: asset_receiver,\n        }\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_destroy_inner_txn(smart_asa_id: Expr) -> Expr:\n    return InnerTxnBuilder.Execute(\n        {\n            TxnField.fee: Int(0),\n            TxnField.type_enum: TxnType.AssetConfig,\n            TxnField.config_asset: smart_asa_id,\n        }\n    )\n\n\n@Subroutine(TealType.none)\ndef is_valid_address_bytes_length(address: Expr) -> Expr:\n    # WARNING: Note this check only ensures proper bytes' length on `address`,\n    # but doesn't ensure that those 32 bytes are a _proper_ Algorand address.\n    return Assert(Len(address) == Int(key_len_bytes), comment=Error.address_length)\n\n\n@Subroutine(TealType.uint64)\ndef circulating_supply(asset_id: Expr):\n    smart_asa_reserve = AssetHolding.balance(\n        Global.current_application_address(), asset_id\n    )\n    return Seq(smart_asa_reserve, UNDERLYING_ASA_TOTAL - smart_asa_reserve.value())\n\n\n@Subroutine(TealType.none)\ndef getter_preconditions(asset_id: Expr) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset_id\n    return Seq(\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n    )\n\n\n# / --- --- ABI\n# / --- --- BARE CALLS\n@Subroutine(TealType.none)\ndef asset_app_create() -> Expr:\n    return Seq(\n        # Preconditions\n        # Not mandatory - Smart ASA Application self validate its state.\n        Assert(\n            Txn.global_num_uints() == Int(GlobalState.num_uints()),\n            comment=f\"Wrong State Schema - Expexted Global Ints: \"\n            f\"{GlobalState.num_uints()}\",\n        ),\n        Assert(\n            Txn.global_num_byte_slices() == Int(GlobalState.num_bytes()),\n            comment=f\"Wrong State Schema - Expexted Global Bytes: \"\n            f\"{GlobalState.num_bytes()}\",\n        ),\n        Assert(\n            Txn.local_num_uints() == Int(LocalState.num_uints()),\n            comment=f\"Wrong State Schema - Expexted Local Ints: \"\n            f\"{LocalState.num_uints()}\",\n        ),\n        Assert(\n            Txn.local_num_byte_slices() == Int(LocalState.num_bytes()),\n            comment=f\"Wrong State Schema - Expexted Local Bytes: \"\n            f\"{LocalState.num_bytes()}\",\n        ),\n        init_global_state(),\n        Approve(),\n    )\n\n\nsmart_asa_abi = Router(\n    \"Smart ASA ref. implementation\",\n    BareCallActions(\n        no_op=OnCompleteAction.create_only(asset_app_create()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not updatable.\n        update_application=OnCompleteAction.always(Reject()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not deletable.\n        delete_application=OnCompleteAction.always(Reject()),\n        clear_state=OnCompleteAction.call_only(Reject()),\n    ),\n)\n\n\n# / --- --- METHODS\n@smart_asa_abi.method(opt_in=CallConfig.ALL)\ndef asset_app_optin(\n    asset: abi.Asset,\n    underlying_asa_optin: abi.AssetTransferTransaction,\n) -> Expr:\n    \"\"\"\n    Smart ASA atomic opt-in to Smart ASA App and Underlying ASA.\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n        underlying_asa_optin: Underlying ASA opt-in transaction.\n    \"\"\"\n    # On OptIn the frozen status must be set to `True` if account owns any\n    # units of the underlying ASA. This prevents malicious users to circumvent\n    # the `default_frozen` status by clearing their Local State. Note that this\n    # could be avoided by the use of Boxes once available.\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset.asset_id()\n    default_frozen = App.globalGet(GlobalState.default_frozen)\n    freeze_account = App.localPut(Txn.sender(), LocalState.frozen, Int(1))\n    account_balance = AssetHolding().balance(Txn.sender(), asset.asset_id())\n    optin_to_underlying_asa = account_balance.hasValue()\n    return Seq(\n        # Preconditions\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        Assert(\n            underlying_asa_optin.get().type_enum() == TxnType.AssetTransfer,\n            comment=\"Underlying ASA Opt-In Txn: Wrong Txn Type (Expected: Axfer)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().xfer_asset() == smart_asa_id,\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset ID (Expected: Smart ASA ID)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().sender() == Txn.sender(),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Sender (Expected: App Caller)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().asset_receiver() == Txn.sender(),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset Receiver (Expected: App Caller)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().asset_amount() == Int(0),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset Amount (Expected: 0)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().asset_close_to() == Global.zero_address(),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset CloseTo (Expected: Zero Address)\",\n        ),\n        account_balance,\n        Assert(optin_to_underlying_asa, comment=\"Missing Opt-In to Underlying ASA\"),\n        # Effects\n        init_local_state(),\n        If(Or(default_frozen, account_balance.value() > Int(0))).Then(freeze_account),\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_create(\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n    *,\n    output: abi.Uint64,\n) -> Expr:\n    \"\"\"\n    Create a Smart ASA (triggers inner creation of an Underlying ASA).\n\n    Args:\n        total: The total number of base units of the Smart ASA to create.\n        decimals: The number of digits to use after the decimal point when displaying the Smart ASA. If 0, the Smart ASA is not divisible.\n        default_frozen: Smart ASA default frozen status (True to freeze holdings by default).\n        unit_name: The name of a unit of Smart ASA.\n        name: The name of the Smart ASA.\n        url: Smart ASA external URL.\n        metadata_hash: Smart ASA metadata hash (suggested 32 bytes hash).\n        manager_addr: The address of the account that can manage the configuration of the Smart ASA and destroy it.\n        reserve_addr: The address of the account that holds the reserve (non-minted) units of the asset and can mint or burn units of Smart ASA.\n        freeze_addr: The address of the account that can freeze/unfreeze holdings of this Smart ASA globally or locally (specific accounts). If empty, freezing is not permitted.\n        clawback_addr: The address of the account that can clawback holdings of this asset. If empty, clawback is not permitted.\n\n    Returns:\n        New Smart ASA ID.\n    \"\"\"\n\n    is_creator = Txn.sender() == Global.creator_address()\n    smart_asa_not_created = Not(App.globalGet(GlobalState.smart_asa_id))\n    smart_asa_id = underlying_asa_create_inner_tx()\n\n    return Seq(\n        # Preconditions\n        Assert(is_creator, comment=Error.not_creator_addr),\n        Assert(smart_asa_not_created, comment=\"Smart ASA ID already exists\"),\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        # Effects\n        # Underlying ASA creation\n        App.globalPut(GlobalState.smart_asa_id, smart_asa_id),\n        # Smart ASA properties\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n        output.set(App.globalGet(GlobalState.smart_asa_id)),\n    )\n\n\n@smart_asa_abi.method\ndef asset_config(\n    config_asset: abi.Asset,\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n) -> Expr:\n    \"\"\"\n    Configure the Smart ASA. Use existing values for unchanged parameters. Setting Smart ASA roles to zero-address is irreversible.\n\n    Args:\n        config_asset: Underlying ASA ID to configure (ref. App Global State: \"smart_asa_id\").\n        total: The total number of base units of the Smart ASA to create. It can not be configured to less than its current circulating supply.\n        decimals: The number of digits to use after the decimal point when displaying the Smart ASA. If 0, the Smart ASA is not divisible.\n        default_frozen: Smart ASA default frozen status (True to freeze holdings by default).\n        unit_name: The name of a unit of Smart ASA.\n        name: The name of the Smart ASA.\n        url: Smart ASA external URL.\n        metadata_hash: Smart ASA metadata hash (suggested 32 bytes hash).\n        manager_addr: The address of the account that can manage the configuration of the Smart ASA and destroy it.\n        reserve_addr: The address of the account that holds the reserve (non-minted) units of the asset and can mint or burn units of Smart ASA.\n        freeze_addr: The address of the account that can freeze/unfreeze holdings of this Smart ASA globally or locally (specific accounts). If empty, freezing is not permitted.\n        clawback_addr: The address of the account that can clawback holdings of this asset. If empty, clawback is not permitted.\n    \"\"\"\n\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    current_manager_addr = App.globalGet(GlobalState.manager_addr)\n    current_reserve_addr = App.globalGet(GlobalState.reserve_addr)\n    current_freeze_addr = App.globalGet(GlobalState.freeze_addr)\n    current_clawback_addr = App.globalGet(GlobalState.clawback_addr)\n\n    is_manager_addr = Txn.sender() == current_manager_addr\n    is_correct_smart_asa_id = smart_asa_id == config_asset.asset_id()\n\n    update_reserve_addr = current_reserve_addr != reserve_addr.get()\n    update_freeze_addr = current_freeze_addr != freeze_addr.get()\n    update_clawback_addr = current_clawback_addr != clawback_addr.get()\n\n    # NOTE: In ref. implementation Smart ASA total can not be configured to\n    # less than its current circulating supply.\n    is_valid_total = total.get() >= circulating_supply(smart_asa_id)\n\n    return Seq(\n        # Preconditions\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        # NOTE: useless in ref. impl since 1 ASA : 1 App\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        Assert(is_manager_addr, comment=Error.not_manager_addr),\n        If(update_reserve_addr).Then(\n            Assert(\n                current_reserve_addr != Global.zero_address(),\n                comment=\"Reserve Address has been deleted\",\n            )\n        ),\n        If(update_freeze_addr).Then(\n            Assert(\n                current_freeze_addr != Global.zero_address(),\n                comment=\"Freeze Address has been deleted\",\n            )\n        ),\n        If(update_clawback_addr).Then(\n            Assert(\n                current_clawback_addr != Global.zero_address(),\n                comment=\"Clawback Address has been deleted\",\n            )\n        ),\n        Assert(is_valid_total, comment=\"Invalid Total (must be >= Circulating Supply)\"),\n        # Effects\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n    )\n\n\n@smart_asa_abi.method\ndef asset_transfer(\n    xfer_asset: abi.Asset,\n    asset_amount: abi.Uint64,\n    asset_sender: abi.Account,\n    asset_receiver: abi.Account,\n) -> Expr:\n    \"\"\"\n    Smart ASA transfers: regular, clawback (Clawback Address), mint or burn (Reserve Address).\n\n    Args:\n        xfer_asset: Underlying ASA ID to transfer (ref. App Global State: \"smart_asa_id\").\n        asset_amount: Smart ASA amount to transfer.\n        asset_sender: Smart ASA sender, for regular transfer this must be equal to the Smart ASA App caller.\n        asset_receiver: The recipient of the Smart ASA transfer.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    clawback_addr = App.globalGet(GlobalState.clawback_addr)\n    is_not_clawback = And(\n        Txn.sender() == asset_sender.address(),\n        Txn.sender() != clawback_addr,\n    )\n\n    # NOTE: Ref. implementation grants _minting_ premission to `reserve_addr`,\n    # has restriction no restriction on who is the minting _receiver_.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off minting.\n    is_minting = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == Global.current_application_address(),\n    )\n\n    # NOTE: Ref. implementation grants _burning_ premission to `reserve_addr`,\n    # has restriction both on burning _sender_ and _receiver_ to prevent\n    # _clawback_ throug burning.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off burning.\n    is_burning = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == App.globalGet(GlobalState.reserve_addr),\n        asset_receiver.address() == Global.current_application_address(),\n    )\n\n    is_clawback = Txn.sender() == clawback_addr\n    is_correct_smart_asa_id = smart_asa_id == xfer_asset.asset_id()\n\n    # NOTE: Ref. implementation checks that `smart_asa_id` is correct in Local\n    # State since the App could generate a new Smart ASA (if the previous one\n    # has been dystroied) requiring users to opt-in again to gain a coherent\n    # new `frozen` status.\n    is_current_smart_asa_id = And(\n        smart_asa_id == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n        smart_asa_id == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n    )\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_sender_frozen = App.localGet(asset_sender.address(), LocalState.frozen)\n    asset_receiver_frozen = App.localGet(asset_receiver.address(), LocalState.frozen)\n    return Seq(\n        # Preconditions\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        is_valid_address_bytes_length(asset_sender.address()),\n        is_valid_address_bytes_length(asset_receiver.address()),\n        If(is_not_clawback)\n        .Then(\n            # Asset Regular Transfer Preconditions\n            Assert(Not(asset_frozen), comment=Error.asset_frozen),\n            Assert(Not(asset_sender_frozen), comment=Error.sender_frozen),\n            Assert(Not(asset_receiver_frozen), comment=Error.receiver_frozen),\n            Assert(is_current_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        )\n        .ElseIf(is_minting)\n        .Then(\n            # Asset Minting Preconditions\n            Assert(Not(asset_frozen), comment=Error.asset_frozen),\n            Assert(Not(asset_receiver_frozen), comment=Error.receiver_frozen),\n            Assert(\n                smart_asa_id\n                == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n                comment=Error.invalid_smart_asa_id,\n            ),\n            # NOTE: Ref. implementation prevents minting more than `total`.\n            Assert(\n                circulating_supply(smart_asa_id) + asset_amount.get()\n                <= App.globalGet(GlobalState.total),\n                comment=\"Over-minting (can not mint more than Total)\",\n            ),\n        )\n        .ElseIf(is_burning)\n        .Then(\n            # Asset Burning Preconditions\n            Assert(Not(asset_frozen), comment=Error.asset_frozen),\n            Assert(Not(asset_sender_frozen), comment=Error.sender_frozen),\n            Assert(\n                smart_asa_id\n                == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n                comment=Error.invalid_smart_asa_id,\n            ),\n        )\n        .Else(\n            # Asset Clawback Preconditions\n            Assert(is_clawback, comment=Error.not_clawback_addr),\n            # NOTE: `is_current_smart_asa_id` implicitly checks that both\n            # `asset_sender` and `asset_receiver` opted-in the Smart ASA\n            # App. This ensures that _mint_ and _burn_ can not be\n            # executed as _clawback_, since the Smart ASA App can not\n            # opt-in to itself.\n            Assert(is_current_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        ),\n        # Effects\n        smart_asa_transfer_inner_txn(\n            xfer_asset.asset_id(),\n            asset_amount.get(),\n            asset_sender.address(),\n            asset_receiver.address(),\n        ),\n    )\n\n\n@smart_asa_abi.method\ndef asset_freeze(freeze_asset: abi.Asset, asset_frozen: abi.Bool) -> Expr:\n    \"\"\"\n    Smart ASA global freeze (all accounts), called by the Freeze Address.\n\n    Args:\n        freeze_asset: Underlying ASA ID to freeze/unfreeze (ref. App Global State: \"smart_asa_id\").\n        asset_frozen: Smart ASA ID forzen status.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Asset Freeze Preconditions\n        Assert(\n            smart_asa_id,\n            comment=Error.missing_smart_asa_id,\n        ),\n        Assert(\n            is_correct_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            is_freeze_addr,\n            comment=Error.not_freeze_addr,\n        ),\n        # Effects\n        App.globalPut(GlobalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method\ndef account_freeze(\n    freeze_asset: abi.Asset,\n    freeze_account: abi.Account,\n    asset_frozen: abi.Bool,\n) -> Expr:\n    \"\"\"\n    Smart ASA local freeze (account specific), called by the Freeze Address.\n\n    Args:\n        freeze_asset: Underlying ASA ID to freeze/unfreeze (ref. App Global State: \"smart_asa_id\").\n        freeze_account: Account to freeze/unfreeze.\n        asset_frozen: Smart ASA ID forzen status.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Account Freeze Preconditions\n        is_valid_address_bytes_length(freeze_account.address()),\n        Assert(\n            smart_asa_id,\n            comment=Error.missing_smart_asa_id,\n        ),\n        Assert(\n            is_correct_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            is_freeze_addr,\n            comment=Error.not_freeze_addr,\n        ),\n        # Effects\n        App.localPut(freeze_account.address(), LocalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method(close_out=CallConfig.ALL)\ndef asset_app_closeout(\n    close_asset: abi.Asset,\n    close_to: abi.Account,\n) -> Expr:\n    \"\"\"\n    Smart ASA atomic close-out of Smart ASA App and Underlying ASA.\n\n    Args:\n        close_asset: Underlying ASA ID to close-out (ref. App Global State: \"smart_asa_id\").\n        close_to: Account to send all Smart ASA reminder to. If the asset/account is forzen then this must be set to Smart ASA Creator.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == close_asset.asset_id()\n    current_smart_asa_id = App.localGet(Txn.sender(), LocalState.smart_asa_id)\n    is_current_smart_asa_id = current_smart_asa_id == close_asset.asset_id()\n    account_balance = AssetHolding().balance(Txn.sender(), close_asset.asset_id())\n    asset_creator = AssetParam().creator(close_asset.asset_id())\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_closer_frozen = App.localGet(Txn.sender(), LocalState.frozen)\n    asa_closeout_relative_idx = Txn.group_index() + Int(1)\n    return Seq(\n        # Preconditions\n        # NOTE: Smart ASA existence is not checked by default on close-out\n        # since would be impossible to close-out destroyed assets.\n        is_valid_address_bytes_length(close_to.address()),\n        Assert(\n            is_current_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            Global.group_size() > asa_closeout_relative_idx,\n            comment=\"Smart ASA CloseOut: Wrong group size (Expected: 2)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].type_enum() == TxnType.AssetTransfer,\n            comment=\"Underlying ASA CloseOut Txn: Wrong Txn type (Expected: Axfer)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].xfer_asset() == close_asset.asset_id(),\n            comment=\"Underlying ASA CloseOut Txn: Wrong ASA ID (Expected: Smart ASA ID)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].sender() == Txn.sender(),\n            comment=\"Underlying ASA CloseOut Txn: Wrong sender (Expected: Smart ASA CloseOut caller)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].asset_amount() == Int(0),\n            comment=\"Underlying ASA CloseOut Txn: Wrong amount (Expected: 0)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].asset_close_to()\n            == Global.current_application_address(),\n            comment=\"Underlying ASA CloseOut Txn: Wrong CloseTo address (Expected: Smart ASA App Account)\",\n        ),\n        # Effects\n        asset_creator,\n        # NOTE: Skip checks if Underlying ASA has been destroyed to avoid\n        # users' lock-in.\n        If(asset_creator.hasValue()).Then(\n            # NOTE: Smart ASA has not been destroyed.\n            Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n            If(Or(asset_frozen, asset_closer_frozen)).Then(\n                # NOTE: If Smart ASA is frozen, users can only close-out to\n                # Creator\n                Assert(\n                    close_to.address() == Global.current_application_address(),\n                    comment=\"Wrong CloseTo address: Frozen Smart ASA must be closed-out to creator\",\n                ),\n            ),\n            If(close_to.address() != Global.current_application_address()).Then(\n                # NOTE: If the target of close-out is not Creator, it MUST be\n                # opted-in to the current Smart ASA.\n                Assert(\n                    smart_asa_id\n                    == App.localGet(close_to.address(), LocalState.smart_asa_id),\n                    comment=Error.invalid_smart_asa_id,\n                )\n            ),\n            account_balance,\n            smart_asa_transfer_inner_txn(\n                close_asset.asset_id(),\n                account_balance.value(),\n                Txn.sender(),\n                close_to.address(),\n            ),\n        ),\n        # NOTE: If Smart ASA has been destroyed:\n        #   1. The close-to address could be anyone\n        #   2. No InnerTxn happens\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_destroy(destroy_asset: abi.Asset) -> Expr:\n    \"\"\"\n    Destroy the Underlying ASA, must be called by Manager Address.\n\n    Args:\n        destroy_asset: Underlying ASA ID to destroy (ref. App Global State: \"smart_asa_id\").\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == destroy_asset.asset_id()\n    is_manager_addr = Txn.sender() == App.globalGet(GlobalState.manager_addr)\n    return Seq(\n        # Asset Destroy Preconditions\n        Assert(\n            smart_asa_id,\n            comment=Error.missing_smart_asa_id,\n        ),\n        Assert(\n            is_correct_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            is_manager_addr,\n            comment=Error.not_manager_addr,\n        ),\n        # Effects\n        smart_asa_destroy_inner_txn(destroy_asset.asset_id()),\n        init_global_state(),\n    )\n\n\n# / --- --- GETTERS\n@smart_asa_abi.method\ndef get_asset_is_frozen(freeze_asset: abi.Asset, *, output: abi.Bool) -> Expr:\n    \"\"\"\n    Get Smart ASA global frozen status.\n\n    Args:\n        freeze_asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA global frozen status.\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        # Effects\n        output.set(App.globalGet(GlobalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_account_is_frozen(\n    freeze_asset: abi.Asset, freeze_account: abi.Account, *, output: abi.Bool\n) -> Expr:\n    \"\"\"\n    Get Smart ASA local frozen status (account specific).\n\n    Args:\n        freeze_asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n        freeze_account: Account to check.\n\n    Returns:\n        Smart ASA local frozen status (account specific).\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        is_valid_address_bytes_length(freeze_account.address()),\n        # Effects\n        output.set(App.localGet(freeze_account.address(), LocalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_circulating_supply(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Get Smart ASA circulating supply.\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA circulating supply.\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(circulating_supply(asset.asset_id())),\n    )\n\n\n@smart_asa_abi.method\ndef get_optin_min_balance(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Get Smart ASA required minimum balance (including Underlying ASA and App Local State).\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA required minimum balance in microALGO.\n    \"\"\"\n    min_balance = Int(\n        OPTIN_COST\n        + UINTS_COST * LocalState.num_uints()\n        + BYTES_COST * LocalState.num_bytes()\n    )\n\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(min_balance),\n    )\n\n\n@smart_asa_abi.method\ndef get_asset_config(asset: abi.Asset, *, output: SmartASAConfig) -> Expr:\n    \"\"\"\n    Get Smart ASA configuration.\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA configuration parameters.\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        (total := abi.Uint64()).set(App.globalGet(GlobalState.total)),\n        (decimals := abi.Uint32()).set(App.globalGet(GlobalState.decimals)),\n        (default_frozen := abi.Bool()).set(App.globalGet(GlobalState.default_frozen)),\n        (unit_name := abi.String()).set(App.globalGet(GlobalState.unit_name)),\n        (name := abi.String()).set(App.globalGet(GlobalState.name)),\n        (url := abi.String()).set(App.globalGet(GlobalState.url)),\n        (metadata_hash_str := abi.String()).set(\n            App.globalGet(GlobalState.metadata_hash)\n        ),\n        (metadata_hash := abi.make(abi.DynamicArray[abi.Byte])).decode(\n            metadata_hash_str.encode()\n        ),\n        (manager_addr := abi.Address()).set(App.globalGet(GlobalState.manager_addr)),\n        (reserve_addr := abi.Address()).set(App.globalGet(GlobalState.reserve_addr)),\n        (freeze_addr := abi.Address()).set(App.globalGet(GlobalState.freeze_addr)),\n        (clawback_addr := abi.Address()).set(App.globalGet(GlobalState.clawback_addr)),\n        output.set(\n            total,\n            decimals,\n            default_frozen,\n            unit_name,\n            name,\n            url,\n            metadata_hash,\n            manager_addr,\n            reserve_addr,\n            freeze_addr,\n            clawback_addr,\n        ),\n    )\n\n\ndef compile_stateful(program: Expr) -> str:\n    return compileTeal(\n        program,\n        Mode.Application,\n        version=TEAL_VERSION,\n        assembleConstants=True,\n        optimize=OptimizeOptions(scratch_slots=True),\n    )\n\n\nif __name__ == \"__main__\":\n    # Allow quickly testing compilation.\n    from smart_asa_test import test_compile\n\n    test_compile(*smart_asa_abi.build_program())"}
{"file_path": "https://github.com/McEazy2700/vericert-backend/blob/52c53f1ee2ae599117a50436675833bfbf614441/veecert_backend/apps/common/smart_contract_client.py", "code": "# flake8: noqa\n# fmt: off\n# mypy: disable-error-code=\"no-any-return, no-untyped-call, misc, type-arg\"\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^1.2.0\nimport base64\nimport dataclasses\nimport decimal\nimport typing\nfrom abc import ABC, abstractmethod\n\nimport algokit_utils\nimport algosdk\nfrom algosdk.v2client import models\nfrom algosdk.atomic_transaction_composer import (\n    AtomicTransactionComposer,\n    AtomicTransactionResponse,\n    SimulateAtomicTransactionResponse,\n    TransactionSigner,\n    TransactionWithSigner\n)\n\n_APP_SPEC_JSON = r\"\"\"{\n    \"hints\": {\n        \"hello(string)string\": {\n            \"call_config\": {\n                \"no_op\": \"CALL\"\n            }\n        },\n        \"create_certificate_nft((string,string,uint64,string,string))uint64\": {\n            \"structs\": {\n                \"args\": {\n                    \"name\": \"NewCertificateNftArgs\",\n                    \"elements\": [\n                        [\n                            \"name\",\n                            \"string\"\n                        ],\n                        [\n                            \"image_url\",\n                            \"string\"\n                        ],\n                        [\n                            \"certificate_id\",\n                            \"uint64\"\n                        ],\n                        [\n                            \"metadata_hash\",\n                            \"string\"\n                        ],\n                        [\n                            \"unit_name\",\n                            \"string\"\n                        ]\n                    ]\n                }\n            },\n            \"call_config\": {\n                \"no_op\": \"CALL\"\n            }\n        },\n        \"update()bool\": {\n            \"call_config\": {\n                \"update_application\": \"CALL\"\n            }\n        },\n        \"delete()bool\": {\n            \"call_config\": {\n                \"delete_application\": \"CALL\"\n            }\n        }\n    },\n    \"source\": {\n        \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmFwcHJvdmFsX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYmFyZV9yb3V0aW5nQDgKICAgIG1ldGhvZCAiaGVsbG8oc3RyaW5nKXN0cmluZyIKICAgIG1ldGhvZCAiY3JlYXRlX2NlcnRpZmljYXRlX25mdCgoc3RyaW5nLHN0cmluZyx1aW50NjQsc3RyaW5nLHN0cmluZykpdWludDY0IgogICAgbWV0aG9kICJ1cGRhdGUoKWJvb2wiCiAgICBtZXRob2QgImRlbGV0ZSgpYm9vbCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5faGVsbG9fcm91dGVAMiBtYWluX2NyZWF0ZV9jZXJ0aWZpY2F0ZV9uZnRfcm91dGVAMyBtYWluX3VwZGF0ZV9yb3V0ZUA0IG1haW5fZGVsZXRlX3JvdXRlQDUKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5faGVsbG9fcm91dGVAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6MTgKICAgIC8vIGNsYXNzIENlcnQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBoZWxsbwogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfY2VydGlmaWNhdGVfbmZ0X3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE4CiAgICAvLyBjbGFzcyBDZXJ0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2NlcnRpZmljYXRlX25mdAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjQ0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIlVwZGF0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBpbnQgVXBkYXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIFVwZGF0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB1cGRhdGUKICAgIGJ5dGUgMHgwMAogICAgaW50IDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGRlbGV0ZQogICAgYnl0ZSAweDAwCiAgICBpbnQgMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0LmNvbnRyYWN0LkNlcnQuaGVsbG8obmFtZTogYnl0ZXMpIC0+IGJ5dGVzOgpoZWxsbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5LTIwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGhlbGxvKHNlbGYsIG5hbWU6IGFyYzQuU3RyaW5nKSAtPiBhcmM0LlN0cmluZzoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6MjEKICAgIC8vIHJldHVybiAiSGVsbG8sICIgKyBuYW1lCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBieXRlICJIZWxsbywgIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnQuY29udHJhY3QuQ2VydC5jcmVhdGVfY2VydGlmaWNhdGVfbmZ0KGFyZ3M6IGJ5dGVzKSAtPiBieXRlczoKY3JlYXRlX2NlcnRpZmljYXRlX25mdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjIzLTI3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9jZXJ0aWZpY2F0ZV9uZnQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBhcmdzOiBOZXdDZXJ0aWZpY2F0ZU5mdEFyZ3MsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyOQogICAgLy8gYXNzZXRfbmFtZT1hcmdzLm5hbWUubmF0aXZlLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDEKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnQgMgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjMxCiAgICAvLyB1bml0X25hbWU9YXJncy51bml0X25hbWUubmF0aXZlLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMTQKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMgogICAgLy8gdXJsPWFyZ3MuaW1hZ2VfdXJsLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMwogICAgLy8gbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM0LTM2CiAgICAvLyBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBkdXBuIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM3CiAgICAvLyBtZXRhZGF0YV9oYXNoPWFyZ3MubWV0YWRhdGFfaGFzaC5uYXRpdmUuYnl0ZXMsCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAxMgogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDEKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnQgMgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyB0eG4uc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNZXRhZGF0YUhhc2gKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0Q2xhd2JhY2sKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRGcmVlemUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VVJMCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyOAogICAgLy8gdHhuID0gaXR4bi5Bc3NldENvbmZpZygKICAgIGludCBhY2ZnCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMAogICAgLy8gZmVlPTEwMDAsCiAgICBpbnQgMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyB0eG4uc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0MAogICAgLy8gYXNzZXQgPSBvcC5JVHhuLmNyZWF0ZWRfYXNzZXRfaWQoKQogICAgaXR4biBDcmVhdGVkQXNzZXRJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDIKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChhc3NldC5pZCkKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0LmNvbnRyYWN0LkNlcnQudXBkYXRlKCkgLT4gdWludDY0Ogp1cGRhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0NC00NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJVcGRhdGVBcHBsaWNhdGlvbiJdKQogICAgLy8gZGVmIHVwZGF0ZShzZWxmKSAtPiBib29sOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0NgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludCAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmRlbGV0ZSgpIC0+IHVpbnQ2NDoKZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDgtNDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiBkZWxldGUoc2VsZikgLT4gYm9vbDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NTAKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCg==\",\n        \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgaW50IDEKICAgIHJldHVybgo=\"\n    },\n    \"state\": {\n        \"global\": {\n            \"num_byte_slices\": 0,\n            \"num_uints\": 0\n        },\n        \"local\": {\n            \"num_byte_slices\": 0,\n            \"num_uints\": 0\n        }\n    },\n    \"schema\": {\n        \"global\": {\n            \"declared\": {},\n            \"reserved\": {}\n        },\n        \"local\": {\n            \"declared\": {},\n            \"reserved\": {}\n        }\n    },\n    \"contract\": {\n        \"name\": \"Cert\",\n        \"methods\": [\n            {\n                \"name\": \"hello\",\n                \"args\": [\n                    {\n                        \"type\": \"string\",\n                        \"name\": \"name\"\n                    }\n                ],\n                \"returns\": {\n                    \"type\": \"string\"\n                }\n            },\n            {\n                \"name\": \"create_certificate_nft\",\n                \"args\": [\n                    {\n                        \"type\": \"(string,string,uint64,string,string)\",\n                        \"name\": \"args\"\n                    }\n                ],\n                \"returns\": {\n                    \"type\": \"uint64\"\n                }\n            },\n            {\n                \"name\": \"update\",\n                \"args\": [],\n                \"returns\": {\n                    \"type\": \"bool\"\n                }\n            },\n            {\n                \"name\": \"delete\",\n                \"args\": [],\n                \"returns\": {\n                    \"type\": \"bool\"\n                }\n            }\n        ],\n        \"networks\": {}\n    },\n    \"bare_call_config\": {\n        \"no_op\": \"CREATE\"\n    }\n}\"\"\"\nAPP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)\n_TReturn = typing.TypeVar(\"_TReturn\")\n\n\nclass _ArgsBase(ABC, typing.Generic[_TReturn]):\n    @staticmethod\n    @abstractmethod\n    def method() -> str:\n        ...\n\n\n_TArgs = typing.TypeVar(\"_TArgs\", bound=_ArgsBase[typing.Any])\n\n\n@dataclasses.dataclass(kw_only=True)\nclass _TArgsHolder(typing.Generic[_TArgs]):\n    args: _TArgs\n\n\n@dataclasses.dataclass(kw_only=True)\nclass Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):\n    pass\n\n\ndef _filter_none(value: dict | typing.Any) -> dict | typing.Any:\n    if isinstance(value, dict):\n        return {k: _filter_none(v) for k, v in value.items() if v is not None}\n    return value\n\n\ndef _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:\n    if data is None:\n        return {}\n    if not dataclasses.is_dataclass(data):\n        raise TypeError(f\"{data} must be a dataclass\")\n    if convert_all:\n        result = dataclasses.asdict(data)\n    else:\n        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}\n    return _filter_none(result)\n\n\ndef _convert_transaction_parameters(\n    transaction_parameters: algokit_utils.TransactionParameters | None,\n) -> algokit_utils.TransactionParametersDict:\n    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))\n\n\ndef _convert_call_transaction_parameters(\n    transaction_parameters: algokit_utils.TransactionParameters | None,\n) -> algokit_utils.OnCompleteCallParametersDict:\n    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))\n\n\ndef _convert_create_transaction_parameters(\n    transaction_parameters: algokit_utils.TransactionParameters | None,\n    on_complete: algokit_utils.OnCompleteActionName,\n) -> algokit_utils.CreateCallParametersDict:\n    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))\n    on_complete_enum = on_complete.replace(\"_\", \" \").title().replace(\" \", \"\") + \"OC\"\n    result[\"on_complete\"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)\n    return result\n\n\ndef _convert_deploy_args(\n    deploy_args: algokit_utils.DeployCallArgs | None,\n) -> algokit_utils.ABICreateCallArgsDict | None:\n    if deploy_args is None:\n        return None\n\n    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))\n    if isinstance(deploy_args, _TArgsHolder):\n        deploy_args_dict[\"args\"] = _as_dict(deploy_args.args)\n        deploy_args_dict[\"method\"] = deploy_args.args.method()\n\n    return deploy_args_dict\n\n\n@dataclasses.dataclass(kw_only=True)\nclass HelloArgs(_ArgsBase[str]):\n    name: str\n\n    @staticmethod\n    def method() -> str:\n        return \"hello(string)string\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass NewCertificateNftArgs:\n    name: str\n    image_url: str\n    certificate_id: int\n    metadata_hash: str\n    unit_name: str\n\n\n@dataclasses.dataclass(kw_only=True)\nclass CreateCertificateNftArgs(_ArgsBase[int]):\n    args: NewCertificateNftArgs\n\n    @staticmethod\n    def method() -> str:\n        return \"create_certificate_nft((string,string,uint64,string,string))uint64\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass UpdateArgs(_ArgsBase[bool]):\n    @staticmethod\n    def method() -> str:\n        return \"update()bool\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass DeleteArgs(_ArgsBase[bool]):\n    @staticmethod\n    def method() -> str:\n        return \"delete()bool\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass SimulateOptions:\n    allow_more_logs: bool = dataclasses.field(default=False)\n    allow_empty_signatures: bool = dataclasses.field(default=False)\n    extra_opcode_budget: int = dataclasses.field(default=0)\n    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)\n\n\nclass Composer:\n\n    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):\n        self.app_client = app_client\n        self.atc = atc\n\n    def build(self) -> AtomicTransactionComposer:\n        return self.atc\n\n    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:\n        request = models.SimulateRequest(\n            allow_more_logs=options.allow_more_logs,\n            allow_empty_signatures=options.allow_empty_signatures,\n            extra_opcode_budget=options.extra_opcode_budget,\n            exec_trace_config=options.exec_trace_config,\n            txn_groups=[]\n        ) if options else None\n        result = self.atc.simulate(self.app_client.algod_client, request)\n        return result\n\n    def execute(self) -> AtomicTransactionResponse:\n        return self.app_client.execute_atc(self.atc)\n\n    def hello(\n        self,\n        *,\n        name: str,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `hello(string)string` ABI method\n        \n        :param str name: The `name` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = HelloArgs(\n            name=name,\n        )\n        self.app_client.compose_call(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def create_certificate_nft(\n        self,\n        *,\n        args: NewCertificateNftArgs,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `create_certificate_nft((string,string,uint64,string,string))uint64` ABI method\n        \n        :param NewCertificateNftArgs args: The `args` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = CreateCertificateNftArgs(\n            args=args,\n        )\n        self.app_client.compose_call(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def create_bare(\n        self,\n        *,\n        on_complete: typing.Literal[\"no_op\"] = \"no_op\",\n        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to create an application using the no_op bare method\n        \n        :param typing.Literal[no_op] on_complete: On completion type to use\n        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        self.app_client.compose_create(\n            self.atc,\n            call_abi_method=False,\n            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),\n        )\n        return self\n\n    def update_update(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `update()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = UpdateArgs()\n        self.app_client.compose_update(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def delete_delete(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `delete()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = DeleteArgs()\n        self.app_client.compose_delete(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def clear_state(\n        self,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n        app_args: list[bytes] | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to the application with on completion set to ClearState\n    \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :param list[bytes] | None app_args: (optional) Application args to pass\"\"\"\n    \n        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)\n        return self\n\n\nclass CertClient:\n    \"\"\"A class for interacting with the Cert app providing high productivity and\n    strongly typed methods to deploy and call the app\"\"\"\n\n    @typing.overload\n    def __init__(\n        self,\n        algod_client: algosdk.v2client.algod.AlgodClient,\n        *,\n        app_id: int = 0,\n        signer: TransactionSigner | algokit_utils.Account | None = None,\n        sender: str | None = None,\n        suggested_params: algosdk.transaction.SuggestedParams | None = None,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        app_name: str | None = None,\n    ) -> None:\n        ...\n\n    @typing.overload\n    def __init__(\n        self,\n        algod_client: algosdk.v2client.algod.AlgodClient,\n        *,\n        creator: str | algokit_utils.Account,\n        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,\n        existing_deployments: algokit_utils.AppLookup | None = None,\n        signer: TransactionSigner | algokit_utils.Account | None = None,\n        sender: str | None = None,\n        suggested_params: algosdk.transaction.SuggestedParams | None = None,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        app_name: str | None = None,\n    ) -> None:\n        ...\n\n    def __init__(\n        self,\n        algod_client: algosdk.v2client.algod.AlgodClient,\n        *,\n        creator: str | algokit_utils.Account | None = None,\n        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,\n        existing_deployments: algokit_utils.AppLookup | None = None,\n        app_id: int = 0,\n        signer: TransactionSigner | algokit_utils.Account | None = None,\n        sender: str | None = None,\n        suggested_params: algosdk.transaction.SuggestedParams | None = None,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        app_name: str | None = None,\n    ) -> None:\n        \"\"\"\n        CertClient can be created with an app_id to interact with an existing application, alternatively\n        it can be created with a creator and indexer_client specified to find existing applications by name and creator.\n        \n        :param AlgodClient algod_client: AlgoSDK algod client\n        :param int app_id: The app_id of an existing application, to instead find the application by creator and name\n        use the creator and indexer_client parameters\n        :param str | Account creator: The address or Account of the app creator to resolve the app_id\n        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by\n        creator and app name\n        :param AppLookup existing_deployments:\n        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and\n        creator was passed as an Account will use that.\n        :param str sender: Address to use as the sender for all transactions, will use the address associated with the\n        signer if not specified.\n        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should\n        *NOT* include the TMPL_ prefix\n        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the\n        Application Specification\n            \"\"\"\n\n        self.app_spec = APP_SPEC\n        \n        # calling full __init__ signature, so ignoring mypy warning about overloads\n        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]\n            algod_client=algod_client,\n            app_spec=self.app_spec,\n            app_id=app_id,\n            creator=creator,\n            indexer_client=indexer_client,\n            existing_deployments=existing_deployments,\n            signer=signer,\n            sender=sender,\n            suggested_params=suggested_params,\n            template_values=template_values,\n            app_name=app_name,\n        )\n\n    @property\n    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:\n        return self.app_client.algod_client\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n\n    @app_id.setter\n    def app_id(self, value: int) -> None:\n        self.app_client.app_id = value\n\n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n\n    @property\n    def sender(self) -> str | None:\n        return self.app_client.sender\n\n    @sender.setter\n    def sender(self, value: str) -> None:\n        self.app_client.sender = value\n\n    @property\n    def signer(self) -> TransactionSigner | None:\n        return self.app_client.signer\n\n    @signer.setter\n    def signer(self, value: TransactionSigner) -> None:\n        self.app_client.signer = value\n\n    @property\n    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:\n        return self.app_client.suggested_params\n\n    @suggested_params.setter\n    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:\n        self.app_client.suggested_params = value\n\n    def hello(\n        self,\n        *,\n        name: str,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[str]:\n        \"\"\"Calls `hello(string)string` ABI method\n        \n        :param str name: The `name` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[str]: The result of the transaction\"\"\"\n\n        args = HelloArgs(\n            name=name,\n        )\n        result = self.app_client.call(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def create_certificate_nft(\n        self,\n        *,\n        args: NewCertificateNftArgs,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[int]:\n        \"\"\"Calls `create_certificate_nft((string,string,uint64,string,string))uint64` ABI method\n        \n        :param NewCertificateNftArgs args: The `args` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction\"\"\"\n\n        args = CreateCertificateNftArgs(\n            args=args,\n        )\n        result = self.app_client.call(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def create_bare(\n        self,\n        *,\n        on_complete: typing.Literal[\"no_op\"] = \"no_op\",\n        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,\n    ) -> algokit_utils.TransactionResponse:\n        \"\"\"Creates an application using the no_op bare method\n        \n        :param typing.Literal[no_op] on_complete: On completion type to use\n        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.TransactionResponse: The result of the transaction\"\"\"\n\n        result = self.app_client.create(\n            call_abi_method=False,\n            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),\n        )\n        return result\n\n    def update_update(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[bool]:\n        \"\"\"Calls `update()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction\"\"\"\n\n        args = UpdateArgs()\n        result = self.app_client.update(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def delete_delete(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[bool]:\n        \"\"\"Calls `delete()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction\"\"\"\n\n        args = DeleteArgs()\n        result = self.app_client.delete(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def clear_state(\n        self,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n        app_args: list[bytes] | None = None,\n    ) -> algokit_utils.TransactionResponse:\n        \"\"\"Calls the application with on completion set to ClearState\n    \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :param list[bytes] | None app_args: (optional) Application args to pass\n        :returns algokit_utils.TransactionResponse: The result of the transaction\"\"\"\n    \n        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)\n\n    def deploy(\n        self,\n        version: str | None = None,\n        *,\n        signer: TransactionSigner | None = None,\n        sender: str | None = None,\n        allow_update: bool | None = None,\n        allow_delete: bool | None = None,\n        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,\n        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        create_args: algokit_utils.DeployCallArgs | None = None,\n        update_args: Deploy[UpdateArgs],\n        delete_args: Deploy[DeleteArgs],\n    ) -> algokit_utils.DeployResponse:\n        \"\"\"Deploy an application and update client to reference it.\n        \n        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator\n        account, including deploy-time template placeholder substitutions.\n        To understand the architecture decisions behind this functionality please see\n        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>\n        \n        ```{note}\n        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to\n        'ReplaceApp' the existing app will be deleted and re-created.\n        ```\n        \n        ```{note}\n        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')\n        the existing app will be deleted and re-created.\n        ```\n        \n        :param str version: version to use when creating or updating app, if None version will be auto incremented\n        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app\n        , if None uses self.signer\n        :param str sender: sender address to use when deploying app, if None uses self.sender\n        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app\n        can be deleted\n        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app\n        can be updated\n        :param OnUpdate on_update: Determines what action to take if an application update is required\n        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements\n        has increased beyond the current allocation\n        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys\n        should *NOT* include the TMPL_ prefix\n        :param algokit_utils.DeployCallArgs | None create_args: Arguments used when creating an application\n        :param Deploy[UpdateArgs] update_args: Arguments used when updating an application\n        :param Deploy[DeleteArgs] delete_args: Arguments used when deleting an application\n        :return DeployResponse: details action taken and relevant transactions\n        :raises DeploymentError: If the deployment failed\"\"\"\n\n        return self.app_client.deploy(\n            version,\n            signer=signer,\n            sender=sender,\n            allow_update=allow_update,\n            allow_delete=allow_delete,\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            template_values=template_values,\n            create_args=_convert_deploy_args(create_args),\n            update_args=_convert_deploy_args(update_args),\n            delete_args=_convert_deploy_args(delete_args),\n        )\n\n    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:\n        return Composer(self.app_client, atc or AtomicTransactionComposer())"}
{"file_path": "https://github.com/lexycole/pay-rent-ng/blob/d572a34a39087e5fd775f8eb3bf88b024379dcd3/projects/pay-rent-ng-contracts/smart_contracts/__main__.py", "code": "# __main__.py\nimport logging\nimport sys\nfrom pathlib import Path\nimport uvicorn\nfrom dotenv import load_dotenv\n\n\nfrom smart_contracts._helpers.api import app\nfrom smart_contracts._helpers.build import build\nfrom smart_contracts._helpers.config import contracts\nfrom smart_contracts._helpers.deploy import deploy\n\n# Uncomment the following lines to enable auto generation of AVM Debugger compliant sourcemap and simulation trace file.\n# Learn more about using AlgoKit AVM Debugger to debug your TEAL source codes and inspect various kinds of\n# Algorand transactions in atomic groups -> https://github.com/algorandfoundation/algokit-avm-vscode-debugger\nfrom algokit_utils.config import config\nconfig.configure(debug=True, trace_all=True)\nlogging.basicConfig(\n    level=logging.DEBUG, format=\"%(asctime)s %(levelname)-10s: %(message)s\"\n)\nlogger = logging.getLogger(__name__)\nlogger.info(\"Loading .env\")\n# For manual script execution (bypassing `algokit project deploy`) with a custom .env,\n# modify `load_dotenv()` accordingly. For example, `load_dotenv('.env.localnet')`.\nload_dotenv()\nroot_path = Path(__file__).parent\n\n\ndef main(action: str, contract_name: str | None = None) -> None:\n    artifact_path = root_path / \"artifacts\"\n\n    # Filter contracts if a specific contract name is provided\n    filtered_contracts = [\n        c for c in contracts if contract_name is None or c.name == contract_name\n    ]\n\n    match action:\n        case \"serve\":\n            logger.info(\"Starting FastAPI server...\")\n            \n            uvicorn.run(\"smart_contracts._helpers.api:app\", host=\"127.0.0.1\", port=8000,  reload=True)\n        case \"build\":\n            for contract in filtered_contracts:\n                logger.info(f\"Building app at {contract.path}\")\n                build(artifact_path / contract.name, contract.path)\n        case \"deploy\":\n            for contract in filtered_contracts:\n                output_dir = artifact_path / contract.name\n                app_spec_file_name = next(\n                    (\n                        file.name\n                        for file in output_dir.iterdir()\n                        if file.is_file() and file.suffixes == [\".arc32\", \".json\"]\n                    ),\n                    None,\n                )\n                if app_spec_file_name is None:\n                    raise Exception(\"Could not deploy app, .arc32.json file not found\")\n                app_spec_path = output_dir / app_spec_file_name\n                if contract.deploy:\n                    logger.info(f\"Deploying app {contract.name}\")\n                    deploy(app_spec_path, contract.deploy)\n        \n\n        case \"all\":\n            for contract in filtered_contracts:\n                logger.info(f\"Building app at {contract.path}\")\n                app_spec_path = build(artifact_path / contract.name, contract.path)\n                if contract.deploy:\n                    logger.info(f\"Deploying {contract.path.name}\")\n                    deploy(app_spec_path, contract.deploy)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 2:\n        main(sys.argv[1], sys.argv[2])\n    elif len(sys.argv) > 1:\n        main(sys.argv[1])\n    else:\n        main(\"all\")"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/is_updatable.py", "code": "\"\"\"Detector for finding execution paths missing UpdateApplication.\"\"\"\n\nfrom typing import List, TYPE_CHECKING, Tuple\n\nfrom tealer.detectors.abstract_detector import (\n    AbstractDetector,\n    DetectorClassification,\n    DetectorType,\n)\nfrom tealer.detectors.utils import (\n    detect_missing_tx_field_validations_group,\n    detect_missing_tx_field_validations_group_complete,\n)\nfrom tealer.utils.teal_enums import TealerTransactionType\nfrom tealer.utils.output import ExecutionPaths\n\nif TYPE_CHECKING:\n    from tealer.teal.basic_blocks import BasicBlock\n    from tealer.utils.output import ListOutput\n    from tealer.teal.context.block_transaction_context import BlockTransactionContext\n    from tealer.teal.teal import Teal\n\n\nclass IsUpdatable(AbstractDetector):  # pylint: disable=too-few-public-methods\n    \"\"\"Detector to find execution paths missing UpdateApplication check.\n\n    Stateful smart contracts(application) can be updated with the new code\n    in algorand. If the application transaction of type UpdateApplication is\n    approved by the contract then the application's approval, clear programs\n    will be replaced by the ones sent along with the transaction. Contracts\n    can check the application transaction type using OnCompletion field.\n\n    This detector tries to find execution paths that approve the application\n    transactions(\"return 1\") and doesn't check the OnCompletion field against\n    UpdateApplication value. Execution paths that only execute if the application\n    transaction is not UpdateApplication are excluded.\n    \"\"\"\n\n    NAME = \"is-updatable\"\n    DESCRIPTION = \"Upgradable Applications\"\n    TYPE = DetectorType.STATEFULL\n\n    IMPACT = DetectorClassification.HIGH\n    CONFIDENCE = DetectorClassification.HIGH\n\n    WIKI_URL = \"https://github.com/crytic/tealer/wiki/Detector-Documentation#upgradable-application\"\n    WIKI_TITLE = \"Upgradable Application\"\n    WIKI_DESCRIPTION = (\n        \"Application can be updated by sending an `UpdateApplication` type application call.\"\n    )\n    WIKI_EXPLOIT_SCENARIO = \"\"\"\n```py\n@router.method(update_application=CallConfig.CALL)\ndef update_application() -> Expr:\n    return Assert(Txn.sender() == Global.creator_address())\n```\n\nCreator updates the application and steals all of its assets.\n\"\"\"\n\n    WIKI_RECOMMENDATION = \"\"\"\nDo not approve `UpdateApplication` type application calls.\n\"\"\"\n\n    def detect(self) -> \"ListOutput\":\n        \"\"\"Detect execution paths with missing UpdateApplication check.\n\n        Returns:\n            ExecutionPaths instance containing the list of vulnerable execution\n            paths along with name, check, impact, confidence and other detector\n            information.\n        \"\"\"\n\n        def checks_field(block_ctx: \"BlockTransactionContext\") -> bool:\n            # return False if Txn Type can be UpdateApplication.\n            # return True if Txn Type cannot be UpdateApplication.\n            return not TealerTransactionType.ApplUpdateApplication in block_ctx.transaction_types\n\n        # there should be a better to decide which function to call ??\n        if self.tealer.output_group:\n            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:\n            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance\n            return list(\n                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)\n            )\n\n        # paths_without_check: List[List[BasicBlock]] = detect_missing_tx_field_validations(\n        #     self.teal, checks_field\n        # )\n\n        # return ExecutionPaths(self.teal, self, paths_without_check)\n        output: List[\n            Tuple[\"Teal\", List[List[\"BasicBlock\"]]]\n        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)\n        detector_output: \"ListOutput\" = []\n        for contract, vulnerable_paths in output:\n            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))\n\n        return detector_output"}
{"file_path": "https://github.com/cusma/pe-de-manga/blob/4b2fde7681ff06232d071a60c7fb9ee83b356d57/pe_de_manga_smart_contract.py", "code": "\"\"\"\nAlgorand Smart Contract Pe de Manga: rega, diga ox\u00ea e receba sua manga NFT! \ud83e\udd6d\n\"\"\"\n\nfrom algosdk.future.transaction import StateSchema\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    Bytes,\n    Cond,\n    Expr,\n    Global,\n    If,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Mode,\n    OnComplete,\n    Reject,\n    Seq,\n    Txn,\n    TxnField,\n    TxnType,\n    compileTeal,\n)\n\nTEAL_VERSION = 5\n\n# SMART CONTRACT STATE SCHEMA\nGLOBAL_NA_MANGUEIRA = Bytes(\"naMangueira\")\n\nGLOBAL_STATE = StateSchema(num_uints=1, num_byte_slices=0)\nLOCAL_STATE = StateSchema(num_uints=0, num_byte_slices=0)\n\n# SMART CONTRACT METHODS\nMETHOD_REGA = \"rega\"\nMETHOD_COLHE = \"ox\u00ea\"\n\n\ndef pe_de_manga_approval() -> Expr:\n    return Cond(\n        [Txn.application_id() == Int(0), on_app_create()],\n        [Txn.on_completion() == OnComplete.NoOp, on_app_call()],\n    )\n\n\ndef pe_de_manga_clear() -> Expr:\n    return Reject()\n\n\ndef on_app_create() -> Expr:\n    precondition = And(\n        Txn.global_num_uints() == Int(GLOBAL_STATE.num_uints),\n        Txn.global_num_byte_slices() == Int(GLOBAL_STATE.num_byte_slices),\n        Txn.local_num_uints() == Int(LOCAL_STATE.num_uints),\n        Txn.local_num_byte_slices() == Int(LOCAL_STATE.num_byte_slices),\n    )\n\n    return Seq(\n        Assert(precondition),\n        App.globalPut(GLOBAL_NA_MANGUEIRA, Int(0)),\n        Approve()\n    )\n\n\ndef on_app_call() -> Expr:\n    method_selector = Txn.application_args[0]\n\n    return Seq(\n        Assert(Txn.application_args.length() == Int(1)),\n        Cond(\n            [method_selector == Bytes(METHOD_REGA), rega_pe_de_manga()],\n            [method_selector == Bytes(METHOD_COLHE), colhe_manga()],\n        ),\n        Approve(),\n    )\n\n\ndef rega_pe_de_manga() -> Expr:\n    mangueira_account = Global.current_application_address()\n\n    nao_tem_manga = App.globalGet(GLOBAL_NA_MANGUEIRA) == Int(0)\n\n    nasce_manga = Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_name: Bytes(\"MANGA\"),\n                TxnField.config_asset_unit_name: Bytes(\"\ud83e\udd6d\"),\n                TxnField.config_asset_url: Bytes(\n                    \"ipfs://bafkreibojeqclpzpz73gotdzqtondllgkncdzarmpad3i5alcvhodv7ujy#arc3\"\n                ),\n                TxnField.config_asset_metadata_hash: Bytes(\n                    \"LkkgJb8vz/ZnTHmE3NGtZlNEPIIseAe0dAsVTuHX9E4=\"\n                ),\n                TxnField.config_asset_decimals: Int(0),\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_manager: mangueira_account,\n                TxnField.config_asset_clawback: Global.zero_address(),\n                TxnField.config_asset_freeze: Global.zero_address(),\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),  # cria uma manga como non-fungible token\n        App.globalPut(GLOBAL_NA_MANGUEIRA, InnerTxn.created_asset_id()),\n        # guarda o Asset ID da ultima manga criada na mangueira\n        Approve(),\n    )\n\n    return Seq(\n        If(nao_tem_manga).Then(\n            nasce_manga\n        ).Else(\n            Reject()\n        )\n    )\n\n\ndef colhe_manga() -> Expr:\n    manga = App.globalGet(GLOBAL_NA_MANGUEIRA)\n\n    colher_da_mangueira = Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: manga,\n                TxnField.asset_amount: Int(1),\n                TxnField.asset_receiver: Txn.sender(),  # quem chamou a dApp\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),  # envie o token MANGA pra quem disse ox\u00ea\n        App.globalPut(GLOBAL_NA_MANGUEIRA, Int(0)),\n        # cancelar o Asset ID da manga que foi tirada da mangueira\n        Approve(),\n    )\n\n    return colher_da_mangueira\n\n\ndef compile_stateful(program) -> str:\n    return compileTeal(\n        program, Mode.Application, assembleConstants=True, version=TEAL_VERSION\n    )\n\n\nif __name__ == \"__main__\":\n    print(compile_stateful(pe_de_manga_approval()))"}
{"file_path": "https://github.com/seetadev/RoadOps/blob/347105e2c5df3247c9bd9ef0a669444b7c13b281/dev/algorand/arc-0020/smart_asa_asc.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nSmart ASA PyTEAL reference implementation based on ARC-20\n\"\"\"\n\n__author__ = \"Cosimo Bassi, Stefano De Angelis\"\n__email__ = \"<cosimo.bassi@algorand.com>, <stefano.deangelis@algorand.com>\"\n\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    AssetHolding,\n    AssetParam,\n    BareCallActions,\n    Bytes,\n    CallConfig,\n    Concat,\n    Expr,\n    Extract,\n    Global,\n    Gtxn,\n    If,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Len,\n    Mode,\n    Not,\n    OnCompleteAction,\n    OptimizeOptions,\n    Or,\n    Reject,\n    Return,\n    Router,\n    Seq,\n    Subroutine,\n    Suffix,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n    compileTeal,\n)\nfrom algosdk.future.transaction import StateSchema\nfrom algosdk.constants import key_len_bytes\n\n\n# / --- CONSTANTS\nTEAL_VERSION = 6\n\n# Descriptive field for the binding of Smart ASA App ID into the Underlying ASA url.\nSMART_ASA_APP_BINDING = \"smart-asa-app-id:\"\n\n# NOTE: The following costs could change over time with protocol upgrades.\nOPTIN_COST = 100_000\nUINTS_COST = 28_500\nBYTES_COST = 50_000\n\n\ndef static_attrs(cls):\n    return [k for k in cls.__dict__ if not k.startswith(\"__\")]\n\n\n# / --- SMART ASA ASC\n# / --- --- GLOBAL STATE\nclass GlobalInts:\n    total = Bytes(\"total\")\n    decimals = Bytes(\"decimals\")\n    default_frozen = Bytes(\"default_frozen\")\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass GlobalBytes:\n    unit_name = Bytes(\"unit_name\")\n    name = Bytes(\"name\")\n    url = Bytes(\"url\")\n    metadata_hash = Bytes(\"metadata_hash\")\n    manager_addr = Bytes(\"manager_addr\")\n    reserve_addr = Bytes(\"reserve_addr\")\n    freeze_addr = Bytes(\"freeze_addr\")\n    clawback_addr = Bytes(\"clawback_addr\")\n\n\nclass GlobalState(GlobalInts, GlobalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(GlobalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(GlobalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\nclass SmartASAConfig(abi.NamedTuple):\n    total: abi.Field[abi.Uint64]\n    decimals: abi.Field[abi.Uint32]\n    default_frozen: abi.Field[abi.Bool]\n    unit_name: abi.Field[abi.String]\n    name: abi.Field[abi.String]\n    url: abi.Field[abi.String]\n    metadata_hash: abi.Field[abi.DynamicArray[abi.Byte]]\n    manager_addr: abi.Field[abi.Address]\n    reserve_addr: abi.Field[abi.Address]\n    freeze_addr: abi.Field[abi.Address]\n    clawback_addr: abi.Field[abi.Address]\n\n\n# / --- --- LOCAL STATE\n# NOTE: Local State is needed only if the Smart ASA has `account_frozen`.\n# Local State is not needed in case Smart ASA has just \"global\" `asset_freeze`.\nclass LocalInts:\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass LocalBytes:\n    ...\n\n\nclass LocalState(LocalInts, LocalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(LocalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(LocalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\n# / --- --- SUBROUTINES\n@Subroutine(TealType.none)\ndef init_global_state() -> Expr:\n    return Seq(\n        App.globalPut(GlobalState.smart_asa_id, Int(0)),\n        App.globalPut(GlobalState.total, Int(0)),\n        App.globalPut(GlobalState.decimals, Int(0)),\n        App.globalPut(GlobalState.default_frozen, Int(0)),\n        # NOTE: ASA behaves excluding `unit_name` field if not declared:\n        App.globalPut(GlobalState.unit_name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `name` field if not declared:\n        App.globalPut(GlobalState.name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `url` field if not declared:\n        App.globalPut(GlobalState.url, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `metadata_hash` field if not declared:\n        App.globalPut(GlobalState.metadata_hash, Bytes(\"\")),\n        App.globalPut(GlobalState.manager_addr, Global.zero_address()),\n        App.globalPut(GlobalState.reserve_addr, Global.zero_address()),\n        App.globalPut(GlobalState.freeze_addr, Global.zero_address()),\n        App.globalPut(GlobalState.clawback_addr, Global.zero_address()),\n        # Special Smart ASA fields\n        App.globalPut(GlobalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.none)\ndef init_local_state() -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    return Seq(\n        App.localPut(Txn.sender(), LocalState.smart_asa_id, smart_asa_id),\n        App.localPut(Txn.sender(), LocalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef digit_to_ascii(i: Expr) -> Expr:\n    \"\"\"digit_to_ascii converts an integer < 10 to the ASCII byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), i, Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i: Expr) -> Expr:\n    \"\"\"itoa converts an integer to the ASCII byte string it represents.\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            digit_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef strip_len_prefix(abi_encoded: Expr) -> Expr:\n    return Suffix(abi_encoded, Int(abi.Uint16TypeSpec().byte_length_static()))\n\n\n# / --- --- UNDERLYING ASA CONFIG\nUNDERLYING_ASA_TOTAL = Int(2**64 - 1)\nUNDERLYING_ASA_DECIMALS = Int(0)\nUNDERLYING_ASA_DEFAULT_FROZEN = Int(1)\nUNDERLYING_ASA_UNIT_NAME = Bytes(\"S-ASA\")\nUNDERLYING_ASA_NAME = Bytes(\"SMART-ASA\")\nUNDERLYING_ASA_URL = Concat(\n    Bytes(SMART_ASA_APP_BINDING), itoa(Global.current_application_id())\n)\nUNDERLYING_ASA_METADATA_HASH = Bytes(\"\")\nUNDERLYING_ASA_MANAGER_ADDR = Global.current_application_address()\nUNDERLYING_ASA_RESERVE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_FREEZE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_CLAWBACK_ADDR = Global.current_application_address()\n\n\n@Subroutine(TealType.uint64)\ndef underlying_asa_create_inner_tx() -> Expr:\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: UNDERLYING_ASA_TOTAL,\n                TxnField.config_asset_decimals: UNDERLYING_ASA_DECIMALS,\n                TxnField.config_asset_default_frozen: UNDERLYING_ASA_DEFAULT_FROZEN,\n                TxnField.config_asset_unit_name: UNDERLYING_ASA_UNIT_NAME,\n                TxnField.config_asset_name: UNDERLYING_ASA_NAME,\n                TxnField.config_asset_url: UNDERLYING_ASA_URL,\n                TxnField.config_asset_manager: UNDERLYING_ASA_MANAGER_ADDR,\n                TxnField.config_asset_reserve: UNDERLYING_ASA_RESERVE_ADDR,\n                TxnField.config_asset_freeze: UNDERLYING_ASA_FREEZE_ADDR,\n                TxnField.config_asset_clawback: UNDERLYING_ASA_CLAWBACK_ADDR,\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        Return(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_transfer_inner_txn(\n    smart_asa_id: Expr,\n    asset_amount: Expr,\n    asset_sender: Expr,\n    asset_receiver: Expr,\n) -> Expr:\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: smart_asa_id,\n                TxnField.asset_amount: asset_amount,\n                TxnField.asset_sender: asset_sender,\n                TxnField.asset_receiver: asset_receiver,\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_destroy_inner_txn(smart_asa_id: Expr) -> Expr:\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset: smart_asa_id,\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef is_valid_address_bytes_length(address: Expr) -> Expr:\n    # WARNING: Note this check only ensures proper bytes' length on `address`,\n    # but doesn't ensure that those 32 bytes are a _proper_ Algorand address.\n    return Assert(Len(address) == Int(key_len_bytes))\n\n\n@Subroutine(TealType.uint64)\ndef circulating_supply(asset_id: Expr):\n    smart_asa_reserve = AssetHolding.balance(\n        Global.current_application_address(), asset_id\n    )\n    return Seq(smart_asa_reserve, UNDERLYING_ASA_TOTAL - smart_asa_reserve.value())\n\n\n@Subroutine(TealType.none)\ndef getter_preconditions(asset_id: Expr) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset_id\n    return Assert(\n        smart_asa_id,\n        is_correct_smart_asa_id,\n    )\n\n\n# / --- --- ABI\n# / --- --- BARE CALLS\n@Subroutine(TealType.none)\ndef asset_app_create() -> Expr:\n    return Seq(\n        # Preconditions\n        # Not mandatory - Smart ASA Application self validate its state.\n        Assert(\n            Txn.global_num_uints() == Int(GlobalState.num_uints()),\n            Txn.global_num_byte_slices() == Int(GlobalState.num_bytes()),\n            Txn.local_num_uints() == Int(LocalState.num_uints()),\n            Txn.local_num_byte_slices() == Int(LocalState.num_bytes()),\n        ),\n        init_global_state(),\n        Approve(),\n    )\n\n\nsmart_asa_abi = Router(\n    \"Smart ASA ref. implementation\",\n    BareCallActions(\n        no_op=OnCompleteAction.create_only(asset_app_create()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not updatable.\n        update_application=OnCompleteAction.always(Reject()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not deletable.\n        delete_application=OnCompleteAction.always(Reject()),\n        clear_state=OnCompleteAction.call_only(Reject()),\n    ),\n)\n\n\n# / --- --- METHODS\n@smart_asa_abi.method(opt_in=CallConfig.ALL)\ndef asset_app_optin(\n    asset: abi.Asset,\n    underlying_asa_optin: abi.AssetTransferTransaction,\n) -> Expr:\n    # On OptIn the frozen status must be set to `True` if account owns any\n    # units of the underlying ASA. This prevents malicious users to circumvent\n    # the `default_frozen` status by clearing their Local State. Note that this\n    # could be avoided by the use of Boxes once available.\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset.asset_id()\n    default_frozen = App.globalGet(GlobalState.default_frozen)\n    freeze_account = App.localPut(Txn.sender(), LocalState.frozen, Int(1))\n    account_balance = AssetHolding().balance(Txn.sender(), asset.asset_id())\n    optin_to_underlying_asa = account_balance.hasValue()\n    return Seq(\n        # Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n            underlying_asa_optin.get().type_enum() == TxnType.AssetTransfer,\n            underlying_asa_optin.get().xfer_asset() == smart_asa_id,\n            underlying_asa_optin.get().sender() == Txn.sender(),\n            underlying_asa_optin.get().asset_receiver() == Txn.sender(),\n            underlying_asa_optin.get().asset_amount() == Int(0),\n            underlying_asa_optin.get().asset_close_to() == Global.zero_address(),\n        ),\n        account_balance,\n        Assert(optin_to_underlying_asa),\n        # Effects\n        init_local_state(),\n        If(Or(default_frozen, account_balance.value() > Int(0))).Then(freeze_account),\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_create(\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n    *,\n    output: abi.Uint64,\n) -> Expr:\n\n    is_creator = Txn.sender() == Global.creator_address()\n    smart_asa_not_created = Not(App.globalGet(GlobalState.smart_asa_id))\n    smart_asa_id = underlying_asa_create_inner_tx()\n\n    return Seq(\n        # Preconditions\n        Assert(is_creator, smart_asa_not_created),\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        # Effects\n        # Underlying ASA creation\n        App.globalPut(GlobalState.smart_asa_id, smart_asa_id),\n        # Smart ASA properties\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n        output.set(App.globalGet(GlobalState.smart_asa_id)),\n    )\n\n\n@smart_asa_abi.method\ndef asset_config(\n    config_asset: abi.Asset,\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n) -> Expr:\n\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    current_manager_addr = App.globalGet(GlobalState.manager_addr)\n    current_reserve_addr = App.globalGet(GlobalState.reserve_addr)\n    current_freeze_addr = App.globalGet(GlobalState.freeze_addr)\n    current_clawback_addr = App.globalGet(GlobalState.clawback_addr)\n\n    is_manager_addr = Txn.sender() == current_manager_addr\n    is_correct_smart_asa_id = smart_asa_id == config_asset.asset_id()\n\n    update_reserve_addr = current_reserve_addr != reserve_addr.get()\n    update_freeze_addr = current_freeze_addr != freeze_addr.get()\n    update_clawback_addr = current_clawback_addr != clawback_addr.get()\n\n    # NOTE: In ref. implementation Smart ASA total can not be configured to\n    # less than its current circulating supply.\n    is_valid_total = total.get() >= circulating_supply(smart_asa_id)\n\n    return Seq(\n        # Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n        ),  # NOTE: usless in ref. impl since 1 ASA : 1 App\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        Assert(is_manager_addr),\n        If(update_reserve_addr).Then(\n            Assert(current_reserve_addr != Global.zero_address())\n        ),\n        If(update_freeze_addr).Then(\n            Assert(current_freeze_addr != Global.zero_address())\n        ),\n        If(update_clawback_addr).Then(\n            Assert(current_clawback_addr != Global.zero_address())\n        ),\n        Assert(is_valid_total),\n        # Effects\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n    )\n\n\n@smart_asa_abi.method\ndef asset_transfer(\n    xfer_asset: abi.Asset,\n    asset_amount: abi.Uint64,\n    asset_sender: abi.Account,\n    asset_receiver: abi.Account,\n) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    clawback_addr = App.globalGet(GlobalState.clawback_addr)\n    is_not_clawback = And(\n        Txn.sender() == asset_sender.address(),\n        Txn.sender() != clawback_addr,\n    )\n\n    # NOTE: Ref. implementation grants _minting_ premission to `reserve_addr`,\n    # has restriction no restriction on who is the minting _receiver_.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off minting.\n    is_minting = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == Global.current_application_address(),\n    )\n\n    # NOTE: Ref. implementation grants _burning_ premission to `reserve_addr`,\n    # has restriction both on burning _sender_ and _receiver_ to prevent\n    # _clawback_ throug burning.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off burning.\n    is_burning = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == App.globalGet(GlobalState.reserve_addr),\n        asset_receiver.address() == Global.current_application_address(),\n    )\n\n    is_clawback = Txn.sender() == clawback_addr\n    is_correct_smart_asa_id = smart_asa_id == xfer_asset.asset_id()\n\n    # NOTE: Ref. implementation checks that `smart_asa_id` is correct in Local\n    # State since the App could generate a new Smart ASA (if the previous one\n    # has been dystroied) requiring users to opt-in again to gain a coherent\n    # new `frozen` status.\n    is_current_smart_asa_id = And(\n        smart_asa_id == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n        smart_asa_id == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n    )\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_sender_frozen = App.localGet(asset_sender.address(), LocalState.frozen)\n    asset_receiver_frozen = App.localGet(asset_receiver.address(), LocalState.frozen)\n    return Seq(\n        # Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n        ),\n        is_valid_address_bytes_length(asset_sender.address()),\n        is_valid_address_bytes_length(asset_receiver.address()),\n        If(is_not_clawback)\n        .Then(\n            # Asset Regular Transfer Preconditions\n            Assert(\n                Not(asset_frozen),\n                Not(asset_sender_frozen),\n                Not(asset_receiver_frozen),\n                is_current_smart_asa_id,\n            ),\n        )\n        .ElseIf(is_minting)\n        .Then(\n            # Asset Minting Preconditions\n            Assert(\n                Not(asset_frozen),\n                Not(asset_receiver_frozen),\n                smart_asa_id\n                == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n                # NOTE: Ref. implementation prevents minting more than `total`.\n                circulating_supply(smart_asa_id) + asset_amount.get()\n                <= App.globalGet(GlobalState.total),\n            ),\n        )\n        .ElseIf(is_burning)\n        .Then(\n            # Asset Burning Preconditions\n            Assert(\n                Not(asset_frozen),\n                Not(asset_sender_frozen),\n                smart_asa_id\n                == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n            ),\n        )\n        .Else(\n            # Asset Clawback Preconditions\n            Assert(is_clawback),\n            # NOTE: `is_current_smart_asa_id` implicitly checks that both\n            # `asset_sender` and `asset_receiver` opted-in the Smart ASA\n            # App. This ensures that _mint_ and _burn_ can not be\n            # executed as _clawback_, since the Smart ASA App can not\n            # opt-in to itself.\n            Assert(is_current_smart_asa_id),\n        ),\n        # Effects\n        smart_asa_transfer_inner_txn(\n            xfer_asset.asset_id(),\n            asset_amount.get(),\n            asset_sender.address(),\n            asset_receiver.address(),\n        ),\n    )\n\n\n@smart_asa_abi.method\ndef asset_freeze(freeze_asset: abi.Asset, asset_frozen: abi.Bool) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Asset Freeze Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n            is_freeze_addr,\n        ),\n        # Effects\n        App.globalPut(GlobalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method\ndef account_freeze(\n    freeze_asset: abi.Asset,\n    freeze_account: abi.Account,\n    asset_frozen: abi.Bool,\n) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Account Freeze Preconditions\n        is_valid_address_bytes_length(freeze_account.address()),\n        Assert(smart_asa_id, is_correct_smart_asa_id, is_freeze_addr),\n        # Effects\n        App.localPut(freeze_account.address(), LocalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method(close_out=CallConfig.ALL)\ndef asset_app_closeout(\n    close_asset: abi.Asset,\n    close_to: abi.Account,\n) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == close_asset.asset_id()\n    current_smart_asa_id = App.localGet(Txn.sender(), LocalState.smart_asa_id)\n    is_current_smart_asa_id = current_smart_asa_id == close_asset.asset_id()\n    account_balance = AssetHolding().balance(Txn.sender(), close_asset.asset_id())\n    asset_creator = AssetParam().creator(close_asset.asset_id())\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_closer_frozen = App.localGet(Txn.sender(), LocalState.frozen)\n    asa_closeout_relative_idx = Txn.group_index() + Int(1)\n    return Seq(\n        # Preconditions\n        # NOTE: Smart ASA existence is not checked by default on close-out\n        # since would be impossible to close-out destroyed assets.\n        is_valid_address_bytes_length(close_to.address()),\n        Assert(\n            is_current_smart_asa_id,\n            Global.group_size() > asa_closeout_relative_idx,\n            Gtxn[asa_closeout_relative_idx].type_enum() == TxnType.AssetTransfer,\n            Gtxn[asa_closeout_relative_idx].xfer_asset() == close_asset.asset_id(),\n            Gtxn[asa_closeout_relative_idx].sender() == Txn.sender(),\n            Gtxn[asa_closeout_relative_idx].asset_amount() == Int(0),\n            Gtxn[asa_closeout_relative_idx].asset_close_to()\n            == Global.current_application_address(),\n        ),\n        # Effects\n        asset_creator,\n        # NOTE: Skip checks if Underlying ASA has been destroyed to avoid\n        # users' lock-in.\n        If(asset_creator.hasValue()).Then(\n            # NOTE: Smart ASA has not been destroyed.\n            Assert(is_correct_smart_asa_id),\n            If(Or(asset_frozen, asset_closer_frozen)).Then(\n                # NOTE: If Smart ASA is frozen, users can only close-out to\n                # Creator\n                Assert(close_to.address() == Global.current_application_address())\n            ),\n            If(close_to.address() != Global.current_application_address()).Then(\n                # NOTE: If the target of close-out is not Creator, it MUST be\n                # opted-in to the current Smart ASA.\n                Assert(\n                    smart_asa_id\n                    == App.localGet(close_to.address(), LocalState.smart_asa_id)\n                )\n            ),\n            account_balance,\n            smart_asa_transfer_inner_txn(\n                close_asset.asset_id(),\n                account_balance.value(),\n                Txn.sender(),\n                close_to.address(),\n            ),\n        ),\n        # NOTE: If Smart ASA has been destroyed:\n        #   1. The close-to address could be anyone\n        #   2. No InnerTxn happens\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_destroy(destroy_asset: abi.Asset) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == destroy_asset.asset_id()\n    is_manager_addr = Txn.sender() == App.globalGet(GlobalState.manager_addr)\n    return Seq(\n        # Asset Destroy Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n            is_manager_addr,\n        ),\n        # Effects\n        smart_asa_destroy_inner_txn(destroy_asset.asset_id()),\n        init_global_state(),\n    )\n\n\n# / --- --- GETTERS\n@smart_asa_abi.method\ndef get_asset_is_frozen(freeze_asset: abi.Asset, *, output: abi.Bool) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        # Effects\n        output.set(App.globalGet(GlobalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_account_is_frozen(\n    freeze_asset: abi.Asset, freeze_account: abi.Account, *, output: abi.Bool\n) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        is_valid_address_bytes_length(freeze_account.address()),\n        # Effects\n        output.set(App.localGet(freeze_account.address(), LocalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_circulating_supply(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(circulating_supply(asset.asset_id())),\n    )\n\n\n@smart_asa_abi.method\ndef get_optin_min_balance(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    min_balance = Int(\n        OPTIN_COST\n        + UINTS_COST * LocalState.num_uints()\n        + BYTES_COST * LocalState.num_bytes()\n    )\n\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(min_balance),\n    )\n\n\n@smart_asa_abi.method\ndef get_asset_config(asset: abi.Asset, *, output: SmartASAConfig) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        (total := abi.Uint64()).set(App.globalGet(GlobalState.total)),\n        (decimals := abi.Uint32()).set(App.globalGet(GlobalState.decimals)),\n        (default_frozen := abi.Bool()).set(App.globalGet(GlobalState.default_frozen)),\n        (unit_name := abi.String()).set(App.globalGet(GlobalState.unit_name)),\n        (name := abi.String()).set(App.globalGet(GlobalState.name)),\n        (url := abi.String()).set(App.globalGet(GlobalState.url)),\n        (metadata_hash_str := abi.String()).set(\n            App.globalGet(GlobalState.metadata_hash)\n        ),\n        (metadata_hash := abi.make(abi.DynamicArray[abi.Byte])).decode(\n            metadata_hash_str.encode()\n        ),\n        (manager_addr := abi.Address()).set(App.globalGet(GlobalState.manager_addr)),\n        (reserve_addr := abi.Address()).set(App.globalGet(GlobalState.reserve_addr)),\n        (freeze_addr := abi.Address()).set(App.globalGet(GlobalState.freeze_addr)),\n        (clawback_addr := abi.Address()).set(App.globalGet(GlobalState.clawback_addr)),\n        output.set(\n            total,\n            decimals,\n            default_frozen,\n            unit_name,\n            name,\n            url,\n            metadata_hash,\n            manager_addr,\n            reserve_addr,\n            freeze_addr,\n            clawback_addr,\n        ),\n    )\n\n\ndef compile_stateful(program: Expr) -> str:\n    return compileTeal(\n        program,\n        Mode.Application,\n        version=TEAL_VERSION,\n        assembleConstants=True,\n        optimize=OptimizeOptions(scratch_slots=True),\n    )\n\n\nif __name__ == \"__main__\":\n    # Allow quickly testing compilation.\n    from smart_asa_test import test_compile\n\n    test_compile(*smart_asa_abi.build_program())"}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/voting_process/voting.py", "code": "#This defines voting functions using traditional majority, STAR, and approval protocols.\n#All of the protocols below use Choice Coin to both quantify and send votes.\n#The funcions also define the ability to create accounts for an arbitary amount of voters.\n#The protocols below are minimum representations for two candidates, decisions,etc.\n#Read the Docs to learn how to add more candiates, decisions, and how to implement this protocol \n#into you governance system.\n\nfrom algosdk import account, encoding, mnemonic,transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\nfrom algorand_demo import choice_trade\nalgod_address = \"\"\nalgod_token = \"\"\n#Initializes Client for node\nheaders = {\"X-API-Key\": algod_token }\nalgod_client = algod.AlgodClient(algod_token,algod_address,headers)\nfund_address = \"\" #Put in main fund address here\nfund_mnemonic = \"\" #Put in main fund receiver_mnemonic here\nfund_key = mnemonic.to_private_key(fund_mnemonic)\nchoice_id = 17264161 #Official Test Asset ID for Choice Coin\ndecision_one = \"\"\ndecision_two = \"\"\ntest_address = ''\ntest_mnemonic = ''\n\ndef algo_inital(sender, key, receiver,comment):\n    parameters = algod_client.suggested_params()\n    #Initalize parameters\n    transaction = PaymentTxn(sender, parameters, receiver, 300000,note=comment)\n    #Defines an inital transaction for Algo.\n    #Add some sort of hash to ensure that fund addresses are hashed properly\n    #Add a hash to ensure that client addresses are protected\n    signature = transaction.sign(key)\n    #Signs the transaction with the sender's private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    return True\n\n\n\ndef count(address):\n    message = ''\n    error = ''\n    account_info = algod_client.account_info(address)\n    assets = account_info.get(\"assets\")\n    for asset in assets:\n        if asset[\"asset-id\"] ==  choice_id:\n            amount = asset.get(\"amount\")\n            message = amount\n            return message\n    error = 'The account has not opted-in to the asset yet.'\n    return error\n\n\n\n#This is quantifies a voter's vote and allows its to be recorded on the Algorand Blockchain through Choice Coin.\n#Each of the candiates/decisions will have their own Algorand Accounts to recieve these votes in the form of Choice Coin.\ndef choice_vote(sender, key, receiver,amount):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, choice_id)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\ndef create_optin(receiver_mnemonic,receiver_address,index):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(receiver_address, parameters, receiver_address, 0, index)\n    #Defines a transaction that will opt the receiver into the asset.\n    key = mnemonic.to_private_key(receiver_mnemonic)\n    signature = transaction.sign(key)\n    algod_client.send_transaction(signature)\n    #Opts-in the account to the asset\n    return True\n\n\n#This allows the organization to generate an arbitary amount of Algorand Accounts for its voters.\ndef initiate_new_accounts():\n    x = input(\"How many voters do you need?\")\n    x = int(x)\n    for y in range(0,x):\n        private,public = account.generate_account()\n        passphrase = mnemonic.from_private_key(private)\n        algo_inital(fund_address,fund_key,public,\"Balance to opt-in to Choice Coin\")\n        create_optin(passphrase,public,choice_id)\n        print(\"Address: {}\\nPasscode: \\\"{}\\\"\".format(public, passphrase))\n\n\n        \n#This defines a basic majority scheme on the Algorand Blockchain using the choice_vote function described earlier.       \ndef new_vote(vote,address,t_mnemonic):\n    private_key = mnemonic.to_private_key(mnemonic)\n    if vote == \"Yes\":\n        choice_vote(address,private_key,decision_one,100)\n    elif vote == \"No\":\n        choice_vote(address,private_key,decision_two,100)\n    else:\n        print(\"You did not submit the proper input\")\n\n#This defines a basic Star_Voting scheme using Choice Coin. Users are allowed to rate\n#each candidate. Once they have done this, the choice_vote function will\n#send the appropriate allocation of Choice Coin to the winner account.\n#Read the docs to create a restriction on how many start per voter\n#are possible.\ndef star_voting(address,t_mnemonic,candidate_rating,candiate_type):\n    if candiate_type == 'one':\n        candiate_rating = int(candidate_rating)\n        amount = candiate_rating * 100\n        private_key = mnemonic.to_private_key(t_mnemonic)\n        choice_vote(address,private_key,decision_one,amount)\n    elif candiate_type == 'two':\n        candiate_rating = int(candidate_rating)\n        amount = candiate_rating * 100\n        private_key = mnemonic.to_private_key(t_mnemonic)\n        choice_vote(address,private_key,decision_one,amount)\n    print(\"Ballot Tabulated\")\n\n#This defines a basic approval voting system. Again, this allows the voter \n#to select all the decisons/candidates they approve of. This again only has two decisions.\n#Read our Docs to find out more!\ndef approval_voting(address,t_mnemonic):\n    first = input(\"Do you approve of first decision? Please answer using Yes or No\")\n    second = input(\"Do you approve of second decision? Please answer using Yes or No\")\n    first = first.lower()\n    second = second.lower()\n    if first == 'yes':\n        choice_vote(address,private_key,decision_one,100)\n    elif second == 'yes':\n        choice_vote(address,private_key,decision_two,100)\n        \ndef check_holdings(asset_id, address):\n\t\"\"\"\n\tChecks the asset balance for the specific address and asset id.\n\t\"\"\"\n\taccount_info = client.account_info(address)\n\tassets = account_info.get(\"assets\")\n\tfor asset in assets:\n\t\tif asset['asset-id'] == asset_id:\n\t\t\tamount = asset.get(\"amount\")\n\t\t\tprint(\"Account {} has {}.\".format(address, balance_formatter(amount, asset_id, client)))\n\t\t\treturn\n\tprint(\"Account {} must opt-in to Asset ID {}.\".format(address, asset_id))\n    \n  \n#This is a stateful smart contract to count the number of votes each candiate recieved\n#on the Algorand Blockchain.\ndef count_votes():\n    yes_count = check_holdings(decision_one)\n    no_count = check_holding(decision_two)\n    if yes_count > no_count:\n        print(\"Decision One had the most votes!\")\n    if no_count > yes_count:\n        print(\"Decision Two had the most votes!\")"}
{"file_path": "https://github.com/Ecosteer-SRL/dvco-algorand/blob/00c9b22b07980fe9f6ced4363862aa7d05c6c416/worker/worker_algorand.py", "code": "#   ver:    0.5\n#   date:   24/10/2022\n#   author: georgiana-bud\nimport os\nimport base64\nfrom typing import Tuple, Type, Optional, Union\n\n\n \n#\tWARNING:\n#\tNOTE:\tthe kmd.net and kmd.token files are in a folder\n#\t\t    named based on the release of kmd - HOWEVER - to date\n#\t\t    no easy way has been found to determine the version of kmd\n#\t\t    programmatically - find a way or pass the version\n#\t\t    as a configuration parameter\n\n\n\nimport  algosdk                                      #   better type support (not necessary)                \nfrom    algosdk                     import mnemonic                                  \nfrom    algosdk                     import account\nfrom    algosdk.v2client            import algod\nfrom    algosdk.wallet              import Wallet\nfrom    algosdk                     import kmd\nfrom    algosdk.future              import transaction\nfrom    algosdk.future.transaction  import PaymentTxn\nfrom    algosdk.future.transaction  import ApplicationNoOpTxn\nfrom    algosdk.future.transaction  import ApplicationCreateTxn\nfrom    algosdk.future.transaction  import ApplicationOptInTxn\nfrom    algosdk.future.transaction  import ApplicationCloseOutTxn\n\nfrom error import DopError \n\n#   class workerAlgorand\n#   the following methods have to be implemented\n#\n#   (x) begin_transaction\n#   (x) rollback\n#   (x) commit\n#   (x) create_user\n#   (x) deploy_contract\n#   (x) get_wallet_balance\n#   (x) subscribe\n#   (x) unsubscribe\n#   balance                 NOTE:   not in first implementation\n#   (x) get_balance         NOTE:   not fully implemented (product related balance)\n#   admin_get_grants        NOTE:   not in first implementation - to be moved to chain 2 (offchain)\n#   get_receipt             NOTE:   to be removed - to be considered a private/provider specific method\n#   set_starting_balance    \n#   (x) grant\n#   (x) revoke\n\n\nclass workerAlgorand():\n    \n    def __init__ (self):\n        pass\n\n\n    def begin_transaction(self) -> DopError:\n        return DopError(0,\"\")\n\n    def rollback(self) -> DopError:\n        return DopError(0,\"\")\n\n    def commit(self) -> DopError:\n        return DopError(0,\"\")\n\n    def __wallet_id(\n        self,\n        wallet_name: str\n        ) -> Tuple[str, DopError]:\n\n        \"\"\"\n            returns the wallet id of the wallet named wallet_name\n        \"\"\"\n        if self._i_kmd_client == None:\n            return \"\",DopError(2,\"Missing value for kmd client.\")\n\n        wallets = self._i_kmd_client.list_wallets()\n        for arrayitem in wallets:\n            if arrayitem.get(\"name\") == wallet_name:\n                walletid = arrayitem.get(\"id\")\n                return walletid,DopError(0,'')\n                break\n        return '',DopError(101,\"The wallet id for the specified wallet name could not be retrieved.\")\n\n    def __account_mnemonic(\n        self,\n        wallet_name: str,\n        wallet_password: str,\n        account_address: str\n        ) -> Tuple[str, DopError]:\n\n        if self._i_kmd_client == None:\n            return \"\",DopError(2,\"Missing value for kmd client.\")\n\n        err: DopError\n        wallet_id, err = self.__wallet_id(wallet_name)\n        if err.isError():\n            return \"\",err\n\n        wallet_handle = self._i_kmd_client.init_wallet_handle(wallet_id, wallet_password)\n        account_key = self._i_kmd_client.export_key(wallet_handle, wallet_password, account_address )\n        key_mnemonic = mnemonic.from_private_key(account_key)\n\n        #   check for error, exceptions, etc.\n        return key_mnemonic, DopError(0,\"\")\n\n\n\n\n    @staticmethod\n    def dop_stateless_create(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   teal_template_path: str                 #   the absolute path of the teal contract template\n    ,   creator_address: str                    #   the address of the creator of the smart contract\n        ) -> Tuple[str, DopError]:\n        \"\"\"\n            creates the stateless smart contract\n            if successful   -> returns the address of the stateless smart contract \n            otherwise       -> returns an empty string\n        \"\"\"\n\n        #   compile the stateless teal prog\n        #   set source code \n        #       the source code to be used for this example is DOP/dop.account/dop.account.teal.template\n        #       NOTE:   the dop.account.teal (the source code to be compiled) is generated using the file \n        #               dop.account.teal.template by replacing the macro \"_RECEIVERADDRESS_\" with the \"creator_address\"\n        #               see DOP/dop.account/00_create.sh - that contains the following cmd\n        #               sed \"s/_RECEIVERADDRESS_/$CREATOR/g\" dop.account.teal.template > dop.account.teal\n\n\n        #   read the template\n        teal_template: str = \"\"\n        try:\n            with open(teal_template_path, 'r', encoding='utf-8') as f:\n                teal_template = f.read()\n        except Exception:\n            return \"\",DopError(3,\"Teal template file not found.\")\n\n        #   now the _RECEIVERADDRESS_ nacro has to be substituted with creator_address\n        teal_source = teal_template.replace('_RECEIVERADDRESS_', creator_address)\n\n        \n        try:\n            compile_response = client.compile(teal_source)\n            #   return base64.b64decode(compile_response['result'])\n            #   compile_response example\n            #   {\n            #       'hash': 'LILX6GOG4N6LAOTFT4WW5VTXK5AN4KA5TAN5CYAE7LX5GPC2XXU6NNHDTA', \n            #       'result': 'AyAHAgEABmTIAaCNBiYBIOKaz1eO1YI9t+Lp5CmWTNrK6kvjiZCylN6neTTnB6YYMgQiD0AAKTIEIxJAAAIkQzMAECMSQAAKMwAQJRJAAA0kQzMABygTQAAlIQRDIQVDMwAQIxNAABczARAlE0AADzMBGCQSQAAHMwAIIQYPQyRD'\n            #   }\n            #   where   'result'    holds the compiled code\n            #           'hash'      is the address of the smart contract\n        except Exception:\n            return \"\",DopError(4,\"Error compiling teal source.\")\n\n        smart_contract_address = compile_response['hash']\n\n        #   TODO:   \n        #           check if the stateless smart contract needs to be immediately funded\n        return smart_contract_address,DopError(0,\"\")\n\n    @staticmethod\n    def dop_stateful_create(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   teal_clear_program_path: str\n    ,   teal_approval_program_path: str\n    ,   creator_address: str\n    ,   creator_private_key: str\n    ,   smart_contract_address: str                     #   address of the stateless smart contract\n        ) -> Tuple[str, DopError]:\n        \"\"\"\n            creates the stateful smart contract\n            if successful   -> returns the txn_id of the stateful smart contract creation transaction\n            otherwise       -> returns an empty string\n        \"\"\"\n\n        #ApplicationCreateTxn\n\n        #   get and compile the clear program\n        teal_clear_source: str = \"\"\n        try:\n            with open(teal_clear_program_path, 'r', encoding='utf-8') as f:\n                teal_clear_source = f.read()\n        except Exception:\n            return \"\",DopError(5,\"Teal clear file not found.\")\n\n        compile_response = client.compile(teal_clear_source)            \n        clear_program = base64.b64decode(compile_response['result'])\n\n\n        # declare on_complete as NoOp\n        on_complete = transaction.OnComplete.NoOpOC.real\n\n        #   get and compile the approval program\n        teal_approval_source: str = \"\"\n        try:\n            with open(teal_approval_program_path, 'r', encoding='utf-8') as f:\n                teal_approval_source = f.read()\n        except Exception:\n            return \"\",DopError(6,\"Teal approval file not found.\")\n\n        compile_response = client.compile(teal_approval_source) \n        approval_program = base64.b64decode(compile_response['result'])           \n\n        params = client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n\n        #compile_result = base64.b64decode(compile_response['result'])\n        \n        smart_contract_arguments = {\n            \"args\":     [smart_contract_address]    #   list of app arguments (goal app create --app-arg)\n#       ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n        }\n\n        app_args: list   = workerAlgorand.getArgs(smart_contract_arguments)\n\n        # declare application state storage (immutable)\n        local_ints      = 5\n        local_bytes     = 5\n        global_ints     = 5\n        global_bytes    = 5\n\n        # define schema (<class 'algosdk.future.transaction.StateSchema'>)\n        global_schema   = transaction.StateSchema(global_ints, global_bytes)\n        local_schema    = transaction.StateSchema(local_ints, local_bytes)\n\n        unsigned_txn = ApplicationCreateTxn(creator_address, params, on_complete, approval_program, clear_program, global_schema, local_schema, app_args)\n        # sign transaction\n        signed_txn = unsigned_txn.sign(creator_private_key)\n        txn_id = signed_txn.transaction.get_txid()\n\n        #   send transaction\n        try: \n            client.send_transactions([signed_txn])    \n        except Exception as err:\n            return txn_id, DopError(120, f\"An error occurred while creating stateful \\\n                smart contract.\")\n        return (txn_id,DopError(0,\"\"))\n\n    @staticmethod\n    def mnemonic_to_private_key(mnemonic_key: str) -> Tuple[str, DopError]:\n        \"\"\"\n        convert a menmonic key into a \"single string\" private key\n        \"\"\"\n        private_key: str = \"\"\n        try:\n            private_key = mnemonic.to_private_key(mnemonic_key)\n        except Exception:\n            return \"\",DopError(10,\"Mnemonic could not be converted to private key.\")\n\n        return private_key,DopError(0,\"\")\n\n\n    \n    #   private method\n    def __algorand_smart_contract_create(\n        self\n    ,   client: algosdk.v2client.algod.AlgodClient\n    ,   creator_mnemonic: str\n        ) -> Tuple[str, str, DopError]:\n        \n        \"\"\"\n            the DOP smart contract is a linked smart contract\n            (there is a stateless part, to represent the smart contract account\n            and a stateful part, holding the DOP logic)\n            RETURNS:    \n                    address of the stateless smart contract\n                    app index of the stateful smart contract\n                    DopError\n\n            see https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/?from_query=call%20smart%20contract%20from%20javascript#call-noop\n            see https://github.com/algorand/py-algorand-sdk/blob/5b496e0928af1dcae4e393693421f590a6111907/algosdk/future/transaction.py\n            see https://developer.algorand.org/docs/rest-apis/algod/v2/\n        \"\"\"\n\n        err: DopError\n        creator_private_key: str\n\n        creator_private_key, err = self.mnemonic_to_private_key(creator_mnemonic)\n        if err.isError():\n            return (\"\",0,err)\n        creator_address       = account.address_from_private_key(creator_private_key)         #   this line to be deleted\n\n        smart_contract_address, err = self.dop_stateless_create(client, self._i_stateless_teal_template_path, creator_address)\n        if err.isError():\n            return (\"\",0,err)\n\n        txn_id, err = self.dop_stateful_create(client, self._i_teal_clear_program_path, self._i_teal_approval_program_path, creator_address, creator_private_key, smart_contract_address)\n\n        if err.isError():\n            return \"\",0,err\n\n        # await confirmation\n        confirmed_txn = self.wait_for_confirmation(client, txn_id, 4)  \n\n\n        #   confirmed_txn holds:\n        #   {\n        #       'application-index': 392, \n        #       'confirmed-round': 66118, \n        #       'global-state-delta': [\n        #                               {'key': 'a2V5', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, \n        #                               {'key': 'a2lk', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, \n        #                               {'key': 'bGlua2Vk', 'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}}, \n        #                               {'key': 'Y3JlYXRvcg==', 'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}}\n        #                               ], \n        #       'pool-error': '', \n        #       'sender-rewards': 16230, \n        #       'txn': {'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', \n        #               'txn': {'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], \n        #                       'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', \n        #                       'apgs': {'nbs': 5, 'nui': 5}, \n        #                       'apls': {'nbs': 5, 'nui': 5}, \n        #                       'apsu': 'AyABASI=', \n        #                       'fee': 1000, \n        #                       'fv': 66017, \n        #                       'gen': 'private-v1', \n        #                       'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', \n        #                       'lv': 67017, \n        #                       'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', \n        #                       'type': 'appl'}\n        #               }\n        #       }\n\n\n        # display results\n        transaction_response = client.pending_transaction_info(txn_id)\n\n        #   transaction_response\n        #   {\n        #       'application-index': 392, \n        #       'confirmed-round': 66118, \n        #       'global-state-delta': [\n        #                               {\n        #                                   'key': 'Y3JlYXRvcg==', \n        #                                   'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}\n        #                               }, \n        #                               {\n        #                                   'key': 'a2V5', \n        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}\n        #                               }, \n        #                               {\n        #                                   'key': 'a2lk', \n        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}\n        #                               }, \n        #                               {\n        #                                   'key': 'bGlua2Vk', \n        #                                   'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}\n        #                               }\n        #                               ], \n        #       'pool-error': '', \n        #       'sender-rewards': 16230, \n        #       'txn': {\n        #                   'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', \n        #                   'txn': {\n        #                               'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], \n        #                               'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', \n        #                               'apgs': {'nbs': 5, 'nui': 5}, \n        #                               'apls': {'nbs': 5, 'nui': 5}, \n        #                               'apsu': 'AyABASI=', \n        #                               'fee': 1000, \n        #                               'fv': 66017, \n        #                               'gen': 'private-v1', \n        #                               'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', \n        #                               'lv': 67017, \n        #                               'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', \n        #                               'type': 'appl'\n        #                           }\n        #               }\n        #       }\n\n        app_id = transaction_response['application-index']\n        return (smart_contract_address, str(app_id), DopError(0,\"\"))\n\n\n    #   private method\n    def __account_send(self, from_mnemonic, to_address, amount) -> Tuple[str,DopError]:\n\n        \"\"\"\n        Sends tokens from one account to another\n        \"\"\"\n        if self._i_algod_client == None:\n            return \"\",DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTIN\".encode()\n\n        err: DopError\n\n        from_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return \"\",err\n        from_address = account.address_from_private_key(from_private_key)\n\n        \n        params = self._i_algod_client.suggested_params()\n        # comment out the next two (2) lines to use suggested fees\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP funds\".encode()\n\n        #   create an unsigned transaction\n        unsigned_txn = PaymentTxn(from_address, params, to_address, amount, None, txn_note)\n\n        #   sign the transaction using the private key of the sender (from_address)\n        signed_txn = unsigned_txn.sign(from_private_key)\n\n        #submit transaction\n        txid = self._i_algod_client.send_transaction(signed_txn)\n        print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        # wait for confirmation \n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n        except Exception as err:\n            print(err)\n            return \"\", DopError(301,'An exception occurred while waiting \\\n                for the confirmation of the send transaction.')\n        \n        return txid, DopError(0,)\n    \n    @staticmethod\n    def wait_for_confirmation(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   transaction_id: str\n    ,   timeout: int\n    ):\n        \"\"\"\n        Wait until the transaction is confirmed or rejected, or until 'timeout'\n        number of rounds have passed.\n        Args:\n            transaction_id (str): the transaction to wait for\n            timeout (int): maximum number of rounds to wait    \n        Returns:\n            dict: pending transaction information, or throws an error if the transaction\n                is not confirmed or rejected in the next timeout rounds\n        \"\"\"\n        start_round = client.status()[\"last-round\"] + 1\n        current_round = start_round\n\n        while current_round < start_round + timeout:\n            try:\n                pending_txn = client.pending_transaction_info(transaction_id)\n            except Exception:\n                return \n            if pending_txn.get(\"confirmed-round\", 0) > 0:\n                return pending_txn\n            elif pending_txn[\"pool-error\"]:  \n                raise Exception(\n                    'pool error: {}'.format(pending_txn[\"pool-error\"]))\n            client.status_after_block(current_round)                   \n            current_round += 1\n        raise Exception(\n            'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))\n\n    @staticmethod\n    def Token(token: str, path: str) -> Tuple[DopError, str]:\n        ntoken: str = token\n        if ntoken == '':\n            try:\n                with open(path, 'r') as f:\n                    ntoken = f.readline()\n            except Exception as e:\n                #print(str(e))\n                return (DopError(20,\"An exception occurred while reading token file.\"),ntoken)\n\n            l: list = ntoken.split('\\n')\n            ntoken = l[0]\n        return (DopError(), ntoken)\n\n    @staticmethod \n    def Port(port: str, path: str) -> Tuple[DopError, str]:\n        nport: str = port\n        host: str = ''\n        if nport == '':\n            try:\n                with open(path, 'r') as f:\n                    host = f.readline()\n            except:\n                return (DopError(21,\"An exception occurred while reading port file.\"),nport)\n\n        l: list = host.split('\\n')\n        host = l[0]\n        l = host.split(':')\n        if len(l) > 1:\n            nport = l[1]\n\n        return (DopError(), nport)\n        \n    def algodToken(self) -> Tuple[DopError, str]:\n        \"\"\"\n        returns the token of necessary to connect to the algod node\n        NOTE:   the token is retrieved by reading and parsing the file \"$ALGORAND_DATA/algod.token\"\n                so this function requires the macro ALGORAND_DATA to be defined and available\n                to the process calling this method\n        \"\"\"\n\n        token: str\n        if 'atoken' in self._i_config:\n            #   atoken passed in connstring - ignore file containing token\n            token = self._i_config['atoken']\n            self._i_algo_token = token\n            return DopError(),token\n\n        err, token = self.Token(self._i_algo_token, self._i_algo_token_file)\n        if err.code == 0:\n            self._i_algo_token = token\n\n        return (err,token)\n\n    def algodPort(self) -> Tuple[DopError, str]:\n        \"\"\"\n        returns the TCP port the algod node is listening to\n        NOTE:   the port is retrieved by reading and parsing the file \"$ALGORAND_DATA/algod.net\"\n                so this function requires the macro ALGORAND_DATA to be defined and available\n                to the process calling this method\n        \"\"\"\n        port: int\n        if 'anetprt' in self._i_config:\n            #   anetprt passed in connstring - ignore file containing port\n            port = int(self._i_config['anetprt'])\n            self._i_algo_port = port\n            return DopError(),port\n\n        err, port = self.Port(self._i_algo_port, self._i_algo_net_file)\n        if err.code == 0:\n            self._i_algo_port = port\n        return (err, port)\n\n    def kmdToken(self) -> Tuple[DopError, str]:\n        token: str\n        if 'ktoken' in self._i_config:\n            #   atoken passed in connstring - ignore file containing token\n            token = self._i_config['ktoken']\n            self._i_kmd_token = token\n            return DopError(),token\n\n        err, token = self.Token(self._i_kmd_token, self._i_kmd_token_file)\n        if err.code == 0:\n            self._i_kmd_token = token\n        return (err, token)\n\n    def kmdPort(self) -> Tuple[DopError, str]:\n        port: int\n        if 'knetprt' in self._i_config:\n            #   anetprt passed in connstring - ignore file containing port\n            port = int(self._i_config['knetprt'])\n            self._i_kmd_port = port\n            return DopError(),port\n\n        err, port = self.Port(self._i_kmd_port, self._i_kmd_net_file)\n        if err.code == 0:\n            self._i_kmd_port = port\n        return (err, port)\n\n    def kmd(self) -> Tuple[DopError, algosdk.kmd.KMDClient]:\n        err, kmd_token = self.kmdToken()\n        if err.code != 0:\n            return (err,None)\n        err, kmd_port = self.kmdPort()\n        if err.code != 0:\n            return (err,None)\n\n        kmd_ip_address: str = 'http://localhost:' \n        if 'knetip' in self._i_config:\n            kmd_ip_address = 'http://' + self._i_config['knetip'] + ':'\n        kmd_address = kmd_ip_address + str(kmd_port)\n\n        kcl = kmd.KMDClient(kmd_token, kmd_address)\n\n        try:\n            #   NOTE:           it seems that the kmd can be instantiated only if using localhost\n            #                   to be checked with algorand\n            kcl.versions()  #   generates an exception if the kcl is not connected\n        except Exception:\n            return(DopError(22, \"An exception occurred while initializing kmd client.\"),kcl)\n\n        return(DopError(),kcl)\n    \n    def algod(self) -> Tuple[DopError, algosdk.v2client.algod.AlgodClient]:\n        #   get algod token\n        err, algod_token = self.algodToken()\n        if err.code != 0:\n            return (err,None)\n        #   get algod port\n        err, algod_port = self.algodPort()\n        if err.code != 0:\n            return (err,None)\n        #   get algo node address (default is localhost)\n\n        algod_ip_address: str = 'http://localhost:' \n        if 'anetip' in self._i_config:\n            algod_ip_address = 'http://' + self._i_config['anetip'] + ':'\n        #algod_address = 'http://localhost:' + str(algod_port)\n        algod_address = algod_ip_address + str(algod_port)\n        algocl = algod.AlgodClient(algod_token, algod_address)\n\n        #   check if the algod client is valid\n        try:\n            algocl.status()\n        except Exception:\n            return(DopError(23, \"Error in initializing algod client.\"),algocl)\n\n        return(DopError(),algocl)\n\n    @staticmethod\n    def getArgs(argsobj: dict) -> list:\n        args = argsobj.get(\"args\")\n\n        if args==None:\n            return None\n\n        if len(args) < 1:\n            return None\n\n        b_args: list = []\n        for item in args:\n            b_args.append(bytes(item,'utf-8'))\n        return b_args\n\n    @staticmethod\n    def getAccounts(argsobj: dict) -> list:\n        args = argsobj.get(\"addrs\")\n\n        if args==None:\n            return None\n\n        if len(args) < 1:\n            return None\n\n        return args\n\n    def dopSmartContract(\n        self\n    ,   algod_client: algosdk.v2client.algod.AlgodClient\n    ,   appid:  int                     #   smart contract index (address)\n    ,   owner_mnemonic: str             #   private key (mnemonic) of the owner of the smart contract\n    ,   scarguments: dict               #   {\"args\":[argslist], \"addrs\":[accountaddresseslist]}\n    ,   transaction_note: str           #   the note field withon the transaction\n    ) -> Tuple[str, DopError]:               #   error code, transaction id\n\n        #   retrieve and change suggested params (for the transaction)        \n        #   this could become an argument, to be investigated (future releases)\n        params = algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n\n        txn_note = transaction_note.encode()\n\n        err: DopError\n        owner_private_key: str\n        owner_private_key,err   = self.mnemonic_to_private_key(owner_mnemonic)\n        if err.isError():\n            return \"\",err\n\n        owner_address       = account.address_from_private_key(owner_private_key)         #   this line to be deleted\n\n        arguments_list   = self.getArgs(scarguments)\n        accounts_list    = self.getAccounts(scarguments)\n\n        unsigned_txn = ApplicationNoOpTxn(owner_address, params, appid, arguments_list, accounts_list, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(owner_private_key)\n\n        txid = ''\n        try:\n            txid = algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #print(err)\n            return \"\", DopError(202,f\"An exception occurred when sending transaction.\")\n\n        return(txid, DopError(0,\"\"))      #   now the transaction can be waited for\n\n    def __default(self):\n        #   set default parameters\n        self._i_algo_token      = ''\n        self._i_algo_port       = ''\n        self._i_algod_client    = None\n\n        self._i_kmd_token       = ''\n        self._i_kmd_port        = ''\n        self._i_kmd_client      = None\n\n        self._i_config: dict   = {}\n        \n        algorand_data_path: str = '/home/ecosteer/dop/externals/algorand/net1/Primary'\n        if 'ALGORAND_DATA' in os.environ:\n            algorand_data_path = os.environ['ALGORAND_DATA']\n\n        self._i_algo_token_file     = algorand_data_path + '/algod.token'           #   this has to go\n        self._i_config['atokf']     = algorand_data_path + '/algod.token'\n\n        self._i_algo_net_file       = algorand_data_path + '/algod.net'             #   this has to go\n        self._i_config['anetf']     = algorand_data_path + '/algod.net'\n\n        self._i_kmd_token_file      = algorand_data_path + '/kmd-v0.5/kmd.token'    #   this has to go\n        self._i_config['ktokf']     = algorand_data_path + '/kmd-v0.5/kmd.token'\n\n        self._i_kmd_net_file        = algorand_data_path + '/kmd-v0.5/kmd.net'      #   this has to go\n        self._i_config['knetf']     = algorand_data_path + '/kmd-v0.5/kmd.net'\n        \n\n        dop_smart_contract_root_path: str = '/home/ecosteer/dop/intermediation/algorand/DOP'\n        self._i_config['scrf'] = dop_smart_contract_root_path\n\n        user_wallet: str            = \"unencrypted-default-wallet\"                  # wallet where the users are created\n        user_wallet_password: str   = \"\"                                            # password to access the wallet\n        self._i_config['usrwlab']   = user_wallet\n        self._i_config['usrwpwd']   = user_wallet_password\n\n\n        if 'DOP_SMART_CONTRACT_ROOT_FOLDER' in os.environ:\n            dop_smart_contract_root_path = os.environ['DOP_SMART_CONTRACT_ROOT_FOLDER']\n            \n        self._i_stateless_teal_template_path    = dop_smart_contract_root_path + '/dop.account/dop.account.teal.template'\n        self._i_config['sttp'] = 'dop.account/dop.account.teal.template'\n        self._i_teal_approval_program_path      = dop_smart_contract_root_path + '/dop.stateful/dop.stateful.teal'\n        self._i_config['tapp'] = 'dop.stateful/dop.stateful.teal'\n        self._i_teal_clear_program_path         = dop_smart_contract_root_path + '/dop.clear/basicClear.teal'\n        self._i_config['tcpp'] = 'dop.clear/basicClear.teal'\n\n        self._i_config['ownmne'] = ''\n\n\n    #============================================================================\n    #   abstract methods\n    #============================================================================\n    #   NOTE:   init must become an abstract method\n    def init(self, constring: str) -> DopError:\n\n        self.__default()\n                \n        #   convert connstring into a dict (see config_to_dict in shared.utils.py)\n        temp_config: dict = {}\n\n        temp_list: list = constring.split(';')\n        for el in temp_list:\n            ell = el.split('=')\n            if len(ell) != 2:\n                continue\n            temp_config[ell[0]]=ell[1]\n\n        pars: list = [\n            'atokf',\n            'anetf',\n            'ktokf',\n            'knetf',\n            'atoken',\n            'anetprt',\n            'anetip',\n            'ktoken',\n            'knetprt',\n            'knetip',\n            'scrf',\n            'sttp',\n            'tapp',\n            'tcpp',\n            'usrwlab',\n            'usrwpwd',\n            'ownmne'\n            ]\n\n        for p in pars:\n            if p in temp_config:\n                self._i_config[p] = temp_config[p]\n\n\n        \n        #   connection string parameters\n        #   label   type        logic\n        #   ------+---------+------------------------------------------------------------------------------------------------\n        #   atokf   string      absolute path of the algod.token file\n        #   anetf   string      absolute path of the algod.net file     \n        #   ktokf   string      absolute path of the kmd.token file\n        #   knetf   string      absolute path of the kmd.net file\n        #   atoken  string      algod token (if this is defined then atokf will not be used)\n        #   anetprt int         algod tcp ip port (if this is defined then the anetf will not be used - anetip required)\n        #   anetip  string      algod tcp ip address (if this is defined then the anetf will not be used - anetprt required)\n        #   ktoken  string      kmd token (if this is defined then atokf will not be used)\n        #   knetprt int         kmd tcp ip port (if this is defined then the knetf will not be used - knetip required)\n        #   knetip  string      kmd tcp ip address (if this is defined then the knetf will not be used - knetprt required)\n        #   scrf    string      smart contract root folder      : absolute path of the folder containing sttp, atpt and tcpp\n        #   sttp    string      stateless teal template path    : relative path of the stateless teal template\n        #   tapp    string      teal approval program path      : relative path of the teal approval program\n        #   tcpp    string      teal clear program path         : relative path of the teal clear program\n        #\tusrwlab\tstring\t\tuser wallet (the wallet used by the worker to create accounts)\n\t\t#\tusrwpwd\tstring\t\tuser wallet password\n\n        #   ownmne  string      mnemonic of the owner account to be used to fund newly created accounts\n\n        #   example 1 (can be used only if the kmd and algod are running on localhost)\n        #   atokf=/home/ecosteer/algorand/net1/Primary/algod.token;anetf=/home/ecosteer/algorand/net1/Primary/algod.net;\\\n        #   ktokf=/home/ecosteer/algorand/net1/Primary/kmd.token;knetf=/home/ecosteer/algorand/net1/Primary/kmd.net;\\\n        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\\\n        #   sttp=dop.account/dop.account.teal.template;\\\n        #   tapp=dop.stateful/dop.stateful.teal;\\\n        #   tcpp=dop.clear/basicClear.teal;\n\n        #   example 2 (to be used if the kmd and algod are running on a remote host)\n        #   atoken=45d2689bb4b555b757b00972d82c0a872f7b2aa136a5351768280dbe7cf2e9b2;\\\n        #   anetprt=18445;\\\n        #   anetip=192.178.20.30;\\\n        #   ktoken=d278689bb4b555b7502030465782c0a872f7b2aa136a5351768280dbe7cf2ab90;\\\n        #   knetprt=18435;\\\n        #   knetip=192.178.20.30;\\\n        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\\\n        #   sttp=dop.account/dop.account.teal.template;\\\n        #   tapp=dop.stateful/dop.stateful.teal;\\\n        #   tcpp=dop.clear/basicClear.teal;\n\n        #   test only\n        for el in self._i_config:\n            print(el + ':[' + self._i_config[el] + ']')\n        \n        return DopError(0, \"\")\n\n    def open(self) -> DopError:\n        \"\"\"\n            open the algod client and the kmd client\n            the following properties are valorized:\n            1)  _i_algod_token\n            2)  _i_algod_port\n            3)  _i_kmd_token\n            4)  _i_kmd_port\n        \"\"\"\n\n\n        #   self.algod\n        #   sets self._i_algod_token and self._i_algod_port\n        err, self._i_algod_client = self.algod()\n        if err.isError():\n            return err\n\n        err, self._i_kmd_client = self.kmd()\n        if err.isError():\n            return err\n\n        if 'ownmne' in self._i_config: \n            self._own_mnemonic = self._i_config['ownmne']\n        else:\n            self._own_mnemonic = None\n            return DopError(201, \"Owner mnemonic not provided.\")\n\n        return err\n\n    def close(self) -> DopError:\n        #   TODO:   check if algod and kmd client have to be \"closed\" \n        return DopError(0,\"\")\n\n\n    def get_balance(self,\n                    publisher_address: str,                         #   EoA address of the publisher (contract owner)\n                    subscriber_address: str,                        #   EoA address of the subscriber we want to check the balance \n                    contract_address: str) -> Tuple[dict, DopError]:   #   address (blockchain layer) of the contract) -> Tuple[dict, DopError]:\n        \"\"\"\n        in this version this method is not \"really\" implemented\n        \"\"\"\n        response = {}\n        response['subscribed'] = 1\n        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use DB\n        response['credit'] = 100\n        response['debit'] = 0\n\n        return response, DopError(0,\"\")\n\n    def create_user(self, username: str, password: str) -> Tuple[str, str, DopError]: \n        \"\"\"\n            creates a blockchain account and returns the address (public key) of the account and the password\n            of the account (ethereum: input password, algorand, generated private key)\n\n        \"\"\"\n        user_address = \"\"\n        wallet_id: str\n        err: DopError\n\n        wallet_name = self._i_config['usrwlab']\n        wallet_password = self._i_config['usrwpwd']\n\n        wallet_id, err = self.__wallet_id(wallet_name)\n        if err.isError():\n            return \"\",\"\",err\n\n        \n        try:\n            wallet = Wallet(wallet_name, wallet_password, self._i_kmd_client)\n            #   create the account\n            account_address     = wallet.generate_key()\n            account_mnemonic, err    = self.__account_mnemonic(wallet_name,wallet_password,account_address)\n            if err.isError():\n                return \"\",\"\",err\n            #   return err=0,account_address\n            return account_address, account_mnemonic,DopError(0,\"\")\n\n        except Exception as err:\n            #   likely the password is wrong\n            print(err)      #   logging etc.\n            return \"\",\"\",DopError(203,\"An exception occurred while creating user.\")\n\n        return \"\",\"\",DopError(1000,\"\")             # never hit\n\n\n        return (user_address,user_mnemonic,DopError(0,\"\"))\n    \n\n\n    def get_wallet_balance(self, account_address: str, currency=\"algo\") -> Tuple[str, DopError]:\n        \"\"\"\n            TODO:       return account_balance, DopError (as usual)\n            TODO:       the method name should be change into \"get_account_balance\" to disambiguate between account and wallet\n            NOTE:       the abstract was defined with a str return value\n        \"\"\"\n        if self._i_algod_client == None:\n            return \"\", DopError(1,\"Missing value for algod client.\")\n\n        try:\n            #   address is the account address - for instance: \"4KNM6V4O2WBD3N7C5HSCTFSM3LFOUS7DRGILFFG6U54TJZYHUYMDPN26KY\"\n            from_account_info = self._i_algod_client.account_info(account_address)\n            #   the account balance is in micro algos\n            account_balance = from_account_info.get('amount')\n            #print(\"Origin Account balance     : [{} microAlgos]\".format(from_account_info.get('amount')))\n            return account_balance, DopError(0,\"\")\n        except Exception:\n            return \"\",DopError(204,\"An exception occurred while getting wallet balance.\")\n\n        \n    def deploy_contract(self,\n                        publisher_address: str,                 #   address of the owner account\n                        secret: str,                            #   secret for the owner account (algorand: private key mnemonic of the owner)\n                        tariff_period: int,                     #   period of the tariff \n                        tariff_price: int                       #   price of a period\n                        ) -> Tuple[Optional[str], DopError]:\n        \"\"\"\n            NOTE:\n                The abstract method returns a transaction hash that is inserted into the \n                rdbms (transactions schema) - as this is typically a pending operation finalized by an event emitted by the monitor.\n                For Algorand: this might require a complete different logic of the processor \"product_create.py\" - possibly a \n                processor specific for Algorand will have to be implemented.\n                See also monitor_des.py - it processes the event (DEPLOY_CONTRACT) that is\n                meant to close the pending op\n\n                NOTE:   EnableDeveloperAPI must be set to true (node configuration file)\n                NOTE:   https://developer.algorand.org/docs/run-a-node/reference/config/\n\n                TODO:   review static and private method dop_stateful/dop_stateless/__algorand_smart_contract_create\n        \"\"\"\n\n        #   publisher_address:      not used\n        #   tariff_period:          not used (for future release)\n        #   tariff_price:           not used (for future release)\n        #   secret: is the mnemonic of the publisher\n        \n        smart_contract_address: str     #   the address of the stateless smart contract (the smart contract linked to the stateful smart contract)\n                                        #   as the previously defined abstract method allows tp return just two values\n                                        #   we will not return the smart contract address for the moment - to be checked\n                                        #   in this release the smart_comtract_address will be encoded using the following string:\n                                        #   %smart_contract_adress%@%app_id\n\n        app_id: str                     #   the application id (this id will have to be used for invoking the smart contract)\n        err: DopError\n\n        if self._i_algod_client == None:\n            #   must open before\n            return (\"\",DopError(1,\"Missing value for algod client.\"))\n\n        smart_contract_address, app_id, err = self.__algorand_smart_contract_create(self._i_algod_client, secret) \n        if err.isError():\n            return \"\", err\n        #   TODO check if stateless contract has to be funded\n        encoded_smart_contract_address: str = smart_contract_address + '@' + str(app_id)\n        return (encoded_smart_contract_address, err)\n\n    def algorand_sub_optin(     #   ALGORAND SPECIFIC\n        self,\n        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in\n        application_address: str    #   application index of the smart contract the account wants to opt into\n        ) -> DopError:\n        \"\"\"\n        Algorand specific (an account has to optin before subscribing to a smart contract)\n        this methid can be called by a specific Algorand processor provider (not an abstract method),\n        for instance by the processor provider that implement the subscription logic\n        SO: it has not be implemented as a private method - but an Algorand specific method.\n\n        NOTE:   the subscriber, before subscribing the contract X, MUST opt-in to the contract X\n        \"\"\"\n        #   see 01_sub_optin.py\n        \n        if self._i_algod_client == None:\n            return DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTIN\".encode()\n\n        err: DopError\n\n        #subscriber_private_key = mnemonic.to_private_key(from_mnemonic)\n        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return err\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        appid = int(application_address)\n        unsigned_txn = ApplicationOptInTxn(subscriber_address, params, appid, None, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid =''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(205,\"An exception occurred when sending optin transaction.\")\n\n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n            #   TODO: confirmed_txn can be used to provide detailed log, see next\n            #   commented lines\n            #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(302,\"An exception occurred while waiting for confirmation of optin transaction.\")\n\n        return DopError(0,\"\")\n\n\n    def algorand_sub_optout(     #   ALGORAND SPECIFIC\n        self,\n        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in\n        application_address: str    #   application index of the smart contract the account wants to opt into\n        ) -> DopError:\n        \"\"\"\n        Algorand specific (symmetric to algorand_sub_optin)\n        NOTE:   a subscriber that has unsubscribed should call optout, too\n        \"\"\"\n        \n        if self._i_algod_client == None:\n            return DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTOUT\".encode()\n\n        err: DopError\n        subscriber_private_key: str\n\n        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return err\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        appid = int(application_address)\n        unsigned_txn = ApplicationCloseOutTxn(subscriber_address, params, appid, None, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid =''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(206,\"An exception occurred when sending optout transaction.\")\n\n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n            #   TODO: confirmed_txn can be used to provide detailed log, see next\n            #   commented lines\n            #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(303,\"An exception occurred while waiting for \\\n                        confirmation of optout transaction.\")\n\n        return DopError(0,\"\")\n\n\n    def subscribe(self,\n                  subscriber_addr: str,             #   subscriber address\n                  subscriber_psw: str,              #   private key mnemonic\n                  contract_address: str,            #   algorand application index\n                  secret: str                       #   not used in this release\n                  ) -> Tuple[str, DopError]:  \n        \"\"\"\n        Subscribe to a contract\n        \"\"\"\n\n        if self._i_algod_client == None:\n            return \"\",DopError(1,\"\")        #   must be connected to a node\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP SUBSCRIBE\".encode()\n\n    #   the transaction type that has to be sent is of type ApplicationNoOpTxn\n    #   see https://github.com/algorand/py-algorand-sdk/blob/5ca32cea62168ae339ccfdfbefaa6bc6ac094052/algosdk/future/transaction.py#L2040\n    #   line 2040\n        \n        err: DopError\n        subscriber_private_key: str\n\n        subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)\n        if err.isError():\n            return \"\",err\n\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        app_args : list = []\n        app_args.append(bytes('subscribe','utf-8'))\n        unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, contract_address, app_args, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid = ''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #print(err)\n            return \"\", DopError(207,\"An exception occurred when sending subscribe transaction.\")\n\n        # wait for confirmation \n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client,txid,4)\n\n            #print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #print(err)\n            return \"\",DopError(304,\"An exception occurred while waiting for confirmation \\\n                    of subscribe transaction.\")\n\n        return txid,DopError(0,\"\")\n\n\n    def unsubscribe(self, \n                    subscriber_addr: str,               #   not used\n                    subscriber_psw: str,                #   subscriber account private key mnemonic\n                    contract_address: str             #   application index\n                    #,secret: str                         #   not used \n                    ) -> Tuple[str, DopError]:\n            \"\"\"\n            UnSubscribe from a contract\n            return transaction id\n            \"\"\"\n\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")        #   must be connected to a node\n\n            params = self._i_algod_client.suggested_params()\n            params.flat_fee = True\n            params.fee = 1000\n            txn_note = \"DOP UNSUBSCRIBE\".encode()\n\n            err: DopError\n            subscriber_private_key: str\n            subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)\n            if err.isError():\n                return \"\",err\n            subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n            application_index = int(contract_address)\n\n            app_args : list = []\n            app_args.append(bytes('unsubscribe','utf-8'))\n            unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, application_index, app_args, None, None, None, txn_note)\n            signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n            txid = ''\n            try:\n                txid = self._i_algod_client.send_transaction(signed_txn)\n                #print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n            except Exception as err:\n                #print(err)\n                return \"\", DopError(208,'An exception occurred when sending unsubscribe transaction.')\n\n            # wait for confirmation \n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n\n                return \"\",DopError(305,'An exception occurred while waiting for \\\n                            confirmation of unsubscribe transaction')\n\n            return txid,DopError(0,'')\n\n\n    def grant(self,\n              publisher_address: str,       #   not used\n              publisher_passw: str,         #   publisher private key mnemonic\n              contract_address: str,        #   application index            \n              subscriber_address: str       #   address of the subscriber to be granted\n              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError\n              \n            # see 06_pub_call_grant.py\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")\n\n            smart_contract_arguments = {\n                    \"args\":     ['grant']                   #   list of app arguments\n                ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n                }\n\n            transaction_note = \"DOP GRANT\"\n\n            err: DopError\n            txid: str = \"\"\n            txid, err = self.dopSmartContract(\n                self._i_algod_client\n            ,   int(contract_address)\n            ,   publisher_passw\n            ,   smart_contract_arguments\n            ,   transaction_note\n            )\n\n            if err.isError():\n                return \"\",err\n\n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n                #print(err)\n                return txid,DopError(306,\"An exception occurred while waiting for \\\n                    confirmation of grant transaction.\")\n\n            return txid,DopError(0,\"\")\n            \n\n\n\n    def revoke(self,\n              publisher_address: str,       #   not used\n              publisher_passw: str,         #   publisher private key mnemonic\n              contract_address: str,        #   application index            \n              subscriber_address: str       #   address of the subscriber to be revoked\n              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError\n\n              # see 07_pub_call_revoke.py\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")\n\n            smart_contract_arguments = {\n                \"args\":     ['revoke']                   #   list of app arguments\n            ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n            }\n\n            transaction_note = \"DOP REVOKE\"\n\n            txid: str = \"\"\n            err: DopError\n            txid, err = self.dopSmartContract(\n                self._i_algod_client\n            ,   contract_address\n            ,   publisher_passw\n            ,   smart_contract_arguments\n            ,   transaction_note\n            )\n\n            if err.isError():\n                return \"\",err\n\n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n                #print(err)\n                return txid,DopError(307,\"An exception occurred while waiting for \\\n                    confirmation of revoke transaction.\")\n\n            return txid,DopError(0,\"\")\n\n\n\n    def balance(self,\n                subscriber_address: str,                            #   subscriber EoA address\n                secret: str,                                        #   subscriber contract secret\n                contract_address: str) -> Tuple[dict, DopError]:       #   address (blockchain layer) of the contract\n        \"\"\"\n        Get the balance of a user with `address` of the contract with `contract_address`\n        \"\"\"\n        \"\"\"\n        in this version this method is not \"really\" implemented\n        \"\"\"\n        response = {}\n        response['subscribed'] = 1\n        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use postgres DB\n        response['credit'] = 100\n        response['debit'] = 0\n\n        return (response, DopError(0,\"\"))\n\n    \n    def admin_get_grants(self,\n                        publisher_address: str,             #   EoA address of the publisher (contract owner)\n                        contract_address: str) -> Tuple[list, DopError]:    #   address (blockchain layer) of the contract\n        \"\"\"\n        This method is used by the publisher only in order to retrieve the list \n        of the EoA address of the granted subscribers\n        \"\"\"\n        return [], DopError()\n\n\n    def set_starting_balance(self, \n                            address,\n                            amount) -> str: # EoA of the user \n        \"\"\"\n        Sets the starting balance of an EoA\n        \"\"\"\n        #self._own_mnemonic = \"ability improve suspect canyon castle fire flock forum monitor travel know write similar denial thought \\\n        #    online ripple squeeze this finish jar parrot rabbit ability crouch\"\n        if self._own_mnemonic == None:\n            return \"\"\n\n        txid, err = self.__account_send(from_mnemonic = self._own_mnemonic, to_address=address, amount=amount)\n        if err.isError():\n            return \"\" \n\n        return txid"}
{"file_path": "https://github.com/Fracture-Labs/FractureDAO/blob/c41923fed2b894e4fde9b7dc1c687917beff4d5a/contract/contract.py", "code": "from pyteal import *\nimport os\n\n# Global state \n# - totalApproved (int)\n\n# Local state \n# Delegatee account (6 int)\n# - NumOfTrustees (int)\n# - Threshold (int) \n# - Trustee_address (max 4): Trustee_approval_status (unapproved: Int(1), approved: Int(2)) (int)\n\ndef approval_program():\n    \n    on_create = Seq(\n        App.globalPut(Bytes(\"totalApproved\"), Int(0)),\n        Approve(),\n    )\n\n\n    # Ensure trustee has not approved before\n    # get(delegatee_account, key_of_sender_aka_trustee)\n    # Note: if the key is not there, Int(0) is returned so we cannot initialise it as UInt(0) \n    ensure_trustee_unapproved = Int(1) == App.localGet(Txn.accounts[1], Txn.accounts[0])\n    ensure_unapproved = Int(1) == App.localGet(Txn.accounts[1], Txn.accounts[0])\n    num_of_approved_trustees = App.localGet(Txn.accounts[1], Bytes(\"Approved\"))\n    threshold = App.localGet(Txn.accounts[1], Bytes(\"Threshold\"))\n    g_approved = App.globalGet(Bytes(\"totalApproved\"))\n\n    new_num_of_approved_trustees = ScratchVar(TealType.uint64)\n    new_g_approved = ScratchVar(TealType.uint64)\n    on_req_kfrags = Seq(\n        # Ensure there is a target account to apporve for\n        Assert(Txn.accounts.length() == Int(1)),\n        # Ensure this trustee has not previously approved this account\n        Assert(ensure_trustee_unapproved),\n        # Ensure this account has not been approved\n        Assert(ensure_unapproved),\n        # Store state to approve the account\n        App.localPut(Txn.accounts[1], Txn.accounts[0], Int(2)),\n        # Store state of new total approved trustees \n        new_num_of_approved_trustees.store(num_of_approved_trustees + Int(1)),\n        App.localPut(Txn.accounts[1], Bytes(\"Approved\"), new_num_of_approved_trustees.load()),\n        # Update global state if it has been approved\n        If(new_num_of_approved_trustees.load() >= threshold)\n        .Then(App.globalPut(Bytes(\"totalApproved\"), g_approved + Int(1))),\n        Approve(),\n    )\n\n    on_call = Seq(\n        # First, lets fail immediately if this transaction is grouped with any others\n        Assert(Global.group_size() == Int(1)), \n        Cond(\n            [Txn.application_args[0] == Bytes(\"reqKfrags\"), on_req_kfrags ],\n        )\n    )\n\n    # OptIn from the delegatee\n    # - allows the app to write into their local state\n    # - take the Txn.accounts max 4 https://developer.algorand.org/docs/get-details/parameter_tables/?from_query=reference%20#smart-signature-constraints\n    i = ScratchVar(TealType.uint64)\n    on_optIn = Seq(\n        Assert(Txn.accounts.length() > Int(0)),\n        # Threshold for approval\n        Assert(Btoi(Txn.application_args[0]) <= Txn.accounts.length()),\n        # Loop through all the foreign accounts (aka trustees)\n        i.store(Int(1)),\n        While(i.load() < Txn.accounts.length()+Int(1) ).Do(Seq([\n        # Set Approved state as unapproved Int(1)\n        App.localPut(Txn.accounts[0], Txn.accounts[i.load()], Int(1)),\n        i.store(i.load() + Int(1))\n        ])),\n        # Set NumOfTrustees given\n        App.localPut(Txn.accounts[0], Bytes(\"NumOfTrustees\"), Txn.accounts.length()),\n        # Set Threshold required to approve kfrags \n        App.localPut(Txn.accounts[0], Bytes(\"Threshold\"), Btoi(Txn.application_args[0])),\n        App.localPut(Txn.accounts[0], Bytes(\"Approved\"), Int(0)),\n        Approve(),\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, on_call],\n        [Txn.on_completion() == OnComplete.OptIn, on_optIn],\n        [\n            Or(\n                Txn.on_completion() == OnComplete.CloseOut,\n                Txn.on_completion() == OnComplete.UpdateApplication,\n            ),\n            Reject(),\n        ],\n    )\n\n    return compileTeal(program, Mode.Application, version=5)\n\ndef clear_state_program():\n   program = Approve()\n   # Mode.Application specifies that this is a stateful smart contract\n   return compileTeal(program, Mode.Application, version=5)\n\npath = os.path.dirname(os.path.abspath(__file__))\n\n\n# compile program to TEAL assembly\nwith open(os.path.join(path, \"./approval.teal\"), \"w\") as f:\n    approval_program_teal = approval_program()\n    f.write(approval_program_teal)\n\n\n    # compile program to TEAL assembly\nwith open(os.path.join(path, \"./clear.teal\"), \"w\") as f:\n    clear_state_program_teal = clear_state_program()\n    f.write(clear_state_program_teal)\n    \nprint(approval_program())\nprint(clear_state_program())"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/is_deletable.py", "code": "\"\"\"Detector for finding execution paths missing DeleteApplication check.\"\"\"\n\nfrom typing import List, TYPE_CHECKING, Tuple\n\nfrom tealer.detectors.abstract_detector import (\n    AbstractDetector,\n    DetectorClassification,\n    DetectorType,\n)\n\nfrom tealer.detectors.utils import (\n    detect_missing_tx_field_validations_group,\n    detect_missing_tx_field_validations_group_complete,\n)\nfrom tealer.utils.teal_enums import TealerTransactionType\nfrom tealer.utils.output import ExecutionPaths\n\nif TYPE_CHECKING:\n    from tealer.utils.output import ListOutput\n    from tealer.teal.basic_blocks import BasicBlock\n    from tealer.teal.context.block_transaction_context import BlockTransactionContext\n    from tealer.teal.teal import Teal\n\n\nclass IsDeletable(AbstractDetector):  # pylint: disable=too-few-public-methods\n    \"\"\"Detector to find execution paths missing DeleteApplication check.\n\n    Stateful smart contracts(application) can be deleted in algorand. If the\n    application transaction of type DeleteApplication is approved by the application,\n    then the application will be deleted. Contracts can check the application\n    transaction type using OnCompletion field.\n\n    This detector tries to find execution paths that approve the application\n    transaction(\"return 1\") and doesn't check the OnCompletion field against\n    DeleteApplication value. Execution paths that only execute if the application\n    transaction is not DeleteApplication are excluded.\n    \"\"\"\n\n    NAME = \"is-deletable\"\n    DESCRIPTION = \"Deletable Applications\"\n    TYPE = DetectorType.STATEFULL\n\n    IMPACT = DetectorClassification.HIGH\n    CONFIDENCE = DetectorClassification.HIGH\n\n    WIKI_URL = \"https://github.com/crytic/tealer/wiki/Detector-Documentation#deletable-application\"\n    WIKI_TITLE = \"Deletable Application\"\n    WIKI_DESCRIPTION = (\n        \"Application can be deleted by sending an `DeleteApplication` type application call. \"\n    )\n    WIKI_EXPLOIT_SCENARIO = \"\"\"\n```py\n@router.method(delete_application=CallConfig.CALL)\ndef delete_application() -> Expr:\n    return Assert(Txn.sender() == Global.creator_address())\n```\n\nEve steals application creator's private key and deletes the application. Application's assets are permanently lost.\n\"\"\"\n\n    WIKI_RECOMMENDATION = \"\"\"\nDo not approve `DeleteApplication` type application calls.\n\"\"\"\n\n    def detect(self) -> \"ListOutput\":\n        \"\"\"Detect execution paths with missing DeleteApplication check.\n\n        Returns:\n            ExecutionPaths instance containing the list of vulnerable execution\n            paths along with name, check, impact, confidence and other detector\n            information.\n        \"\"\"\n\n        def checks_field(block_ctx: \"BlockTransactionContext\") -> bool:\n            # return False if Txn Type can be DeleteApplication.\n            # return True if Txn Type cannot be DeleteApplication.\n            return not TealerTransactionType.ApplDeleteApplication in block_ctx.transaction_types\n\n        # there should be a better to decide which function to call ??\n        if self.tealer.output_group:\n            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:\n            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance\n            return list(\n                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)\n            )\n\n        output: List[\n            Tuple[\"Teal\", List[List[\"BasicBlock\"]]]\n        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)\n        detector_output: \"ListOutput\" = []\n        for contract, vulnerable_paths in output:\n            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))\n\n        return detector_output"}
{"file_path": "https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/adaptors/algod_application.py", "code": "from base64 import b64decode\nfrom typing import List, Optional, cast\n\nfrom algosdk.v2client import models\nfrom pyk.kast.inner import KApply, KInner, KLabel, KSort, KToken\nfrom pyk.kast.manip import split_config_from\n\nfrom kavm.adaptors.teal_key_value import (\n    list_state_to_dict_bytes_bytes,\n    list_state_to_dict_bytes_ints,\n    teal_key_value_store_from_k_cell,\n)\nfrom kavm.pyk_utils import map_bytes_bytes, map_bytes_ints\n\n\nclass KAVMApplicationParams(models.ApplicationParams):\n    inverted_attribute_map = {v: k for k, v in models.ApplicationParams.attribute_map.items()}\n\n\nclass KAVMApplication(models.Application):\n    \"\"\"\n    Convenience class abstracting an Algorand smart contract (aka stateful application)\n    \"\"\"\n\n    inverted_attribute_map = {v: k for k, v in models.Application.attribute_map.items()}\n\n    @staticmethod\n    def from_k_cell(term: KInner, creator: str) -> 'KAVMApplication':\n        \"\"\"\n        Parse a KAVMApplication instance from a Kast term\n        \"\"\"\n        (_, subst) = split_config_from(term)\n        parsed_app_id = int(cast(KToken, subst['APPID_CELL']).token)\n        parsed_approval_program = b64decode(cast(KToken, subst['APPROVALPGM_CELL']).token)\n        parsed_clear_state_program = b64decode(cast(KToken, subst['CLEARSTATEPGM_CELL']).token)\n        parsed_global_state = teal_key_value_store_from_k_cell(\n            subst['GLOBALINTS_CELL']\n        ) + teal_key_value_store_from_k_cell(subst['GLOBALBYTES_CELL'])\n        parsed_params = KAVMApplicationParams(\n            # approval_pgm_src=subst['APPROVALPGMSRC_CELL'],\n            # clear_state_pgm_src=subst['CLEARSTATEPGMSRC_CELL'],\n            creator=creator,\n            approval_program=parsed_approval_program if parsed_approval_program else None,\n            clear_state_program=parsed_clear_state_program if parsed_clear_state_program else None,\n            local_state_schema=models.ApplicationStateSchema(\n                num_uint=int(cast(KToken, subst['LOCALNUMINTS_CELL']).token),\n                num_byte_slice=int(cast(KToken, subst['LOCALNUMBYTES_CELL']).token),\n            ),\n            global_state_schema=models.ApplicationStateSchema(\n                num_uint=int(cast(KToken, subst['GLOBALNUMINTS_CELL']).token),\n                num_byte_slice=int(cast(KToken, subst['GLOBALNUMBYTES_CELL']).token),\n            ),\n            global_state=parsed_global_state if len(parsed_global_state) else None,\n            # extra_pages=int(cast(KToken, subst['EXTRAPAGES_CELL']).token),\n        )\n        return KAVMApplication(id=parsed_app_id, params=parsed_params)\n\n\ndef application_k_term(\n    app_id: int,\n    global_state_schema: Optional[models.ApplicationStateSchema] = None,\n    local_state_schema: Optional[models.ApplicationStateSchema] = None,\n    global_state: Optional[List[models.TealKeyValue]] = None,\n) -> KInner:\n    global_num_ints = global_state_schema.num_uint if global_state_schema else 0\n    global_num_byte_slice = global_state_schema.num_byte_slice if global_state_schema else 0\n    local_num_ints = local_state_schema.num_uint if local_state_schema else 0\n    local_num_byte_slice = local_state_schema.num_byte_slice if local_state_schema else 0\n    global_bytes = list_state_to_dict_bytes_bytes(global_state) if global_state else {}\n    global_ints = list_state_to_dict_bytes_ints(global_state) if global_state else {}\n\n    return KApply(\n        label=KLabel(name='<app>', params=()),\n        args=(\n            KApply(label=KLabel(name='<appID>', params=()), args=(KToken(token=str(app_id), sort=KSort(name='Int')),)),\n            KApply(\n                label=KLabel(name='<approvalPgmSrc>', params=()),\n                args=(KApply(label=KLabel(name='.K', params=()), args=()),),\n            ),\n            KApply(\n                label=KLabel(name='<clearStatePgmSrc>', params=()),\n                args=(KApply(label=KLabel(name='.K', params=()), args=()),),\n            ),\n            KApply(\n                label=KLabel(name='<approvalPgm>', params=()), args=(KToken(token='\"\"', sort=KSort(name='String')),)\n            ),\n            KApply(\n                label=KLabel(name='<clearStatePgm>', params=()), args=(KToken(token='\"\"', sort=KSort(name='String')),)\n            ),\n            KApply(\n                label=KLabel(name='<globalState>', params=()),\n                args=(\n                    KApply(\n                        label=KLabel(name='<globalNumInts>', params=()),\n                        args=(KToken(token=str(global_num_ints), sort=KSort(name='Int')),),\n                    ),\n                    KApply(\n                        label=KLabel(name='<globalNumBytes>', params=()),\n                        args=(KToken(token=str(global_num_byte_slice), sort=KSort(name='Int')),),\n                    ),\n                    KApply(\n                        label=KLabel(name='<globalBytes>', params=()),\n                        args=[map_bytes_bytes(global_bytes)],\n                    ),\n                    KApply(\n                        label=KLabel(name='<globalInts>', params=()),\n                        args=[map_bytes_ints(global_ints)],\n                    ),\n                ),\n            ),\n            KApply(\n                label=KLabel(name='<localState>', params=()),\n                args=(\n                    KApply(\n                        label=KLabel(name='<localNumInts>', params=()),\n                        args=(KToken(token=str(local_num_ints), sort=KSort(name='Int')),),\n                    ),\n                    KApply(\n                        label=KLabel(name='<localNumBytes>', params=()),\n                        args=(KToken(token=str(local_num_byte_slice), sort=KSort(name='Int')),),\n                    ),\n                ),\n            ),\n            KApply(label=KLabel(name='<extraPages>', params=()), args=(KToken(token='0', sort=KSort(name='Int')),)),\n        ),\n    )"}
{"file_path": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/permissioned-voting/assets/permissioned-voting-approval.py", "code": "from pyteal import *\n\ndef approval_program():\n    \"\"\"\n    https://developer.algorand.org/solutions/example-permissioned-voting-stateful-smart-contract-application/?query=asset%2520contract\n    To implement a permissioned voting application on Algorand, a central authority is needed to\n    provide users the right to vote. In this example, this is handled by an Algorand Standard\n    Asset. The central authority creates a vote token and then gives voters who have registered\n    one voting token. The voter then registers within a round range with the voting smart\n    contract, by Opting into the contract. Voters then vote by grouping two transactions.\n    The first is a smart contract call to vote for either candidate A or candidate B, and\n    the second is transferring the vote token back to the central authority. Voting is only\n    allowed within the voting range.\n    \"\"\"\n    # Check to see that the application ID is not set, indicating this is a creation call.\n    # Store the creator address to global state.\n    # Store both register and voting round ranges to global state.\n    # Store Asset ID to global state\n    on_creation = Seq([\n        App.globalPut(Bytes(\"Creator\"), Txn.sender()),\n        Assert(Txn.application_args.length() == Int(5)),\n        App.globalPut(Bytes(\"RegBegin\"), Btoi(Txn.application_args[0])),\n        App.globalPut(Bytes(\"RegEnd\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"VoteBegin\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"VoteEnd\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"AssetID\"), Btoi(Txn.application_args[4])),\n        Return(Int(1))\n    ])\n\n    # Always verify that the RekeyTo property of any transaction is set to the ZeroAddress\n    # unless the contract is specifically involved ina rekeying operation.\n    no_rekey_addr = Txn.rekey_to() == Global.zero_address()\n\n    # Checks whether the sender is creator.\n    is_creator = Txn.sender() == App.globalGet(Bytes(\"Creator\"))\n\n    # Checks whether sender has voted before or not.\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n\n    on_closeout = Seq([\n        get_vote_of_sender,\n        If(And(Global.round() <= App.globalGet(Bytes(\"VoteEnd\")), get_vote_of_sender.hasValue()),\n            App.globalPut(get_vote_of_sender.value(), App.globalGet(get_vote_of_sender.value()) - Int(1))\n        ),\n        Return(Int(1))\n    ])\n\n    # Checks that the first argument to the smart contract is the word \u201cregister\u201d.\n    # Verifies that the round is currently between registration begin and end rounds.\n    on_register = Return(\n        And(\n        no_rekey_addr,\n        Txn.application_args[0] == Bytes(\"register\"),\n        Global.round() >= App.globalGet(Bytes(\"RegBegin\")),\n        Global.round() <= App.globalGet(Bytes(\"RegEnd\")))\n    )\n\n    # Verifies the first application argument contains the string \u201cvote\u201d.\n    # Verifies the vote call is between the beginning and end of the voting round ranges.\n    # Verifies that two transactions are in the group.\n    # Checks that the second transaction is an asset transfer, and the token transferred is the vote token.\n    # Checks that the second transaction receiver is the creator of the application.\n    # Checks if the account has already voted, and if so, just returns true with no change to global state.\n    # Verifies that the user is either voting for candidate A or B.\n    # Reads the candidate\u2019s current total from the global state and increments the value.\n    # Stores the candidate choice to the user\u2019s local state.\n    choice = Txn.application_args[1]\n    choice_tally = App.globalGet(choice)\n    on_vote = Seq([\n        Assert(And(\n            no_rekey_addr,\n            Global.round() >= App.globalGet(Bytes(\"VoteBegin\")),\n            Global.round() <= App.globalGet(Bytes(\"VoteEnd\"))\n        )),\n        Assert(And(\n            Global.group_size() == Int(2),\n            Gtxn[1].type_enum() == TxnType.AssetTransfer,\n            Gtxn[1].asset_receiver() == App.globalGet(Bytes(\"Creator\")),\n            Gtxn[1].xfer_asset() == App.globalGet(Bytes(\"AssetID\")),\n            Gtxn[1].asset_amount() == Int(1),\n            Or(choice == Bytes(\"candidatea\"), choice == Bytes(\"candidateb\"))\n        )),\n        get_vote_of_sender,\n        If(get_vote_of_sender.hasValue(),\n            Return(Int(0))\n        ),\n        App.globalPut(choice, choice_tally + Int(1)),\n        App.localPut(Int(0), Bytes(\"voted\"), choice),\n        Return(Int(1))\n    ])\n\n    # Verfies that the application_id is 0, jumps to on_creation.\n    # Verifies that DeleteApplication is used and verifies that sender is creator.\n    # Verifies that UpdateApplication is used and verifies that sender is creator.\n    # Verifies that closeOut is used and jumps to on_closeout.\n    # Verifies that the account has opted in and jumps to on_register.\n    # Verifies that first argument is \"vote\" and jumps to on_vote.\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, on_register],\n        [Txn.application_args[0] == Bytes(\"vote\"), on_vote]\n    )\n\n    return program\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(approval_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"file_path": "https://github.com/defimono/algorand_asset_price_oracle/blob/8a2d410737d0795ea2f5a7e497b03f39e84af00c/handler.py", "code": "import json\n\nfrom algosdk import account\nfrom algosdk.future import transaction\nfrom algosdk.future.transaction import wait_for_confirmation\nfrom dotenv import load_dotenv\n\nfrom modules.config.algod_client import initialize_algod_client\nfrom modules.config.load_config import load_config\nfrom modules.config.logger import logger\nimport requests\n\nload_dotenv()\n\n\ndef get_updated_price():\n    \"\"\"\n    Query public API for ALGO price information. Will query, parse, and return a float representation pegged to USD.\n    :return: float representation of price\n    \"\"\"\n    url = \"https://api.coinbase.com/v2/prices/ALGO-USD/buy\"\n\n    raw_response = requests.get(url)\n\n    price_data = raw_response.json()\n\n    real_price = price_data.get('data').get('amount')\n\n    parsed_price = float(real_price)\n\n    logger.info(\"Got real price from coinbase set to: ${}\".format(parsed_price))\n\n    return parsed_price\n\n\ndef call_noop(algod_client, app_id, private_key, app_args):\n    \"\"\"\n    Call the update function in the deployed application with the new application TEAL\n    :param algod_client: preconfigured algod client for desired chain (main, test, or beta)\n    :param app_args: app args to pass to teal function inside smart contract on chain\n    :param app_id: application id to update\n    :param private_key: private key to authenticate and approve ourselves following the teal logic\n    :return: raw transaction response of the update function\n    \"\"\"\n    sender = account.address_from_private_key(private_key)\n\n    logger.debug(\"Sender wallet: {}\".format(sender))\n\n    # get node suggested parameters\n    params = algod_client.suggested_params()\n\n    logger.debug(\"params: {}\".format(params))\n\n    # create unsigned transaction\n    txn = transaction.ApplicationNoOpTxn(sender, params, app_id, app_args)\n\n    logger.debug(\"txn: {}\".format(txn))\n\n    # sign transaction\n    signed_txn = txn.sign(private_key)\n\n    tx_id = signed_txn.transaction.get_txid()\n\n    # send transaction\n    algod_client.send_transactions([signed_txn])\n\n    # await confirmation\n    wait_for_confirmation(algod_client, tx_id, 10)\n\n\ndef lambda_handler(event, context):\n    try:\n        app_config = load_config()\n\n        algod_address = app_config.get(\"algod_address\")\n\n        algod_token = app_config.get(\"algod_token\")\n\n        algod_client = initialize_algod_client(algod_address, algod_token)\n\n        oracle_app_id = app_config.get(\"oracle_app_id\")\n\n        admin_private_key = app_config.get(\"admin_private_key\")\n\n        # get new price\n        real_price = get_updated_price()\n\n        # Real price is to fixed point to get round the issues with float in\n        # teal\n        price_fixed_point = int(real_price * 10 ** 2)\n\n        logger.info(\n            \"Setting 2 digit fixed point price to: {} \".format(price_fixed_point))\n\n        # call noop with new price and sign with service account\n        # 2 meas we want two digits in the fixed point precision of the price\n        app_args = [\"update_price\", price_fixed_point, 2]\n\n        # Call the update operation in the published stateful algorand smart\n        # contract\n        call_noop(algod_client, oracle_app_id, admin_private_key, app_args)\n\n        logger.info(\"Application update called successfully\")\n\n        # If called via API Gateway, return a formatted response body as\n        # needed.\n        response = {\n            \"statusCode\": 200,\n            \"body\": json.dumps(price_fixed_point)\n        }\n\n        return response\n\n    except Exception as error:\n        logger.error(\"{}\".format(error))\n\n        response = {\n            \"statusCode\": 500,\n            \"body\": json.dumps(error)\n        }\n\n        return response\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Local development helper.\n    \"\"\"\n    logger.info(lambda_handler(None, None))"}
{"file_path": "https://github.com/aldur/tc-asa/blob/3570860ecc32d92ace483e2f3472b0a301f4cdc2/tc_asa.py", "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nTransfer-controlled Algorand Standard Asset (TC-ASA).\n\nTies an ASA to an ASC (Algorand Smart Contract) and exposes methods to\nmint/burn/transfer.\n\nEnables custom / extended logic around transfers.\n\"\"\"\n\nimport dataclasses\n\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    AssetHolding,\n    Bytes,\n    Cond,\n    Expr,\n    Global,\n    InnerTxnBuilder,\n    Int,\n    Mode,\n    Not,\n    OnComplete,\n    Or,\n    Reject,\n    Seq,\n    Txn,\n    TxnField,\n    TxnType,\n    compileTeal,\n)\nfrom pyteal.ast.asset import AssetParam\n\nfrom state import AVMState\nfrom abi import ABI\n\nTEAL_VERSION = 6\n\n\n@dataclasses.dataclass\nclass Config(AVMState):\n    master: AVMState.Address  # Master address (can be multi-sig)\n\n    # The asset may be globally \"frozen\", no transfers will be approved until it is \"unfrozen\".\n    is_frozen: AVMState.UInt = AVMState.UInt(0)\n\n    # Corresponding ASA token\n    asa: AVMState.UInt = AVMState.UInt(0)  # Wil be set by `init`\n\n\n@dataclasses.dataclass\nclass LocalConfig(AVMState):\n    is_locked: AVMState.UInt = AVMState.UInt(0)\n    is_whitelisted: AVMState.UInt = AVMState.UInt(0)\n\n\nKeys = Config.to_keys(\"Keys\")\nLocalKeys = LocalConfig.to_keys(\"LocalKeys\")\n\n\nTC_ASA_RESERVE = Global.current_application_address()\n\n\nUNLOCKED = Int(ABI.FALSE)\nLOCKED = Int(ABI.TRUE)\nLOCK_INTERFACE = {\n    \"name\": \"setLock\",\n    \"args\": [\n        {\"name\": \"user\", \"type\": \"account\", \"desc\": \"User to lock/unlock.\"},\n        {\n            \"name\": \"isLocked\",\n            \"type\": \"bool\",\n            \"desc\": \"Lock (`true`) / unlock (`false`).\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(LOCK_INTERFACE)\ndef set_lock_unlock(args: ABI.TealArgs) -> Expr:\n    \"\"\"\n    Specific users may be \"locked\" by `master` so that they cannot transfer\n    their tokens without being \"unlocked first\".\n    \"\"\"\n    is_locked_arg = args.isLocked\n    precondition = And(\n        is_master(Txn.sender()),\n        Or(  # Pedantic\n            is_locked_arg == UNLOCKED,\n            is_locked_arg == LOCKED,\n        ),\n        Not(App.localGet(args.user, LocalKeys.is_locked) == is_locked_arg),\n    )\n\n    return Seq(\n        Assert(precondition),\n        # Lock user (account #1)\n        App.localPut(args.user, LocalKeys.is_locked, is_locked_arg),\n        Approve(),\n    )\n\n\ndef _is_locked(account: Expr) -> Expr:\n    return App.localGet(account, LocalKeys.is_locked) == LOCKED\n\n\nNOT_WHITELISTED = Int(ABI.FALSE)\nWHITELISTED = Int(ABI.TRUE)\nWHITELIST_INTERFACE = {\n    \"name\": \"setWhitelist\",\n    \"args\": [\n        {\"name\": \"user\", \"type\": \"account\", \"desc\": \"User to whitelist.\"},\n        {\n            \"name\": \"isWhitelisted\",\n            \"type\": \"bool\",\n            \"desc\": \"Whitelist (`true`) / remove whitelist (`false`).\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(WHITELIST_INTERFACE)\ndef set_whitelist(args: ABI.TealArgs) -> Expr:\n    \"\"\"\n    Whitelist a user.\n    \"\"\"\n    whitelist_arg = args.isWhitelisted\n    precondition = And(\n        is_master(Txn.sender()),\n        Or(  # Pedantic\n            whitelist_arg == NOT_WHITELISTED,\n            whitelist_arg == WHITELISTED,\n        ),\n        Not(App.localGet(args.user, LocalKeys.is_whitelisted) == whitelist_arg),\n    )\n\n    return Seq(\n        Assert(precondition),\n        # Whitelist user (account #1)\n        App.localPut(args.user, LocalKeys.is_whitelisted, whitelist_arg),\n        Approve(),\n    )\n\n\ndef _is_whitelisted(account: Expr) -> Expr:\n    return App.localGet(account, LocalKeys.is_whitelisted) == WHITELISTED\n\n\nNOT_FROZEN = Int(ABI.FALSE)\nFROZEN = Int(ABI.TRUE)\nFREEZE_INTERFACE = {\n    \"name\": \"setFreeze\",\n    \"args\": [\n        {\n            \"name\": \"isFrozen\",\n            \"type\": \"bool\",\n            \"desc\": \"Frozen (`true`) / not frozen (`false`).\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(FREEZE_INTERFACE)\ndef set_freeze_unfreeze_token(args: ABI.TealArgs) -> Expr:\n    \"\"\"\n    The asset may be \"frozen\" by `master`, at which point no transfers will be\n    approved until it is \"unfrozen\".\n    \"\"\"\n    freeze_arg = args.isFrozen\n\n    precondition = And(\n        is_master(Txn.sender()),\n        Or(  # Pedantic\n            freeze_arg == NOT_FROZEN,\n            freeze_arg == FROZEN,\n        ),\n        Not(App.globalGet(Keys.is_frozen) == freeze_arg),\n    )\n\n    return Seq(\n        Assert(precondition),\n        App.globalPut(Keys.is_frozen, freeze_arg),\n        Approve(),\n    )\n\n\ndef _is_frozen():\n    return App.globalGet(Keys.is_frozen) == FROZEN\n\n\ndef is_master(account: Expr) -> Expr:\n    \"\"\"\n    Check whether the provided `account` is the `master`.\n    \"\"\"\n    return account == App.globalGet(Keys.master)\n\n\nMINT_INTERFACE = {\n    \"name\": \"mint\",\n    \"args\": [\n        {\n            \"name\": \"user\",\n            \"type\": \"account\",\n            \"desc\": \"The user that will receive the funds.\",\n        },\n        {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount of funds to mint to the user.\",\n        },\n        {\n            \"name\": \"asset\",\n            \"type\": \"asset\",\n            \"desc\": \"Reference to the ASA controlled by this smart contract.\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(MINT_INTERFACE)\ndef mint(args: ABI.TealArgs) -> Expr:\n    \"\"\"\n    `master` can mint new tokens into circulation.\n\n    The `user` receiving the funds must be `whitelisted` and the asset must NOT\n    be `frozen`.\n    \"\"\"\n    asset = args.asset\n    is_tc_asa = asset_is_tc_asa(asset)\n\n    user = args.user\n    amount = args.amount\n    positive_amount = amount > Int(0)\n\n    token_is_not_frozen = Not(_is_frozen())\n    user_is_whitelisted = _is_whitelisted(args.user)\n\n    precondition = And(\n        is_master(Txn.sender()),\n        is_tc_asa,\n        positive_amount,\n        token_is_not_frozen,\n        user_is_whitelisted,\n    )\n\n    tc_asa_mint = [\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, App.globalGet(Keys.asa)),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, user),\n        InnerTxnBuilder.SetField(TxnField.asset_sender, TC_ASA_RESERVE),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.Submit(),\n    ]\n\n    return Seq(\n        Assert(precondition),\n        *tc_asa_mint,\n        Approve(),\n    )\n\n\nBURN_INTERFACE = {\n    \"name\": \"burn\",\n    \"args\": [\n        {\n            \"name\": \"user\",\n            \"type\": \"account\",\n            \"desc\": \"Funds will be burned from this user's balance.\",\n        },\n        {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount of funds to burn.\",\n        },\n        {\n            \"name\": \"asset\",\n            \"type\": \"asset\",\n            \"desc\": \"Reference to the ASA controlled by this smart contract.\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(BURN_INTERFACE)\ndef burn(args: ABI.TealArgs) -> Expr:\n    \"\"\"\n    `master` can transfer from a user back to the treasury.\n    \"\"\"\n    asset = args.asset\n    user = args.user\n    amount = args.amount\n    is_tc_asa = asset_is_tc_asa(asset)\n\n    positive_amount = amount > Int(0)\n\n    precondition = And(\n        is_master(Txn.sender()),\n        is_tc_asa,\n        positive_amount,\n    )\n\n    tc_asa_burn = [\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, App.globalGet(Keys.asa)),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),\n        InnerTxnBuilder.SetField(TxnField.asset_sender, user),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, TC_ASA_RESERVE),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.Submit(),\n    ]\n\n    return Seq(\n        Assert(precondition),\n        *tc_asa_burn,\n        Approve(),\n    )\n\n\nTRANSFER_INTERFACE = {\n    \"name\": \"transfer\",  # TC-ASA standard.\n    \"args\": [\n        {\n            \"name\": \"receiver\",\n            \"type\": \"account\",\n            \"desc\": \"The user that will receive the funds.\",\n        },\n        {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount of funds to transfer to the user.\",\n        },\n        {\n            \"name\": \"asset\",\n            \"type\": \"asset\",\n            \"desc\": \"Reference to the ASA controlled by this smart contract.\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(TRANSFER_INTERFACE)\ndef transfer(args: ABI.TealArgs) -> Expr:\n    \"\"\"Controlled transfer of the underlying ASA from `Transaction.Sender` to `user`.\"\"\"\n    asset = args.asset\n    is_tc_asa = asset_is_tc_asa(asset)\n\n    receiver = args.receiver\n    amount = args.amount\n    positive_amount = amount > Int(0)\n\n    no_self_payment = Txn.sender() != receiver\n\n    token_is_not_frozen = Not(_is_frozen())\n\n    sender_is_not_locked = Not(_is_locked(Txn.sender()))\n\n    sender_has_enough_balance = Seq(  # pedantic, the ASA clawback will underflow if not\n        sender_asset_balance := AssetHolding.balance(Txn.sender(), asset),\n        sender_asset_balance.value() - amount >= Int(0),\n    )\n\n    sender_is_whitelisted = _is_whitelisted(Txn.sender())\n    receiver_is_whitelisted = _is_whitelisted(receiver)\n\n    precondition = And(\n        is_tc_asa,\n        positive_amount,\n        no_self_payment,\n        token_is_not_frozen,\n        sender_is_not_locked,\n        sender_has_enough_balance,\n        sender_is_whitelisted,\n        receiver_is_whitelisted,\n    )\n\n    tc_asa_transfer = [\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, App.globalGet(Keys.asa)),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, receiver),\n        InnerTxnBuilder.SetField(TxnField.asset_sender, Txn.sender()),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.Submit(),\n    ]\n\n    return Seq(\n        Assert(precondition),\n        *tc_asa_transfer,\n        Approve(),\n    )\n\n\ndef asset_is_tc_asa(e: Expr) -> Expr:\n    \"\"\"Check that provided asset is the TC-ASA handled by this contract.\"\"\"\n    return e == App.globalGet(Keys.asa)\n\n\nINIT_INTERFACE = {\n    \"name\": \"init\",\n    \"desc\": \"Transfer the ASA reserve into the ASC.\",\n    \"args\": [\n        {\n            \"name\": \"asset\",\n            \"type\": \"asset\",\n            \"desc\": \"Reference to the ASA controlled by this smart contract.\",\n        },\n    ],\n    \"returns\": {\"type\": \"void\"},\n}\n\n\n@ABI.method(INIT_INTERFACE)\ndef init(args: ABI.TealArgs):\n    current_app_address = Global.current_application_address()\n    precondition = And(\n        is_master(Txn.sender()),\n        App.globalGet(Keys.asa) == Int(0),  # This prevents double initialization.\n        Seq(\n            asset_clawback := AssetParam.clawback(args.asset),\n            Assert(asset_clawback.hasValue()),\n            asset_clawback.value() == TC_ASA_RESERVE,\n        ),\n        Seq(\n            asset_freeze := AssetParam.freeze(args.asset),\n            Assert(asset_freeze.hasValue()),\n            asset_freeze.value() == TC_ASA_RESERVE,\n        ),\n        Seq(\n            asset_manager := AssetParam.manager(args.asset),\n            Assert(asset_manager.hasValue()),\n            asset_manager.value() == TC_ASA_RESERVE,\n        ),\n        Seq(\n            asset_reserve := AssetParam.reserve(args.asset),\n            Assert(asset_reserve.hasValue()),\n            asset_reserve.value() == TC_ASA_RESERVE,\n        ),\n        Seq(\n            asset_default_frozen := AssetParam.defaultFrozen(args.asset),\n            Assert(asset_default_frozen.hasValue()),\n            asset_default_frozen.value() == Int(1),\n        ),\n    )\n    return Seq(\n        Assert(precondition),\n        asa_total_supply := AssetParam.total(args.asset),\n        Assert(asa_total_supply.hasValue()),\n        # Global storage for TC-ASA and role ASA\n        App.globalPut(Keys.asa, args.asset),\n        # Opt-in\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, args.asset),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.sender, current_app_address),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, current_app_address),\n        InnerTxnBuilder.Submit(),\n        # Clawback reserve\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, args.asset),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, asa_total_supply.value()),\n        InnerTxnBuilder.SetField(TxnField.asset_sender, Txn.sender()),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, current_app_address),\n        InnerTxnBuilder.Submit(),\n        Approve(),\n    )\n\n\ndef on_create(cfg: Config) -> Expr:\n    \"\"\"Writes provided configuration to global state.\"\"\"\n    return Seq(\n        *(  # NOTE: Here we are calling an API of `Config` that seems out of place here.\n            # Refactor this to provide the mapping AVM key/value under a better API.\n            App.globalPut(Bytes(Config.field_to_key(f)), cfg.encode_to_avm(f))\n            for f in dataclasses.fields(cfg)\n        ),\n        Approve(),\n    )\n\n\ndef on_call(_: Config) -> Expr:\n    precondition = And(\n        Txn.application_args.length() >= Int(ABI.ON_CALL_NUM_APP_ARGS),\n    )\n\n    selector = Txn.application_args[ABI.ON_CALL_NUM_APP_ARGS - 1]\n    return Seq(\n        Assert(precondition),\n        # Poor man dispatcher based on ABI selectors.\n        Cond(*([selector == Bytes(k), f()] for k, f in ABI.DISPATCH_TABLE.items())),\n    )\n\n\ndef on_optin(_: Config) -> Expr:\n    return Seq(Approve())\n\n\ndef on_update(_: Config) -> Expr:\n    precondition = is_master(Txn.sender())\n    return Seq(Assert(precondition), Approve())\n\n\ndef on_delete(_: Config) -> Expr:\n    return Seq(Reject())\n\n\ndef on_closeout_or_clear(_: Config) -> Expr:\n    return Seq(Reject())\n\n\ndef asc_approval(cfg: Config) -> Expr:\n    return Cond(\n        [Txn.application_id() == Int(0), on_create(cfg)],\n        [Txn.on_completion() == OnComplete.NoOp, on_call(cfg)],\n        [Txn.on_completion() == OnComplete.OptIn, on_optin(cfg)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout_or_clear(cfg)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, on_update(cfg)],\n        [Txn.on_completion() == OnComplete.DeleteApplication, on_delete(cfg)],\n        # ClearStateProgram will execute on ClearState, no need to worry about it here.\n    )\n\n\ndef compile_stateful(program) -> str:\n    return compileTeal(\n        program, Mode.Application, assembleConstants=True, version=TEAL_VERSION\n    )\n\n\nif __name__ == \"__main__\":\n    # Allow quickly testing compilation.\n    path = \"/tmp/tc_asa.teal\"\n    with open(path, \"w\") as f:\n        print(f\"Writing compiled TC-ASA to '{path}'.\")\n        f.write(\n            compile_stateful(\n                asc_approval(\n                    Config(\n                        master=AVMState.Address(\n                            \"Y76M3MSY6DKBRHBL7C3NNDXGS5IIMQVQVUAB6MP4XEMMGVF2QWNPL226CA\"\n                        )\n                    )\n                )\n            )\n        )"}
{"file_path": "https://github.com/natyrix/algorand/blob/2bd1d8ee68e74cbc6a0e6d35ff83fef89b2dac08/scripts/smart_contract.py", "code": "import base64\nimport os\nfrom algosdk.future import transaction\nfrom algosdk import mnemonic\nfrom algosdk.v2client import algod\nfrom pyteal import *\nfrom dotenv import load_dotenv\n\nAPI_KEY = \"3L6Urqa3Bs1PE1ghfZcgx9FHti0mtDSp2ECv3jql\"\n# user declared account mnemonics\nbenefactor_mnemonic = \"angry spend ice estate spoil title deer divide once crazy head magnet supreme icon secret unfair domain section clean scrub want stairs excite abandon dad\"\nsender_mnemonic = \"across wrap wisdom museum piece patch custom wait price discover cloud group garbage dry prize purity fetch burger blood purchase wrist ramp between above lesson\"\n\nprint(\"API_KEY\")\nprint(API_KEY)\n\nprint(\"MNEMONIC\")\nprint(sender_mnemonic)\n\n# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config\nalgod_address = \"https://testnet-algorand.api.purestake.io/ps2\"\nalgod_token = API_KEY\n\n# helper function to compile program source\ndef compile_smart_signature(client, source_code):\n    compile_response = client.compile(source_code)\n    return compile_response['result'], compile_response['hash']\n\n# helper function that converts a mnemonic passphrase into a private signing key\ndef get_private_key_from_mnemonic(mn) :\n    private_key = mnemonic.to_private_key(mn)\n    return private_key\n\n\n\ndef payment_transaction(creator_mnemonic, amt, rcv, algod_client)->dict:\n    params = algod_client.suggested_params()\n    add = mnemonic.to_public_key(creator_mnemonic)\n    key = mnemonic.to_private_key(creator_mnemonic)\n    unsigned_txn = transaction.PaymentTxn(add, params, rcv, amt)\n    signed = unsigned_txn.sign(key)\n    txid = algod_client.send_transaction(signed)\n    pmtx = transaction.wait_for_confirmation(algod_client, txid , 5)\n    return pmtx\n\ndef lsig_payment_txn(escrowProg, escrow_address, amt, rcv, algod_client):\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(escrow_address, params, rcv, amt)\n    encodedProg = escrowProg.encode()\n    program = base64.decodebytes(encodedProg)\n    lsig = transaction.LogicSigAccount(program)\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\"\"\"Basic Donation Escrow\"\"\"\n\ndef donation_escrow(benefactor):\n    Fee = Int(1000)\n\n    #Only the benefactor account can withdraw from this escrow\n    program = And(\n        Txn.type_enum() == TxnType.Payment,\n        Txn.fee() <= Fee,\n        Txn.receiver() == Addr(benefactor),\n        Global.group_size() == Int(1),\n        Txn.rekey_to() == Global.zero_address()\n    )\n\n    # Mode.Signature specifies that this is a smart signature\n    return compileTeal(program, Mode.Signature, version=5)\n\ndef main() :\n    # initialize an algodClient\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n\n    # define private keys\n    receiver_public_key = mnemonic.to_public_key(benefactor_mnemonic)\n\n    print(\"--------------------------------------------\")\n    print(\"Compiling Donation Smart Signature......\")\n\n    stateless_program_teal = donation_escrow(receiver_public_key)\n    escrow_result, escrow_address= compile_smart_signature(algod_client, stateless_program_teal)\n\n    print(\"Program:\", escrow_result)\n    print(\"hash: \", escrow_address)\n\n    print(\"--------------------------------------------\")\n    print(\"Activating Donation Smart Signature......\")\n\n    # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator\n    amt = 2001000\n    payment_transaction(sender_mnemonic, amt, escrow_address, algod_client)\n\n    print(\"--------------------------------------------\")\n    print(\"Withdraw from Donation Smart Signature......\")\n\n    # Withdraws 1 ALGO from smart signature using logic signature.\n    withdrawal_amt = 1000000\n    lsig_payment_txn(escrow_result, escrow_address, withdrawal_amt, receiver_public_key, algod_client)\n\nmain()"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/plugin_example/rekey_plugin/tealer_rekey_plugin/detectors/rekeyto_stateless.py", "code": "\"\"\"Detector for finding execution paths missing RekeyTo check.\"\"\"\n\nfrom typing import List, TYPE_CHECKING, Tuple\n\nfrom tealer.detectors.abstract_detector import (\n    AbstractDetector,\n    DetectorClassification,\n    DetectorType,\n)\nfrom tealer.detectors.utils import detect_missing_tx_field_validations_group\nfrom tealer.utils.output import ExecutionPaths\n\n\nif TYPE_CHECKING:\n    from tealer.teal.basic_blocks import BasicBlock\n    from tealer.utils.output import ListOutput\n    from tealer.teal.context.block_transaction_context import BlockTransactionContext\n    from tealer.teal.teal import Teal\n\n\nclass CanRekey(AbstractDetector):  # pylint: disable=too-few-public-methods\n    \"\"\"Detector to find execution paths missing RekeyTo check.\n\n    TEAL, from version 2 onwards supports rekeying of accounts.\n    An account can be rekeyed to a different address. Once rekeyed,\n    rekeyed address has entire authority over the account. Contract\n    Accounts can also be rekeyed. If RekeyTo field of the transaction\n    is set to malicious actor's address, then they can control the account\n    funds, assets directly bypassing the contract's restrictions.\n\n    This detector tries to find execution paths that approve the algorand\n    transaction(\"return 1\") and doesn't check the RekeyTo transaction field.\n    Additional to checking rekeying of it's own contract, detector also finds\n    execution paths that doesn't check RekeyTo field of other transactions\n    in the atomic group.\n    \"\"\"\n\n    NAME = \"rekey-to\"\n    DESCRIPTION = \"Rekeyable Logic Signatures\"\n    TYPE = DetectorType.STATELESS\n\n    IMPACT = DetectorClassification.HIGH\n    CONFIDENCE = DetectorClassification.HIGH\n\n    WIKI_URL = \"https://github.com/crytic/tealer/wiki/Detector-Documentation#rekeyable-logicsig\"\n    WIKI_TITLE = \"Rekeyable LogicSig\"\n    WIKI_DESCRIPTION = (\n        \"Logic signature does not validate `RekeyTo` field.\"\n        \" Attacker can submit a transaction with `RekeyTo` field set to their address and take control over the account.\"\n        \" More at [building-secure-contracts/not-so-smart-contracts/algorand/rekeying]\"\n        \"(https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/algorand/rekeying)\"\n    )\n    WIKI_EXPLOIT_SCENARIO = \"\"\"\n```py\ndef withdraw(...) -> Expr:\n    return Seq(\n        [\n            Assert(\n                And(\n                    Txn.type_enum() == TxnType.Payment,\n                    Txn.first_valid() % period == Int(0),\n                    Txn.last_valid() == Txn.first_valid() + duration,\n                    Txn.receiver() == receiver,\n                    Txn.amount() == amount,\n                    Txn.first_valid() < timeout,\n                )\n            ),\n            Approve(),\n        ]\n    )\n```\n\nAlice signs the logic-sig to allow recurring payments to Bob.\\\n Eve uses the logic-sig and submits a valid transaction with `RekeyTo` field set to her address.\\\n Eve takes over Alice's account.\n\"\"\"\n\n    WIKI_RECOMMENDATION = \"\"\"\nValidate `RekeyTo` field in the LogicSig.\n\"\"\"\n\n    def detect(self) -> \"ListOutput\":\n        \"\"\"Detect execution paths with missing CloseRemainderTo check.\n\n        Returns:\n            ExecutionPaths instance containing the list of vulnerable execution\n            paths along with name, check, impact, confidence and other detector\n            information.\n        \"\"\"\n\n        def checks_field(block_ctx: \"BlockTransactionContext\") -> bool:\n            # return False if RekeyTo field can have any address.\n            # return True if RekeyTo should have some address or zero address\n            return not block_ctx.rekeyto.any_addr\n\n        output: List[\n            Tuple[\"Teal\", List[List[\"BasicBlock\"]]]\n        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)\n        detector_output: \"ListOutput\" = []\n        for contract, vulnerable_paths in output:\n            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))\n\n        return detector_output"}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Choice_Coin_Voting/vote.py", "code": "# Open Source under Apache License\n\n# This code defines a decenteralized voting system on the Algorand Blockchain.\n# It uses Choice Coin, an Algorand Standard Asset, to record votes on a distributed ledger.\n# The system makes both efficiency and security a priority.\n# An escrow account holds the total number of Choice Coin required for the voting process, and Algorand accounts for each of the decisions made.\n# Each of the individual decisions made by the voters connect back to the escrow account.\n# In turn, one Choice Coin transfers to the appropriate decision account through a stateless smart contract.\n# Furthermore, a SHA-512 hashing algorithm is used to encrypt voter information at all stages, ensuring that private information is made secure.\n# This is especially useful where voters need to give personal identification for verification purposes.\n\n# Imports and dependicies include the Algorand Python SDK, the Python Hashlib library, and the Python Matplotlib library.\nfrom algosdk import account, encoding, mnemonic, transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\nimport hashlib\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport random\nimport base64\nimport io\n\nplt.style.use('fivethirtyeight')\n\n\n# Matplot parameters for the matplotlib function to generate a new plot.\nmatplotlib.use('TkAgg')\nalgod_address = \"\"  # Put Algod Token here\nalgod_token = \"\"  # Put Algod Client address here\nheaders = {\"X-API-Key\": algod_token}\n# Initializes client for node.\nalgod_client = algod.AlgodClient(algod_token, algod_address, headers)\n\n# Escrow creation.\nescrow_address = \"\"  # Put in main fund address here\n# Put in main fund receiver_mnemonic here\nescrow_mnemonic = \"\"\nescrow_key = mnemonic.to_private_key(escrow_mnemonic)\nchoice_id = 21364625  # Official Test Asset ID for Choice Coin\n\n# Decisions.\n# To add more decisions for the election process, add the address for the new decision here.\n# Then, add an appropriate boolean statement at line 100 of this file. Be sure to also add additional\n# counts at line 148 of this file as well.\ndecision_one = \"\"\ndecision_two = \"\"\ncorporate_decision_one = \"\"\ncorporate_decision_two = \"\"\n\n# Clawback Address required to reset accounts to start new voting process.\n# Sets up accounts for both the regular election process and the corporate decision process.\n# Add more accounts to adjust for more decisions.\nclawback_address = \"\"\nclawback_mnemonic = \"\"\nclawback_key = mnemonic.to_private_key(clawback_mnemonic)\n\n# This function counts the number of Choice Coin in an account.\n# It first fetches the account_info, and specifically searches among the assets that the account owns for Choice Coin.\n# It then returns the number of Choice Coin that the account owns.\n\n\ndef count(address):\n    message = ''\n    error = ''\n    account_info = algod_client.account_info(address)  # Fetch account information for the address.\n    assets = account_info.get(\"assets\")  # Fetch asset information.\n    for asset in assets:\n        # Iterate over assets until Choice Coin is reached. Return the amount if it exists.\n        if asset[\"asset-id\"] == choice_id:\n            amount = asset.get(\"amount\")\n            message = amount\n            return message\n    error = 'The account has not opted-in to the asset yet.'\n    return error\n\n# This function hashes a string using the SHA-512 cryptographic scheme.\n# SHA-512 is a post-quantum cryptographic scheme, thus ensuring that private information is made secure from malicious attackers.\n\n\ndef hashing(item):\n    # Assumes the default UTF-8.\n    hash_object = hashlib.sha512(item.encode())  # This encodes the string with the SHA-512 scheme.\n    item = hash_object.hexdigest()  # This returns the hexadecimal encode as a string.\n    return item\n\n# This function defines a stateless smart contract on the Algorand Network.\n# It sends Choice Coin to the appropriate destination address based on user input.\n\n\ndef choice_vote(sender, key, receiver, amount, comment):\n    parameters = algod_client.suggested_params()  # Sets suggested parameters\n    # transaction = AssetTransferTxn(sender, parameters, receiver, amount, choice_id, note=comment)\n    transaction = AssetTransferTxn(sender, parameters, receiver, 0, choice_id, note=comment)\n    # Defines an inital transaction for Choice Coin\n    signature = transaction.sign(key)\n    # Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    # Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n# This function describes a methodology for Electoral Voting on the Choice Coin platform.\n# It calls the choice_vote() function with the appropriate inputs based on which decision the voter selected.\n# It is currently defined for two candidates/decisions, but it can be easily amended to include more.\n\n\ndef election_voting(vote):\n    message = ''\n    if vote == 'YES':  # Add more boolean statements for more decisions or candidates.\n        # choice_vote() function called for \"YES\".\n        TX_ID = choice_vote(escrow_address, escrow_key, decision_one,\n                            100, \"Tabulated using Choice Coin\")\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n            TX_ID[1] + \".\"\n        # AlgoExplorer returned for validation.\n    elif vote == 'NO':\n        TX_ID = choice_vote(escrow_address, escrow_key, decision_two,\n                            100, \"Tabulated using Choice Coin\")\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n            TX_ID[1] + \".\"\n    return message\n\n# This defines a corporate voting mechanism using Choice Coin.\n# It works very similarly to the electoral voting scheme defined earlier.\n# However, it does introduce the stake as a new variable.\n# The stake defines the ownership stake of the shareholder that is voting.\n\n\ndef corporate_voting(vote, stake):\n    message = ''\n    stake = int(stake)  # Define the ownership stake.\n    amount = 100 * stake\n    comment = \"Tabulated using Choice Coin\"\n    if vote == 'YES':\n        choice_vote(escrow_address, escrow_key, corporate_decision_one, amount, comment)\n        # Call the choice_vote() function that sends the appropriate number of Choice Coin based on the ownership stake.\n        message = \"Ballot Tabulated\"\n    elif vote == 'NO':\n        choice_vote(escrow_address, escrow_key, corporate_decision_two, amount, comment)\n        message = \"Ballot Tabulated\"\n    return message\n\n# Returns a dynamic bar-graph showing the results of the vote.\n# Uses PyPlot for both corporate and electoral voting.\n\n\ndef show_results(yes_count, no_count):\n    names = ['Candidate 1', 'Candidate 2']  # Define the two decisions.\n    values = [yes_count, no_count]  # Fetch the total number of votes for each decision.\n    # Define a new pyplot\n    s = io.BytesIO()\n    plt.figure(figsize=(9, 3))\n    plt.subplots()\n    plt.xlabel('Candidates')\n    plt.ylabel('Vote Count')\n    plt.bar(names, values)\n    for i, v in enumerate(values):\n        plt.text(i, v, int(v), color='black', fontweight='bold')\n    \n    plt.suptitle('Election Results')\n    plt.savefig('./static/img/plot.png', dpi=400, format='png', bbox_inches=\"tight\")\n    plt.close()\n    s = base64.b64encode(s.getvalue()).decode('utf-8').replace(\"\\n\", \"\")\n    # Return the results.\n\n\ndef show_corporate_results(yes_count, no_count):\n    names = ['Decision 1', 'Decision 2']\n    values = [yes_count, no_count]\n    plt.figure(figsize=(9, 3))\n    plt.subplots()\n    plt.xlabel('Candidates')\n    plt.ylabel('Vote Count')\n    plt.bar(names, values)\n    for i, v in enumerate(values):\n        plt.text(i, v, int(v), color='black', fontweight='bold')\n    \n    plt.suptitle('Corporate Voting Results')\n    plt.savefig('/home/archie/Inital_Demo/static/img/Figure_2.png')\n\n# Counts the total number of votes to return a statement regarding which candidate has won.\n# Applies to both corporate and electoral voting.\n\n\ndef count_votes():\n    yes_count = count(decision_one)\n    no_count = count(decision_two)\n    show_results(yes_count, no_count)\n    if yes_count > no_count:\n        if yes_count == 1:\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} vote.\".format(yes_count)\n        else:\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} votes.\".format(yes_count)\n    if no_count > yes_count:\n        if no_count == 1:\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} vote.\".format(no_count)\n        else:\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} votes.\".format(no_count)\n\n    else:\n        # Random sample generated from adiabatic quantum computer.\n        # Generated using QunatumQuery.py.\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0,\n                          1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n        # Random sample from quantum sample.\n        Q = random.choice(quantum_sample)\n        if Q:\n            return(\"Tie. The Quantum Oracle selects Candidate One!\")\n        else:\n            return(\"Tie. The Quantum Oracle selects Candidate Two!\")\n\n\ndef count_corporate_votes():\n    yes_count = count(corporate_decision_one)\n    no_count = count(corporate_decision_two)\n    show_corporate_results(yes_count, no_count)\n    if yes_count > no_count:\n        return \"The Voting Process has ended. Decision One had the most votes!\"\n    if no_count > yes_count:\n        return \"Decision Two had the most votes!\"\n    else:\n        # Random sample generated from adiabatic quantum computer.\n        # Generated using QunatumQuery.py.\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0,\n                          1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n        # Random sample from quantum sample.\n        Q = random.choice(quantum_sample)\n        if Q:\n            return(\"Tie. The Quantum Oracle selects Decision One!\")\n        else:\n            return(\"Tie. The Quantum Oracle selects Decision Two!\")\n\n# This function resets the voting accounts to start a new voting process.\n# It uses the clawback functionality built into Choice Coin to send the Choice Coin back to the main escrow account.\n\n\ndef reset_votes():\n    message = ''\n    params = algod_client.suggested_params()\n    yes_count = count(decision_one)\n    no_count = count(decision_two)\n    # Fetches the total number of Choice Coin in each account.\n    if yes_count > 0:\n        transaction_2 = AssetTransferTxn(\n            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=decision_one)\n        signature_2 = transaction_2.sign(clawback_key)\n        algod_client.send_transaction(signature_2)\n        # Defines a clawback transaction to send Choice Coin back to the escrow account if the number of Choice Coin in the account exceeds zero.\n    if no_count > 0:\n        transaction_3 = AssetTransferTxn(\n            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=decision_two)\n        signature_3 = transaction_3.sign(clawback_key)\n        algod_client.send_transaction(signature_3)\n    message = 'Vote accounts reset. New Voting Process started.'\n    return message\n\n\ndef reset_corporate_votes():\n    message = ''\n    params = algod_client.suggested_params()\n    yes_count = count(corporate_decision_one)\n    no_count = count(corporate_decision_two)\n    if yes_count > 0:\n        transaction_2 = AssetTransferTxn(\n            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=corporate_decision_one)\n        signature_2 = transaction_2.sign(clawback_key)\n        algod_client.send_transaction(signature_2)\n    if no_count > 0:\n        transaction_3 = AssetTransferTxn(\n            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=corporate_decision_two)\n        signature_3 = transaction_3.sign(clawback_key)\n        algod_client.send_transaction(signature_3)\n    message = 'Vote accounts reset. New Voting Process started.'\n    return message"}
{"file_path": "https://github.com/Ecosteer-SRL/dvco-algorand/blob/00c9b22b07980fe9f6ced4363862aa7d05c6c416/worker/worker_algorand.py", "code": "#   ver:    0.5\n#   date:   24/10/2022\n#   author: georgiana-bud\nimport os\nimport base64\nfrom typing import Tuple, Type, Optional, Union\n\n\n \n#\tWARNING:\n#\tNOTE:\tthe kmd.net and kmd.token files are in a folder\n#\t\t    named based on the release of kmd - HOWEVER - to date\n#\t\t    no easy way has been found to determine the version of kmd\n#\t\t    programmatically - find a way or pass the version\n#\t\t    as a configuration parameter\n\n\n\nimport  algosdk                                      #   better type support (not necessary)                \nfrom    algosdk                     import mnemonic                                  \nfrom    algosdk                     import account\nfrom    algosdk.v2client            import algod\nfrom    algosdk.wallet              import Wallet\nfrom    algosdk                     import kmd\nfrom    algosdk.future              import transaction\nfrom    algosdk.future.transaction  import PaymentTxn\nfrom    algosdk.future.transaction  import ApplicationNoOpTxn\nfrom    algosdk.future.transaction  import ApplicationCreateTxn\nfrom    algosdk.future.transaction  import ApplicationOptInTxn\nfrom    algosdk.future.transaction  import ApplicationCloseOutTxn\n\nfrom error import DopError \n\n#   class workerAlgorand\n#   the following methods have to be implemented\n#\n#   (x) begin_transaction\n#   (x) rollback\n#   (x) commit\n#   (x) create_user\n#   (x) deploy_contract\n#   (x) get_wallet_balance\n#   (x) subscribe\n#   (x) unsubscribe\n#   balance                 NOTE:   not in first implementation\n#   (x) get_balance         NOTE:   not fully implemented (product related balance)\n#   admin_get_grants        NOTE:   not in first implementation - to be moved to chain 2 (offchain)\n#   get_receipt             NOTE:   to be removed - to be considered a private/provider specific method\n#   set_starting_balance    \n#   (x) grant\n#   (x) revoke\n\n\nclass workerAlgorand():\n    \n    def __init__ (self):\n        pass\n\n\n    def begin_transaction(self) -> DopError:\n        return DopError(0,\"\")\n\n    def rollback(self) -> DopError:\n        return DopError(0,\"\")\n\n    def commit(self) -> DopError:\n        return DopError(0,\"\")\n\n    def __wallet_id(\n        self,\n        wallet_name: str\n        ) -> Tuple[str, DopError]:\n\n        \"\"\"\n            returns the wallet id of the wallet named wallet_name\n        \"\"\"\n        if self._i_kmd_client == None:\n            return \"\",DopError(2,\"Missing value for kmd client.\")\n\n        wallets = self._i_kmd_client.list_wallets()\n        for arrayitem in wallets:\n            if arrayitem.get(\"name\") == wallet_name:\n                walletid = arrayitem.get(\"id\")\n                return walletid,DopError(0,'')\n                break\n        return '',DopError(101,\"The wallet id for the specified wallet name could not be retrieved.\")\n\n    def __account_mnemonic(\n        self,\n        wallet_name: str,\n        wallet_password: str,\n        account_address: str\n        ) -> Tuple[str, DopError]:\n\n        if self._i_kmd_client == None:\n            return \"\",DopError(2,\"Missing value for kmd client.\")\n\n        err: DopError\n        wallet_id, err = self.__wallet_id(wallet_name)\n        if err.isError():\n            return \"\",err\n\n        wallet_handle = self._i_kmd_client.init_wallet_handle(wallet_id, wallet_password)\n        account_key = self._i_kmd_client.export_key(wallet_handle, wallet_password, account_address )\n        key_mnemonic = mnemonic.from_private_key(account_key)\n\n        #   check for error, exceptions, etc.\n        return key_mnemonic, DopError(0,\"\")\n\n\n\n\n    @staticmethod\n    def dop_stateless_create(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   teal_template_path: str                 #   the absolute path of the teal contract template\n    ,   creator_address: str                    #   the address of the creator of the smart contract\n        ) -> Tuple[str, DopError]:\n        \"\"\"\n            creates the stateless smart contract\n            if successful   -> returns the address of the stateless smart contract \n            otherwise       -> returns an empty string\n        \"\"\"\n\n        #   compile the stateless teal prog\n        #   set source code \n        #       the source code to be used for this example is DOP/dop.account/dop.account.teal.template\n        #       NOTE:   the dop.account.teal (the source code to be compiled) is generated using the file \n        #               dop.account.teal.template by replacing the macro \"_RECEIVERADDRESS_\" with the \"creator_address\"\n        #               see DOP/dop.account/00_create.sh - that contains the following cmd\n        #               sed \"s/_RECEIVERADDRESS_/$CREATOR/g\" dop.account.teal.template > dop.account.teal\n\n\n        #   read the template\n        teal_template: str = \"\"\n        try:\n            with open(teal_template_path, 'r', encoding='utf-8') as f:\n                teal_template = f.read()\n        except Exception:\n            return \"\",DopError(3,\"Teal template file not found.\")\n\n        #   now the _RECEIVERADDRESS_ nacro has to be substituted with creator_address\n        teal_source = teal_template.replace('_RECEIVERADDRESS_', creator_address)\n\n        \n        try:\n            compile_response = client.compile(teal_source)\n            #   return base64.b64decode(compile_response['result'])\n            #   compile_response example\n            #   {\n            #       'hash': 'LILX6GOG4N6LAOTFT4WW5VTXK5AN4KA5TAN5CYAE7LX5GPC2XXU6NNHDTA', \n            #       'result': 'AyAHAgEABmTIAaCNBiYBIOKaz1eO1YI9t+Lp5CmWTNrK6kvjiZCylN6neTTnB6YYMgQiD0AAKTIEIxJAAAIkQzMAECMSQAAKMwAQJRJAAA0kQzMABygTQAAlIQRDIQVDMwAQIxNAABczARAlE0AADzMBGCQSQAAHMwAIIQYPQyRD'\n            #   }\n            #   where   'result'    holds the compiled code\n            #           'hash'      is the address of the smart contract\n        except Exception:\n            return \"\",DopError(4,\"Error compiling teal source.\")\n\n        smart_contract_address = compile_response['hash']\n\n        #   TODO:   \n        #           check if the stateless smart contract needs to be immediately funded\n        return smart_contract_address,DopError(0,\"\")\n\n    @staticmethod\n    def dop_stateful_create(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   teal_clear_program_path: str\n    ,   teal_approval_program_path: str\n    ,   creator_address: str\n    ,   creator_private_key: str\n    ,   smart_contract_address: str                     #   address of the stateless smart contract\n        ) -> Tuple[str, DopError]:\n        \"\"\"\n            creates the stateful smart contract\n            if successful   -> returns the txn_id of the stateful smart contract creation transaction\n            otherwise       -> returns an empty string\n        \"\"\"\n\n        #ApplicationCreateTxn\n\n        #   get and compile the clear program\n        teal_clear_source: str = \"\"\n        try:\n            with open(teal_clear_program_path, 'r', encoding='utf-8') as f:\n                teal_clear_source = f.read()\n        except Exception:\n            return \"\",DopError(5,\"Teal clear file not found.\")\n\n        compile_response = client.compile(teal_clear_source)            \n        clear_program = base64.b64decode(compile_response['result'])\n\n\n        # declare on_complete as NoOp\n        on_complete = transaction.OnComplete.NoOpOC.real\n\n        #   get and compile the approval program\n        teal_approval_source: str = \"\"\n        try:\n            with open(teal_approval_program_path, 'r', encoding='utf-8') as f:\n                teal_approval_source = f.read()\n        except Exception:\n            return \"\",DopError(6,\"Teal approval file not found.\")\n\n        compile_response = client.compile(teal_approval_source) \n        approval_program = base64.b64decode(compile_response['result'])           \n\n        params = client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n\n        #compile_result = base64.b64decode(compile_response['result'])\n        \n        smart_contract_arguments = {\n            \"args\":     [smart_contract_address]    #   list of app arguments (goal app create --app-arg)\n#       ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n        }\n\n        app_args: list   = workerAlgorand.getArgs(smart_contract_arguments)\n\n        # declare application state storage (immutable)\n        local_ints      = 5\n        local_bytes     = 5\n        global_ints     = 5\n        global_bytes    = 5\n\n        # define schema (<class 'algosdk.future.transaction.StateSchema'>)\n        global_schema   = transaction.StateSchema(global_ints, global_bytes)\n        local_schema    = transaction.StateSchema(local_ints, local_bytes)\n\n        unsigned_txn = ApplicationCreateTxn(creator_address, params, on_complete, approval_program, clear_program, global_schema, local_schema, app_args)\n        # sign transaction\n        signed_txn = unsigned_txn.sign(creator_private_key)\n        txn_id = signed_txn.transaction.get_txid()\n\n        #   send transaction\n        try: \n            client.send_transactions([signed_txn])    \n        except Exception as err:\n            return txn_id, DopError(120, f\"An error occurred while creating stateful \\\n                smart contract.\")\n        return (txn_id,DopError(0,\"\"))\n\n    @staticmethod\n    def mnemonic_to_private_key(mnemonic_key: str) -> Tuple[str, DopError]:\n        \"\"\"\n        convert a menmonic key into a \"single string\" private key\n        \"\"\"\n        private_key: str = \"\"\n        try:\n            private_key = mnemonic.to_private_key(mnemonic_key)\n        except Exception:\n            return \"\",DopError(10,\"Mnemonic could not be converted to private key.\")\n\n        return private_key,DopError(0,\"\")\n\n\n    \n    #   private method\n    def __algorand_smart_contract_create(\n        self\n    ,   client: algosdk.v2client.algod.AlgodClient\n    ,   creator_mnemonic: str\n        ) -> Tuple[str, str, DopError]:\n        \n        \"\"\"\n            the DOP smart contract is a linked smart contract\n            (there is a stateless part, to represent the smart contract account\n            and a stateful part, holding the DOP logic)\n            RETURNS:    \n                    address of the stateless smart contract\n                    app index of the stateful smart contract\n                    DopError\n\n            see https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/?from_query=call%20smart%20contract%20from%20javascript#call-noop\n            see https://github.com/algorand/py-algorand-sdk/blob/5b496e0928af1dcae4e393693421f590a6111907/algosdk/future/transaction.py\n            see https://developer.algorand.org/docs/rest-apis/algod/v2/\n        \"\"\"\n\n        err: DopError\n        creator_private_key: str\n\n        creator_private_key, err = self.mnemonic_to_private_key(creator_mnemonic)\n        if err.isError():\n            return (\"\",0,err)\n        creator_address       = account.address_from_private_key(creator_private_key)         #   this line to be deleted\n\n        smart_contract_address, err = self.dop_stateless_create(client, self._i_stateless_teal_template_path, creator_address)\n        if err.isError():\n            return (\"\",0,err)\n\n        txn_id, err = self.dop_stateful_create(client, self._i_teal_clear_program_path, self._i_teal_approval_program_path, creator_address, creator_private_key, smart_contract_address)\n\n        if err.isError():\n            return \"\",0,err\n\n        # await confirmation\n        confirmed_txn = self.wait_for_confirmation(client, txn_id, 4)  \n\n\n        #   confirmed_txn holds:\n        #   {\n        #       'application-index': 392, \n        #       'confirmed-round': 66118, \n        #       'global-state-delta': [\n        #                               {'key': 'a2V5', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, \n        #                               {'key': 'a2lk', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, \n        #                               {'key': 'bGlua2Vk', 'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}}, \n        #                               {'key': 'Y3JlYXRvcg==', 'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}}\n        #                               ], \n        #       'pool-error': '', \n        #       'sender-rewards': 16230, \n        #       'txn': {'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', \n        #               'txn': {'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], \n        #                       'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', \n        #                       'apgs': {'nbs': 5, 'nui': 5}, \n        #                       'apls': {'nbs': 5, 'nui': 5}, \n        #                       'apsu': 'AyABASI=', \n        #                       'fee': 1000, \n        #                       'fv': 66017, \n        #                       'gen': 'private-v1', \n        #                       'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', \n        #                       'lv': 67017, \n        #                       'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', \n        #                       'type': 'appl'}\n        #               }\n        #       }\n\n\n        # display results\n        transaction_response = client.pending_transaction_info(txn_id)\n\n        #   transaction_response\n        #   {\n        #       'application-index': 392, \n        #       'confirmed-round': 66118, \n        #       'global-state-delta': [\n        #                               {\n        #                                   'key': 'Y3JlYXRvcg==', \n        #                                   'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}\n        #                               }, \n        #                               {\n        #                                   'key': 'a2V5', \n        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}\n        #                               }, \n        #                               {\n        #                                   'key': 'a2lk', \n        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}\n        #                               }, \n        #                               {\n        #                                   'key': 'bGlua2Vk', \n        #                                   'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}\n        #                               }\n        #                               ], \n        #       'pool-error': '', \n        #       'sender-rewards': 16230, \n        #       'txn': {\n        #                   'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', \n        #                   'txn': {\n        #                               'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], \n        #                               'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', \n        #                               'apgs': {'nbs': 5, 'nui': 5}, \n        #                               'apls': {'nbs': 5, 'nui': 5}, \n        #                               'apsu': 'AyABASI=', \n        #                               'fee': 1000, \n        #                               'fv': 66017, \n        #                               'gen': 'private-v1', \n        #                               'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', \n        #                               'lv': 67017, \n        #                               'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', \n        #                               'type': 'appl'\n        #                           }\n        #               }\n        #       }\n\n        app_id = transaction_response['application-index']\n        return (smart_contract_address, str(app_id), DopError(0,\"\"))\n\n\n    #   private method\n    def __account_send(self, from_mnemonic, to_address, amount) -> Tuple[str,DopError]:\n\n        \"\"\"\n        Sends tokens from one account to another\n        \"\"\"\n        if self._i_algod_client == None:\n            return \"\",DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTIN\".encode()\n\n        err: DopError\n\n        from_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return \"\",err\n        from_address = account.address_from_private_key(from_private_key)\n\n        \n        params = self._i_algod_client.suggested_params()\n        # comment out the next two (2) lines to use suggested fees\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP funds\".encode()\n\n        #   create an unsigned transaction\n        unsigned_txn = PaymentTxn(from_address, params, to_address, amount, None, txn_note)\n\n        #   sign the transaction using the private key of the sender (from_address)\n        signed_txn = unsigned_txn.sign(from_private_key)\n\n        #submit transaction\n        txid = self._i_algod_client.send_transaction(signed_txn)\n        print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        # wait for confirmation \n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n        except Exception as err:\n            print(err)\n            return \"\", DopError(301,'An exception occurred while waiting \\\n                for the confirmation of the send transaction.')\n        \n        return txid, DopError(0,)\n    \n    @staticmethod\n    def wait_for_confirmation(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   transaction_id: str\n    ,   timeout: int\n    ):\n        \"\"\"\n        Wait until the transaction is confirmed or rejected, or until 'timeout'\n        number of rounds have passed.\n        Args:\n            transaction_id (str): the transaction to wait for\n            timeout (int): maximum number of rounds to wait    \n        Returns:\n            dict: pending transaction information, or throws an error if the transaction\n                is not confirmed or rejected in the next timeout rounds\n        \"\"\"\n        start_round = client.status()[\"last-round\"] + 1\n        current_round = start_round\n\n        while current_round < start_round + timeout:\n            try:\n                pending_txn = client.pending_transaction_info(transaction_id)\n            except Exception:\n                return \n            if pending_txn.get(\"confirmed-round\", 0) > 0:\n                return pending_txn\n            elif pending_txn[\"pool-error\"]:  \n                raise Exception(\n                    'pool error: {}'.format(pending_txn[\"pool-error\"]))\n            client.status_after_block(current_round)                   \n            current_round += 1\n        raise Exception(\n            'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))\n\n    @staticmethod\n    def Token(token: str, path: str) -> Tuple[DopError, str]:\n        ntoken: str = token\n        if ntoken == '':\n            try:\n                with open(path, 'r') as f:\n                    ntoken = f.readline()\n            except Exception as e:\n                #print(str(e))\n                return (DopError(20,\"An exception occurred while reading token file.\"),ntoken)\n\n            l: list = ntoken.split('\\n')\n            ntoken = l[0]\n        return (DopError(), ntoken)\n\n    @staticmethod \n    def Port(port: str, path: str) -> Tuple[DopError, str]:\n        nport: str = port\n        host: str = ''\n        if nport == '':\n            try:\n                with open(path, 'r') as f:\n                    host = f.readline()\n            except:\n                return (DopError(21,\"An exception occurred while reading port file.\"),nport)\n\n        l: list = host.split('\\n')\n        host = l[0]\n        l = host.split(':')\n        if len(l) > 1:\n            nport = l[1]\n\n        return (DopError(), nport)\n        \n    def algodToken(self) -> Tuple[DopError, str]:\n        \"\"\"\n        returns the token of necessary to connect to the algod node\n        NOTE:   the token is retrieved by reading and parsing the file \"$ALGORAND_DATA/algod.token\"\n                so this function requires the macro ALGORAND_DATA to be defined and available\n                to the process calling this method\n        \"\"\"\n\n        token: str\n        if 'atoken' in self._i_config:\n            #   atoken passed in connstring - ignore file containing token\n            token = self._i_config['atoken']\n            self._i_algo_token = token\n            return DopError(),token\n\n        err, token = self.Token(self._i_algo_token, self._i_algo_token_file)\n        if err.code == 0:\n            self._i_algo_token = token\n\n        return (err,token)\n\n    def algodPort(self) -> Tuple[DopError, str]:\n        \"\"\"\n        returns the TCP port the algod node is listening to\n        NOTE:   the port is retrieved by reading and parsing the file \"$ALGORAND_DATA/algod.net\"\n                so this function requires the macro ALGORAND_DATA to be defined and available\n                to the process calling this method\n        \"\"\"\n        port: int\n        if 'anetprt' in self._i_config:\n            #   anetprt passed in connstring - ignore file containing port\n            port = int(self._i_config['anetprt'])\n            self._i_algo_port = port\n            return DopError(),port\n\n        err, port = self.Port(self._i_algo_port, self._i_algo_net_file)\n        if err.code == 0:\n            self._i_algo_port = port\n        return (err, port)\n\n    def kmdToken(self) -> Tuple[DopError, str]:\n        token: str\n        if 'ktoken' in self._i_config:\n            #   atoken passed in connstring - ignore file containing token\n            token = self._i_config['ktoken']\n            self._i_kmd_token = token\n            return DopError(),token\n\n        err, token = self.Token(self._i_kmd_token, self._i_kmd_token_file)\n        if err.code == 0:\n            self._i_kmd_token = token\n        return (err, token)\n\n    def kmdPort(self) -> Tuple[DopError, str]:\n        port: int\n        if 'knetprt' in self._i_config:\n            #   anetprt passed in connstring - ignore file containing port\n            port = int(self._i_config['knetprt'])\n            self._i_kmd_port = port\n            return DopError(),port\n\n        err, port = self.Port(self._i_kmd_port, self._i_kmd_net_file)\n        if err.code == 0:\n            self._i_kmd_port = port\n        return (err, port)\n\n    def kmd(self) -> Tuple[DopError, algosdk.kmd.KMDClient]:\n        err, kmd_token = self.kmdToken()\n        if err.code != 0:\n            return (err,None)\n        err, kmd_port = self.kmdPort()\n        if err.code != 0:\n            return (err,None)\n\n        kmd_ip_address: str = 'http://localhost:' \n        if 'knetip' in self._i_config:\n            kmd_ip_address = 'http://' + self._i_config['knetip'] + ':'\n        kmd_address = kmd_ip_address + str(kmd_port)\n\n        kcl = kmd.KMDClient(kmd_token, kmd_address)\n\n        try:\n            #   NOTE:           it seems that the kmd can be instantiated only if using localhost\n            #                   to be checked with algorand\n            kcl.versions()  #   generates an exception if the kcl is not connected\n        except Exception:\n            return(DopError(22, \"An exception occurred while initializing kmd client.\"),kcl)\n\n        return(DopError(),kcl)\n    \n    def algod(self) -> Tuple[DopError, algosdk.v2client.algod.AlgodClient]:\n        #   get algod token\n        err, algod_token = self.algodToken()\n        if err.code != 0:\n            return (err,None)\n        #   get algod port\n        err, algod_port = self.algodPort()\n        if err.code != 0:\n            return (err,None)\n        #   get algo node address (default is localhost)\n\n        algod_ip_address: str = 'http://localhost:' \n        if 'anetip' in self._i_config:\n            algod_ip_address = 'http://' + self._i_config['anetip'] + ':'\n        #algod_address = 'http://localhost:' + str(algod_port)\n        algod_address = algod_ip_address + str(algod_port)\n        algocl = algod.AlgodClient(algod_token, algod_address)\n\n        #   check if the algod client is valid\n        try:\n            algocl.status()\n        except Exception:\n            return(DopError(23, \"Error in initializing algod client.\"),algocl)\n\n        return(DopError(),algocl)\n\n    @staticmethod\n    def getArgs(argsobj: dict) -> list:\n        args = argsobj.get(\"args\")\n\n        if args==None:\n            return None\n\n        if len(args) < 1:\n            return None\n\n        b_args: list = []\n        for item in args:\n            b_args.append(bytes(item,'utf-8'))\n        return b_args\n\n    @staticmethod\n    def getAccounts(argsobj: dict) -> list:\n        args = argsobj.get(\"addrs\")\n\n        if args==None:\n            return None\n\n        if len(args) < 1:\n            return None\n\n        return args\n\n    def dopSmartContract(\n        self\n    ,   algod_client: algosdk.v2client.algod.AlgodClient\n    ,   appid:  int                     #   smart contract index (address)\n    ,   owner_mnemonic: str             #   private key (mnemonic) of the owner of the smart contract\n    ,   scarguments: dict               #   {\"args\":[argslist], \"addrs\":[accountaddresseslist]}\n    ,   transaction_note: str           #   the note field withon the transaction\n    ) -> Tuple[str, DopError]:               #   error code, transaction id\n\n        #   retrieve and change suggested params (for the transaction)        \n        #   this could become an argument, to be investigated (future releases)\n        params = algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n\n        txn_note = transaction_note.encode()\n\n        err: DopError\n        owner_private_key: str\n        owner_private_key,err   = self.mnemonic_to_private_key(owner_mnemonic)\n        if err.isError():\n            return \"\",err\n\n        owner_address       = account.address_from_private_key(owner_private_key)         #   this line to be deleted\n\n        arguments_list   = self.getArgs(scarguments)\n        accounts_list    = self.getAccounts(scarguments)\n\n        unsigned_txn = ApplicationNoOpTxn(owner_address, params, appid, arguments_list, accounts_list, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(owner_private_key)\n\n        txid = ''\n        try:\n            txid = algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #print(err)\n            return \"\", DopError(202,f\"An exception occurred when sending transaction.\")\n\n        return(txid, DopError(0,\"\"))      #   now the transaction can be waited for\n\n    def __default(self):\n        #   set default parameters\n        self._i_algo_token      = ''\n        self._i_algo_port       = ''\n        self._i_algod_client    = None\n\n        self._i_kmd_token       = ''\n        self._i_kmd_port        = ''\n        self._i_kmd_client      = None\n\n        self._i_config: dict   = {}\n        \n        algorand_data_path: str = '/home/ecosteer/dop/externals/algorand/net1/Primary'\n        if 'ALGORAND_DATA' in os.environ:\n            algorand_data_path = os.environ['ALGORAND_DATA']\n\n        self._i_algo_token_file     = algorand_data_path + '/algod.token'           #   this has to go\n        self._i_config['atokf']     = algorand_data_path + '/algod.token'\n\n        self._i_algo_net_file       = algorand_data_path + '/algod.net'             #   this has to go\n        self._i_config['anetf']     = algorand_data_path + '/algod.net'\n\n        self._i_kmd_token_file      = algorand_data_path + '/kmd-v0.5/kmd.token'    #   this has to go\n        self._i_config['ktokf']     = algorand_data_path + '/kmd-v0.5/kmd.token'\n\n        self._i_kmd_net_file        = algorand_data_path + '/kmd-v0.5/kmd.net'      #   this has to go\n        self._i_config['knetf']     = algorand_data_path + '/kmd-v0.5/kmd.net'\n        \n\n        dop_smart_contract_root_path: str = '/home/ecosteer/dop/intermediation/algorand/DOP'\n        self._i_config['scrf'] = dop_smart_contract_root_path\n\n        user_wallet: str            = \"unencrypted-default-wallet\"                  # wallet where the users are created\n        user_wallet_password: str   = \"\"                                            # password to access the wallet\n        self._i_config['usrwlab']   = user_wallet\n        self._i_config['usrwpwd']   = user_wallet_password\n\n\n        if 'DOP_SMART_CONTRACT_ROOT_FOLDER' in os.environ:\n            dop_smart_contract_root_path = os.environ['DOP_SMART_CONTRACT_ROOT_FOLDER']\n            \n        self._i_stateless_teal_template_path    = dop_smart_contract_root_path + '/dop.account/dop.account.teal.template'\n        self._i_config['sttp'] = 'dop.account/dop.account.teal.template'\n        self._i_teal_approval_program_path      = dop_smart_contract_root_path + '/dop.stateful/dop.stateful.teal'\n        self._i_config['tapp'] = 'dop.stateful/dop.stateful.teal'\n        self._i_teal_clear_program_path         = dop_smart_contract_root_path + '/dop.clear/basicClear.teal'\n        self._i_config['tcpp'] = 'dop.clear/basicClear.teal'\n\n        self._i_config['ownmne'] = ''\n\n\n    #============================================================================\n    #   abstract methods\n    #============================================================================\n    #   NOTE:   init must become an abstract method\n    def init(self, constring: str) -> DopError:\n\n        self.__default()\n                \n        #   convert connstring into a dict (see config_to_dict in shared.utils.py)\n        temp_config: dict = {}\n\n        temp_list: list = constring.split(';')\n        for el in temp_list:\n            ell = el.split('=')\n            if len(ell) != 2:\n                continue\n            temp_config[ell[0]]=ell[1]\n\n        pars: list = [\n            'atokf',\n            'anetf',\n            'ktokf',\n            'knetf',\n            'atoken',\n            'anetprt',\n            'anetip',\n            'ktoken',\n            'knetprt',\n            'knetip',\n            'scrf',\n            'sttp',\n            'tapp',\n            'tcpp',\n            'usrwlab',\n            'usrwpwd',\n            'ownmne'\n            ]\n\n        for p in pars:\n            if p in temp_config:\n                self._i_config[p] = temp_config[p]\n\n\n        \n        #   connection string parameters\n        #   label   type        logic\n        #   ------+---------+------------------------------------------------------------------------------------------------\n        #   atokf   string      absolute path of the algod.token file\n        #   anetf   string      absolute path of the algod.net file     \n        #   ktokf   string      absolute path of the kmd.token file\n        #   knetf   string      absolute path of the kmd.net file\n        #   atoken  string      algod token (if this is defined then atokf will not be used)\n        #   anetprt int         algod tcp ip port (if this is defined then the anetf will not be used - anetip required)\n        #   anetip  string      algod tcp ip address (if this is defined then the anetf will not be used - anetprt required)\n        #   ktoken  string      kmd token (if this is defined then atokf will not be used)\n        #   knetprt int         kmd tcp ip port (if this is defined then the knetf will not be used - knetip required)\n        #   knetip  string      kmd tcp ip address (if this is defined then the knetf will not be used - knetprt required)\n        #   scrf    string      smart contract root folder      : absolute path of the folder containing sttp, atpt and tcpp\n        #   sttp    string      stateless teal template path    : relative path of the stateless teal template\n        #   tapp    string      teal approval program path      : relative path of the teal approval program\n        #   tcpp    string      teal clear program path         : relative path of the teal clear program\n        #\tusrwlab\tstring\t\tuser wallet (the wallet used by the worker to create accounts)\n\t\t#\tusrwpwd\tstring\t\tuser wallet password\n\n        #   ownmne  string      mnemonic of the owner account to be used to fund newly created accounts\n\n        #   example 1 (can be used only if the kmd and algod are running on localhost)\n        #   atokf=/home/ecosteer/algorand/net1/Primary/algod.token;anetf=/home/ecosteer/algorand/net1/Primary/algod.net;\\\n        #   ktokf=/home/ecosteer/algorand/net1/Primary/kmd.token;knetf=/home/ecosteer/algorand/net1/Primary/kmd.net;\\\n        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\\\n        #   sttp=dop.account/dop.account.teal.template;\\\n        #   tapp=dop.stateful/dop.stateful.teal;\\\n        #   tcpp=dop.clear/basicClear.teal;\n\n        #   example 2 (to be used if the kmd and algod are running on a remote host)\n        #   atoken=45d2689bb4b555b757b00972d82c0a872f7b2aa136a5351768280dbe7cf2e9b2;\\\n        #   anetprt=18445;\\\n        #   anetip=192.178.20.30;\\\n        #   ktoken=d278689bb4b555b7502030465782c0a872f7b2aa136a5351768280dbe7cf2ab90;\\\n        #   knetprt=18435;\\\n        #   knetip=192.178.20.30;\\\n        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\\\n        #   sttp=dop.account/dop.account.teal.template;\\\n        #   tapp=dop.stateful/dop.stateful.teal;\\\n        #   tcpp=dop.clear/basicClear.teal;\n\n        #   test only\n        for el in self._i_config:\n            print(el + ':[' + self._i_config[el] + ']')\n        \n        return DopError(0, \"\")\n\n    def open(self) -> DopError:\n        \"\"\"\n            open the algod client and the kmd client\n            the following properties are valorized:\n            1)  _i_algod_token\n            2)  _i_algod_port\n            3)  _i_kmd_token\n            4)  _i_kmd_port\n        \"\"\"\n\n\n        #   self.algod\n        #   sets self._i_algod_token and self._i_algod_port\n        err, self._i_algod_client = self.algod()\n        if err.isError():\n            return err\n\n        err, self._i_kmd_client = self.kmd()\n        if err.isError():\n            return err\n\n        if 'ownmne' in self._i_config: \n            self._own_mnemonic = self._i_config['ownmne']\n        else:\n            self._own_mnemonic = None\n            return DopError(201, \"Owner mnemonic not provided.\")\n\n        return err\n\n    def close(self) -> DopError:\n        #   TODO:   check if algod and kmd client have to be \"closed\" \n        return DopError(0,\"\")\n\n\n    def get_balance(self,\n                    publisher_address: str,                         #   EoA address of the publisher (contract owner)\n                    subscriber_address: str,                        #   EoA address of the subscriber we want to check the balance \n                    contract_address: str) -> Tuple[dict, DopError]:   #   address (blockchain layer) of the contract) -> Tuple[dict, DopError]:\n        \"\"\"\n        in this version this method is not \"really\" implemented\n        \"\"\"\n        response = {}\n        response['subscribed'] = 1\n        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use DB\n        response['credit'] = 100\n        response['debit'] = 0\n\n        return response, DopError(0,\"\")\n\n    def create_user(self, username: str, password: str) -> Tuple[str, str, DopError]: \n        \"\"\"\n            creates a blockchain account and returns the address (public key) of the account and the password\n            of the account (ethereum: input password, algorand, generated private key)\n\n        \"\"\"\n        user_address = \"\"\n        wallet_id: str\n        err: DopError\n\n        wallet_name = self._i_config['usrwlab']\n        wallet_password = self._i_config['usrwpwd']\n\n        wallet_id, err = self.__wallet_id(wallet_name)\n        if err.isError():\n            return \"\",\"\",err\n\n        \n        try:\n            wallet = Wallet(wallet_name, wallet_password, self._i_kmd_client)\n            #   create the account\n            account_address     = wallet.generate_key()\n            account_mnemonic, err    = self.__account_mnemonic(wallet_name,wallet_password,account_address)\n            if err.isError():\n                return \"\",\"\",err\n            #   return err=0,account_address\n            return account_address, account_mnemonic,DopError(0,\"\")\n\n        except Exception as err:\n            #   likely the password is wrong\n            print(err)      #   logging etc.\n            return \"\",\"\",DopError(203,\"An exception occurred while creating user.\")\n\n        return \"\",\"\",DopError(1000,\"\")             # never hit\n\n\n        return (user_address,user_mnemonic,DopError(0,\"\"))\n    \n\n\n    def get_wallet_balance(self, account_address: str, currency=\"algo\") -> Tuple[str, DopError]:\n        \"\"\"\n            TODO:       return account_balance, DopError (as usual)\n            TODO:       the method name should be change into \"get_account_balance\" to disambiguate between account and wallet\n            NOTE:       the abstract was defined with a str return value\n        \"\"\"\n        if self._i_algod_client == None:\n            return \"\", DopError(1,\"Missing value for algod client.\")\n\n        try:\n            #   address is the account address - for instance: \"4KNM6V4O2WBD3N7C5HSCTFSM3LFOUS7DRGILFFG6U54TJZYHUYMDPN26KY\"\n            from_account_info = self._i_algod_client.account_info(account_address)\n            #   the account balance is in micro algos\n            account_balance = from_account_info.get('amount')\n            #print(\"Origin Account balance     : [{} microAlgos]\".format(from_account_info.get('amount')))\n            return account_balance, DopError(0,\"\")\n        except Exception:\n            return \"\",DopError(204,\"An exception occurred while getting wallet balance.\")\n\n        \n    def deploy_contract(self,\n                        publisher_address: str,                 #   address of the owner account\n                        secret: str,                            #   secret for the owner account (algorand: private key mnemonic of the owner)\n                        tariff_period: int,                     #   period of the tariff \n                        tariff_price: int                       #   price of a period\n                        ) -> Tuple[Optional[str], DopError]:\n        \"\"\"\n            NOTE:\n                The abstract method returns a transaction hash that is inserted into the \n                rdbms (transactions schema) - as this is typically a pending operation finalized by an event emitted by the monitor.\n                For Algorand: this might require a complete different logic of the processor \"product_create.py\" - possibly a \n                processor specific for Algorand will have to be implemented.\n                See also monitor_des.py - it processes the event (DEPLOY_CONTRACT) that is\n                meant to close the pending op\n\n                NOTE:   EnableDeveloperAPI must be set to true (node configuration file)\n                NOTE:   https://developer.algorand.org/docs/run-a-node/reference/config/\n\n                TODO:   review static and private method dop_stateful/dop_stateless/__algorand_smart_contract_create\n        \"\"\"\n\n        #   publisher_address:      not used\n        #   tariff_period:          not used (for future release)\n        #   tariff_price:           not used (for future release)\n        #   secret: is the mnemonic of the publisher\n        \n        smart_contract_address: str     #   the address of the stateless smart contract (the smart contract linked to the stateful smart contract)\n                                        #   as the previously defined abstract method allows tp return just two values\n                                        #   we will not return the smart contract address for the moment - to be checked\n                                        #   in this release the smart_comtract_address will be encoded using the following string:\n                                        #   %smart_contract_adress%@%app_id\n\n        app_id: str                     #   the application id (this id will have to be used for invoking the smart contract)\n        err: DopError\n\n        if self._i_algod_client == None:\n            #   must open before\n            return (\"\",DopError(1,\"Missing value for algod client.\"))\n\n        smart_contract_address, app_id, err = self.__algorand_smart_contract_create(self._i_algod_client, secret) \n        if err.isError():\n            return \"\", err\n        #   TODO check if stateless contract has to be funded\n        encoded_smart_contract_address: str = smart_contract_address + '@' + str(app_id)\n        return (encoded_smart_contract_address, err)\n\n    def algorand_sub_optin(     #   ALGORAND SPECIFIC\n        self,\n        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in\n        application_address: str    #   application index of the smart contract the account wants to opt into\n        ) -> DopError:\n        \"\"\"\n        Algorand specific (an account has to optin before subscribing to a smart contract)\n        this methid can be called by a specific Algorand processor provider (not an abstract method),\n        for instance by the processor provider that implement the subscription logic\n        SO: it has not be implemented as a private method - but an Algorand specific method.\n\n        NOTE:   the subscriber, before subscribing the contract X, MUST opt-in to the contract X\n        \"\"\"\n        #   see 01_sub_optin.py\n        \n        if self._i_algod_client == None:\n            return DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTIN\".encode()\n\n        err: DopError\n\n        #subscriber_private_key = mnemonic.to_private_key(from_mnemonic)\n        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return err\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        appid = int(application_address)\n        unsigned_txn = ApplicationOptInTxn(subscriber_address, params, appid, None, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid =''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(205,\"An exception occurred when sending optin transaction.\")\n\n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n            #   TODO: confirmed_txn can be used to provide detailed log, see next\n            #   commented lines\n            #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(302,\"An exception occurred while waiting for confirmation of optin transaction.\")\n\n        return DopError(0,\"\")\n\n\n    def algorand_sub_optout(     #   ALGORAND SPECIFIC\n        self,\n        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in\n        application_address: str    #   application index of the smart contract the account wants to opt into\n        ) -> DopError:\n        \"\"\"\n        Algorand specific (symmetric to algorand_sub_optin)\n        NOTE:   a subscriber that has unsubscribed should call optout, too\n        \"\"\"\n        \n        if self._i_algod_client == None:\n            return DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTOUT\".encode()\n\n        err: DopError\n        subscriber_private_key: str\n\n        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return err\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        appid = int(application_address)\n        unsigned_txn = ApplicationCloseOutTxn(subscriber_address, params, appid, None, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid =''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(206,\"An exception occurred when sending optout transaction.\")\n\n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n            #   TODO: confirmed_txn can be used to provide detailed log, see next\n            #   commented lines\n            #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(303,\"An exception occurred while waiting for \\\n                        confirmation of optout transaction.\")\n\n        return DopError(0,\"\")\n\n\n    def subscribe(self,\n                  subscriber_addr: str,             #   subscriber address\n                  subscriber_psw: str,              #   private key mnemonic\n                  contract_address: str,            #   algorand application index\n                  secret: str                       #   not used in this release\n                  ) -> Tuple[str, DopError]:  \n        \"\"\"\n        Subscribe to a contract\n        \"\"\"\n\n        if self._i_algod_client == None:\n            return \"\",DopError(1,\"\")        #   must be connected to a node\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP SUBSCRIBE\".encode()\n\n    #   the transaction type that has to be sent is of type ApplicationNoOpTxn\n    #   see https://github.com/algorand/py-algorand-sdk/blob/5ca32cea62168ae339ccfdfbefaa6bc6ac094052/algosdk/future/transaction.py#L2040\n    #   line 2040\n        \n        err: DopError\n        subscriber_private_key: str\n\n        subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)\n        if err.isError():\n            return \"\",err\n\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        app_args : list = []\n        app_args.append(bytes('subscribe','utf-8'))\n        unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, contract_address, app_args, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid = ''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #print(err)\n            return \"\", DopError(207,\"An exception occurred when sending subscribe transaction.\")\n\n        # wait for confirmation \n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client,txid,4)\n\n            #print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #print(err)\n            return \"\",DopError(304,\"An exception occurred while waiting for confirmation \\\n                    of subscribe transaction.\")\n\n        return txid,DopError(0,\"\")\n\n\n    def unsubscribe(self, \n                    subscriber_addr: str,               #   not used\n                    subscriber_psw: str,                #   subscriber account private key mnemonic\n                    contract_address: str             #   application index\n                    #,secret: str                         #   not used \n                    ) -> Tuple[str, DopError]:\n            \"\"\"\n            UnSubscribe from a contract\n            return transaction id\n            \"\"\"\n\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")        #   must be connected to a node\n\n            params = self._i_algod_client.suggested_params()\n            params.flat_fee = True\n            params.fee = 1000\n            txn_note = \"DOP UNSUBSCRIBE\".encode()\n\n            err: DopError\n            subscriber_private_key: str\n            subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)\n            if err.isError():\n                return \"\",err\n            subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n            application_index = int(contract_address)\n\n            app_args : list = []\n            app_args.append(bytes('unsubscribe','utf-8'))\n            unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, application_index, app_args, None, None, None, txn_note)\n            signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n            txid = ''\n            try:\n                txid = self._i_algod_client.send_transaction(signed_txn)\n                #print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n            except Exception as err:\n                #print(err)\n                return \"\", DopError(208,'An exception occurred when sending unsubscribe transaction.')\n\n            # wait for confirmation \n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n\n                return \"\",DopError(305,'An exception occurred while waiting for \\\n                            confirmation of unsubscribe transaction')\n\n            return txid,DopError(0,'')\n\n\n    def grant(self,\n              publisher_address: str,       #   not used\n              publisher_passw: str,         #   publisher private key mnemonic\n              contract_address: str,        #   application index            \n              subscriber_address: str       #   address of the subscriber to be granted\n              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError\n              \n            # see 06_pub_call_grant.py\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")\n\n            smart_contract_arguments = {\n                    \"args\":     ['grant']                   #   list of app arguments\n                ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n                }\n\n            transaction_note = \"DOP GRANT\"\n\n            err: DopError\n            txid: str = \"\"\n            txid, err = self.dopSmartContract(\n                self._i_algod_client\n            ,   int(contract_address)\n            ,   publisher_passw\n            ,   smart_contract_arguments\n            ,   transaction_note\n            )\n\n            if err.isError():\n                return \"\",err\n\n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n                #print(err)\n                return txid,DopError(306,\"An exception occurred while waiting for \\\n                    confirmation of grant transaction.\")\n\n            return txid,DopError(0,\"\")\n            \n\n\n\n    def revoke(self,\n              publisher_address: str,       #   not used\n              publisher_passw: str,         #   publisher private key mnemonic\n              contract_address: str,        #   application index            \n              subscriber_address: str       #   address of the subscriber to be revoked\n              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError\n\n              # see 07_pub_call_revoke.py\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")\n\n            smart_contract_arguments = {\n                \"args\":     ['revoke']                   #   list of app arguments\n            ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n            }\n\n            transaction_note = \"DOP REVOKE\"\n\n            txid: str = \"\"\n            err: DopError\n            txid, err = self.dopSmartContract(\n                self._i_algod_client\n            ,   contract_address\n            ,   publisher_passw\n            ,   smart_contract_arguments\n            ,   transaction_note\n            )\n\n            if err.isError():\n                return \"\",err\n\n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n                #print(err)\n                return txid,DopError(307,\"An exception occurred while waiting for \\\n                    confirmation of revoke transaction.\")\n\n            return txid,DopError(0,\"\")\n\n\n\n    def balance(self,\n                subscriber_address: str,                            #   subscriber EoA address\n                secret: str,                                        #   subscriber contract secret\n                contract_address: str) -> Tuple[dict, DopError]:       #   address (blockchain layer) of the contract\n        \"\"\"\n        Get the balance of a user with `address` of the contract with `contract_address`\n        \"\"\"\n        \"\"\"\n        in this version this method is not \"really\" implemented\n        \"\"\"\n        response = {}\n        response['subscribed'] = 1\n        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use postgres DB\n        response['credit'] = 100\n        response['debit'] = 0\n\n        return (response, DopError(0,\"\"))\n\n    \n    def admin_get_grants(self,\n                        publisher_address: str,             #   EoA address of the publisher (contract owner)\n                        contract_address: str) -> Tuple[list, DopError]:    #   address (blockchain layer) of the contract\n        \"\"\"\n        This method is used by the publisher only in order to retrieve the list \n        of the EoA address of the granted subscribers\n        \"\"\"\n        return [], DopError()\n\n\n    def set_starting_balance(self, \n                            address,\n                            amount) -> str: # EoA of the user \n        \"\"\"\n        Sets the starting balance of an EoA\n        \"\"\"\n        #self._own_mnemonic = \"ability improve suspect canyon castle fire flock forum monitor travel know write similar denial thought \\\n        #    online ripple squeeze this finish jar parrot rabbit ability crouch\"\n        if self._own_mnemonic == None:\n            return \"\"\n\n        txid, err = self.__account_send(from_mnemonic = self._own_mnemonic, to_address=address, amount=amount)\n        if err.isError():\n            return \"\" \n\n        return txid"}
{"file_path": "https://github.com/Tao242dn/algo-rpg-cli/blob/75e5ce829abd131fe964909785110608999a66ee/contents.py", "code": "plot_summary = \"\"\"\nA text-based RPG unfolds entirely within the command-line interface, where players' actions directly interact with the Algorand blockchain.\n\nA command-line interface (CLI) based RPG guides new users through the concepts of the Algorand blockchain.\n\nThe game mechanics directly utilize Algorand's features, turning abstract technical concepts into tangible actions within the game's narrative.\n\nThis provides a hands-on, interactive learning experience for newcomers to Algorand, making the technology more accessible and engaging.\n\"\"\"\n\nquests = [\n    \"Environmental Check [red](command: env)[/red] Before we begin our journey, let's ensure your surroundings are properly configured. Use the env command to check if your system meets the requirements for interacting with the Algorand blockchain. This involves verifying the necessary software and tools are installed and that your environment variables are set correctly.\",\n    \n    \"Account Creation [red](command: account)[/red] Every adventurer needs an identity! Create your Algorand account using the account command. This will generate a unique address and private key, which are essential for managing your assets and interacting with the blockchain. Keep your private key safe \u2013 it's the key to your digital kingdom!\",\n    \n    \"Funding Your Adventure [red](command: fund)[/red] Every great quest requires provisions. Fund your newly created Algorand account using the fund command. You'll need some Algo (Algorand's native cryptocurrency) to pay for transaction fees and interact with the blockchain. Think of it as stocking up on potions and supplies before embarking on a dangerous journey.\",\n    \n    \"Checking Your Provisions [red](command: balance)[/red] Wise adventurers keep track of their resources. Use the balance command to check the balance of your Algorand account. This will show you how much Algo you have available for your quests.\",\n    \n    \"Sharing the Spoils [red](command: send)[/red] Generosity is a virtue, even in the digital realm. Use the send command to send Algo to another Algorand account. This is like sharing your treasure with a fellow adventurer [bold](note: 1 Algo = 1_000_000 MicroAlgos)[/bold]\",\n    \n    \"Project Genesis [red](command: init)[/red] Time to craft something new! Use the init command to initialize a new Algorand project. This creates the foundation for building your own smart contracts \u2013 the magical spells of the Algorand world. We recommend using project name [red]auction_project[/red] match with my default template.\",\n    \n    \"Constructing the Spell [red](command: build)[/red]: With a project in place, you can now begin building your smart contract. The build command compiles your code into the bytecode that the Algorand Virtual Machine (AVM) understands. This is like carefully inscribing the runes of your spell.\",\n    \n    \"Trial Run [red](command: test)[/red]: Before unleashing your magic upon the world, it's wise to practice. Use the test command to test your smart contract in a safe, isolated environment. This allows you to identify and fix any bugs or vulnerabilities before deploying it to the main blockchain.\",\n    \n    \"Scrutiny of the Sages [red](command: audit)[/red] Even the most skilled mages seek peer review. Use the audit command to analyze your smart contract for potential security flaws and inefficiencies. This is like having a council of wise mages examine your spell for weaknesses.\",\n    \n    \"Unleashing the Magic [red](command: deploy)[/red] Once you're confident in your creation, it's time to deploy your smart contract to the Algorand blockchain. The deploy command makes your contract live, allowing other users to interact with it. Your spell is now active in the world!\",\n    \n    \"Preserving the Lore [red](command: upload)[/red] Important artifacts and knowledge deserve to be preserved. Use the upload command to upload files to IPFS (InterPlanetary File System), a decentralized storage network. This ensures that your data is immutable and accessible to anyone, even if parts of the network go offline. Think of it as storing your magical scrolls in a secure, distributed library.\"\n]\n\nqa_dict = {\n    \"Who founded Algorand?\": [[\"Vitalik Buterin\", \"Satoshi Nakamoto\", \"Silvio Micali\", \"Charles Hoskinson\"], \"Silvio Micali\"],\n    \n    \"What consensus mechanism does Algorand use?\": [[\"Proof-of-Work\", \"Delegated Proof-of-Stake\", \"Byzantine Fault Tolerance\", \"Pure Proof-of-Stake (PPoS)\"], \"Pure Proof-of-Stake (PPoS)\"],\n    \n    \"What is the native cryptocurrency of Algorand?\": [[\"ALGO\", \"ETH\", \"BTC\", \"SOL\"], \"ALGO\"],\n    \n    \"How does Algorand ensure decentralization?\": [[\"Mining\", \"Random selection of validators\", \"Staking\", \"Proof of Work\"], \"Random selection of validators\"],\n    \n    \"What is the average block time on Algorand?\": [[\"3.7 seconds\", \"10 minutes\", \"15 seconds\", \"1 hour\"], \"3.7 seconds\"],\n    \n    \"How does Algorand solve the blockchain trilemma?\": [[\"Mining\", \"Proof-of-Stake\", \"Scalability, security, decentralization\", \"Validators\"], \"Scalability, security, decentralization\"],\n    \n    \"How does Algorand handle transaction finality?\": [[\"Immediate finality\", \"Confirmation in 10 blocks\", \"Delayed finality\", \"Stochastic finality\"], \"Immediate finality\"],\n    \n    \"What is the main purpose of Algorand?\": [[\"Smart contracts\", \"NFT minting\", \"High-speed transactions\", \"DeFi\"], \"High-speed transactions\"],\n    \n    \"What is Algorand\u2019s approach to scalability?\": [[\"Sidechains\", \"Layer-2\", \"Sharding\", \"Efficient consensus\"], \"Efficient consensus\"],\n    \n    \"How does Algorand achieve low transaction costs?\": [[\"High gas fees\", \"Layer-2\", \"Efficient consensus\", \"Sharding\"], \"Efficient consensus\"],\n    \n    \"What feature allows Algorand to handle multiple transactions simultaneously?\": [[\"Parallel processing\", \"Atomic transfers\", \"Sharding\", \"Multi-threading\"], \"Atomic transfers\"],\n    \n    \"What is the Algorand Foundation\u2019s role?\": [[\"Funding and research\", \"Governance and development\", \"Marketing and promotion\", \"Community building\"], \"Governance and development\"],\n    \n    \"How does TEAL ensure smart contract security in Algorand?\": [[\"Formal verification\", \"Stack-based language\", \"Sandboxing\", \"Static analysis\"], \"Stack-based language\"],\n    \n    \"How does Algorand handle stateful vs. stateless smart contracts?\": [[\"Combined execution\", \"Separate execution environments\", \"Dynamic switching\", \"Hybrid approach\"], \"Separate execution environments\"],\n    \n    \"Explain Algorand\u2019s approach to optimizing transaction throughput in its protocol?\": [[\"Sharding\", \"Fast consensus and block finality\", \"Large block sizes\", \"Off-chain transactions\"], \"Fast consensus and block finality\"],\n    \n    \"What role do relay nodes play in Algorand\u2019s network architecture?\": [[\"Facilitate communication\", \"Validate transactions\", \"Store blockchain data\", \"Execute smart contracts\"], \"Facilitate communication\"],\n    \n    \"Discuss the role of Algorand\u2019s Virtual Machine (AVM) in executing contracts?\": [[\"Compiles TEAL code\", \"Executes TEAL scripts\", \"Manages state\", \"Verifies transactions\"], \"Executes TEAL scripts\"],\n    \n    \"Explain how atomic transfers are implemented in Algorand?\": [[\"Single transactions\", \"Grouped transactions\", \"Chained transactions\", \"Smart contracts\"], \"Grouped transactions\"],\n    \n    \"What are the engineering challenges in implementing Algorand Standard Assets (ASA)?\": [[\"Tokenization standards\", \"Custom asset creation\", \"Decentralized exchange\", \"Security audits\"], \"Custom asset creation\"],\n    \n    \"How does Algorand manage network latency and ensure consistency?\": [[\"Centralized servers\", \"Fast block propagation\", \"Caching mechanisms\", \"Redundant networks\"], \"Fast block propagation\"],\n    \n    \"What is the TEAL programming language used for in Algorand?\": [[\"Writing smart contracts\", \"Developing dApps\", \"Building blockchain infrastructure\", \"Creating cryptographic algorithms\"], \"Writing smart contracts\"],\n    \n    \"What are Algorand Smart Contracts (ASC1)?\": [[\"Off-chain contracts\", \"Layer-2 smart contracts\", \"Layer-1 smart contracts\", \"Hybrid smart contracts\"], \"Layer-1 smart contracts\"],\n    \n    \"What is an Algorand Standard Asset (ASA)?\": [[\"Native cryptocurrency\", \"Custom tokens framework\", \"Stablecoin protocol\", \"Decentralized exchange\"], \"Custom tokens framework\"],\n    \n    \"How does Algorand handle smart contract execution fees?\": [[\"Fixed fees\", \"Based on complexity\", \"Gas fees\", \"Transaction size\"], \"Based on complexity\"],\n    \n    \"What is a Stateful Smart Contract in Algorand?\": [[\"Stateless contract\", \"Maintains state\", \"Temporary contract\", \"Immutable contract\"], \"Maintains state\"],\n    \n    \"How are nodes incentivized in the Algorand network?\": [[\"Transaction fees\", \"Block rewards\", \"Staking rewards\", \"Mining rewards\"], \"Block rewards\"],\n    \n    \"What are the security implications of Algorand\u2019s PPoS model?\": [[\"Increases centralization risk\", \"Reduces centralization risk\", \"Vulnerable to 51% attacks\", \"Requires high energy consumption\"], \"Reduces centralization risk\"],\n    \n    \"What is Cryptographic Sortition in Algorand?\": [[\"Random number generation\", \"Selects consensus participants\", \"Encrypts transactions\", \"Verifies block integrity\"], \"Selects consensus participants\"],\n    \n    \"Can anyone participate in Algorand's consensus?\": [[\"Yes\", \"No\", \"Only selected nodes\", \"Only authorized participants\"], \"Yes\"],\n    \n    \"What year was Algorand launched?\": [[\"2017\", \"2018\", \"2019\", \"2020\"], \"2019\"]\n}\n\nchoice_content = \"[bold green]Choose an option you would like:\\n1. Option [red]Q&A[/red] \ud83e\udd16 you can interactive with AI really insteresting huh.\\n2. With [red]Game[/red] \ud83c\udfae we start the game explore 11 quests.\\n3. Let [red]Quiz[/red] \ud83d\udcd6 if you want to test your knowledge.\\n4. Or [red]Quit[/red] \ud83d\udc4c quit the game, your journey is over.[/bold green]\\nTell me what your choice\"\n\nafter_credits = \"\"\"\nThank you for playing AlgoRPG!\n\nWe hope you enjoyed your adventure through the world of Algorand and that the game helped you learn more about blockchain technology. Your feedback is valuable to us, so please let us know what you thought of your experience. Did you find the game helpful in understanding Algorand? What did you enjoy most? What could we improve?\n\nWe're constantly working to make AlgoRPG even better, so your input is greatly appreciated.\n\"\"\""}
{"file_path": "https://github.com/gwumex/choice/blob/0821bddd5da1f1a4c5710fb0c8372a857600f338/vote.py", "code": "# Open Source under Apache License\n\n\n\n# This code defines a decenteralized voting system on the Algorand Blockchain.\n\n# It uses Choice Coin, an Algorand Standard Asset, to record votes on a distributed ledger.\n\n# The system makes both efficiency and security a priority.\n\n# An escrow account holds the total number of Choice Coin required for the voting process, and Algorand accounts for each of the decisions are made.\n\n# Each of the individual decisions made by the voters connect back to the escrow account.\n\n# In turn, one Choice Coin transfers to the appropriate decision account through a stateless smart contract.\n\n# Furthermore, a SHA-512 hashing algorithm is used to encrypt voter information at all stages, ensuring that private information is made secure.\n\n# This is especially useful where voters need to give personal identification for verification purposes.\n\n\n\n# Imports and dependicies include the Algorand Python SDK, the Python Hashlib library, and the Python Matplotlib library.\n\nfrom algosdk import account, encoding, mnemonic, transaction\n\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\n\nfrom algosdk.v2client import algod\n\nimport hashlib\n\nimport matplotlib\n\nimport matplotlib.pyplot as plt\n\nimport random\n\nimport numpy as np\n\n\n\n# Matplot parameters for the matplotlib function to generate a new plot.\n\nmatplotlib.use('TkAgg')\n\n# Put Algod Client address here\n\nalgod_address = \"https://testnet-algorand.api.purestake.io/ps2\"\n\n# Put Algod Token here\n\nalgod_token = \"3nErwJTbc94LTx3AxczGBNymarZg6cF8gWTqiDIf\"\n\nheaders = {\"X-API-Key\": algod_token}\n\n# Initializes client for node.\n\nalgod_client = algod.AlgodClient(algod_token, algod_address, headers)\n\n\n\n# Escrow creation.\n\n# Put in main fund address here\n\n# Put in main fund receiver_mnemonic here\n\nescrow_address = \"\"\n\nescrow_mnemonic = \"\"\n\nescrow_key = mnemonic.to_private_key(escrow_mnemonic)\n\nchoice_id = 21364625  # Official Test Asset ID for Choice Coin\n\n\n\n# Decisions.\n\n# To add more decisions for the election process, add the address for the new decision here.\n\n# Then, add an appropriate boolean statement at line 100 of this file. Be sure to also add additional\n\n# counts at line 148 of this file as well.\n\ndecision_one = \"\"\n\ndecision_two = \"\"\n\ncorporate_decision_one = \"\"\n\ncorporate_decision_two = \"\"\n\n\n\n# Clawback Address required to reset accounts to start new voting process.\n\n# Sets up accounts for both the regular election process and the corporate decision process.\n\n# Add more accounts to adjust for more decisions.\n\nclawback_address = \"\"\n\nclawback_mnemonic = \"\"\n\nclawback_key = mnemonic.to_private_key(clawback_mnemonic)\n\n\n\n# This function counts the number of Choice Coin in an account.\n\n# It first fetches the account_info, and specifically searches among the assets that the account owns for Choice Coin.\n\n# It then returns the number of Choice Coin that the account owns.\n\n\n\n\n\ndef count(address):\n\n    message = ''\n\n    error = ''\n\n    # Fetch account information for the address.\n\n    account_info = algod_client.account_info(address)\n\n    assets = account_info.get(\"assets\")  # Fetch asset information.\n\n    for asset in assets:\n\n        # Iterate over assets until Choice Coin is reached. Return the amount if it exists.\n\n        if asset[\"asset-id\"] == choice_id:\n\n            amount = asset.get(\"amount\")\n\n            message = amount\n\n            return message\n\n    error = 'The account has not opted-in to the asset yet.'\n\n    return error\n\n\n\n# This function hashes a string using the SHA-512 cryptographic scheme.\n\n# SHA-512 is a post-quantum cryptographic scheme, thus ensuring that private information is made secure from malicious attackers.\n\n\n\n\n\ndef hashing(item):\n\n    # Assumes the default UTF-8.\n\n    # This encodes the string with the SHA-512 scheme.\n\n    hash_object = hashlib.sha512(item.encode())\n\n    # This returns the hexadecimal encode as a string.\n\n    item = hash_object.hexdigest()\n\n    return item\n\n\n\n# This function defines a stateless smart contract on the Algorand Network.\n\n# It sends Choice Coin to the appropriate destination address based on user input.\n\n\n\n\n\ndef choice_vote(sender, key, receiver, amount, comment):\n\n    parameters = algod_client.suggested_params()  # Sets suggested parameters\n\n    transaction = AssetTransferTxn(\n\n        sender, parameters, receiver, amount, choice_id, note=comment)\n\n    # Defines an inital transaction for Choice Coin\n\n    signature = transaction.sign(key)\n\n    # Signs the transaction with the senders private key\n\n    algod_client.send_transaction(signature)\n\n    # Sends the transaction with the signature\n\n    final = transaction.get_txid()\n\n    return True, final\n\n\n\n# This function describes a methodology for Electoral Voting on the Choice Coin platform.\n\n# It calls the choice_vote() function with the appropriate inputs based on which decision the voter selected.\n\n# It is currently defined for two candidates/decisions, but it can be easily amended to include more.\n\n\n\n\n\ndef election_voting(vote):\n\n    message = ''\n\n    # Add more boolean statements for more decisions or candidates.\n\n    if vote == 'YES':\n\n        # choice_vote() function called for \"YES\".\n\n        TX_ID = choice_vote(escrow_address, escrow_key,\n\n                            decision_one, 100, \"Tabulated using Choice Coin\")\n\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n\n            TX_ID[1] + \".\"\n\n        # AlgoExplorer returned for validation.\n\n    elif vote == 'NO':\n\n        TX_ID = choice_vote(escrow_address, escrow_key,\n\n                            decision_two, 100, \"Tabulated using Choice Coin\")\n\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n\n            TX_ID[1] + \".\"\n\n    return message\n\n\n\n# This defines a corporate voting mechanism using Choice Coin.\n\n# It works very similarly to the electoral voting scheme defined earlier.\n\n# However, it does introduce the stake as a new variable.\n\n# The stake defines the ownership stake of the shareholder that is voting.\n\n\n\n\n\ndef corporate_voting(vote, stake):\n\n    message = ''\n\n    stake = int(stake)  # Define the ownership stake.\n\n    amount = 100 * stake\n\n    if vote == 'YES':\n\n        comment = \"Tabulated using Choice Coin\"\n\n        choice_vote(escrow_address, escrow_key,\n\n                    corporate_decision_one, amount, comment)\n\n        # Call the choice_vote() function that sends the appropriate number of Choice Coin based on the ownership stake.\n\n        message = \"Ballot Tabulated\"\n\n    elif vote == 'NO':\n\n        comment = \"Tabulated using Choice Coin\"\n\n        choice_vote(escrow_address, escrow_key,\n\n                    corporate_decision_two, amount, comment)\n\n        message = \"Ballot Tabulated\"\n\n    return message\n\n\n\n# Returns a dynamic bar-graph showing the results of the vote.\n\n# Uses PyPlot for both corporate and electoral voting.\n\n\n\n\n\ndef show_results(yes_count, no_count):\n\n    names = ['Candidate 1', 'Candidate 2']  # Define the two decisions.\n\n    # Fetch the total number of votes for each decision.\n\n    values = [yes_count, no_count]\n\n    # Define a new pyplot\n\n    data = np.arange(4000).reshape((100,40))\n\n    plt.figure(figsize=(15, 6))\n\n    plt.subplot(131)\n\n    plt.bar(names, values)\n\n    plt.title('Election Results', fontdict = {'fontsize' : 20})\n\n    plt.savefig('static/img/Figure_1', bbox_inches='tight')\n\n   \n\n    # Return the results.\n\n\n\n\n\ndef show_corporate_results(yes_count, no_count):\n\n    names = ['Decision 1', 'Decision 2']\n\n    values = [yes_count, no_count]\n\n    plt.figure(figsize=(9, 3))\n\n    plt.subplot(131)\n\n    plt.bar(names, values)\n\n    plt.suptitle('Corporate Voting Results')\n\n    plt.savefig('/home/archie/Inital_Demo/static/img/Figure_2.png')\n\n\n\n# Counts the total number of votes to return a statement regarding which candidate has won.\n\n# Applies to both corporate and electoral voting.\n\n\n\n\n\ndef count_votes():\n\n    yes_count = int(count(decision_one)/100)\n\n    no_count = int(count(decision_two)/100)\n\n    show_results(yes_count, no_count)\n\n    if yes_count > no_count:\n\n        if yes_count == 1:\n\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} vote.\".format(yes_count)\n\n        else:\n\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} votes.\".format(yes_count)\n\n    if no_count > yes_count:\n\n        if no_count == 1:\n\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} vote.\".format(no_count)\n\n        else:\n\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} votes.\".format(no_count)\n\n\n\n    else:\n\n        # Random sample generated from adiabatic quantum computer.\n\n        # Generated using QunatumQuery.py.\n\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,\n\n                          0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n\n        # Random sample from quantum sample.\n\n        Q = random.choice(quantum_sample)\n\n        if Q:\n\n            return(\"Tie. The Quantum Oracle selects Candidate One!\")\n\n        else:\n\n            return(\"Tie. The Quantum Oracle selects Candidate Two!\")\n\n\n\n\n\ndef count_corporate_votes():\n\n    yes_count = count(corporate_decision_one)\n\n    no_count = count(corporate_decision_two)\n\n    show_corporate_results(yes_count, no_count)\n\n    if yes_count > no_count:\n\n        return \"The Voting Process has ended. Decision One had the most votes!\"\n\n    if no_count > yes_count:\n\n        return \"Decision Two had the most votes!\"\n\n    else:\n\n        # Random sample generated from adiabatic quantum computer.\n\n        # Generated using QunatumQuery.py.\n\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,\n\n                          0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n\n        # Random sample from quantum sample.\n\n        Q = random.choice(quantum_sample)\n\n        if Q:\n\n            return(\"Tie. The Quantum Oracle selects Decision One!\")\n\n        else:\n\n            return(\"Tie. The Quantum Oracle selects Decision Two!\")\n\n\n\n# This function resets the voting accounts to start a new voting process.\n\n# It uses the clawback functionality built into Choice Coin to send the Choice Coin back to the main escrow account.\n\n\n\n\n\ndef reset_votes():\n\n    message = ''\n\n#    params = algod_client.suggested_params()\n\n#    yes_count = count(decision_one)\n\n#    no_count = count(decision_two)\n\n    # Fetches the total number of Choice Coin in each account.\n\n#    if yes_count > 0:\n\n#        transaction_2 = AssetTransferTxn(\n\n#            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=decision_one)\n\n#        signature_2 = transaction_2.sign(clawback_key)\n\n#        algod_client.send_transaction(signature_2)\n\n        # Defines a clawback transaction to send Choice Coin back to the escrow account if the number of Choice Coin in the account exceeds zero.\n\n#    if no_count > 0:\n\n#        transaction_3 = AssetTransferTxn(\n\n#            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=decision_two)\n\n#        signature_3 = transaction_3.sign(clawback_key)\n\n#        algod_client.send_transaction(signature_3)\n\n    message = 'Vote accounts reset. New Voting Process started.'\n\n    return message\n\n\n\n\n\ndef reset_corporate_votes():\n\n    message = ''\n\n    params = algod_client.suggested_params()\n\n    yes_count = count(corporate_decision_one)\n\n    no_count = count(corporate_decision_two)\n\n    if yes_count > 0:\n\n        transaction_2 = AssetTransferTxn(\n\n            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=corporate_decision_one)\n\n        signature_2 = transaction_2.sign(clawback_key)\n\n        algod_client.send_transaction(signature_2)\n\n    if no_count > 0:\n\n        transaction_3 = AssetTransferTxn(\n\n            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=corporate_decision_two)\n\n        signature_3 = transaction_3.sign(clawback_key)\n\n        algod_client.send_transaction(signature_3)\n\n    message = 'Vote accounts reset. New Voting Process started.'\n\n    return message"}
{"file_path": "https://github.com/ChoiceCoin/Smart_Contracts/blob/785460d5ed406ef3fb7acfaeaa4cf2f8dd54cbfd/Smarter_Contracts_Bash/jessika_Smarter_Contracts_Bash/game.py", "code": "import random as r\nfrom algosdk import account, encoding, mnemonic,transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\n\n#This is an Algogenous Smart Contract for a guessing game where if  the user wins he/she gets a reward of a particular amount of a token of your choice and if the player loses he/she loses that same amount of a token of your choice \n#Connect to the Algorand Client (This is for sandbox) here. \nalgod_address = \"http://localhost:4001\"\nalgod_token = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n#Initializes Client for node\nheaders = {\"X-API-Key\": algod_token }\nalgod_client = algod.AlgodClient(algod_token,algod_address,headers)\n\n\n#The fund address and fund mnemonic defined below should belong to the creator account that controls the asset that you want to offer.\n\n#In this code I created an ASA TEE COIN on the testnet which I used to reward the user, but you can decide to change it up and use your own asa with a diffrent address and passphrase\n\n#The address I used is  KE3P22YHKMC23OHDPYIMGVG7DHA6GP6T6DBROYRTZX3RQJ73Y2EFM5OEO4\n#The passphrase  is : light truck alley era debris mango country lake solution impact captain casual steel mechanic coil ceiling exhibit reject skirt february apart parent master able random\n#Warning !!!! This is solely for development purposes and the tokens have 0 value.\n\ncreator_address = \"KE3P22YHKMC23OHDPYIMGVG7DHA6GP6T6DBROYRTZX3RQJ73Y2EFM5OEO4\" #Put the creator address here. \ncreator_mnemonic = \"light truck alley era debris mango country lake solution impact captain casual steel mechanic coil ceiling exhibit reject skirt february apart parent master able random\" #Put the creator mnemonic here. \nfund_key = mnemonic.to_private_key(creator_mnemonic)\n\n#Asset ID for Tee Coin\nasset_id = \"88713385\"\n\n#Welocome Screen\n#This prompts the user to input his/her name,testnet address with sufficent algos and the required asa, and their passpharase\nprint(\"WELCOME TO THE PRICE IS RIGHT \\nGUESS THE RIGHT NUMBER AND GET A CHANCE TO WIN ANY AMOUNT TEECOIN\\n---------DISCLAIMER---------\\nYOU CAN ALSO LOSE THAT AMOUNT OF TEECOIN IF YOU DONT GUESS RIGHT.\")\nuser_name = input('Type your name : ').title()\nprint(f'Hello {user_name}.')\nuser_said = input(f'{user_name} do you want to play Number Guessing game (Y/N) : ').lower()\n\nwhile True:\n    try: \n        user_wage =int(input(\"ENTER THE AMOUNT OF TEECOIN YOU WANT TO WAGER: \"))\n\n    \n\n    except ValueError:\n        print(\"THIS IS NOT A NUMBER\")\n        continue\n    else:\n        break\n        \n\nuser_address = input(\"\\n ENTER YOUR TESTNET ADDRESS WITH SUFFICIENT TESTNET ALGOS: \")\nuser_key = input(\"\\n PASTE YOUR PASSPHRASE IN THE CORRECT SYNTAX: \")\nreciver_address = user_address\nreciver_mnemonic = user_key\nreciver_key = mnemonic.to_private_key(reciver_mnemonic)\namount = int(user_wage) * 100 \namount2 = amount / 100 \nindex = asset_id\n\n\n\n\n\n\n#This defines a stateless transfer of funds from the creator account  to the user account.  \ndef asset_transfer_fund(creator_address, fund_key, reciver_address,amount, index = asset_id):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(creator_address, parameters, reciver_address, amount, index =  asset_id )\n    signature = transaction.sign(fund_key)\n    #Signs the transaction\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    print(\"TRANSACTION ID : \" ,final)\n    return True, final\n\n#This defines a stateless transfer of funds from the  user account to the creator account. \ndef asset_transfer_user(reciver_address, reciver_key, creator_address, amount, index = asset_id):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(reciver_address, parameters, creator_address, amount, index =  asset_id )\n    signature = transaction.sign(reciver_key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    print(\"TRANSACTION ID : \",final)\n    return True, final\n\n#This automates the optin action so the user can recieve the token\ndef optin(reciver_mnemonic,reciver_address,amount,index):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(reciver_address, parameters, reciver_address, 0, index = asset_id)\n    key = mnemonic.to_private_key(reciver_mnemonic)\n    signature = transaction.sign(key)\n    algod_client.send_transaction(signature)\n    #Opts-in the account to the asset\n    return True\n\n\n\n\n#This defines the game logic\ndef Main(user_said):\n\n    while True:\n        \n\n        if ('y' not in user_said) and ('n' not in user_said) and (user_said != True):\n            user_said = input('Invalid keyword\\nType again : ').lower()\n\n        elif 'y' in user_said:\n            winning_number = r.randint(1,100)\n            user_guessed = int(input('\\nYou have 6 guesses.\\nGuess any number between 1 and 100\\nGuess the number : '))\n            turn = 1\n\n            while True:\n            \n                if winning_number == user_guessed:\n                    print(f'Congrats you guessed the number in {turn} times.')\n                    \n                    return 1\n                    \n\n                elif turn == 6:\n                    print(f'Sorry You can\\'t guess the number. The number is {winning_number}.')\n                    return 0\n                   \n\n                else:\n                    if winning_number > user_guessed:\n                        print('Too Low')\n                    else:\n                        print('Too High')\n\n                    print(f'You have {6-turn} guesses left.')\n                    \n                    turn += 1\n                    user_guessed = int(input('Guess again : '))\n\n        \n\n#This checks if the user wins or loses and calls the respective functions to carry out the appropriate transaction which prints out the transaction id which can be verified on algoexplorer.\nif Main(user_said) == 1:\n    print(\"YOU WON\" ,amount2, \" TeeCoin\" )\n    optin(reciver_mnemonic,reciver_address,amount,index)\n    asset_transfer_fund(creator_address, fund_key, reciver_address,amount, index = asset_id)\nelse :\n    print(\"YOU LOST\",amount2, \" TeeCoin\" )\n    optin(reciver_mnemonic,reciver_address,amount,index)\n    asset_transfer_user(reciver_address, reciver_key, creator_address, amount, index = asset_id)"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/fee_check.py", "code": "\"\"\"Detector for finding execution paths missing Fee check.\"\"\"\n\nfrom typing import List, TYPE_CHECKING, Tuple\n\nfrom tealer.detectors.abstract_detector import (\n    AbstractDetector,\n    DetectorClassification,\n    DetectorType,\n)\nfrom tealer.detectors.utils import (\n    detect_missing_tx_field_validations_group,\n    detect_missing_tx_field_validations_group_complete,\n)\nfrom tealer.utils.algorand_constants import MAX_TRANSACTION_COST\nfrom tealer.utils.output import ExecutionPaths\n\nif TYPE_CHECKING:\n    from tealer.utils.output import ListOutput\n    from tealer.teal.basic_blocks import BasicBlock\n    from tealer.teal.context.block_transaction_context import BlockTransactionContext\n    from tealer.teal.teal import Teal\n\n\nclass MissingFeeCheck(AbstractDetector):  # pylint: disable=too-few-public-methods\n    \"\"\"Detector to find execution paths missing Fee check.\n\n    The fee for stateless contract transactions will be deducted\n    from the contract account or the LogicSig signer account. An\n    attacker could set the fee to high value and drain the account\n    funds in form of fees.\n\n    This detector tries to find execution paths that approve the algorand\n    transaction(\"return 1\") and doesn't check the Fee field.\n    \"\"\"\n\n    NAME = \"missing-fee-check\"\n    DESCRIPTION = \"Missing Fee Field Validation\"\n    TYPE = DetectorType.STATELESS\n\n    IMPACT = DetectorClassification.HIGH\n    CONFIDENCE = DetectorClassification.HIGH\n\n    WIKI_URL = (\n        \"https://github.com/crytic/tealer/wiki/Detector-Documentation#missing-fee-field-validation\"\n    )\n    WIKI_TITLE = \"Missing Fee Field Validation\"\n    WIKI_DESCRIPTION = (\n        \"LogicSig does not validate `Fee` field.\"\n        \" Attacker can submit a transaction with `Fee` field set to large value and drain the account balance.\"\n        \" More at [building-secure-contracts/not-so-smart-contracts/algorand/unchecked_transaction_fee]\"\n        \"(https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/algorand/unchecked_transaction_fee)\"\n    )\n    WIKI_EXPLOIT_SCENARIO = \"\"\"\n```py\ndef withdraw(...) -> Expr:\n    return Seq(\n        [\n            Assert(\n                And(\n                    Txn.type_enum() == TxnType.Payment,\n                    Txn.first_valid() % period == Int(0),\n                    Txn.last_valid() == Txn.first_valid() + duration,\n                    Txn.receiver() == receiver,\n                    Txn.amount() == amount,\n                    Txn.first_valid() < timeout,\n                )\n            ),\n            Approve(),\n        ]\n    )\n```\n\nAlice signs the logic-sig to allow recurring payments to Bob.\\\n Eve uses the logic-sig and submits a valid transaction with `Fee` set to 1 million ALGOs.\\\n Alice loses 1 million ALGOs.\n\"\"\"\n\n    WIKI_RECOMMENDATION = \"\"\"\nValidate `Fee` field in the LogicSig.\n\"\"\"\n\n    def detect(self) -> \"ListOutput\":\n        \"\"\"Detect execution paths with missing Fee check.\n\n        Returns:\n            ExecutionPaths instance containing the list of vulnerable execution\n            paths along with name, check, impact, confidence and other detector\n            information.\n        \"\"\"\n\n        def checks_field(block_ctx: \"BlockTransactionContext\") -> bool:\n            # returns True if fee is bounded by some unknown value\n            # or is bounded by some known value less than maximum transaction cost.\n            return block_ctx.max_fee_unknown or block_ctx.max_fee <= MAX_TRANSACTION_COST\n\n        # there should be a better to decide which function to call ??\n        if self.tealer.output_group:\n            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:\n            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance\n            return list(\n                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)\n            )\n\n        output: List[\n            Tuple[\"Teal\", List[List[\"BasicBlock\"]]]\n        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)\n        detector_output: \"ListOutput\" = []\n        for contract, vulnerable_paths in output:\n            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))\n\n        return detector_output"}
{"file_path": "https://github.com/ChoiceCoin/Choice-V1/blob/6597152bea3dc46545d7c969b76ead8d1ebf7c9d/contracts/Democratic_Rewards.py", "code": "#Stateless Smart Contracts on the Algorand Blockhain to send rewards for Democratic Participation.\n#Choice Coin seeks to provide rewards to its community for participating in their local democracy.\n#The inagaural democratic rewards program will focus on the advocacy for blockchain and cryptocurrency acceptance.\n\n  \nfrom algosdk import account, encoding, mnemonic,transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\n\n\nalgod_address = \"\"\nalgod_token = \"\"\n# Initializes Client for node\nheaders = {\"X-API-Key\": algod_token }\nalgod_client = algod.AlgodClient(algod_token,algod_address,headers)\nreserve_address = \"\" # Put in main fund address here\nreserve_mnemonic = \"\" # Put in main fund receiver_mnemonic here\nreserve_key = mnemonic.to_private_key(reserve_mnemonic)\nasset_id =  # Probably will want to change if when we create a new asset\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\n\ndef init_democratic_participation():\n    parameters = algod_client.suggested_params()\n    choice_trade(reserve_address,reserve_key,participation_awards,\"Value\",asset_id,'Initial Democratic Participation Rewards')\n\n\ndef democratic_awards(query,address):\n    if query == 'Letter to local legistature':\n        comment = 'Here is your Choice Coin Reward. \\n Thanks for sending a letter to your local government'\n        reward_amount = \"\"#Amount of Reward\n        choice_trade(fund_address, fund_key, address, reward_amount, asset_id,comment)\n    else:\n        comment = \"Here is you Choice Coin Reward! \\n Thanks for participating in our democracy!\"\n        reward_amount = \"\"#Amount of Reward\n        choice_trade(fund_address, fund_key, address, reward_amount, asset_id,comment)"}
{"file_path": "https://github.com/arty-arty/thefairrandomizer/blob/aa040d0fd50fe85a7e640a05a0b1419490b8a1ff/contract/mainWithNumber.py", "code": "import base64\nfrom email import message\n\nfrom algosdk.future import transaction\nfrom algosdk import mnemonic\nfrom algosdk.v2client import algod\nfrom pyteal import *\nfrom pytealutils.strings import atoi\n\nsender_mnemonic = \"paste your own mnemonic here\"\nreceiver_public_key = \"UFAGBH5BHBAKDSSSBKP6LAZ7VFIA3ETNK7LVNEH6KXRRNTYE6WYHTEMEGU\"\nfee_provider_public_key = \"I4P7CYNN2S24FJ546IS76M2RJDIAAHJ6CHF7MGH3RBJAPFSDZNNZDRGRSE\"\n#algod_address = \"http://localhost:4001\"\n#algod_token = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\nalgod_address = \"https://node.testnet.algoexplorerapi.io\"\nalgod_token = \"\"\n\n\ndef compile_smart_signature(client, source_code):\n    compile_response = client.compile(source_code)\n    return compile_response['result'], compile_response['hash']\n\n\ndef wait_for_confirmation(client, transaction_id, timeout):\n    start_round = client.status()[\"last-round\"] + 1\n    current_round = start_round\n\n    while current_round < start_round + timeout:\n        try:\n            pending_txn = client.pending_transaction_info(transaction_id)\n        except Exception:\n            return\n        if pending_txn.get(\"confirmed-round\", 0) > 0:\n            return pending_txn\n        elif pending_txn[\"pool-error\"]:\n            raise Exception('pool error: {}'.format(pending_txn[\"pool-error\"]))\n        client.status_after_block(current_round)\n        current_round += 1\n    raise Exception(\n        'pending tx not found in timeout rounds, timeout value = {}'.format(timeout))\n\n#{\"blockSeedTakenFromBlockWithId\": \"25010658\", \"publicKey\": \"40ps3+H7aCMHsosRXB8D/cT/T/SyErbpVVYjI9/SxcY=\", \"randNumber\": \"230\", \"proof\": \"5rQ79zemy800T2Gze6Lf6E+u3S/+6W0RwHOOBXlFHnolsHKJzHlXABlOf0ZBdSUFdTYyznEpj4MOpJCZX9NMgFajlpwHPRbp8Oa7E5hAswI=\"}\n\n\ndef verified_random_announcer(benefactor, feeprovider):\n    #fee_cond = Txn.fee() <= Global.min_txn_fee()\n    fee_cond = Gtxn[0].fee() == Int(0)\n    safety_cond = And(\n        Global.group_size() == Int(2),\n        Gtxn[0].type_enum() == TxnType.Payment,\n        Gtxn[0].close_remainder_to() == Global.zero_address(),\n        Gtxn[0].asset_close_to() == Global.zero_address(),\n        Gtxn[0].rekey_to() == Global.zero_address(),\n        Gtxn[0].amount() == Int(0),\n        Gtxn[1].type_enum() == TxnType.Payment,\n        Gtxn[1].close_remainder_to() == Global.zero_address(),\n        Gtxn[1].asset_close_to() == Global.zero_address(),\n        Gtxn[1].rekey_to() == Global.zero_address(),\n        Gtxn[1].amount() == Int(0),\n    )\n\n    futureBlockId = JsonRef.as_uint64(\n        Txn.note(), Bytes(\"blockSeedTakenFromBlockWithId\"))\n    blockSeed = Block.seed(futureBlockId)\n    #message = Sha256(blockSeed)\n    message = blockSeed\n    proof = Base64Decode.std(JsonRef.as_string(\n        Txn.note(), Bytes(\"proof\")))\n    randNumber0 = JsonRef.as_uint64(\n        Txn.note(), Bytes(\"randNumber\"))\n\n    publicKey = Base64Decode.std(JsonRef.as_string(\n        Txn.note(), Bytes(\"publicKey\")))\n\n    program = And(\n        Gtxn[1].sender() == Addr(feeprovider),\n        Gtxn[1].receiver() == Addr(feeprovider),\n        randNumber0 == GetByte(proof, Int(0)),\n        #blockSeed == actualBlockSeed,\n        VrfVerify.algorand(message, proof, publicKey).outputReducer(\n            lambda x, y: y == Int(1))\n    )\n    safe_program = And(fee_cond, safety_cond, program)\n    return compileTeal(safe_program, Mode.Signature, version=7)\n\n\ndef payment_transaction(creator_mnemonic, amt, rcv, algod_client):\n    params = algod_client.suggested_params()\n    add = mnemonic.to_public_key(creator_mnemonic)\n    key = mnemonic.to_private_key(creator_mnemonic)\n    unsigned_txn = transaction.PaymentTxn(\n        add, params, rcv, amt, note=\"Yeah\".encode())\n    signed = unsigned_txn.sign(key)\n    txid = algod_client.send_transaction(signed)\n    pmtx = wait_for_confirmation(algod_client, txid, 5)\n    return pmtx\n\n\n#{\"blockSeed\": \"3P5WUDZKFHH7BLSYJYZUGJ5KLCFO72M7733MVWAE5JXD7N7MY54A\", \"proof\": \"bICa1Ajt27oTDzMf5O02vdfuYNvfBBAsrqr8f05jh0vuqTfHy7yV+82QRCw52erX6rlhzZ6Pdv8XyhWZTvOG4eksdNN6QhAYZyJo408wYgs=\", \"publicKey\": \"H/IBtJ8dSMRjYo344o/gtfiZToq9+cfPOHtCG6dfZ/U=\", \"randNumber\": \"087\"}\n\n\ndef lsig_payment_txn(escrowProg, escrow_address, amt, rcv, algod_client):\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(\n        escrow_address, params, rcv, amt, note='''{\"blockSeed\": \"3P5WUDZKFHH7BLSYJYZUGJ5KLCFO72M7733MVWAE5JXD7N7MY54A\", \"proof\": \"bICa1Ajt27oTDzMf5O02vdfuYNvfBBAsrqr8f05jh0vuqTfHy7yV+82QRCw52erX6rlhzZ6Pdv8XyhWZTvOG4eksdNN6QhAYZyJo408wYgs=\", \"publicKey\": \"H/IBtJ8dSMRjYo344o/gtfiZToq9+cfPOHtCG6dfZ/U=\"}'''.encode())\n    encodedProg = escrowProg.encode()\n    program = base64.decodebytes(encodedProg)\n    lsig = transaction.LogicSig(program)\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\ndef main():\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n    print(\"--------------------------------------------\")\n    print(\"Compiling Donation Smart Signature ...\")\n    stateless_program_teal = verified_random_announcer(\n        receiver_public_key, fee_provider_public_key)\n    escrow_result, escrow_address = compile_smart_signature(\n        algod_client, stateless_program_teal)\n    print(\"Program:\", escrow_result)\n    print(\"Contract Address:\", escrow_address)\n\n    # print(\"--------------------------------------------\")\n    #print(\"Sending Fund to Donation Smart Signature ...\")\n    #amt = 220000\n    #payment_transaction(sender_mnemonic, amt, escrow_address, algod_client)\n\n    # print(\"--------------------------------------------\")\n    #print(\"Withdraw from Donation Smart Signature ...\")\n    #withdrawal_amt = 0\n    # lsig_payment_txn(escrow_result, escrow_address,\n    #                withdrawal_amt, receiver_public_key, algod_client)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"file_path": "https://github.com/ChoiceCoin/Algorand-Protocol/blob/1f920b76c6c31eff23ed07b2248aabee32c821ae/AtomicTransfers/MoonX_Atomic_Transfer_Bash/transfer.py", "code": "import os , json\nimport easygui\n\nfrom algosdk import account, mnemonic \nfrom algosdk.v2client import algod\nfrom algosdk.future import transaction\n\nmn1 = 'shuffle speed split bread mansion limb daughter destroy minimum town pistol slam leaf slide potato mule alpha furnace glass humble ladder kiss eight abandon gasp'\nmn2 = 'hazard dust join live water venue few grant neglect road illegal sad mammal demand often must infant horn magic piano goat exchange deny ability tag'\n\ndef createAccount():\n    private_key, address = account.generate_account()\n    print(\"Receiver address: {}\".format(address))\n    print(\"Receivers mnemonic passphrase: {}\".format(mnemonic.from_private_key(private_key)))\n    return private_key, address\n\ndef get_address(mn):\n    pk_account_a = mnemonic.to_private_key(mn)\n    address = account.address_from_private_key(pk_account_a)\n    print(\"Address :\", address)\n    return address\n\ndef getInfo(algod_client, addr):\n    try:\n        accountInfo = algod_client.account_info(addr)\n        return accountInfo\n    except Exception as e:\n        print(\"Error Occured {}\".format(str(e)))\n        exit()\n\n\ndef printAccount(account_info_1, account_info_2, indent=4):\n    try:\n        data = [[account_info_1['address'], account_info_1['amount'] / 1000000],\n                [account_info_2['address'], account_info_2['amount'] / 1000000]]\n        format_row = \"{:<2}{:>12}\"\n        print(\"{:<60} {:<15}\".format(\"Address\",\"Amount(Algo)\"))\n        for account in data:\n            print(format_row.format(*account))\n        print(\"\")\n    except Exception as e:\n        print(\"Error Occur: \" + str(e))\n\n\ndef transfer():\n    try:\n        print(\"########### CHOICE-COIN ATOMIC TRANSFER ##################\")\n           # user declared algod connection parameters\n        algod_address = \"https://testnet-algorand.api.purestake.io/ps2\"\n        algod_token = \"HfiEnjsWGW28EEEdqURGt40hxXT3hVSs6nkGAr9Y\"\n        headers = {\"X-API-Key\": algod_token }\n\n\n        # Initialize an algodClient\n        algod_client = algod.AlgodClient(algod_token, algod_address, headers)\n\n        account_1 = get_address(mn1)\n        account_2 = get_address(mn2)\n\n        account_1_key = mnemonic.to_private_key(mn1)\n        account_2_key = mnemonic.to_private_key(mn2)\n        print('Getting account information....')\n        account_1_info = getInfo(algod_client, account_1)\n        account_2_info = getInfo(algod_client, account_2)\n        printAccount(account_1_info, account_2_info)\n\n\n        print('Generating receivers account...')\n        acount_3_key, account_3 = createAccount()\n\n        amount = easygui.enterbox(\"Algo amount\")\n        amount = int(amount) * 1000000\n        print(\"Creating transactions...\")\n        params = algod_client.suggested_params()\n        txn_1 = transaction.PaymentTxn(account_1, params, account_3, amount)\n        txn_2 = transaction.PaymentTxn(account_2, params, account_3, amount)\n        print('Calculating Group ID...')\n        gid = transaction.calculate_group_id([txn_1, txn_2])\n        txn_1.group = gid\n        txn_2.group = gid\n\n        print('Signing transaction....')\n        stxn_1 = txn_1.sign(account_1_key)\n        stxn_2 = txn_2.sign(account_2_key)\n        signed_group = [stxn_1, stxn_2]\n        print('Sending Transaction')\n        tx_id = algod_client.send_transactions(signed_group)\n        print(\"TransactionId: {}\".format(tx_id))\n        confirmed_txn = transaction.wait_for_confirmation(algod_client, tx_id)\n        print(\"Transaction confirmed\")\n        print(f'Visit https://testnet.algoexplorer.io/tx/{tx_id}')\n        print(\"Transaction information: {}\\n\".format(json.dumps(confirmed_txn)))\n    except Exception as e:\n        print(\"Error occured: \" + str(e))\n\n\n\n\nif __name__ == '__main__':\n    transfer()"}
{"file_path": "https://github.com/algorandfoundation/algokit-cli/blob/d7fdc1207d443c056d5bf6a616ec01b253ea25e2/src/algokit/cli/tasks/transfer.py", "code": "import logging\n\nimport click\nfrom algokit_utils import AlgoAmount, AssetTransferParams, PaymentParams, SendAtomicTransactionComposerResults\n\nfrom algokit.cli.common.constants import AlgorandNetwork, ExplorerEntityType\nfrom algokit.cli.common.utils import get_explorer_url\nfrom algokit.cli.tasks.utils import (\n    get_account_with_private_key,\n    get_address,\n    get_asset_decimals,\n    load_algod_client,\n    validate_address,\n    validate_balance,\n)\nfrom algokit.core.utils import get_algorand_client_for_network\n\nlogger = logging.getLogger(__name__)\n\n# TODO: upon algokit nfd lookup being implemented receiver will also allow nfd lookups\n\n\n@click.command(name=\"transfer\", help=\"\"\"Transfer algos or assets from one account to another.\"\"\")\n@click.option(\"--sender\", \"-s\", type=click.STRING, help=\"Address or alias of the sender account.\", required=True)\n@click.option(\n    \"--receiver\",\n    \"-r\",\n    type=click.STRING,\n    help=\"Address or alias to an account that will receive the asset(s).\",\n    required=True,\n)\n@click.option(\n    \"--asset\",\n    \"--id\",\n    \"asset_id\",\n    type=click.INT,\n    help=\"Asset ID to transfer. Defaults to 0 (Algo).\",\n    default=0,\n    required=False,\n)\n@click.option(\"--amount\", \"-a\", type=click.INT, help=\"Amount to transfer.\", required=True)\n@click.option(\n    \"--whole-units\",\n    \"whole_units\",\n    is_flag=True,\n    type=click.BOOL,\n    help=(\n        \"Use whole units (Algos | ASAs) instead of smallest divisible units (for example, microAlgos). \"\n        \"Disabled by default.\"\n    ),\n    default=False,\n    required=False,\n)\n@click.option(\n    \"-n\",\n    \"--network\",\n    type=click.Choice([choice.value for choice in AlgorandNetwork]),\n    default=AlgorandNetwork.LOCALNET,\n    required=False,\n    help=f\"Network to use. Refers to `{AlgorandNetwork.LOCALNET}` by default.\",\n)\ndef transfer(  # noqa: PLR0913\n    *,\n    sender: str,\n    receiver: str,\n    asset_id: int,\n    amount: int,\n    whole_units: bool,\n    network: AlgorandNetwork,\n) -> None:\n    # Load addresses and accounts from mnemonics or aliases\n    sender_account = get_account_with_private_key(sender)\n    receiver_address = get_address(receiver)\n\n    # Get algod client\n    algod_client = load_algod_client(network)\n\n    # Convert amount to whole units if specified\n    if whole_units:\n        amount = amount * (10 ** get_asset_decimals(asset_id, algod_client))\n\n    # Validate inputs\n    validate_address(receiver_address)\n    validate_balance(algod_client, sender_account, asset_id, amount)\n    validate_balance(algod_client, receiver_address, asset_id)\n\n    # Transfer algos or assets depending on asset_id\n    txn_response: SendAtomicTransactionComposerResults | None = None\n    algorand = get_algorand_client_for_network(network)\n    try:\n        if asset_id == 0:\n            txn_response = (\n                algorand.new_group()\n                .add_payment(\n                    PaymentParams(\n                        sender=sender_account.address,\n                        receiver=receiver_address,\n                        amount=AlgoAmount(micro_algo=amount),\n                        signer=sender_account.signer,\n                    )\n                )\n                .send()\n            )\n        else:\n            txn_response = (\n                algorand.new_group()\n                .add_asset_transfer(\n                    AssetTransferParams(\n                        sender=sender_account.address,\n                        receiver=receiver_address,\n                        amount=amount,\n                        asset_id=asset_id,\n                        signer=sender_account.signer,\n                    ),\n                )\n                .send()\n            )\n\n        txn_url = get_explorer_url(\n            identifier=txn_response.tx_ids[0],\n            network=network,\n            entity_type=ExplorerEntityType.TRANSACTION,\n        )\n        click.echo(f\"Successfully performed transfer. See details at {txn_url}\")\n\n    except Exception as err:\n        logger.debug(err, exc_info=True)\n        raise click.ClickException(\"Failed to perform transfer\") from err"}
{"file_path": "https://github.com/manicdon7/algorand/blob/c12ccc8b6be34ae27fe836d267cdf66e25740079/.venv/Lib/site-packages/algokit_utils/_transfer.py", "code": "import dataclasses\nimport logging\nfrom typing import TYPE_CHECKING\n\nimport algosdk.transaction\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner\nfrom algosdk.transaction import AssetTransferTxn, PaymentTxn, SuggestedParams\n\nfrom algokit_utils.models import Account\n\nif TYPE_CHECKING:\n    from algosdk.v2client.algod import AlgodClient\n\n__all__ = [\"TransferParameters\", \"transfer\", \"TransferAssetParameters\", \"transfer_asset\"]\nlogger = logging.getLogger(__name__)\n\n\n@dataclasses.dataclass(kw_only=True)\nclass TransferParametersBase:\n    \"\"\"Parameters for transferring \u00b5ALGOs between accounts\n\n    Args:\n        from_account (Account | AccountTransactionSigner): The account (with private key) or signer that will send\n            the \u00b5ALGOs\n        to_address (str): The account address that will receive the \u00b5ALGOs\n        suggested_params (SuggestedParams | None): (optional) transaction parameters\n        note (str | bytes | None): (optional) transaction note\n        fee_micro_algos (int | None): (optional) The flat fee you want to pay, useful for covering extra fees in a\n            transaction group or app call\n        max_fee_micro_algos (int | None): (optional) The maximum fee that you are happy to pay (default: unbounded)\n            - if this is set it's possible the transaction could get rejected during network congestion\n    \"\"\"\n\n    from_account: Account | AccountTransactionSigner\n    to_address: str\n    suggested_params: SuggestedParams | None = None\n    note: str | bytes | None = None\n    fee_micro_algos: int | None = None\n    max_fee_micro_algos: int | None = None\n\n\n@dataclasses.dataclass(kw_only=True)\nclass TransferParameters(TransferParametersBase):\n    \"\"\"Parameters for transferring \u00b5ALGOs between accounts\"\"\"\n\n    micro_algos: int\n\n\n@dataclasses.dataclass(kw_only=True)\nclass TransferAssetParameters(TransferParametersBase):\n    \"\"\"Parameters for transferring assets between accounts\n\n    Args:\n       asset_id (int): The asset id that will be transfered\n       amount (int): The amount to send\n       clawback_from (str | None): An address of a target account from which to perform a clawback operation. Please\n           note, in such cases senderAccount must be equal to clawback field on ASA metadata.\n    \"\"\"\n\n    asset_id: int\n    amount: int\n    clawback_from: str | None = None\n\n\ndef _check_fee(transaction: PaymentTxn | AssetTransferTxn, max_fee: int | None) -> None:\n    if max_fee is not None:\n        # Once a transaction has been constructed by algosdk, transaction.fee indicates what the total transaction fee\n        # Will be based on the current suggested fee-per-byte value.\n        if transaction.fee > max_fee:\n            raise Exception(\n                f\"Cancelled transaction due to high network congestion fees. \"\n                f\"Algorand suggested fees would cause this transaction to cost {transaction.fee} \u00b5ALGOs. \"\n                f\"Cap for this transaction is {max_fee} \u00b5ALGOs.\"\n            )\n        if transaction.fee > algosdk.constants.MIN_TXN_FEE:\n            logger.warning(\n                f\"Algorand network congestion fees are in effect. \"\n                f\"This transaction will incur a fee of {transaction.fee} \u00b5ALGOs.\"\n            )\n\n\ndef transfer(client: \"AlgodClient\", parameters: TransferParameters) -> PaymentTxn:\n    \"\"\"Transfer \u00b5ALGOs between accounts\"\"\"\n\n    params = parameters\n    params.suggested_params = parameters.suggested_params or client.suggested_params()\n    from_account = params.from_account\n    sender = _get_address(from_account)\n    transaction = PaymentTxn(\n        sender=sender,\n        receiver=params.to_address,\n        amt=params.micro_algos,\n        note=params.note.encode(\"utf-8\") if isinstance(params.note, str) else params.note,\n        sp=params.suggested_params,\n    )  # type: ignore[no-untyped-call]\n\n    result = _send_transaction(client=client, transaction=transaction, parameters=params)\n    assert isinstance(result, PaymentTxn)\n    return result\n\n\ndef transfer_asset(client: \"AlgodClient\", parameters: TransferAssetParameters) -> AssetTransferTxn:\n    \"\"\"Transfer assets between accounts\"\"\"\n\n    params = parameters\n    params.suggested_params = parameters.suggested_params or client.suggested_params()\n    sender = _get_address(parameters.from_account)\n    suggested_params = parameters.suggested_params or client.suggested_params()\n    xfer_txn = AssetTransferTxn(\n        sp=suggested_params,\n        sender=sender,\n        receiver=params.to_address,\n        close_assets_to=None,\n        revocation_target=params.clawback_from,\n        amt=params.amount,\n        note=params.note,\n        index=params.asset_id,\n        rekey_to=None,\n    )  # type: ignore[no-untyped-call]\n\n    result = _send_transaction(client=client, transaction=xfer_txn, parameters=params)\n    assert isinstance(result, AssetTransferTxn)\n    return result\n\n\ndef _send_transaction(\n    client: \"AlgodClient\",\n    transaction: PaymentTxn | AssetTransferTxn,\n    parameters: TransferAssetParameters | TransferParameters,\n) -> PaymentTxn | AssetTransferTxn:\n    if parameters.fee_micro_algos:\n        transaction.fee = parameters.fee_micro_algos\n\n    if parameters.suggested_params is not None and not parameters.suggested_params.flat_fee:\n        _check_fee(transaction, parameters.max_fee_micro_algos)\n\n    signed_transaction = transaction.sign(parameters.from_account.private_key)  # type: ignore[no-untyped-call]\n    client.send_transaction(signed_transaction)\n\n    txid = transaction.get_txid()  # type: ignore[no-untyped-call]\n    logger.debug(f\"Sent transaction {txid} type={transaction.type} from {_get_address(parameters.from_account)}\")\n\n    return transaction\n\n\ndef _get_address(account: Account | AccountTransactionSigner) -> str:\n    if type(account) is Account:\n        return account.address\n    else:\n        address = address_from_private_key(account.private_key)  # type: ignore[no-untyped-call]\n        return str(address)"}
{"file_path": "https://github.com/Ganainmtech/Algorand_Bytes/blob/6d78e8afabc809164c366607e1a9892af80c6750/localnet_examples/Intermediate/00_atomicTransfer.py", "code": "'''\nThis script demonstrates how to execute multiple transactions atomically, ensuring all transactions in a group either succeed or fail together.\n\nThis is where you would include any setup code needed, such as:\n\n- Import the necessary libraries and modules:\n  from algokit_utils.beta.algorand_client import *\n- Generate Algorand Accounts\n- Fund the accounts\n\nYou can find all the foundational code in the 'Beginner' folder.\n'''\n\n# Initialize the Algorand Client\nalgorand = AlgorandClient.default_local_net()\n\n# Group transactions for atomic transfer\ngroup_tx = algorand.new_group()\n\n# Add the first payment transaction to the group\ngroup_tx.add_payment(\n    PayParams(\n        sender=receiver_one.address,   # Address of the first sender\n        receiver=receiver_two.address, # Address of the first receiver\n        amount=1_000_000               # Amount to transfer (in microAlgos)\n    ))\n\n# Add the second payment transaction to the group\ngroup_tx.add_payment(\n    PayParams(\n        sender=receiver_two.address,   # Address of the second sender\n        receiver=receiver_one.address, # Address of the second receiver\n        amount=1_000_000               # Amount to transfer (in microAlgos)\n    ))\n\n# Execute the grouped transactions atomically\ngroup_tx.execute()\n\n'''\nAbout atomic transfers:\n- Atomic transfers or swaps ensure that every transaction in a group either all succeed or else all fail.\n- You can use this structure to execute multiple transactions as a single atomic unit.\n\nWhy Use Atomic Transfers?\n- Atomic transfers are essential when you need to ensure consistency and reliability across multiple transactions. For example:\n  - When performing a swap or exchange where multiple parties are involved, you want to ensure that all parts of the transaction complete successfully before finalizing.\n  - In decentralized finance (DeFi) applications, atomic transfers can be used to maintain integrity and prevent partial or failed transactions that could lead to unexpected outcomes.\n\nRemember:\n- Atomic transfers are subject to the Algorand networks transaction limits and fees. Make sure you account for these in your planning.\n- The success of atomic transfers depends on the overall validity of the group transaction. If any single transaction fails validation, the entire group will be rejected.\n'''"}
{"file_path": "https://github.com/atsoc1993/Hot-Potato-Contract-AVM/blob/e2e4979b491c97f4d333eeaf1332fecd566e505d/AlgoPotatoClient.py", "code": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"methods\": [{\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"asset\", \"name\": \"asset\"}, {\"type\": \"txn\", \"name\": \"mbr_payment\"}], \"name\": \"asset_opt_in\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Confirm the minimum balance requirement for the asset opt in of 100,000 Microalgo, or 0.1 Algo, was sent to the contract\\n(Prevents potential usage of Algo funds reserves for games or excess mbr from box deletions)\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"txn\", \"name\": \"asset_deposit\"}, {\"type\": \"txn\", \"name\": \"mbr_fee\"}], \"name\": \"create_game\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Initializes a game\\n- Dynamically confirms the contract is the receiver of both the asset deposit and mbr fee - Gets the asset id and amount transferred from the asset deposit - Constructs a box name instance using the sender and current global counter - Constructs a box value template with only non-default values being player 1 address, asset (0 if algo), asset deposit amount, and player 1 round (current round) - Writes the box name and value\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"(address,uint64)\", \"name\": \"game_box_name\", \"struct\": \"GameBoxName\"}, {\"type\": \"txn\", \"name\": \"asset_deposit\"}], \"name\": \"prime_game_vrf\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Asserts the contract is the receiver of player 2's asset deposit\\nGets the current game details Verifies that the asset deposit matches the game details, Updates the current game box with player 2's information Writes the updated information into box storage\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"(address,uint64)\", \"name\": \"game_box_name\", \"struct\": \"GameBoxName\"}], \"name\": \"play_game\", \"returns\": {\"type\": \"string\"}, \"desc\": \"Initializes the \\\"Hot Potato\\\" Game\\n- Starts with an ensure budget requiring 14 inner txns - Gets the game information - Ensures a player 2 has joined and the game is ready - Gets the VRF Output % 240, see \\\"get_vrf_output_modulo\\\" for information on why the # 240 was chosen - Verifies both users are opted in or asset is Algorand which does not require opt in - If either of the users are not opted into the asset then the reward goes to the user that is still opted in - If both users are not opted in the first to opt in can claim the reward - If the VRF round has expired (1,512 rounds have passed since the VRF round selected) a new VRF round is created 9 rounds into the future - Hot Potato game starts, the contract sends Algo or Asset zero amount transactions to both players until the target modulo is reached - The player the 'Hot Potato' was on at the target modulo receives the reward - The reward is dispensed and the box is deleted to prevent state bloat - A little string is returned that states which player won\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"(address,uint64)\", \"name\": \"game_box_name\", \"struct\": \"GameBoxName\"}], \"name\": \"cancel_game\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Cancels a game if and only if there is no active player 2\\nDispenses the asset deposit to player 1\", \"events\": [], \"readonly\": false, \"recommendations\": {}}], \"name\": \"AlgoPotato\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"games_played\": {\"key\": \"Z2FtZXNfcGxheWVk\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"counter\": {\"key\": \"Y291bnRlcg==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"vrf_app_id\": {\"key\": \"dnJmX2FwcF9pZA==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}}, \"local\": {}}, \"maps\": {\"box\": {\"game_box\": {\"keyType\": \"GameBoxName\", \"valueType\": \"GameBoxValue\", \"prefix\": \"\"}}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 0, \"ints\": 3}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {\"GameBoxName\": [{\"name\": \"player_1\", \"type\": \"address\"}, {\"name\": \"counter\", \"type\": \"uint64\"}], \"GameBoxValue\": [{\"name\": \"player_1\", \"type\": \"address\"}, {\"name\": \"player_2\", \"type\": \"address\"}, {\"name\": \"player_1_round\", \"type\": \"uint64\"}, {\"name\": \"player_2_round\", \"type\": \"uint64\"}, {\"name\": \"vrf_round\", \"type\": \"uint64\"}, {\"name\": \"asset\", \"type\": \"uint64\"}, {\"name\": \"asset_amount\", \"type\": \"uint64\"}]}, \"byteCode\": {\"approval\": \"CiAFAAEEAu/ojZ4CJgYMZ2FtZXNfcGxheWVkB2NvdW50ZXIIAAAAAAAAAAAABBUffHUDBoEBMRhAABUoImcpImeACnZyZl9hcHBfaWQhBGcxG0EAlIIFBCjFvuoEA+IL6gSpwiWGBC85JNcEg1HatzYaAI4FAFQAQAAtABEAAiJDMRkURDEYRDYaAYgEHiNDMRkURDEYRDYaAYgBqUkVFlcGAkxQJwRMULAjQzEZFEQxGEQ2GgExFiMJiAESI0MxGRREMRhEMRYlCTEWIwmIAH4jQzEZFEQxGEQ2GgEXwDAxFiMJiAAzI0MxGUD/kTEYFEQjQ4oBAIv/OBBJIxJBAAmL/zgHMgoSRImLACQSQf/4i/84FDIKEkSJigIAi/+I/9IyCov+cABFAUAAG4v/OAiBoI0GEkSxMgqyFIv+shEkshAisgGziYv/OAgURImKAgCL/oj/nYv/iP+YIkmL/jgQSSMSSUAAB4sCJBJBAFsjRIsDQQA+IowAi/44CIwBiwFJRCIpZUQjCClMZzEAIillRBZQMQAyAzIGFosAFk8FFk8ETwRQTwNQKlAqUE8CUExQv4mLAiQSQf/Ei/44EYwAi/44EowBQv+1IkL/oooCAIv/iP8di/6+RIv/OBBJJBJAAAeLASMSQQBWI0SLASMSQQAziwBJV1gIKqhEV2AIi/84CBaoRIsASVcgIDIDEkQxAFwgMgYWXEgyBoEJCBZcUIv+TL+JiwBJV1gIi/84ERaoRFdgCIv/OBIWqERC/8YiQv+nigEBIkcGK0cHgZpOMgwNQQAYsYEGshCBBbIZJwWyHicFsh8isgGzQv/fi/++TElOAowARElXUAhJjAYqqUQyBkyBUFsJgegLDUEB2yJJjA6MC4sASVcAIIwBSVcgIIwCSYFYW0lOAowHgWBbJQuMCEABHSMrjAWMCYsOQAAlMgaBCQgWiwBMXFCL/0y/gBFWUkYgUm91bmQgZXhwaXJlZIwAiYsJQAASi/+8SCIoZUQjCChMZ4sFjACJMgOMA4sLIwiMDCKMCosKiwwMiwOMBEEAOIsKJRhJjA1AAASLAYwDiw1BAASLAowDiwqLCxJBAGuLB0AAT7GLCLIIiwOyByOyECKyAbOLA4wEiwSL/7xIIihlRCMIKExniwESQQATgA5QbGF5ZXIgMSBXaW5zIYwAiYAOUGxheWVyIDIgV2lucyGMAImxiwiyEosDshSLB7IRJLIQIrIBs0L/qosHQAAYsSKyCIsDsgcjshAisgGziwojCIwKQv9NsSKyEosDshSLB7IRJLIQIrIBs0L/4YsBiwdwAEUBQAA8sYsIshKLArIUiweyESSyECKyAbMigB5QbGF5ZXIgMSBGb3JmZWl0IGJ5IG9wdGluZyBvdXSMBYwJQv6iiwKLB3AARQFAADyxiwiyEosBshSLB7IRJLIQIrIBsyKAHlBsYXllciAyIEZvcmZlaXQgYnkgb3B0aW5nIG91dIwFjAlC/lsjK4wFjAlC/lKxiwBJFRZXBgJMUCEEshiABEfCDCOyGosGshqyGoEGshAisgGztD5JVwAEJwQSRFcGAIAB8KoXjAsjjA5C/eyKAQCL/75ESVcAIExJVyAgSwGBWFtJTgNOBEyBYFtOAzIDEkRAABGxsgeyCCOyECKyAbOL/7xIibFMshKLALIRshQkshAisgGzQv/n\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 2}}, \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcG90YXRvLkFsZ29Qb3RhdG8uX19hbGdvcHlfZW50cnlwb2ludF93aXRoX2luaXQoKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDQgMiA2MDAwMTE4ODcKICAgIGJ5dGVjYmxvY2sgImdhbWVzX3BsYXllZCIgImNvdW50ZXIiIDB4MDAwMDAwMDAwMDAwMDAwMCAiIiAweDE1MWY3Yzc1IDB4MDY4MTAxCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBhbGdvcG90YXRvLnB5OjQxCiAgICAvLyBzZWxmLmdhbWVzX3BsYXllZCA9IFVJbnQ2NCgwKQogICAgYnl0ZWNfMCAvLyAiZ2FtZXNfcGxheWVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQyCiAgICAvLyBzZWxmLmNvdW50ZXIgPSBVSW50NjQoMCkKICAgIGJ5dGVjXzEgLy8gImNvdW50ZXIiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQKICAgIC8vIHNlbGYudnJmX2FwcF9pZCA9IEFwcGxpY2F0aW9uKDYwMDAxMTg4NykgI1Rlc3RuZXQKICAgIHB1c2hieXRlcyAidnJmX2FwcF9pZCIKICAgIGludGMgNCAvLyA2MDAwMTE4ODcKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzEKICAgIC8vIGNsYXNzIEFsZ29Qb3RhdG8oQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AxMAogICAgcHVzaGJ5dGVzcyAweDI4YzViZWVhIDB4MDNlMjBiZWEgMHhhOWMyMjU4NiAweDJmMzkyNGQ3IDB4ODM1MWRhYjcgLy8gbWV0aG9kICJhc3NldF9vcHRfaW4oYXNzZXQsdHhuKXZvaWQiLCBtZXRob2QgImNyZWF0ZV9nYW1lKHR4bix0eG4pdm9pZCIsIG1ldGhvZCAicHJpbWVfZ2FtZV92cmYoKGFkZHJlc3MsdWludDY0KSx0eG4pdm9pZCIsIG1ldGhvZCAicGxheV9nYW1lKChhZGRyZXNzLHVpbnQ2NCkpc3RyaW5nIiwgbWV0aG9kICJjYW5jZWxfZ2FtZSgoYWRkcmVzcyx1aW50NjQpKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2Fzc2V0X29wdF9pbl9yb3V0ZUA1IG1haW5fY3JlYXRlX2dhbWVfcm91dGVANiBtYWluX3ByaW1lX2dhbWVfdnJmX3JvdXRlQDcgbWFpbl9wbGF5X2dhbWVfcm91dGVAOCBtYWluX2NhbmNlbF9nYW1lX3JvdXRlQDkKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzEKICAgIC8vIGNsYXNzIEFsZ29Qb3RhdG8oQVJDNENvbnRyYWN0KToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fY2FuY2VsX2dhbWVfcm91dGVAOToKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDY4CiAgICAvLyBAYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzEKICAgIC8vIGNsYXNzIEFsZ29Qb3RhdG8oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDY4CiAgICAvLyBAYWJpbWV0aG9kCiAgICBjYWxsc3ViIGNhbmNlbF9nYW1lCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3BsYXlfZ2FtZV9yb3V0ZUA4OgogICAgLy8gYWxnb3BvdGF0by5weTo0MDcKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gYWxnb3BvdGF0by5weTo0MDcKICAgIC8vIEBhYmltZXRob2QKICAgIGNhbGxzdWIgcGxheV9nYW1lCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9wcmltZV9nYW1lX3ZyZl9yb3V0ZUA3OgogICAgLy8gYWxnb3BvdGF0by5weToyNDcKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICAvLyBhbGdvcG90YXRvLnB5OjI0NwogICAgLy8gQGFiaW1ldGhvZAogICAgY2FsbHN1YiBwcmltZV9nYW1lX3ZyZgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfZ2FtZV9yb3V0ZUA2OgogICAgLy8gYWxnb3BvdGF0by5weToxODAKICAgIC8vIEBhYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMyAvLyAyCiAgICAtCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIGFsZ29wb3RhdG8ucHk6MTgwCiAgICAvLyBAYWJpbWV0aG9kCiAgICBjYWxsc3ViIGNyZWF0ZV9nYW1lCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2Fzc2V0X29wdF9pbl9yb3V0ZUA1OgogICAgLy8gYWxnb3BvdGF0by5weTo2MQogICAgLy8gQGFiaW1ldGhvZAogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBhbGdvcG90YXRvLnB5OjMxCiAgICAvLyBjbGFzcyBBbGdvUG90YXRvKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hcyBBc3NldHMKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgLy8gYWxnb3BvdGF0by5weTo2MQogICAgLy8gQGFiaW1ldGhvZAogICAgY2FsbHN1YiBhc3NldF9vcHRfaW4KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDEwOgogICAgLy8gYWxnb3BvdGF0by5weTozMQogICAgLy8gY2xhc3MgQWxnb1BvdGF0byhBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAxMgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBhbGdvcG90YXRvLkFsZ29Qb3RhdG8uY29udHJhY3RfaXNfcmVjZWl2ZXIodHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNvbnRyYWN0X2lzX3JlY2VpdmVyOgogICAgLy8gYWxnb3BvdGF0by5weTo0OC01MgogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBjb250cmFjdF9pc19yZWNlaXZlcigKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIHR4bjogZ3R4bi5UcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gYWxnb3BvdGF0by5weTo1NgogICAgLy8gaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBieiBjb250cmFjdF9pc19yZWNlaXZlcl9lbHNlX2JvZHlAMgogICAgLy8gYWxnb3BvdGF0by5weTo1NwogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydAoKY29udHJhY3RfaXNfcmVjZWl2ZXJfYWZ0ZXJfaWZfZWxzZUA1OgogICAgcmV0c3ViCgpjb250cmFjdF9pc19yZWNlaXZlcl9lbHNlX2JvZHlAMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6NTgKICAgIC8vIGVsaWYgdHhuLnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXI6CiAgICBmcmFtZV9kaWcgMAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICA9PQogICAgYnogY29udHJhY3RfaXNfcmVjZWl2ZXJfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBhbGdvcG90YXRvLnB5OjU5CiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X3JlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQXNzZXRSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIHJldHN1YgoKCi8vIGFsZ29wb3RhdG8uQWxnb1BvdGF0by5hc3NldF9vcHRfaW4oYXNzZXQ6IHVpbnQ2NCwgbWJyX3BheW1lbnQ6IHVpbnQ2NCkgLT4gdm9pZDoKYXNzZXRfb3B0X2luOgogICAgLy8gYWxnb3BvdGF0by5weTo2MS02NgogICAgLy8gQGFiaW1ldGhvZAogICAgLy8gZGVmIGFzc2V0X29wdF9pbigKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFzc2V0OiBBc3NldCwKICAgIC8vICAgICBtYnJfcGF5bWVudDogZ3R4bi5UcmFuc2FjdGlvbgogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjcyCiAgICAvLyBzZWxmLmNvbnRyYWN0X2lzX3JlY2VpdmVyKG1icl9wYXltZW50KQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5Ojc0CiAgICAvLyBpZiBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmlzX29wdGVkX2luKGFzc2V0KSA9PSBGYWxzZToKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXNzZXRfb3B0X2luX2Vsc2VfYm9keUAyCiAgICAvLyBhbGdvcG90YXRvLnB5Ojc1CiAgICAvLyBhc3NlcnQgbWJyX3BheW1lbnQuYW1vdW50ID09IDEwMF8wMDAKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBwdXNoaW50IDEwMDAwMCAvLyAxMDAwMDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6OTAtOTMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGFsZ29wb3RhdG8ucHk6OTIKICAgIC8vIGFzc2V0X3JlY2VpdmVyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6OTAKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMiAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBhbGdvcG90YXRvLnB5OjkwLTkzCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgcmV0c3ViCgphc3NldF9vcHRfaW5fZWxzZV9ib2R5QDI6CiAgICAvLyBhbGdvcG90YXRvLnB5Ojc5CiAgICAvLyBhc3NlcnQgbWJyX3BheW1lbnQuYW1vdW50ID09IDAKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICAhCiAgICBhc3NlcnQKICAgIHJldHN1YgoKCi8vIGFsZ29wb3RhdG8uQWxnb1BvdGF0by5jcmVhdGVfZ2FtZShhc3NldF9kZXBvc2l0OiB1aW50NjQsIG1icl9mZWU6IHVpbnQ2NCkgLT4gdm9pZDoKY3JlYXRlX2dhbWU6CiAgICAvLyBhbGdvcG90YXRvLnB5OjE4MC0xODUKICAgIC8vIEBhYmltZXRob2QKICAgIC8vIGRlZiBjcmVhdGVfZ2FtZSgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFzc2V0X2RlcG9zaXQ6IGd0eG4uVHJhbnNhY3Rpb24sCiAgICAvLyAgICAgbWJyX2ZlZTogZ3R4bi5UcmFuc2FjdGlvbgogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjE5NAogICAgLy8gc2VsZi5jb250cmFjdF9pc19yZWNlaXZlcihhc3NldF9kZXBvc2l0KQogICAgZnJhbWVfZGlnIC0yCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjE5NQogICAgLy8gc2VsZi5jb250cmFjdF9pc19yZWNlaXZlcihtYnJfZmVlKQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjEwNgogICAgLy8gYXNzZXRfaWQgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjEwNwogICAgLy8gYW1vdW50X2RlcG9zaXRlZCA9IFVJbnQ2NCgwKQogICAgZHVwCiAgICAvLyBhbGdvcG90YXRvLnB5OjEwOQogICAgLy8gYXNzZXJ0IGFzc2V0X2RlcG9zaXQudHlwZSBpbiAoVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQsIFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyKQogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBUeXBlRW51bQogICAgZHVwCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgZHVwCiAgICBibnogY3JlYXRlX2dhbWVfYm9vbF90cnVlQDMKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgID09CiAgICBieiBjcmVhdGVfZ2FtZV9ib29sX2ZhbHNlQDQKCmNyZWF0ZV9nYW1lX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCmNyZWF0ZV9nYW1lX2Jvb2xfbWVyZ2VANToKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTA5CiAgICAvLyBhc3NlcnQgYXNzZXRfZGVwb3NpdC50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuUGF5bWVudCwgVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXIpCiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTExCiAgICAvLyBpZiBhc3NldF9kZXBvc2l0LnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgMwogICAgYnogY3JlYXRlX2dhbWVfZWxzZV9ib2R5QDcKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTEyCiAgICAvLyBhc3NldF9pZCA9IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gYWxnb3BvdGF0by5weToxMTMKICAgIC8vIGFtb3VudF9kZXBvc2l0ZWQgPSBhc3NldF9kZXBvc2l0LmFtb3VudAogICAgZnJhbWVfZGlnIC0yCiAgICBndHhucyBBbW91bnQKICAgIGZyYW1lX2J1cnkgMQoKY3JlYXRlX2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTE5CiAgICAvLyBhc3NlcnQgYW1vdW50X2RlcG9zaXRlZCAhPSAwCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTMyCiAgICAvLyBzZWxmLmNvdW50ZXIgKz0gMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImNvdW50ZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY291bnRlciBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBieXRlY18xIC8vICJjb3VudGVyIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTMzCiAgICAvLyB1c2VyX2FkZHIgPSBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjEzNAogICAgLy8gY291bnRlciA9IGFyYzQuVUludDY0KHNlbGYuY291bnRlcikKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJjb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvdW50ZXIgZXhpc3RzCiAgICBpdG9iCiAgICAvLyBhbGdvcG90YXRvLnB5OjEzNi0xMzkKICAgIC8vIHJldHVybiBHYW1lQm94TmFtZSgKICAgIC8vICAgICBwbGF5ZXJfMT11c2VyX2FkZHIsCiAgICAvLyAgICAgY291bnRlcj1jb3VudGVyCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTUyCiAgICAvLyB1c2VyX2FkZHIgPSBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjE1NgogICAgLy8gcGxheWVyXzI9QWRkcmVzcyhHbG9iYWwuemVyb19hZGRyZXNzKSwKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgLy8gYWxnb3BvdGF0by5weToxNTcKICAgIC8vIHBsYXllcl8xX3JvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICBnbG9iYWwgUm91bmQKICAgIGl0b2IKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTYwCiAgICAvLyBhc3NldD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICBmcmFtZV9kaWcgMAogICAgaXRvYgogICAgLy8gYWxnb3BvdGF0by5weToxNjEKICAgIC8vIGFzc2V0X2Ftb3VudD1hcmM0LlVJbnQ2NChhc3NldF9hbW91bnQpCiAgICB1bmNvdmVyIDUKICAgIGl0b2IKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTU0LTE2MgogICAgLy8gcmV0dXJuIEdhbWVCb3hWYWx1ZSgKICAgIC8vICAgICAgICAgcGxheWVyXzE9dXNlcl9hZGRyLAogICAgLy8gICAgICAgICBwbGF5ZXJfMj1BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMV9yb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMl9yb3VuZD1hcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICAgICAgdnJmX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgICAgICBhc3NldD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyAgICAgICAgIGFzc2V0X2Ftb3VudD1hcmM0LlVJbnQ2NChhc3NldF9hbW91bnQpCiAgICAvLyApCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgLy8gYWxnb3BvdGF0by5weToxNTgKICAgIC8vIHBsYXllcl8yX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgYnl0ZWNfMiAvLyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTU0LTE2MgogICAgLy8gcmV0dXJuIEdhbWVCb3hWYWx1ZSgKICAgIC8vICAgICAgICAgcGxheWVyXzE9dXNlcl9hZGRyLAogICAgLy8gICAgICAgICBwbGF5ZXJfMj1BZGRyZXNzKEdsb2JhbC56ZXJvX2FkZHJlc3MpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMV9yb3VuZD1hcmM0LlVJbnQ2NChHbG9iYWwucm91bmQpLAogICAgLy8gICAgICAgICBwbGF5ZXJfMl9yb3VuZD1hcmM0LlVJbnQ2NCgwKSwKICAgIC8vICAgICAgICAgdnJmX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgICAgICBhc3NldD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyAgICAgICAgIGFzc2V0X2Ftb3VudD1hcmM0LlVJbnQ2NChhc3NldF9hbW91bnQpCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MTU5CiAgICAvLyB2cmZfcm91bmQ9YXJjNC5VSW50NjQoMCksCiAgICBieXRlY18yIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgLy8gYWxnb3BvdGF0by5weToxNTQtMTYyCiAgICAvLyByZXR1cm4gR2FtZUJveFZhbHVlKAogICAgLy8gICAgICAgICBwbGF5ZXJfMT11c2VyX2FkZHIsCiAgICAvLyAgICAgICAgIHBsYXllcl8yPUFkZHJlc3MoR2xvYmFsLnplcm9fYWRkcmVzcyksCiAgICAvLyAgICAgICAgIHBsYXllcl8xX3JvdW5kPWFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCksCiAgICAvLyAgICAgICAgIHBsYXllcl8yX3JvdW5kPWFyYzQuVUludDY0KDApLAogICAgLy8gICAgICAgICB2cmZfcm91bmQ9YXJjNC5VSW50NjQoMCksCiAgICAvLyAgICAgICAgIGFzc2V0PWFyYzQuVUludDY0KGFzc2V0X2lkKSwKICAgIC8vICAgICAgICAgYXNzZXRfYW1vdW50PWFyYzQuVUludDY0KGFzc2V0X2Ftb3VudCkKICAgIC8vICkKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gYWxnb3BvdGF0by5weToyMDMKICAgIC8vIHNlbGYuZ2FtZV9ib3hbZ2FtZV9ib3hfbmFtZV0gPSBnYW1lX2JveF92YWx1ZS5jb3B5KCkKICAgIGJveF9wdXQKICAgIHJldHN1YgoKY3JlYXRlX2dhbWVfZWxzZV9ib2R5QDc6CiAgICAvLyBhbGdvcG90YXRvLnB5OjExNQogICAgLy8gZWxpZiBhc3NldF9kZXBvc2l0LnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLkFzc2V0VHJhbnNmZXI6CiAgICBmcmFtZV9kaWcgMgogICAgaW50Y18yIC8vIGF4ZmVyCiAgICA9PQogICAgYnogY3JlYXRlX2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMAogICAgLy8gYWxnb3BvdGF0by5weToxMTYKICAgIC8vIGFzc2V0X2lkID0gYXNzZXRfZGVwb3NpdC54ZmVyX2Fzc2V0LmlkCiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIFhmZXJBc3NldAogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjExNwogICAgLy8gYW1vdW50X2RlcG9zaXRlZCA9IGFzc2V0X2RlcG9zaXQuYXNzZXRfYW1vdW50CiAgICBmcmFtZV9kaWcgLTIKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBmcmFtZV9idXJ5IDEKICAgIGIgY3JlYXRlX2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMAoKY3JlYXRlX2dhbWVfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgY3JlYXRlX2dhbWVfYm9vbF9tZXJnZUA1CgoKLy8gYWxnb3BvdGF0by5BbGdvUG90YXRvLnByaW1lX2dhbWVfdnJmKGdhbWVfYm94X25hbWU6IGJ5dGVzLCBhc3NldF9kZXBvc2l0OiB1aW50NjQpIC0+IHZvaWQ6CnByaW1lX2dhbWVfdnJmOgogICAgLy8gYWxnb3BvdGF0by5weToyNDctMjUyCiAgICAvLyBAYWJpbWV0aG9kCiAgICAvLyBkZWYgcHJpbWVfZ2FtZV92cmYoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2JveF9uYW1lOiBHYW1lQm94TmFtZSwKICAgIC8vICAgICBhc3NldF9kZXBvc2l0OiBndHhuLlRyYW5zYWN0aW9uLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjI2MQogICAgLy8gc2VsZi5jb250cmFjdF9pc19yZWNlaXZlcihhc3NldF9kZXBvc2l0KQogICAgZnJhbWVfZGlnIC0xCiAgICBjYWxsc3ViIGNvbnRyYWN0X2lzX3JlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjI2MwogICAgLy8gZ2FtZV9ib3ggPSBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0yCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2JveCBlbnRyeSBleGlzdHMKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjE4CiAgICAvLyBhc3NlcnQgYXNzZXRfZGVwb3NpdC50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQpCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBkdXAKICAgIGludGNfMiAvLyBheGZlcgogICAgPT0KICAgIGJueiBwcmltZV9nYW1lX3ZyZl9ib29sX3RydWVAMwogICAgZnJhbWVfZGlnIDEKICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBieiBwcmltZV9nYW1lX3ZyZl9ib29sX2ZhbHNlQDQKCnByaW1lX2dhbWVfdnJmX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCnByaW1lX2dhbWVfdnJmX2Jvb2xfbWVyZ2VANToKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjE4CiAgICAvLyBhc3NlcnQgYXNzZXRfZGVwb3NpdC50eXBlIGluIChUcmFuc2FjdGlvblR5cGUuQXNzZXRUcmFuc2ZlciwgVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQpCiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjIwCiAgICAvLyBpZiBhc3NldF9kZXBvc2l0LnR5cGUgPT0gVHJhbnNhY3Rpb25UeXBlLlBheW1lbnQ6CiAgICBmcmFtZV9kaWcgMQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGJ6IHByaW1lX2dhbWVfdnJmX2Vsc2VfYm9keUA3CiAgICAvLyBhbGdvcG90YXRvLnB5OjIyMQogICAgLy8gYXNzZXJ0IGdhbWVfYm94X3ZhbHVlLmFzc2V0ID09IDAKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGV4dHJhY3QgODggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ5dGVjXzIgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCiAgICBiPT0KICAgIGFzc2VydAogICAgLy8gYWxnb3BvdGF0by5weToyMjIKICAgIC8vIGFzc2VydCBnYW1lX2JveF92YWx1ZS5hc3NldF9hbW91bnQgPT0gYXNzZXRfZGVwb3NpdC5hbW91bnQKICAgIGV4dHJhY3QgOTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICBpdG9iCiAgICBiPT0KICAgIGFzc2VydAoKcHJpbWVfZ2FtZV92cmZfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gYWxnb3BvdGF0by5weToyNDAKICAgIC8vIGFzc2VydCBnYW1lX2JveC5wbGF5ZXJfMiA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBleHRyYWN0IDMyIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBhbGdvcG90YXRvLnB5OjI0MQogICAgLy8gZ2FtZV9ib3gucGxheWVyXzIgPSBBZGRyZXNzKFR4bi5zZW5kZXIpCiAgICB0eG4gU2VuZGVyCiAgICByZXBsYWNlMiAzMgogICAgLy8gYWxnb3BvdGF0by5weToyNDIKICAgIC8vIGdhbWVfYm94LnBsYXllcl8yX3JvdW5kID0gYXJjNC5VSW50NjQoR2xvYmFsLnJvdW5kKQogICAgZ2xvYmFsIFJvdW5kCiAgICBpdG9iCiAgICByZXBsYWNlMiA3MgogICAgLy8gYWxnb3BvdGF0by5weToyNDMKICAgIC8vIGdhbWVfYm94LnZyZl9yb3VuZCA9IGFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCArIDkpCiAgICBnbG9iYWwgUm91bmQKICAgIHB1c2hpbnQgOSAvLyA5CiAgICArCiAgICBpdG9iCiAgICByZXBsYWNlMiA4MAogICAgLy8gYWxnb3BvdGF0by5weToyNjgKICAgIC8vIHNlbGYuZ2FtZV9ib3hbZ2FtZV9ib3hfbmFtZV0gPSBnYW1lX2JveC5jb3B5KCkKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgYm94X3B1dAogICAgcmV0c3ViCgpwcmltZV9nYW1lX3ZyZl9lbHNlX2JvZHlANzoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjI1CiAgICAvLyBhc3NlcnQgZ2FtZV9ib3hfdmFsdWUuYXNzZXQgPT0gYXNzZXRfZGVwb3NpdC54ZmVyX2Fzc2V0LmlkCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBleHRyYWN0IDg4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFhmZXJBc3NldAogICAgaXRvYgogICAgYj09CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MjI2CiAgICAvLyBhc3NlcnQgZ2FtZV9ib3hfdmFsdWUuYXNzZXRfYW1vdW50ID09IGFzc2V0X2RlcG9zaXQuYXNzZXRfYW1vdW50CiAgICBleHRyYWN0IDk2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0QW1vdW50CiAgICBpdG9iCiAgICBiPT0KICAgIGFzc2VydAogICAgYiBwcmltZV9nYW1lX3ZyZl9hZnRlcl9pZl9lbHNlQDgKCnByaW1lX2dhbWVfdnJmX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIHByaW1lX2dhbWVfdnJmX2Jvb2xfbWVyZ2VANQoKCi8vIGFsZ29wb3RhdG8uQWxnb1BvdGF0by5wbGF5X2dhbWUoZ2FtZV9ib3hfbmFtZTogYnl0ZXMpIC0+IGJ5dGVzOgpwbGF5X2dhbWU6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQwNy00MTEKICAgIC8vIEBhYmltZXRob2QKICAgIC8vIGRlZiBwbGF5X2dhbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2JveF9uYW1lOiBHYW1lQm94TmFtZSwKICAgIC8vICkgLT4gU3RyaW5nOgogICAgcHJvdG8gMSAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA2CiAgICBieXRlY18zIC8vICIiCiAgICBkdXBuIDcKCnBsYXlfZ2FtZV93aGlsZV90b3BAMjU6CiAgICBwdXNoaW50IDEwMDEwIC8vIDEwMDEwCiAgICBnbG9iYWwgT3Bjb2RlQnVkZ2V0CiAgICA+CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfd2hpbGVAMzAKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgIGl0eG5fZmllbGQgT25Db21wbGV0aW9uCiAgICBieXRlYyA1IC8vIDB4MDY4MTAxCiAgICBpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQogICAgYnl0ZWMgNSAvLyAweDA2ODEwMQogICAgaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBwbGF5X2dhbWVfd2hpbGVfdG9wQDI1CgpwbGF5X2dhbWVfYWZ0ZXJfd2hpbGVAMzA6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQzMQogICAgLy8gZ2FtZV9ib3ggPSBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGZyYW1lX2J1cnkgMAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZV9ib3ggZW50cnkgZXhpc3RzCiAgICAvLyBhbGdvcG90YXRvLnB5OjQwNQogICAgLy8gYXNzZXJ0IGdhbWVfYm94LnZyZl9yb3VuZCAhPSAwCiAgICBkdXAKICAgIGV4dHJhY3QgODAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSA2CiAgICBieXRlY18yIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAogICAgYiE9CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mjg4CiAgICAvLyBpZiBHbG9iYWwucm91bmQgLSB2cmZfcm91bmQubmF0aXZlID4gMTUxMjoKICAgIGdsb2JhbCBSb3VuZAogICAgc3dhcAogICAgLy8gYWxnb3BvdGF0by5weToyODYKICAgIC8vIHZyZl9yb3VuZCA9IGdhbWVfYm94LnZyZl9yb3VuZAogICAgcHVzaGludCA4MCAvLyA4MAogICAgLy8gYWxnb3BvdGF0by5weToyODgKICAgIC8vIGlmIEdsb2JhbC5yb3VuZCAtIHZyZl9yb3VuZC5uYXRpdmUgPiAxNTEyOgogICAgZXh0cmFjdF91aW50NjQKICAgIC0KICAgIHB1c2hpbnQgMTUxMiAvLyAxNTEyCiAgICA+CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAzNgogICAgLy8gYWxnb3BvdGF0by5weToyODkKICAgIC8vIHJldHVybiBVSW50NjQoMCksIEZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDE0CiAgICBmcmFtZV9idXJ5IDExCgpwbGF5X2dhbWVfYWZ0ZXJfaW5saW5lZF9hbGdvcG90YXRvLkFsZ29Qb3RhdG8uZ2V0X3ZyZl9vdXRwdXRfbW9kdWxvQDM3OgogICAgLy8gYWxnb3BvdGF0by5weTozNjkKICAgIC8vIHBsYXllcl8xID0gZ2FtZV9ib3gucGxheWVyXzEubmF0aXZlCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBleHRyYWN0IDAgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzcwCiAgICAvLyBwbGF5ZXJfMiA9IGdhbWVfYm94LnBsYXllcl8yLm5hdGl2ZQogICAgZHVwCiAgICBleHRyYWN0IDMyIDMyIC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfYnVyeSAyCiAgICAvLyBhbGdvcG90YXRvLnB5OjM3MgogICAgLy8gYXNzZXQgPSBnYW1lX2JveC5hc3NldC5uYXRpdmUKICAgIGR1cAogICAgcHVzaGludCA4OCAvLyA4OAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSA3CiAgICAvLyBhbGdvcG90YXRvLnB5OjM3MwogICAgLy8gYXNzZXRfYW1vdW50ID0gZ2FtZV9ib3guYXNzZXRfYW1vdW50Lm5hdGl2ZSAqIDIKICAgIHB1c2hpbnQgOTYgLy8gOTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBpbnRjXzMgLy8gMgogICAgKgogICAgZnJhbWVfYnVyeSA4CiAgICAvLyBhbGdvcG90YXRvLnB5OjM3NQogICAgLy8gaWYgYXNzZXQgPT0gMDoKICAgIGJueiBwbGF5X2dhbWVfZWxzZV9ib2R5QDQwCiAgICAvLyBhbGdvcG90YXRvLnB5OjM3NgogICAgLy8gcmV0dXJuIFRydWUsIFN0cmluZygnJykKICAgIGludGNfMSAvLyAxCiAgICBieXRlY18zIC8vICIiCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2J1cnkgOQoKcGxheV9nYW1lX2FmdGVyX2lubGluZWRfYWxnb3BvdGF0by5BbGdvUG90YXRvLnZlcmlmeV9ib3RoX3VzZXJzX29wdGVkX2luQDQ1OgogICAgLy8gYWxnb3BvdGF0by5weTo0MzkKICAgIC8vIGlmIHZhbGlkX3ZyZl9yb3VuZCA9PSBGYWxzZToKICAgIGZyYW1lX2RpZyAxNAogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlAMgogICAgLy8gYWxnb3BvdGF0by5weTo0NDAKICAgIC8vIGdhbWVfYm94LnZyZl9yb3VuZCA9IGFyYzQuVUludDY0KEdsb2JhbC5yb3VuZCArIDkpCiAgICBnbG9iYWwgUm91bmQKICAgIHB1c2hpbnQgOSAvLyA5CiAgICArCiAgICBpdG9iCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgcmVwbGFjZTIgODAKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQxCiAgICAvLyBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdID0gZ2FtZV9ib3guY29weSgpCiAgICBmcmFtZV9kaWcgLTEKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQyCiAgICAvLyByZXR1cm4gU3RyaW5nKCJWUkYgUm91bmQgZXhwaXJlZCIpCiAgICBwdXNoYnl0ZXMgIlZSRiBSb3VuZCBleHBpcmVkIgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsYXlfZ2FtZV9lbHNlX2JvZHlAMjoKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDQ0CiAgICAvLyBlbGlmIG5vdCBib3RoX3VzZXJzX29wdGVkX2ludG9fYXNzZXQ6CiAgICBmcmFtZV9kaWcgOQogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlANAogICAgLy8gYWxnb3BvdGF0by5weTo0NDYKICAgIC8vIGRlbCBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gYWxnb3BvdGF0by5weTo0NDgKICAgIC8vIHNlbGYuZ2FtZXNfcGxheWVkICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJnYW1lc19wbGF5ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXNfcGxheWVkIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjXzAgLy8gImdhbWVzX3BsYXllZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ1MAogICAgLy8gcmV0dXJuIHJldHVybl9tZXNzYWdlCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsYXlfZ2FtZV9lbHNlX2JvZHlANDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzIxCiAgICAvLyBwb3RhdG9faG9sZGVyID0gR2xvYmFsLnplcm9fYWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzIzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UobW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50ICsgMSk6CiAgICBmcmFtZV9kaWcgMTEKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDEyCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxMAoKcGxheV9nYW1lX2Zvcl9oZWFkZXJAODoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzIzCiAgICAvLyBmb3IgaSBpbiB1cmFuZ2UobW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50ICsgMSk6CiAgICBmcmFtZV9kaWcgMTAKICAgIGZyYW1lX2RpZyAxMgogICAgPAogICAgZnJhbWVfZGlnIDMKICAgIGZyYW1lX2J1cnkgNAogICAgYnogcGxheV9nYW1lX2FmdGVyX2ZvckAyMgogICAgLy8gYWxnb3BvdGF0by5weTozMjQKICAgIC8vIGlmIGkgJSAyID09IDA6CiAgICBmcmFtZV9kaWcgMTAKICAgIGludGNfMyAvLyAyCiAgICAlCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTMKICAgIGJueiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAxMQogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2J1cnkgMwoKcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBhbGdvcG90YXRvLnB5OjMyNwogICAgLy8gaWYgaSAlIDIgIT0gMDoKICAgIGZyYW1lX2RpZyAxMwogICAgYnogcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMTMKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9idXJ5IDMKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gYWxnb3BvdGF0by5weTozMzAKICAgIC8vIGlmIGkgPT0gbW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50OgogICAgZnJhbWVfZGlnIDEwCiAgICBmcmFtZV9kaWcgMTEKICAgID09CiAgICBieiBwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAxOAogICAgLy8gYWxnb3BvdGF0by5weTozMzEKICAgIC8vIGlmIGFzc2V0X2lkID09IDA6CiAgICBmcmFtZV9kaWcgNwogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlAMTYKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzMyLTMzNQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBvdGF0b19ob2xkZXIsCiAgICAvLyAgICAgYW1vdW50PWFzc2V0X2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyA4CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZnJhbWVfZGlnIDMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzMyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzMyLTMzNQogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBvdGF0b19ob2xkZXIsCiAgICAvLyAgICAgYW1vdW50PWFzc2V0X2Ftb3VudCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpwbGF5X2dhbWVfYWZ0ZXJfaWZfZWxzZUAxNzoKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9idXJ5IDQKCnBsYXlfZ2FtZV9hZnRlcl9mb3JAMjI6CiAgICBmcmFtZV9kaWcgNAogICAgLy8gYWxnb3BvdGF0by5weTo0NTcKICAgIC8vIGRlbCBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdCiAgICBmcmFtZV9kaWcgLTEKICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gYWxnb3BvdGF0by5weTo0NTkKICAgIC8vIHNlbGYuZ2FtZXNfcGxheWVkICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJnYW1lc19wbGF5ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZ2FtZXNfcGxheWVkIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ5dGVjXzAgLy8gImdhbWVzX3BsYXllZCIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ2MQogICAgLy8gaWYgcG90YXRvX2hvbGRlciA9PSBwbGF5ZXJfMToKICAgIGZyYW1lX2RpZyAxCiAgICA9PQogICAgYnogcGxheV9nYW1lX2Vsc2VfYm9keUA2CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ2MgogICAgLy8gcmV0dXJuIFN0cmluZygiUGxheWVyIDEgV2lucyEiKQogICAgcHVzaGJ5dGVzICJQbGF5ZXIgMSBXaW5zISIKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpwbGF5X2dhbWVfZWxzZV9ib2R5QDY6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ2NAogICAgLy8gcmV0dXJuIFN0cmluZygiUGxheWVyIDIgV2lucyEiKQogICAgcHVzaGJ5dGVzICJQbGF5ZXIgMiBXaW5zISIKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpwbGF5X2dhbWVfZWxzZV9ib2R5QDE2OgogICAgLy8gYWxnb3BvdGF0by5weTozMzctMzQxCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wb3RhdG9faG9sZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgOAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIDMKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIDcKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBhbGdvcG90YXRvLnB5OjMzNwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzM3LTM0MQogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXRfaWQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cG90YXRvX2hvbGRlciwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9YXNzZXRfYW1vdW50LAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMTcKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDE4OgogICAgLy8gYWxnb3BvdGF0by5weTozNDQKICAgIC8vIGlmIGFzc2V0X2lkID09IDA6CiAgICBmcmFtZV9kaWcgNwogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlAMjAKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzQ1LTM0OAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBvdGF0b19ob2xkZXIsCiAgICAvLyAgICAgYW1vdW50PTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBhbGdvcG90YXRvLnB5OjM0NwogICAgLy8gYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjM0NQogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBhbGdvcG90YXRvLnB5OjM0NS0zNDgKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wb3RhdG9faG9sZGVyLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDIxOgogICAgLy8gYWxnb3BvdGF0by5weTozMjMKICAgIC8vIGZvciBpIGluIHVyYW5nZShtb2R1bG9fMjQwX3ZyZl9ieXRlc19hc19pbnQgKyAxKToKICAgIGZyYW1lX2RpZyAxMAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMTAKICAgIGIgcGxheV9nYW1lX2Zvcl9oZWFkZXJAOAoKcGxheV9nYW1lX2Vsc2VfYm9keUAyMDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzUwLTM1NAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXRfaWQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cG90YXRvX2hvbGRlciwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGFsZ29wb3RhdG8ucHk6MzUzCiAgICAvLyBhc3NldF9hbW91bnQ9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgMwogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgNwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6MzUwCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gYWxnb3BvdGF0by5weTozNTAtMzU0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wb3RhdG9faG9sZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgcGxheV9nYW1lX2FmdGVyX2lmX2Vsc2VAMjEKCnBsYXlfZ2FtZV9lbHNlX2JvZHlANDA6CiAgICAvLyBhbGdvcG90YXRvLnB5OjM3OAogICAgLy8gZWxpZiBwbGF5ZXJfMS5pc19vcHRlZF9pbihBc3NldChhc3NldCkpID09IEZhbHNlOgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyA3CiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IHBsYXlfZ2FtZV9lbHNlX2JvZHlANDIKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mzc5LTM4MwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cGxheWVyXzIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFzc2V0X2Ftb3VudAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIDgKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAyCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyA3CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gYWxnb3BvdGF0by5weTozNzkKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMiAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBhbGdvcG90YXRvLnB5OjM3OS0zODMKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBsYXllcl8yLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBhbGdvcG90YXRvLnB5OjM4NQogICAgLy8gcmV0dXJuIEZhbHNlLCBTdHJpbmcoIlBsYXllciAxIEZvcmZlaXQgYnkgb3B0aW5nIG91dCIpCiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICJQbGF5ZXIgMSBGb3JmZWl0IGJ5IG9wdGluZyBvdXQiCiAgICBmcmFtZV9idXJ5IDUKICAgIGZyYW1lX2J1cnkgOQogICAgLy8gYWxnb3BvdGF0by5weTo0MzcKICAgIC8vIGJvdGhfdXNlcnNfb3B0ZWRfaW50b19hc3NldCwgcmV0dXJuX21lc3NhZ2UgPSBzZWxmLnZlcmlmeV9ib3RoX3VzZXJzX29wdGVkX2luKGdhbWVfYm94LmNvcHkoKSkKICAgIGIgcGxheV9nYW1lX2FmdGVyX2lubGluZWRfYWxnb3BvdGF0by5BbGdvUG90YXRvLnZlcmlmeV9ib3RoX3VzZXJzX29wdGVkX2luQDQ1CgpwbGF5X2dhbWVfZWxzZV9ib2R5QDQyOgogICAgLy8gYWxnb3BvdGF0by5weTozODcKICAgIC8vIGVsaWYgcGxheWVyXzIuaXNfb3B0ZWRfaW4oQXNzZXQoYXNzZXQpKSA9PSBGYWxzZToKICAgIGZyYW1lX2RpZyAyCiAgICBmcmFtZV9kaWcgNwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBwbGF5X2dhbWVfZWxzZV9ib2R5QDQ0CiAgICAvLyBhbGdvcG90YXRvLnB5OjM4OC0zOTIKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBsYXllcl8xLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyA4CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgMQogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgNwogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mzg4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gYWxnb3BvdGF0by5weTozODgtMzkyCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wbGF5ZXJfMSwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9YXNzZXRfYW1vdW50CiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gYWxnb3BvdGF0by5weTozOTQKICAgIC8vIHJldHVybiBGYWxzZSwgU3RyaW5nKCJQbGF5ZXIgMiBGb3JmZWl0IGJ5IG9wdGluZyBvdXQiKQogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiUGxheWVyIDIgRm9yZmVpdCBieSBvcHRpbmcgb3V0IgogICAgZnJhbWVfYnVyeSA1CiAgICBmcmFtZV9idXJ5IDkKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDM3CiAgICAvLyBib3RoX3VzZXJzX29wdGVkX2ludG9fYXNzZXQsIHJldHVybl9tZXNzYWdlID0gc2VsZi52ZXJpZnlfYm90aF91c2Vyc19vcHRlZF9pbihnYW1lX2JveC5jb3B5KCkpCiAgICBiIHBsYXlfZ2FtZV9hZnRlcl9pbmxpbmVkX2FsZ29wb3RhdG8uQWxnb1BvdGF0by52ZXJpZnlfYm90aF91c2Vyc19vcHRlZF9pbkA0NQoKcGxheV9nYW1lX2Vsc2VfYm9keUA0NDoKICAgIC8vIGFsZ29wb3RhdG8ucHk6Mzk3CiAgICAvLyByZXR1cm4gVHJ1ZSwgU3RyaW5nKCcnKQogICAgaW50Y18xIC8vIDEKICAgIGJ5dGVjXzMgLy8gIiIKICAgIGZyYW1lX2J1cnkgNQogICAgZnJhbWVfYnVyeSA5CiAgICAvLyBhbGdvcG90YXRvLnB5OjQzNwogICAgLy8gYm90aF91c2Vyc19vcHRlZF9pbnRvX2Fzc2V0LCByZXR1cm5fbWVzc2FnZSA9IHNlbGYudmVyaWZ5X2JvdGhfdXNlcnNfb3B0ZWRfaW4oZ2FtZV9ib3guY29weSgpKQogICAgYiBwbGF5X2dhbWVfYWZ0ZXJfaW5saW5lZF9hbGdvcG90YXRvLkFsZ29Qb3RhdG8udmVyaWZ5X2JvdGhfdXNlcnNfb3B0ZWRfaW5ANDUKCnBsYXlfZ2FtZV9hZnRlcl9pZl9lbHNlQDM2OgogICAgLy8gYWxnb3BvdGF0by5weToyOTMtMjk4CiAgICAvLyByZXN1bHQsIHR4biA9IGFiaV9jYWxsW0J5dGVzXSgKICAgIC8vICAgICAnbXVzdF9nZXQodWludDY0LGJ5dGVbXSlieXRlW10nLAogICAgLy8gICAgIHZyZl9yb3VuZCwKICAgIC8vICAgICBnYW1lX2JveF9hc19ieXRlcywKICAgIC8vICAgICBhcHBfaWQ9NjAwMDExODg3LAogICAgLy8gKQogICAgaXR4bl9iZWdpbgogICAgLy8gYWxnb3BvdGF0by5weToyOTYKICAgIC8vIGdhbWVfYm94X2FzX2J5dGVzLAogICAgZnJhbWVfZGlnIDAKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBhbGdvcG90YXRvLnB5OjI5NwogICAgLy8gYXBwX2lkPTYwMDAxMTg4NywKICAgIGludGMgNCAvLyA2MDAwMTE4ODcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgLy8gYWxnb3BvdGF0by5weToyOTMtMjk4CiAgICAvLyByZXN1bHQsIHR4biA9IGFiaV9jYWxsW0J5dGVzXSgKICAgIC8vICAgICAnbXVzdF9nZXQodWludDY0LGJ5dGVbXSlieXRlW10nLAogICAgLy8gICAgIHZyZl9yb3VuZCwKICAgIC8vICAgICBnYW1lX2JveF9hc19ieXRlcywKICAgIC8vICAgICBhcHBfaWQ9NjAwMDExODg3LAogICAgLy8gKQogICAgcHVzaGJ5dGVzIDB4NDdjMjBjMjMgLy8gbWV0aG9kICJtdXN0X2dldCh1aW50NjQsYnl0ZVtdKWJ5dGVbXSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQVJDNCBwcmVmaXggaXMgdmFsaWQKICAgIGV4dHJhY3QgNiAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjMwMQogICAgLy8gbW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50ID0gb3AuYnRvaSgodnJmX2J5dGVzX2FzX2ludGVnZXIubmF0aXZlICUgMjQwKS5ieXRlcykKICAgIHB1c2hieXRlcyAweGYwCiAgICBiJQogICAgYnRvaQogICAgZnJhbWVfYnVyeSAxMQogICAgLy8gYWxnb3BvdGF0by5weTozMDMKICAgIC8vIHJldHVybiBtb2R1bG9fMjQwX3ZyZl9ieXRlc19hc19pbnQsIFRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDE0CiAgICAvLyBhbGdvcG90YXRvLnB5OjQzNQogICAgLy8gbW9kdWxvXzI0MF92cmZfYnl0ZXNfYXNfaW50LCB2YWxpZF92cmZfcm91bmQgPSBzZWxmLmdldF92cmZfb3V0cHV0X21vZHVsbyhnYW1lX2JveC5jb3B5KCkpCiAgICBiIHBsYXlfZ2FtZV9hZnRlcl9pbmxpbmVkX2FsZ29wb3RhdG8uQWxnb1BvdGF0by5nZXRfdnJmX291dHB1dF9tb2R1bG9AMzcKCgovLyBhbGdvcG90YXRvLkFsZ29Qb3RhdG8uY2FuY2VsX2dhbWUoZ2FtZV9ib3hfbmFtZTogYnl0ZXMpIC0+IHZvaWQ6CmNhbmNlbF9nYW1lOgogICAgLy8gYWxnb3BvdGF0by5weTo0NjgtNDcyCiAgICAvLyBAYWJpbWV0aG9kCiAgICAvLyBkZWYgY2FuY2VsX2dhbWUoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBnYW1lX2JveF9uYW1lOiBHYW1lQm94TmFtZQogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ3NwogICAgLy8gZ2FtZV9ib3ggPSBzZWxmLmdhbWVfYm94W2dhbWVfYm94X25hbWVdLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5nYW1lX2JveCBlbnRyeSBleGlzdHMKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDc5CiAgICAvLyBwbGF5ZXJfMSA9IGdhbWVfYm94LnBsYXllcl8xLm5hdGl2ZQogICAgZHVwCiAgICBleHRyYWN0IDAgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBzd2FwCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ4MAogICAgLy8gcGxheWVyXzIgPSBnYW1lX2JveC5wbGF5ZXJfMi5uYXRpdmUKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDgzCiAgICAvLyBhc3NldCA9IGdhbWVfYm94LmFzc2V0Lm5hdGl2ZQogICAgZGlnIDEKICAgIHB1c2hpbnQgODggLy8gODgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGNvdmVyIDQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDg0CiAgICAvLyBhc3NldF9hbW91bnQgPSBnYW1lX2JveC5hc3NldF9hbW91bnQubmF0aXZlCiAgICBzd2FwCiAgICBwdXNoaW50IDk2IC8vIDk2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgMwogICAgLy8gYWxnb3BvdGF0by5weTo0ODYKICAgIC8vIGFzc2VydCBwbGF5ZXJfMiA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDg4CiAgICAvLyBpZiBhc3NldCA9PSAwOgogICAgYm56IGNhbmNlbF9nYW1lX2Vsc2VfYm9keUAzCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ4OS00OTIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wbGF5ZXJfMSwKICAgIC8vICAgICBhbW91bnQ9YXNzZXRfYW1vdW50CiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gYWxnb3BvdGF0by5weTo0ODkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gYWxnb3BvdGF0by5weTo0ODktNDkyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9cGxheWVyXzEsCiAgICAvLyAgICAgYW1vdW50PWFzc2V0X2Ftb3VudAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmNhbmNlbF9nYW1lX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIGFsZ29wb3RhdG8ucHk6NTAxCiAgICAvLyBkZWwgc2VsZi5nYW1lX2JveFtnYW1lX2JveF9uYW1lXQogICAgZnJhbWVfZGlnIC0xCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHJldHN1YgoKY2FuY2VsX2dhbWVfZWxzZV9ib2R5QDM6CiAgICAvLyBhbGdvcG90YXRvLnB5OjQ5NS00OTkKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wbGF5ZXJfMSwKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hc3NldF9hbW91bnQKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICAvLyBhbGdvcG90YXRvLnB5OjQ5NQogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGFsZ29wb3RhdG8ucHk6NDk1LTQ5OQogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBsYXllcl8xLAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFzc2V0X2Ftb3VudAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgY2FuY2VsX2dhbWVfYWZ0ZXJfaWZfZWxzZUA1Cg==\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [1179], \"errorMessage\": \"ARC4 prefix is valid\"}, {\"pc\": [504, 510, 523, 555, 565, 635, 667, 673, 1204, 1209], \"errorMessage\": \"Index access is out of bounds\"}, {\"pc\": [132, 147, 175, 194, 214], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [241], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [135, 150, 178, 197, 217], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [391, 402], \"errorMessage\": \"check self.counter exists\"}, {\"pc\": [474, 633, 1202], \"errorMessage\": \"check self.game_box entry exists\"}, {\"pc\": [757, 858], \"errorMessage\": \"check self.games_played exists\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True)\nclass GameBoxName:\n    \"\"\"Struct for GameBoxName\"\"\"\n    player_1: str\n    counter: int\n\n@dataclasses.dataclass(frozen=True)\nclass GameBoxValue:\n    \"\"\"Struct for GameBoxValue\"\"\"\n    player_1: str\n    player_2: str\n    player_1_round: int\n    player_2_round: int\n    vrf_round: int\n    asset: int\n    asset_amount: int\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass AssetOptInArgs:\n    \"\"\"Dataclass for asset_opt_in arguments\"\"\"\n    asset: int\n    mbr_payment: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"asset_opt_in(asset,txn)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass CreateGameArgs:\n    \"\"\"Dataclass for create_game arguments\"\"\"\n    asset_deposit: algokit_utils.AppMethodCallTransactionArgument | None = None\n    mbr_fee: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"create_game(txn,txn)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass PrimeGameVrfArgs:\n    \"\"\"Dataclass for prime_game_vrf arguments\"\"\"\n    game_box_name: GameBoxName\n    asset_deposit: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"prime_game_vrf((address,uint64),txn)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass PlayGameArgs:\n    \"\"\"Dataclass for play_game arguments\"\"\"\n    game_box_name: GameBoxName\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"play_game((address,uint64))string\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass CancelGameArgs:\n    \"\"\"Dataclass for cancel_game arguments\"\"\"\n    game_box_name: GameBoxName\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"cancel_game((address,uint64))void\"\n\n\nclass AlgoPotatoParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def asset_opt_in(\n        self,\n        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"asset_opt_in(asset,txn)void\",\n            \"args\": method_args,\n        }))\n\n    def create_game(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_game(txn,txn)void\",\n            \"args\": method_args,\n        }))\n\n    def prime_game_vrf(\n        self,\n        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"prime_game_vrf((address,uint64),txn)void\",\n            \"args\": method_args,\n        }))\n\n    def play_game(\n        self,\n        args: tuple[GameBoxName] | PlayGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"play_game((address,uint64))string\",\n            \"args\": method_args,\n        }))\n\n    def cancel_game(\n        self,\n        args: tuple[GameBoxName] | CancelGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"cancel_game((address,uint64))void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass AlgoPotatoCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def asset_opt_in(\n        self,\n        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"asset_opt_in(asset,txn)void\",\n            \"args\": method_args,\n        }))\n\n    def create_game(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_game(txn,txn)void\",\n            \"args\": method_args,\n        }))\n\n    def prime_game_vrf(\n        self,\n        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"prime_game_vrf((address,uint64),txn)void\",\n            \"args\": method_args,\n        }))\n\n    def play_game(\n        self,\n        args: tuple[GameBoxName] | PlayGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"play_game((address,uint64))string\",\n            \"args\": method_args,\n        }))\n\n    def cancel_game(\n        self,\n        args: tuple[GameBoxName] | CancelGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"cancel_game((address,uint64))void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass AlgoPotatoSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def asset_opt_in(\n        self,\n        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"asset_opt_in(asset,txn)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def create_game(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_game(txn,txn)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def prime_game_vrf(\n        self,\n        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"prime_game_vrf((address,uint64),txn)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def play_game(\n        self,\n        args: tuple[GameBoxName] | PlayGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[str]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"play_game((address,uint64))string\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)\n\n    def cancel_game(\n        self,\n        args: tuple[GameBoxName] | CancelGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"cancel_game((address,uint64))void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    games_played: int\n    counter: int\n    vrf_app_id: int\n\nclass AlgoPotatoState:\n    \"\"\"Methods to access state for the current AlgoPotato app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\n    @property\n    def box(\n        self\n    ) -> \"_BoxState\":\n            \"\"\"Methods to access box for the current app\"\"\"\n            return _BoxState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def games_played(self) -> int:\n        \"\"\"Get the current value of the games_played key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"games_played\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def counter(self) -> int:\n        \"\"\"Get the current value of the counter key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"counter\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def vrf_app_id(self) -> int:\n        \"\"\"Get the current value of the vrf_app_id key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"vrf_app_id\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\nclass _BoxState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {\n            \"GameBoxValue\": GameBoxValue\n        }\n\n    def get_all(self) -> dict[str, typing.Any]:\n        \"\"\"Get all current keyed values from box state\"\"\"\n        result = self.app_client.state.box.get_all()\n        if not result:\n            return {}\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.box.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return converted\n\n    @property\n    def game_box(self) -> \"_MapState[GameBoxName, GameBoxValue]\":\n        \"\"\"Get values from the game_box map in box state\"\"\"\n        return _MapState(\n            self.app_client.state.box,\n            \"game_box\",\n            self._struct_classes.get(\"GameBoxValue\")\n        )\n\n_KeyType = typing.TypeVar(\"_KeyType\")\n_ValueType = typing.TypeVar(\"_ValueType\")\n\nclass _AppClientStateMethodsProtocol(typing.Protocol):\n    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:\n        ...\n    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:\n        ...\n\nclass _MapState(typing.Generic[_KeyType, _ValueType]):\n    \"\"\"Generic class for accessing state maps with strongly typed keys and values\"\"\"\n\n    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,\n                struct_class: typing.Type[_ValueType] | None = None):\n        self._state_accessor = state_accessor\n        self._map_name = map_name\n        self._struct_class = struct_class\n\n    def get_map(self) -> dict[_KeyType, _ValueType]:\n        \"\"\"Get all current values in the map\"\"\"\n        result = self._state_accessor.get_map(self._map_name)\n        if self._struct_class and result:\n            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v\n                    for k, v in result.items()}  # type: ignore\n        return typing.cast(dict[_KeyType, _ValueType], result or {})\n\n    def get_value(self, key: _KeyType) -> _ValueType | None:\n        \"\"\"Get a value from the map by key\"\"\"\n        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore\n        value = self._state_accessor.get_map_value(self._map_name, key_value)\n        if value is not None and self._struct_class and isinstance(value, dict):\n            return _init_dataclass(self._struct_class, value)  # type: ignore\n        return typing.cast(_ValueType | None, value)\n\n\nclass AlgoPotatoClient:\n    \"\"\"Client for interacting with AlgoPotato smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = AlgoPotatoParams(self.app_client)\n        self.create_transaction = AlgoPotatoCreateTransactionParams(self.app_client)\n        self.send = AlgoPotatoSend(self.app_client)\n        self.state = AlgoPotatoState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"AlgoPotatoClient\":\n        return AlgoPotatoClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"AlgoPotatoClient\":\n        return AlgoPotatoClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"AlgoPotatoClient\":\n        return AlgoPotatoClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"AlgoPotatoComposer\":\n        return AlgoPotatoComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"asset_opt_in(asset,txn)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"create_game(txn,txn)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"prime_game_vrf((address,uint64),txn)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"play_game((address,uint64))string\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> str | None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"cancel_game((address,uint64))void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | str:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass AlgoPotatoBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):\n    \"\"\"Parameters for creating AlgoPotato contract with bare calls\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:\n        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)\n\nclass AlgoPotatoFactory(algokit_utils.TypedAppFactoryProtocol[AlgoPotatoBareCallCreateParams, None, None]):\n    \"\"\"Factory for deploying and managing AlgoPotatoClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = AlgoPotatoFactoryParams(self.app_factory)\n        self.create_transaction = AlgoPotatoFactoryCreateTransaction(self.app_factory)\n        self.send = AlgoPotatoFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: AlgoPotatoBareCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[AlgoPotatoClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return AlgoPotatoClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> AlgoPotatoClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return AlgoPotatoClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> AlgoPotatoClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return AlgoPotatoClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass AlgoPotatoFactoryParams:\n    \"\"\"Parameters for creating transactions for AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = AlgoPotatoFactoryCreateParams(app_factory)\n        self.update = AlgoPotatoFactoryUpdateParams(app_factory)\n        self.delete = AlgoPotatoFactoryDeleteParams(app_factory)\n\nclass AlgoPotatoFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def asset_opt_in(\n        self,\n        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the asset_opt_in(asset,txn)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"asset_opt_in(asset,txn)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def create_game(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the create_game(txn,txn)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"create_game(txn,txn)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def prime_game_vrf(\n        self,\n        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the prime_game_vrf((address,uint64),txn)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"prime_game_vrf((address,uint64),txn)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def play_game(\n        self,\n        args: tuple[GameBoxName] | PlayGameArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the play_game((address,uint64))string ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"play_game((address,uint64))string\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def cancel_game(\n        self,\n        args: tuple[GameBoxName] | CancelGameArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the cancel_game((address,uint64))void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"cancel_game((address,uint64))void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass AlgoPotatoFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass AlgoPotatoFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass AlgoPotatoFactoryCreateTransaction:\n    \"\"\"Create transactions for AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = AlgoPotatoFactoryCreateTransactionCreate(app_factory)\n\n\nclass AlgoPotatoFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass AlgoPotatoFactorySend:\n    \"\"\"Send calls to AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = AlgoPotatoFactorySendCreate(app_factory)\n\n\nclass AlgoPotatoFactorySendCreate:\n    \"\"\"Send create calls to AlgoPotato contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[AlgoPotatoClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return AlgoPotatoClient(result[0]), result[1]\n\n\nclass AlgoPotatoComposer:\n    \"\"\"Composer for creating transaction groups for AlgoPotato contract calls\"\"\"\n\n    def __init__(self, client: \"AlgoPotatoClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    def asset_opt_in(\n        self,\n        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | AssetOptInArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"AlgoPotatoComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.asset_opt_in(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"asset_opt_in(asset,txn)void\", v\n            )\n        )\n        return self\n\n    def create_game(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument | None, algokit_utils.AppMethodCallTransactionArgument] | CreateGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"AlgoPotatoComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.create_game(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"create_game(txn,txn)void\", v\n            )\n        )\n        return self\n\n    def prime_game_vrf(\n        self,\n        args: tuple[GameBoxName, algokit_utils.AppMethodCallTransactionArgument] | PrimeGameVrfArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"AlgoPotatoComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.prime_game_vrf(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"prime_game_vrf((address,uint64),txn)void\", v\n            )\n        )\n        return self\n\n    def play_game(\n        self,\n        args: tuple[GameBoxName] | PlayGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"AlgoPotatoComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.play_game(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"play_game((address,uint64))string\", v\n            )\n        )\n        return self\n\n    def cancel_game(\n        self,\n        args: tuple[GameBoxName] | CancelGameArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"AlgoPotatoComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.cancel_game(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"cancel_game((address,uint64))void\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"AlgoPotatoComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"AlgoPotatoComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"file_path": "https://github.com/Vradss/BUILDH3R_WORKSHOPS/blob/7f9c2a5abec474893022c115e1ace1c9367b10e3/June/Algorand/main.py", "code": "# import the modules to interactive with the chain\nfrom algokit_utils.beta.algorand_client import (\n    AlgorandClient,\n    AssetCreateParams,\n    AssetOptInParams,\n    AssetTransferParams,\n    PayParams,\n)\n# Create our client\nalgorand = AlgorandClient.default_local_net()\n\n# dispenser.address = public key | dispenser.signer = private key\ndispenser = algorand.account.dispenser()\n#print(\"Dispenser Address:\", dispenser.address)\n\n#Create a Wallet & first algorand account\ncreator = algorand.account.random()\n#print(\"Creator Address:\", creator.address)\n#print(algorand.account.get_information(creator.address))\n\n#Create first transaction\nalgorand.send.payment(\n    PayParams(\n        sender=dispenser.address,\n        receiver=creator.address,\n        amount=10_000_000\n    )\n)\n\n#print(algorand.account.get_information(creator.address))\n\n#Create Token\nsent_txn = algorand.send.asset_create(\n    AssetCreateParams(\n        sender=creator.address,\n        total=1000,\n        asset_name=\"BUILDH3R\",\n        unit_name=\"H3R\",\n        manager=creator.address,\n        clawback=creator.address,\n        freeze=creator.address\n        \n    )\n)\n\n#Extract asset ID to identify in blockchain\nasset_id = sent_txn[\"confirmation\"][\"asset-index\"]\n#print(\"Asset ID\", asset_id)\n\n\n# Create the receiver\nreceiver_vrads = algorand.account.random()\n#print(\"Receiver Address:\", receiver_vrads.address)\n\n# Transfer the asset from creator to receiver\n\nalgorand.send.payment(\n    PayParams(\n        sender=dispenser.address,\n        receiver=receiver_vrads.address,\n        amount=10_000_000\n    )\n)\n\n# The atomic transfer segment : add opt_in\ngroup_tx = algorand.new_group()\n\ngroup_tx.add_asset_opt_in(\n    AssetOptInParams(\n        sender=receiver_vrads.address,\n        asset_id=asset_id\n    )\n)\n\ngroup_tx.add_payment(\n    PayParams(\n        sender=receiver_vrads.address,\n        receiver=creator.address,\n        amount=1_000_000\n    )\n)\n\ngroup_tx.add_asset_transfer(\n    AssetTransferParams(\n        sender=creator.address,\n        receiver=receiver_vrads.address,\n        asset_id=asset_id,\n        amount=10\n    )\n)\n\ngroup_tx.execute()\n\n#print(algorand.account.get_information(receiver_vrads.address))\n\nprint(\"Receiver Account Asset Balance:\", algorand.account.get_information(receiver_vrads.address)['assets'][0]['amount'])\nprint(\"Creator Account Asset Balance:\", algorand.account.get_information(creator.address)['assets'][0]['amount'])\n\nalgorand.send.asset_transfer(\n    AssetTransferParams(\n        sender=creator.address,\n        receiver=creator.address,\n        asset_id=asset_id,\n        amount=2,\n        clawback_target=receiver_vrads.address\n    )\n)\n\nprint(\"Post clawback\")\n\nprint(\"Receiver Account Asset Balance:\", algorand.account.get_information(receiver_vrads.address)['assets'][0]['amount'])\nprint(\"Creator Account Asset Balance:\", algorand.account.get_information(creator.address)['assets'][0]['amount'])"}
{"file_path": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/pyteal/ast/txn.py", "code": "from enum import Enum\nfrom typing import Callable, Optional, Union, cast, TYPE_CHECKING\n\nfrom pyteal.types import TealType, require_type\nfrom pyteal.errors import (\n    TealInputError,\n    TealCompileError,\n    verifyFieldVersion,\n    verifyProgramVersion,\n)\nfrom pyteal.ir import TealOp, Op, TealBlock\nfrom pyteal.ast.leafexpr import LeafExpr\nfrom pyteal.ast.expr import Expr\nfrom pyteal.ast.int import EnumInt\nfrom pyteal.ast.array import Array\n\nif TYPE_CHECKING:\n    from pyteal.compiler import CompileOptions\n\n\nclass TxnType:\n    \"\"\"Enum of all possible transaction types.\"\"\"\n\n    Unknown = EnumInt(\"unknown\")  # T2PT7\n    Payment = EnumInt(\"pay\")  # T2PT7\n    KeyRegistration = EnumInt(\"keyreg\")  # T2PT7\n    AssetConfig = EnumInt(\"acfg\")  # T2PT7\n    AssetTransfer = EnumInt(\"axfer\")  # T2PT7\n    AssetFreeze = EnumInt(\"afrz\")  # T2PT7\n    ApplicationCall = EnumInt(\"appl\")  # T2PT7\n\n\nTxnType.__module__ = \"pyteal\"\n\n\nclass TxnField(Enum):\n    sender = (0, \"Sender\", TealType.bytes, False, 2)\n    fee = (1, \"Fee\", TealType.uint64, False, 2)\n    first_valid = (2, \"FirstValid\", TealType.uint64, False, 2)\n    first_valid_time = (3, \"FirstValidTime\", TealType.uint64, False, 7)\n    last_valid = (4, \"LastValid\", TealType.uint64, False, 2)\n    note = (5, \"Note\", TealType.bytes, False, 2)\n    lease = (6, \"Lease\", TealType.bytes, False, 2)\n    receiver = (7, \"Receiver\", TealType.bytes, False, 2)\n    amount = (8, \"Amount\", TealType.uint64, False, 2)\n    close_remainder_to = (9, \"CloseRemainderTo\", TealType.bytes, False, 2)\n    vote_pk = (10, \"VotePK\", TealType.bytes, False, 2)\n    selection_pk = (11, \"SelectionPK\", TealType.bytes, False, 2)\n    vote_first = (12, \"VoteFirst\", TealType.uint64, False, 2)\n    vote_last = (13, \"VoteLast\", TealType.uint64, False, 2)\n    vote_key_dilution = (14, \"VoteKeyDilution\", TealType.uint64, False, 2)\n    type = (15, \"Type\", TealType.bytes, False, 2)\n    type_enum = (16, \"TypeEnum\", TealType.uint64, False, 2)\n    xfer_asset = (17, \"XferAsset\", TealType.uint64, False, 2)\n    asset_amount = (18, \"AssetAmount\", TealType.uint64, False, 2)\n    asset_sender = (19, \"AssetSender\", TealType.bytes, False, 2)\n    asset_receiver = (20, \"AssetReceiver\", TealType.bytes, False, 2)\n    asset_close_to = (21, \"AssetCloseTo\", TealType.bytes, False, 2)\n    group_index = (22, \"GroupIndex\", TealType.uint64, False, 2)\n    tx_id = (23, \"TxID\", TealType.bytes, False, 2)\n    application_id = (24, \"ApplicationID\", TealType.uint64, False, 2)\n    on_completion = (25, \"OnCompletion\", TealType.uint64, False, 2)\n    application_args = (26, \"ApplicationArgs\", TealType.bytes, True, 2)\n    num_app_args = (27, \"NumAppArgs\", TealType.uint64, False, 2)\n    accounts = (28, \"Accounts\", TealType.bytes, True, 2)\n    num_accounts = (2, \"NumAccounts\", TealType.uint64, False, 2)\n    approval_program = (30, \"ApprovalProgram\", TealType.bytes, False, 2)\n    clear_state_program = (31, \"ClearStateProgram\", TealType.bytes, False, 2)\n    rekey_to = (32, \"RekeyTo\", TealType.bytes, False, 2)\n    config_asset = (33, \"ConfigAsset\", TealType.uint64, False, 2)\n    config_asset_total = (34, \"ConfigAssetTotal\", TealType.uint64, False, 2)\n    config_asset_decimals = (35, \"ConfigAssetDecimals\", TealType.uint64, False, 2)\n    config_asset_default_frozen = (\n        36,\n        \"ConfigAssetDefaultFrozen\",\n        TealType.uint64,\n        False,\n        2,\n    )\n    config_asset_unit_name = (37, \"ConfigAssetUnitName\", TealType.bytes, False, 2)\n    config_asset_name = (38, \"ConfigAssetName\", TealType.bytes, False, 2)\n    config_asset_url = (39, \"ConfigAssetURL\", TealType.bytes, False, 2)\n    config_asset_metadata_hash = (\n        40,\n        \"ConfigAssetMetadataHash\",\n        TealType.bytes,\n        False,\n        2,\n    )\n    config_asset_manager = (41, \"ConfigAssetManager\", TealType.bytes, False, 2)\n    config_asset_reserve = (42, \"ConfigAssetReserve\", TealType.bytes, False, 2)\n    config_asset_freeze = (43, \"ConfigAssetFreeze\", TealType.bytes, False, 2)\n    config_asset_clawback = (44, \"ConfigAssetClawback\", TealType.bytes, False, 2)\n    freeze_asset = (45, \"FreezeAsset\", TealType.uint64, False, 2)\n    freeze_asset_account = (46, \"FreezeAssetAccount\", TealType.bytes, False, 2)\n    freeze_asset_frozen = (47, \"FreezeAssetFrozen\", TealType.uint64, False, 2)\n    assets = (48, \"Assets\", TealType.uint64, True, 3)\n    num_assets = (49, \"NumAssets\", TealType.uint64, False, 3)\n    applications = (50, \"Applications\", TealType.uint64, True, 3)\n    num_applications = (51, \"NumApplications\", TealType.uint64, False, 3)\n    global_num_uints = (52, \"GlobalNumUint\", TealType.uint64, False, 3)\n    global_num_byte_slices = (53, \"GlobalNumByteSlice\", TealType.uint64, False, 3)\n    local_num_uints = (54, \"LocalNumUint\", TealType.uint64, False, 3)\n    local_num_byte_slices = (55, \"LocalNumByteSlice\", TealType.uint64, False, 3)\n    extra_program_pages = (56, \"ExtraProgramPages\", TealType.uint64, False, 4)\n    nonparticipation = (57, \"Nonparticipation\", TealType.uint64, False, 5)\n    logs = (58, \"Logs\", TealType.bytes, True, 5)\n    num_logs = (59, \"NumLogs\", TealType.uint64, False, 5)\n    created_asset_id = (60, \"CreatedAssetID\", TealType.uint64, False, 5)\n    created_application_id = (61, \"CreatedApplicationID\", TealType.uint64, False, 5)\n    last_log = (62, \"LastLog\", TealType.bytes, False, 6)\n    state_proof_pk = (63, \"StateProofPK\", TealType.bytes, False, 6)\n    approval_program_pages = (64, \"ApprovalProgramPages\", TealType.bytes, True, 7)\n    num_approval_program_pages = (\n        65,\n        \"NumApprovalProgramPages\",\n        TealType.uint64,\n        False,\n        7,\n    )\n    clear_state_program_pages = (66, \"ClearStateProgramPages\", TealType.bytes, True, 7)\n    num_clear_state_program_pages = (\n        67,\n        \"NumClearStateProgramPages\",\n        TealType.uint64,\n        False,\n        7,\n    )\n\n    def __init__(\n        self, id: int, name: str, type: TealType, is_array: bool, min_version: int\n    ) -> None:\n        self.id = id\n        self.arg_name = name\n        self.ret_type = type\n        self.is_array = is_array\n        self.min_version = min_version\n\n    def type_of(self) -> TealType:\n        return self.ret_type\n\n\nTxnField.__module__ = \"pyteal\"\n\n\nclass TxnExpr(LeafExpr):\n    \"\"\"An expression that accesses a transaction field from the current transaction.\"\"\"\n\n    def __init__(self, op: Op, name: str, field: TxnField) -> None:\n        super().__init__()\n        if field.is_array:\n            raise TealInputError(\"Unexpected array field: {}\".format(field))\n        self.op = op\n        self.name = name\n        self.field = field\n\n    def __str__(self):\n        return \"({} {})\".format(self.name, self.field.arg_name)\n\n    def __teal__(self, options: \"CompileOptions\"):\n        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)\n        verifyProgramVersion(\n            self.op.min_version,\n            options.version,\n            \"Program version too low to use op {}\".format(self.op),\n        )\n\n        op = TealOp(self, self.op, self.field.arg_name)\n        return TealBlock.FromOp(options, op)\n\n    def type_of(self):\n        return self.field.type_of()\n\n\nTxnExpr.__module__ = \"pyteal\"\n\n\nclass TxnaExpr(LeafExpr):\n    \"\"\"An expression that accesses a transaction array field from the current transaction.\"\"\"\n\n    @staticmethod\n    def __validate_index_or_throw(index: Union[int, Expr]):\n        if not isinstance(index, (int, Expr)):\n            raise TealInputError(\n                f\"Invalid index type:  Expected int or Expr, but received {index}.\"\n            )\n        if isinstance(index, Expr):\n            require_type(index, TealType.uint64)\n\n    def __init__(\n        self,\n        staticOp: Op,\n        dynamicOp: Optional[Op],\n        name: str,\n        field: TxnField,\n        index: Union[int, Expr],\n    ) -> None:\n        super().__init__()\n        if not field.is_array:\n            raise TealInputError(\"Unexpected non-array field: {}\".format(field))\n        self.__validate_index_or_throw(index)\n\n        self.staticOp = staticOp\n        self.dynamicOp = dynamicOp\n        self.name = name\n        self.field = field\n        self.index = index\n\n    def __str__(self):\n        return \"({} {} {})\".format(self.name, self.field.arg_name, self.index)\n\n    def __teal__(self, options: \"CompileOptions\"):\n        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)\n\n        opToUse = self.staticOp if type(self.index) is int else self.dynamicOp\n        if opToUse is None:\n            raise TealCompileError(\"Dynamic array indexing not supported\", self)\n\n        verifyProgramVersion(\n            opToUse.min_version,\n            options.version,\n            \"Program version too low to use op {}\".format(opToUse),\n        )\n\n        if type(self.index) is int:\n            op = TealOp(self, opToUse, self.field.arg_name, self.index)\n            return TealBlock.FromOp(options, op)\n\n        op = TealOp(self, opToUse, self.field.arg_name)\n        return TealBlock.FromOp(options, op, cast(Expr, self.index))\n\n    def type_of(self):\n        return self.field.type_of()\n\n\nTxnaExpr.__module__ = \"pyteal\"\n\n\nclass TxnExprBuilder:\n    def __init__(self, op: Op, name: str):\n        self.op = op\n        self.name = name\n\n    def __call__(self, field: TxnField) -> TxnExpr:\n        return TxnExpr(self.op, self.name, field)\n\n\nTxnExprBuilder.__module__ = \"pyteal\"\n\n\nclass TxnaExprBuilder:\n    def __init__(self, staticOp: Op, dynamicOp: Optional[Op], name: str):\n        self.staticOp = staticOp\n        self.dynamicOp = dynamicOp\n        self.name = name\n\n    def __call__(self, field: TxnField, index: Union[int, Expr]) -> TxnaExpr:\n        return TxnaExpr(self.staticOp, self.dynamicOp, self.name, field, index)\n\n\nTxnaExprBuilder.__module__ = \"pyteal\"\n\n\nclass TxnArray(Array):\n    \"\"\"Represents a transaction array field.\"\"\"\n\n    def __init__(\n        self, txnObject: \"TxnObject\", accessField: TxnField, lengthField: TxnField\n    ) -> None:\n        self.txnObject = txnObject\n        self.accessField = accessField\n        self.lengthField = lengthField\n\n    def length(self) -> TxnExpr:\n        return self.txnObject.makeTxnExpr(self.lengthField)\n\n    def __getitem__(self, index: Union[int, Expr]) -> TxnaExpr:\n        if type(index) is int:\n            if index < 0:\n                raise TealInputError(\"Invalid array index: {}\".format(index))\n        else:\n            require_type(cast(Expr, index), TealType.uint64)\n\n        return self.txnObject.makeTxnaExpr(self.accessField, index)\n\n\nTxnArray.__module__ = \"pyteal\"\n\n\nclass TxnObject:\n    \"\"\"Represents a transaction and its fields.\"\"\"\n\n    def __init__(\n        self,\n        makeTxnExpr: Callable[[TxnField], TxnExpr],\n        makeTxnaExpr: Callable[[TxnField, Union[int, Expr]], TxnaExpr],\n    ) -> None:\n        self.makeTxnExpr = makeTxnExpr\n        self.makeTxnaExpr = makeTxnaExpr\n\n    def sender(self) -> TxnExpr:\n        \"\"\"Get the 32 byte address of the sender.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#sender\n        \"\"\"\n        return self.makeTxnExpr(TxnField.sender)\n\n    def fee(self) -> TxnExpr:\n        \"\"\"Get the transaction fee in micro Algos.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#fee\n        \"\"\"\n        return self.makeTxnExpr(TxnField.fee)\n\n    def first_valid(self) -> TxnExpr:\n        \"\"\"Get the first valid round number.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#firstvalid\n        \"\"\"\n        return self.makeTxnExpr(TxnField.first_valid)\n\n    def first_valid_time(self) -> TxnExpr:\n        \"\"\"Get the UNIX timestamp of block before txn.FirstValid. Fails if negative.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#firstvalidtime\n        \"\"\"\n        return self.makeTxnExpr(TxnField.first_valid_time)\n\n    def last_valid(self) -> TxnExpr:\n        \"\"\"Get the last valid round number.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#lastvalid\n        \"\"\"\n        return self.makeTxnExpr(TxnField.last_valid)\n\n    def note(self) -> TxnExpr:\n        \"\"\"Get the transaction note.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#note\n        \"\"\"\n        return self.makeTxnExpr(TxnField.note)\n\n    def lease(self) -> TxnExpr:\n        \"\"\"Get the transaction lease.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#lease\n        \"\"\"\n        return self.makeTxnExpr(TxnField.lease)\n\n    def receiver(self) -> TxnExpr:\n        \"\"\"Get the 32 byte address of the receiver.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#receiver\n        \"\"\"\n        return self.makeTxnExpr(TxnField.receiver)\n\n    def amount(self) -> TxnExpr:\n        \"\"\"Get the amount of the transaction in micro Algos.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#amount\n        \"\"\"\n        return self.makeTxnExpr(TxnField.amount)\n\n    def close_remainder_to(self) -> TxnExpr:\n        \"\"\"Get the 32 byte address of the CloseRemainderTo field.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#closeremainderto\n        \"\"\"\n        return self.makeTxnExpr(TxnField.close_remainder_to)\n\n    def vote_pk(self) -> TxnExpr:\n        \"\"\"Get the root participation public key.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#votepk\n        \"\"\"\n        return self.makeTxnExpr(TxnField.vote_pk)\n\n    def selection_pk(self) -> TxnExpr:\n        \"\"\"Get the VRF public key.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#selectionpk\n        \"\"\"\n        return self.makeTxnExpr(TxnField.selection_pk)\n\n    def vote_first(self) -> TxnExpr:\n        \"\"\"Get the first round that the participation key is valid.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#votefirst\n        \"\"\"\n        return self.makeTxnExpr(TxnField.vote_first)\n\n    def vote_last(self) -> TxnExpr:\n        \"\"\"Get the last round that the participation key is valid.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#votelast\n        \"\"\"\n        return self.makeTxnExpr(TxnField.vote_last)\n\n    def vote_key_dilution(self) -> TxnExpr:\n        \"\"\"Get the dilution for the 2-level participation key.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#votekeydilution\n        \"\"\"\n        return self.makeTxnExpr(TxnField.vote_key_dilution)\n\n    def nonparticipation(self) -> TxnExpr:\n        \"\"\"Marks an account nonparticipating for rewards.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#nonparticipation\n\n        Requires program version 5 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.nonparticipation)\n\n    def type(self) -> TxnExpr:\n        \"\"\"Get the type of this transaction as a byte string.\n\n        In most cases it is preferable to use :any:`type_enum()` instead.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#type\n        \"\"\"\n        return self.makeTxnExpr(TxnField.type)\n\n    def type_enum(self) -> TxnExpr:\n        \"\"\"Get the type of this transaction.\n\n        See :any:`TxnType` for possible values.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.type_enum)\n\n    def xfer_asset(self) -> TxnExpr:\n        \"\"\"Get the ID of the asset being transferred.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#xferasset\n        \"\"\"\n        return self.makeTxnExpr(TxnField.xfer_asset)\n\n    def asset_amount(self) -> TxnExpr:\n        \"\"\"Get the amount of the asset being transferred, measured in the asset's units.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetamount\n        \"\"\"\n        return self.makeTxnExpr(TxnField.asset_amount)\n\n    def asset_sender(self) -> TxnExpr:\n        \"\"\"Get the 32 byte address of the subject of clawback.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetsender\n        \"\"\"\n        return self.makeTxnExpr(TxnField.asset_sender)\n\n    def asset_receiver(self) -> TxnExpr:\n        \"\"\"Get the recipient of the asset transfer.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetreceiver\n        \"\"\"\n        return self.makeTxnExpr(TxnField.asset_receiver)\n\n    def asset_close_to(self) -> TxnExpr:\n        \"\"\"Get the closeout address of the asset transfer.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetcloseto\n        \"\"\"\n        return self.makeTxnExpr(TxnField.asset_close_to)\n\n    def group_index(self) -> TxnExpr:\n        \"\"\"Get the position of the transaction within the atomic transaction group.\n\n        A stand-alone transaction is implictly element 0 in a group of 1.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#group\n        \"\"\"\n        return self.makeTxnExpr(TxnField.group_index)\n\n    def tx_id(self) -> TxnExpr:\n        \"\"\"Get the 32 byte computed ID for the transaction.\"\"\"\n        return self.makeTxnExpr(TxnField.tx_id)\n\n    def application_id(self) -> TxnExpr:\n        \"\"\"Get the application ID from the ApplicationCall portion of the current transaction.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.application_id)\n\n    def on_completion(self) -> TxnExpr:\n        \"\"\"Get the on completion action from the ApplicationCall portion of the transaction.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.on_completion)\n\n    def approval_program(self) -> TxnExpr:\n        \"\"\"Get the approval program.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.approval_program)\n\n    def clear_state_program(self) -> TxnExpr:\n        \"\"\"Get the clear state program.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.clear_state_program)\n\n    def rekey_to(self) -> TxnExpr:\n        \"\"\"Get the sender's new 32 byte AuthAddr.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#rekeyto\n        \"\"\"\n        return self.makeTxnExpr(TxnField.rekey_to)\n\n    def config_asset(self) -> TxnExpr:\n        \"\"\"Get the asset ID in asset config transaction.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#configasset\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset)\n\n    def config_asset_total(self) -> TxnExpr:\n        \"\"\"Get the total number of units of this asset created.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#total\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_total)\n\n    def config_asset_decimals(self) -> TxnExpr:\n        \"\"\"Get the number of digits to display after the decimal place when displaying the asset.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#decimals\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_decimals)\n\n    def config_asset_default_frozen(self) -> TxnExpr:\n        \"\"\"Check if the asset's slots are frozen by default or not.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#defaultfrozen\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_default_frozen)\n\n    def config_asset_unit_name(self) -> TxnExpr:\n        \"\"\"Get the unit name of the asset.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#unitname\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_unit_name)\n\n    def config_asset_name(self) -> TxnExpr:\n        \"\"\"Get the asset name.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetname\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_name)\n\n    def config_asset_url(self) -> TxnExpr:\n        \"\"\"Get the asset URL.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#url\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_url)\n\n    def config_asset_metadata_hash(self) -> TxnExpr:\n        \"\"\"Get the 32 byte commitment to some unspecified asset metdata.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#metadatahash\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_metadata_hash)\n\n    def config_asset_manager(self) -> TxnExpr:\n        \"\"\"Get the 32 byte asset manager address.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#manageraddr\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_manager)\n\n    def config_asset_reserve(self) -> TxnExpr:\n        \"\"\"Get the 32 byte asset reserve address.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#reserveaddr\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_reserve)\n\n    def config_asset_freeze(self) -> TxnExpr:\n        \"\"\"Get the 32 byte asset freeze address.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeaddr\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_freeze)\n\n    def config_asset_clawback(self) -> TxnExpr:\n        \"\"\"Get the 32 byte asset clawback address.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#clawbackaddr\n        \"\"\"\n        return self.makeTxnExpr(TxnField.config_asset_clawback)\n\n    def created_asset_id(self) -> TxnExpr:\n        \"\"\"Get the asset ID allocated by the creation of an ASA.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig` and this is an asset creation transaction.\n\n        Requires program version 5 or higher.\n\n        * v5 - Only works on inner transactions.\n        * >= v6 - Works on top-level and inner transactions.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.created_asset_id)\n\n    def freeze_asset(self) -> TxnExpr:\n        \"\"\"Get the asset ID being frozen or un-frozen.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeasset\n        \"\"\"\n        return self.makeTxnExpr(TxnField.freeze_asset)\n\n    def freeze_asset_account(self) -> TxnExpr:\n        \"\"\"Get the 32 byte address of the account whose asset slot is being frozen or un-frozen.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeaccount\n        \"\"\"\n        return self.makeTxnExpr(TxnField.freeze_asset_account)\n\n    def freeze_asset_frozen(self) -> TxnExpr:\n        \"\"\"Get the new frozen value for the asset.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.\n\n        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetfrozen\n        \"\"\"\n        return self.makeTxnExpr(TxnField.freeze_asset_frozen)\n\n    def global_num_uints(self) -> TxnExpr:\n        \"\"\"Get the schema count of global state integers in an application creation call.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.\n\n        Requires program version 3 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.global_num_uints)\n\n    def global_num_byte_slices(self) -> TxnExpr:\n        \"\"\"Get the schema count of global state byte slices in an application creation call.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.\n\n        Requires program version 3 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.global_num_byte_slices)\n\n    def local_num_uints(self) -> TxnExpr:\n        \"\"\"Get the schema count of local state integers in an application creation call.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.\n\n        Requires program version 3 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.local_num_uints)\n\n    def local_num_byte_slices(self) -> TxnExpr:\n        \"\"\"Get the schema count of local state byte slices in an application creation call.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.\n\n        Requires program version 3 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.local_num_byte_slices)\n\n    def extra_program_pages(self) -> TxnExpr:\n        \"\"\"Get the number of additional pages for each of the application's approval and clear state programs.\n\n        1 additional page means 2048 more total bytes, or 1024 for each program.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.\n\n        Requires program version 4 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.extra_program_pages)\n\n    def created_application_id(self) -> TxnExpr:\n        \"\"\"Get the application ID allocated by the creation of an application.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.\n\n        Requires program version 5 or higher.\n\n        * v5 - Only works on inner transactions.\n        * >= v6 - Works on top-level and inner transactions.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.created_application_id)\n\n    def last_log(self) -> TxnExpr:\n        \"\"\"A convenience method for getting the last logged message from a transaction.\n\n        Only application calls may log a message. Returns an empty string if no messages were logged.\n\n        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.\n\n        Requires program version 6 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.last_log)\n\n    def state_proof_pk(self) -> TxnExpr:\n        \"\"\"Get the state proof public key commitment from a transaction.\n\n        Requires program version 6 or higher.\n        \"\"\"\n        return self.makeTxnExpr(TxnField.state_proof_pk)\n\n    @property\n    def application_args(self) -> TxnArray:\n        \"\"\"Application call arguments array.\n\n        :type: TxnArray\n        \"\"\"\n        return TxnArray(self, TxnField.application_args, TxnField.num_app_args)\n\n    @property\n    def accounts(self) -> TxnArray:\n        \"\"\"The accounts array in an ApplicationCall transaction.\n\n        :type: TxnArray\n        \"\"\"\n        return TxnArray(self, TxnField.accounts, TxnField.num_accounts)\n\n    @property\n    def assets(self) -> TxnArray:\n        \"\"\"The foreign asset array in an ApplicationCall transaction.\n\n        :type: TxnArray\n\n        Requires program version 3 or higher.\n        \"\"\"\n        return TxnArray(self, TxnField.assets, TxnField.num_assets)\n\n    @property\n    def applications(self) -> TxnArray:\n        \"\"\"The applications array in an ApplicationCall transaction.\n\n        :type: TxnArray\n\n        Requires program version 3 or higher.\n        \"\"\"\n        return TxnArray(self, TxnField.applications, TxnField.num_applications)\n\n    @property\n    def logs(self) -> TxnArray:\n        \"\"\"The log messages emitted by an application call.\n\n        :type: TxnArray\n\n        Requires program version 5 or higher.\n\n        * v5 - Only works on inner transactions.\n        * >= v6 - Works on top-level and inner transactions.\n        \"\"\"\n        return TxnArray(self, TxnField.logs, TxnField.num_logs)\n\n    @property\n    def approval_program_pages(self) -> TxnArray:\n        \"\"\"The approval program pages.\n\n        :type: TxnArray\n\n        Requires program version 7 or higher.\n        \"\"\"\n        return TxnArray(\n            self, TxnField.approval_program_pages, TxnField.num_approval_program_pages\n        )\n\n    @property\n    def clear_state_program_pages(self) -> TxnArray:\n        \"\"\"The clear state program pages.\n\n        :type: TxnArray\n\n        Requires program version 7 or higher.\n        \"\"\"\n        return TxnArray(\n            self,\n            TxnField.clear_state_program_pages,\n            TxnField.num_clear_state_program_pages,\n        )\n\n\nTxnObject.__module__ = \"pyteal\"\n\nTxn: TxnObject = TxnObject(\n    TxnExprBuilder(Op.txn, \"Txn\"), TxnaExprBuilder(Op.txna, Op.txnas, \"Txna\")\n)\n\nTxn.__module__ = \"pyteal\""}
{"file_path": "https://github.com/damees/algorand-oracle/blob/f7f078f9d153341d1ba546ff66e8afbf2685f114/algorand-oracle-smart-contracts/src/algorand_oracle.py", "code": "from pyteal import *\n\n\nADMIN_KEY = Bytes(\"admin\")\nWHITELISTED_KEY = Bytes(\"whitelisted\")\nREQUESTS_BALANCE_KEY = Bytes(\"requests_balance\")\nMAX_BUY_AMOUNT = Int(1000000000)\nMIN_BUY_AMOUNT = Int(10000000)\nREQUESTS_SELLER = Addr(\"N5ICVTFKS7RJJHGWWM5QXG2L3BV3GEF6N37D2ZF73O4PCBZCXP4HV3K7CY\")\nMARKET_EXCHANGE_NOTE = Bytes(\"algo-oracle-app-4\")\n\n\ndef approval_program():\n    on_creation = Seq(\n        [\n            Assert(Txn.application_args.length() == Int(0)),\n            App.localPut(Int(0), ADMIN_KEY, Int(1)),\n            Return(Int(1))\n        ]\n    )\n\n    is_contract_admin = App.localGet(Int(0), ADMIN_KEY)\n\n    # set/remove an admin for this contract\n    admin_status = Btoi(Txn.application_args[2])\n    set_admin = Seq(\n        [\n            Assert(\n                And(\n                    is_contract_admin,\n                    Txn.application_args.length() == Int(3),\n                    Txn.accounts.length() == Int(1),\n                    )\n            ),\n            App.localPut(Int(1), ADMIN_KEY, admin_status),\n            Return(Int(1)),\n        ]\n    )\n\n    register = Seq(\n        [\n            App.localPut(Int(0), WHITELISTED_KEY, Int(0)), Return(Int(1))\n        ]\n    )\n\n    # Depending on what you do, you should always consider implementing a whitelisting to\n    # control who access your app. This will allow you to process offchain validation before\n    # allowing an account to call you app.\n    # You may also consider case by case whitelisting to allow access to specific business methods.\n    whitelist = Seq(\n        [\n            Assert(\n                And(\n                    is_contract_admin,\n                    Txn.application_args.length() == Int(2),\n                    Txn.accounts.length() == Int(1)\n                )\n            ),\n            App.localPut(Int(1), WHITELISTED_KEY, Int(1)),\n            Return(Int(1))\n        ]\n    )\n\n    # This should be added to the checklist of business methods.\n    is_whitelisted = App.localGet(Int(0), WHITELISTED_KEY)\n\n    # An admin can increase the request balance of a user.\n    requests_amount = Btoi(Txn.application_args[1])\n    allocate_requests = Seq(\n        [\n            Assert(\n                And(\n                    is_contract_admin,  # Sent by admin\n                    Txn.application_args.length() == Int(3),  # receiver and amount are provided\n                    Txn.accounts.length() == Int(1),\n                    App.localGet(Int(1), WHITELISTED_KEY),  # receiver is whitelisted\n                )\n            ),\n            App.localPut(\n                Int(1),\n                REQUESTS_BALANCE_KEY,\n                App.localGet(Int(1), REQUESTS_BALANCE_KEY) + requests_amount\n            ),\n            Return(Int(1))\n        ]\n    )\n\n    # a client can buy requests\n    buy_requests = Seq(\n        [\n            Assert(\n                And(\n                    is_whitelisted,\n                    Global.group_size() == Int(2),  # buying requests must be done using an atomic transfer\n                    Gtxn[0].type_enum() == TxnType.Payment,  # the first transaction must be a payment...\n                    Gtxn[0].receiver() == REQUESTS_SELLER,  # ...to our address\n                    Gtxn[0].amount() >= MIN_BUY_AMOUNT,  # we don't sell for less than 10...\n                    Gtxn[0].amount() <= MAX_BUY_AMOUNT,  # ...or more than 1000 ALGO\n                    Txn.group_index() == Int(1),  # call to the contract is the second transaction\n                    Txn.application_args.length() == Int(2),\n                    Txn.accounts.length() == Int(1)  # the address which will use the requests must be provided\n                )\n            ),\n            App.localPut(\n                Int(1),\n                REQUESTS_BALANCE_KEY,\n                App.localGet(Int(1), REQUESTS_BALANCE_KEY) + (Gtxn[0].amount() / Int(100000)),\n                ),\n            Return(Int(1))\n        ]\n    )\n\n    market_exchange_rate_request = Seq(\n        [\n            Assert(\n                And(\n                    is_whitelisted,\n                    Txn.note() == MARKET_EXCHANGE_NOTE,\n                    Txn.application_args.length() == Int(4),\n                    Txn.accounts.length() == Int(0),\n                    App.localGet(Int(0), REQUESTS_BALANCE_KEY) >= Int(1)\n                )\n            ),\n            App.localPut(\n                Int(0),\n                REQUESTS_BALANCE_KEY,\n                App.localGet(Int(0), REQUESTS_BALANCE_KEY) - Int(1),\n                ),\n            Return(Int(1))\n        ]\n    )\n    # Implement other oracle methods...\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_contract_admin)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_contract_admin)],\n        [Txn.on_completion() == OnComplete.CloseOut, Return(Int(1))],\n        [Txn.on_completion() == OnComplete.OptIn, register],\n        [Txn.application_args[0] == Bytes(\"set_admin\"), set_admin],\n        [Txn.application_args[0] == Bytes(\"whitelist\"), whitelist],\n        [Txn.application_args[0] == Bytes(\"allocate_requests\"), allocate_requests],\n        [Txn.application_args[0] == Bytes(\"buy_requests\"), buy_requests],\n        [Txn.application_args[0] == Bytes(\"get_market_exchange_rate\"), market_exchange_rate_request]\n    )\n    return program\n\n\ndef clear_state_program():\n    program = Seq(\n        [\n            Return(Int(1))\n        ]\n    )\n\n    return program\n\n\nif __name__ == \"__main__\":\n    with open(\"algorand_oracle_approval.teal\", \"w\") as f:\n        compiled = compileTeal(approval_program(), mode=Mode.Application, version=5)\n        f.write(compiled)\n\n    with open(\"algorand_oracle_clear_state.teal\", \"w\") as f:\n        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=5)\n        f.write(compiled)"}
{"file_path": "https://github.com/0xLiquidGlass/unnamed/blob/b0d80257651279c7a3b02073f5e2f0d313fe7455/unnamedwallet/src/AtomicTxUtils.py", "code": "\"\"\"\nWritten by Liquid Glass\n\nDocumentation for atomic transactions: https://developer.algorand.org/docs/get-details/atomic_transfers/\n\nUseable functions when imported:\n\nNote that atomic transfers will require a minimum of TWO transactions for the transaction to go through\n\nEach atomic transaction can handle a maximum of 16 individual transactions as of 2023 Apr 3\n\nOtherwise, use NormalTxUtils library for just a single transaction\n\n1. initiate_unsigned_tx(currentUtxo, receivingAddress, sendAmount)\n\nThis function will prepare the transaction parameters for ONE transaction and holds the prepared transaction\n\n2. batch_every_unsigned_tx()\n\nWhere this function will batch all of the prepared transaction in batches of 16\n\n3. calculate_group_id()\n\nThis function will calculate the hash for every atomic transaction batch\n\n4. sign_these_unsigned_txs(relevantPrivateKeys)\n\nThis function will sign all of the prepared transactions (which is previously unsigned) with the correct\nprivate key passed to the relevantPrivateKeys paramater\n\n5. batch_every_signed_tx()\n\nThis function will group all of the individual signed transactions in batches of 16\n\n6. broadcast_every_signed_txs()\n\nThis function will broadcast (or send) every batch of atomic transaction (that has 16 individual regular\ntransactions in it) and if successful, the transaction ID and the block which the transaction was confirmed\non will be printed as output\n\"\"\"\n\nfrom globals.AlgodUtils import algodClient\nfrom algosdk import transaction\n\nparams = algodClient.suggested_params()\n\nlistUnsignedTx = []\nlistBatchedUnsignedTx = []\nlistSignedTx = []\nlistBatchedSignedTx = []\n\ncountFrom = int(0)\n\ndef initiate_unsigned_tx(currentUtxo, receivingAddress, sendAmount, closeToAddress):\n        preparedTx = transaction.PaymentTxn(currentUtxo, params, receivingAddress, sendAmount\n                                            , closeToAddress)\n        # For testing\n        # print(preparedTx)\n        listUnsignedTx.append(preparedTx)\n\ndef batch_every_unsigned_tx():\n        countUpTo = len(listUnsignedTx)\n        countIncrement = int(16)\n        for currentUnsignedTx in range(countFrom, countUpTo, countIncrement):\n                batchedUnsignedTx = listUnsignedTx[currentUnsignedTx : currentUnsignedTx + 16]\n                # For testing\n                # print(batchedUnsignedTx)\n                listBatchedUnsignedTx.append(batchedUnsignedTx)\n\ndef calculate_group_id():\n        for currentBatchUnsignedTx in listBatchedUnsignedTx:\n                transaction.assign_group_id(currentBatchUnsignedTx)\n\ndef sign_these_unsigned_txs(relevantPrivateKeys):\n        countUpTo = len(listUnsignedTx)\n        countIncrement = int(1)\n        for currentUnsignedTxIndex in range(countFrom, countUpTo, countIncrement):\n                currentUnsignedTx = listUnsignedTx[currentUnsignedTxIndex]\n                correspondingPrivateKey = relevantPrivateKeys[currentUnsignedTxIndex]\n                signedTx = currentUnsignedTx.sign(correspondingPrivateKey)\n                listSignedTx.append(signedTx)\n\ndef batch_every_signed_tx():\n        countUpTo = len(listSignedTx)\n        countIncrement = int(16)\n        for currentSignedTx in range(countFrom, countUpTo, countIncrement):\n                batchedSignedTx = listSignedTx[currentSignedTx : currentSignedTx + 16]\n                listBatchedSignedTx.append(batchedSignedTx)\n\ndef broadcast_atomic_txs():\n        numberOfTransactions = len(listBatchedSignedTx)\n        countUpTo = len(listBatchedSignedTx)\n        countIncrement = int(1)\n        print(\"\\nYou have {} transactions in queue\" .format(numberOfTransactions))\n        print(\"\\nDo not quit while the transaction is still in progress\")\n        for currentBatchedSignedTxIndex in range(countFrom, countUpTo, countIncrement):\n                numberOfBatchesLeft = numberOfTransactions - (currentBatchedSignedTxIndex + int(1))\n                print(\"\\nNumber of batches left: {}\" .format(numberOfBatchesLeft))\n                currentTxBatch = listBatchedSignedTx[currentBatchedSignedTxIndex]\n                txId = algodClient.send_transactions(currentTxBatch)\n                confirmedTx =  transaction.wait_for_confirmation(algodClient, txId, 10)\n                print(\"\\nTransaction ID: {}\" .format(txId))\n                print(\"\\nConfirmed in round {}\" .format(confirmedTx.get(\"confirmed-round\", 0)))"}
{"file_path": "https://github.com/hodgerpodger/staketaxcsv/blob/98e02ecf0d00e0152d03359fb2f383352ee4702e/src/staketaxcsv/algo/api/indexer.py", "code": "import datetime\nimport logging\nimport math\nimport os\nimport time\nfrom typing import Optional, Tuple\nfrom requests import Session\nfrom requests.adapters import HTTPAdapter, Retry\n\nfrom staketaxcsv.algo.config_algo import localconfig\nfrom staketaxcsv.common.debug_util import debug_cache\nfrom staketaxcsv.settings_csv import ALGO_INDEXER_NODE, REPORTS_DIR\n\n# https://developer.algorand.org/docs/get-details/indexer/#paginated-results\nINDEXER_LIMIT = 2000\n\n\n# API documentation: https://editor.swagger.io/?url=https://openapi.algonode.cloud/indexer2.oas3.json\nclass Indexer:\n    session = None\n\n    def __init__(self):\n        if not Indexer.session:\n            Indexer.session = Session()\n            retries = Retry(total=5, backoff_factor=2, status_forcelist=[429, 500, 502, 503, 504])\n            Indexer.session.mount(\"https://\", HTTPAdapter(max_retries=retries))\n\n    def account_exists(self, address):\n        endpoint = f\"v2/accounts/{address}/transactions\"\n        params = {\"limit\": 1}\n\n        _, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        return status_code == 200\n\n    @debug_cache(os.path.join(REPORTS_DIR, \"algo\", \"accounts\"))\n    def get_account(self, address: str) -> Optional[dict]:\n        \"\"\"\n        This function retrieves account information for a given address.\n\n        Args:\n          address (str): The address of the Algorand account that we want to retrieve information for.\n\n        Returns:\n          A dictionary containing information about the account if successful, `None` otherwise.\n          See account schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Account\n        \"\"\"\n        endpoint = f\"v2/accounts/{address}\"\n        params = {\"include-all\": True}\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        if status_code == 200:\n            return data[\"account\"]\n        else:\n            return None\n\n    def get_transaction(self, txid: str) -> Optional[dict]:\n        \"\"\"\n        This function retrieves a transaction with a given ID.\n\n        Args:\n          txid (str): The ID of the transaction ID that is being requested.\n\n        Returns:\n          A dictionary containing information about a transaction if successful, `None` otherwise.\n          See transaction schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Transaction\n        \"\"\"\n        endpoint = f\"v2/transactions/{txid}\"\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint)\n\n        if status_code == 200:\n            return data[\"transaction\"]\n        else:\n            return None\n\n    def get_transactions(self,\n                         address: str,\n                         after_date: Optional[datetime.date] = None,\n                         before_date: Optional[datetime.date] = None,\n                         min_round: Optional[int] = None,\n                         next: Optional[str] = None) -> Tuple[list, Optional[str]]:\n        \"\"\"\n        This function retrieves transactions for a given address with optional filters and pagination.\n\n        Args:\n          address (str): The Algorand address for which to retrieve transactions.\n          after_date (Optional[datetime.date]): Include results after the given date.\n          before_date (Optional[datetime.date]): Include results before the given date.\n          min_round (Optional[int]): The minimum round number for transactions to be included in the\n        results. Transactions with a round number lower than this value will be excluded.\n          next (Optional[str]): An optional string that represents a token used to\n        retrieve the next page of results in a multi-page request. It is returned in the response of the\n        previous request and can be passed as a parameter to this function to retrieve the next page of\n        transactions.\n\n        Returns:\n          a tuple containing a list of transactions and an optional string representing the next token for\n        pagination. See transaction schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Transaction\n        \"\"\"\n        endpoint = f\"v2/accounts/{address}/transactions\"\n        params = {\"limit\": INDEXER_LIMIT}\n        if after_date:\n            params[\"after-time\"] = after_date.isoformat()\n        if before_date:\n            params[\"before-time\"] = before_date.isoformat()\n        if min_round:\n            params[\"min-round\"] = min_round\n        if next:\n            params[\"next\"] = next\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        if status_code == 200:\n            return data[\"transactions\"], data.get(\"next-token\")\n        else:\n            return [], None\n\n    @debug_cache(os.path.join(REPORTS_DIR, \"algo\", \"transactions\"))\n    def get_all_transactions(self, address: str) -> list:\n        \"\"\"\n        This function retrieves all transactions for a given address within a specified date range and\n        minimum round, using a maximum number of queries and transactions per query. The transactions are\n        obtained by making multiple queries to the indexer API, with a maximum number of transactions per\n        query determined by the `localconfig.limit` parameter.\n\n        Returns:\n            list: List of transaction objects that match the specified criteria,\n                see schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Transaction\n        \"\"\"\n        next = None\n        out = []\n\n        max_txs = localconfig.limit\n        max_queries = math.ceil(max_txs / INDEXER_LIMIT)\n        logging.info(\"max_txs: %s, max_queries: %s\", max_txs, max_queries)\n\n        after_date = None\n        before_date = None\n        if localconfig.start_date:\n            after_date = datetime.date.fromisoformat(localconfig.start_date)\n        if localconfig.end_date:\n            before_date = datetime.date.fromisoformat(localconfig.end_date) + datetime.timedelta(days=1)\n\n        for _ in range(max_queries):\n            transactions, next = self.get_transactions(\n                address, after_date, before_date, localconfig.min_round, next)\n            out.extend(transactions)\n\n            if not next:\n                break\n\n        return out\n\n    def get_transactions_by_group(self, group_id: str) -> list[dict]:\n        \"\"\"\n        This function retrieves a list of transactions associated with a specific group ID.\n\n        Args:\n          group_id (str): The group ID. More details on transaction groups\\\n          at https://developer.algorand.org/docs/get-details/atomic_transfers/\n\n        Returns:\n          This function returns a list of dictionaries containing transaction data for a specific group ID.\n        \"\"\"\n        endpoint = \"v2/transactions\"\n        params = {\"group-id\": group_id}\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        if status_code == 200:\n            return data[\"transactions\"]\n        else:\n            return []\n\n    @debug_cache(os.path.join(REPORTS_DIR, \"algo\", \"transactions\"))\n    def get_transactions_by_app(self, app_id: int, round: int, address: Optional[str] = None) -> list[dict]:\n        \"\"\"\n        This function retrieves a list of transactions for a specific application ID, round, and optional\n        address.\n\n        Args:\n          app_id (int): The ID of the application for which transactions are being requested.\n          round (int): The round number of the transactions to retrieve.\n          address (Optional[str]): Optional parameter to filter transactions by a specific address.\n\n        Returns:\n          This function returns a list of dictionaries containing transactions made with the specified parameters.\n        \"\"\"\n        endpoint = \"v2/transactions\"\n        params = {\n            \"limit\": INDEXER_LIMIT,\n            \"application-id\": app_id,\n            \"round\": round\n        }\n        if address:\n            params[\"address\"] = address\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        if status_code == 200:\n            return data[\"transactions\"]\n        else:\n            return []\n\n    @debug_cache(os.path.join(REPORTS_DIR, \"algo\", \"assets\"))\n    def get_asset(self, id: int) -> Optional[dict]:\n        \"\"\"\n        This function retrieves asset information.\n\n        Args:\n          id (int): Algorand Standard Asset (ASA) id.\n\n        Returns:\n          A dictionary containing asset details if successful, `None` otherwise.\n          See asset params schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Asset\n        \"\"\"\n        endpoint = f\"v2/assets/{id}\"\n        params = {\"include-all\": True}\n\n        # Temporarily slow down asset requests until we either cache them\n        # or https://github.com/algorand/go-algorand/issues/5250 is resolved.\n        time.sleep(0.1)\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        if status_code == 200:\n            return data[\"asset\"]\n        else:\n            return None\n\n    @debug_cache(os.path.join(REPORTS_DIR, \"algo\", \"assets\"))\n    def get_deleted_asset(self, id: int) -> Optional[dict]:\n        \"\"\"\n        This function retrieves information for an asset that has been deleted.\n\n        Args:\n          id (int): Algorand Standard Asset (ASA) id.\n\n        Returns:\n          A dictionary containing asset details if successful, `None` otherwise.\n          See asset params schema at https://app.swaggerhub.com/apis/algonode/indexer/2.0#/Asset\n        \"\"\"\n        endpoint = f\"v2/assets/{id}/transactions\"\n        params = {\"tx-type\": \"acfg\"}\n\n        data, status_code = self._query(ALGO_INDEXER_NODE, endpoint, params)\n\n        if status_code == 200 and len(data.get(\"transactions\", [])) > 0:\n            return data[\"transactions\"][0][\"asset-config-transaction\"]\n        else:\n            return None\n\n    def _query(self, node_url, endpoint, params=None):\n        url = f\"{node_url}/{endpoint}\"\n\n        logging.info(\"Querying Algo Indexer %s with params %s...\", url, params)\n\n        try:\n            response = Indexer.session.get(url, params=params, timeout=5)\n        except Exception as e:\n            logging.error(\"Exception when querying '%s', exception=%s\", url, str(e))\n        else:\n            return response.json(), response.status_code\n\n        return {}, 599"}
{"file_path": "https://github.com/johnnyknoxville1337/voting-contract/blob/fae150f93a98bc0b048a103971785ce891c96eed/src/Beaker/voting.py", "code": "from pyteal import *\nfrom typing import Final\nfrom beaker import Application, AccountStateValue, ApplicationStateValue, Authorize, bare_external, external, create, opt_in\n\n\nclass Voting(Application):\n    proposal: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    start_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    end_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    result: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    num_of_yays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    num_of_nays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    vote_choice: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.bytes\n    )\n    has_vote: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.uint64\n    )\n\n    @create\n    def create(self):\n        return self.initialize_application_state()\n\n    @opt_in\n    def optin(self):\n        return self.initialize_account_state()\n\n    @external(authorize=Authorize.only(Global.creator_address()))\n    def create_proposal(self, proposal: abi.String, end_time: abi.Uint64):\n        return Seq(\n            self.proposal.set(proposal.get()),\n            self.start_time.set(Global.latest_timestamp()),\n            self.end_time.set(Global.latest_timestamp() + end_time.get())\n        )\n\n    @external(authorize=Authorize.opted_in(Global.current_application_id()))\n    def vote(\n        self,\n        vote_choice: abi.String,\n        key: abi.String,\n        app: abi.Application # type: ignore[assignment]\n    ):\n        return Seq(\n            (is_staking := App.localGetEx(account=Txn.sender(), app=app.application_id(), key=key.get())),\n            Assert(is_staking.hasValue()),\n            Assert(\n                And(\n                    Global.latest_timestamp() >= self.start_time,\n                    Global.latest_timestamp() <= self.end_time\n                )\n            ),\n            Assert(is_staking.value() == Int(1)),\n            Assert(self.has_vote == Int(0)),\n            If(vote_choice.get() == Bytes(\"yes\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"yes\")),\n                self.num_of_yays.increment()\n            )\n            .ElseIf(vote_choice.get() == Bytes(\"no\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"no\")),\n                self.num_of_nays.increment()\n            ),\n            self.has_vote.set(Int(1))\n        )\n\n    @external\n    def get_vote_result(self):\n        return Seq(\n            Assert(Global.latest_timestamp() > self.end_time),\n            If(self.num_of_yays > self.num_of_nays)\n            .Then(self.result.set(Bytes(\"passed\")))\n            .ElseIf(self.num_of_yays < self.num_of_nays)\n            .Then(self.result.set(Bytes(\"rejected\")))\n            .Else(self.result.set(Bytes(\"tie\")))\n        )\n\n    @bare_external(close_out=CallConfig.CALL, clear_state=CallConfig.CALL)\n    def clear_vote(self):\n        return Seq(\n            Assert(self.has_vote == Int(1)),\n            If(self.vote_choice == Bytes(\"yes\"))\n            .Then(\n                Assert(self.num_of_yays >= Int(1)),\n                self.num_of_yays.decrement()\n            )\n            .ElseIf(self.vote_choice == Bytes(\"no\")).\n            Then(\n                Assert(self.num_of_nays >= Int(1)),\n                self.num_of_nays.decrement()\n            ),\n            self.vote_choice.set(Bytes(\"\")),\n            self.has_vote.set(Int(0))\n        )\n\n\nVoting().dump()"}
{"file_path": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/permissioned-voting/assets/permissioned-voting-approval.py", "code": "from pyteal import *\n\ndef approval_program():\n    \"\"\"\n    https://developer.algorand.org/solutions/example-permissioned-voting-stateful-smart-contract-application/?query=asset%2520contract\n    To implement a permissioned voting application on Algorand, a central authority is needed to\n    provide users the right to vote. In this example, this is handled by an Algorand Standard\n    Asset. The central authority creates a vote token and then gives voters who have registered\n    one voting token. The voter then registers within a round range with the voting smart\n    contract, by Opting into the contract. Voters then vote by grouping two transactions.\n    The first is a smart contract call to vote for either candidate A or candidate B, and\n    the second is transferring the vote token back to the central authority. Voting is only\n    allowed within the voting range.\n    \"\"\"\n    # Check to see that the application ID is not set, indicating this is a creation call.\n    # Store the creator address to global state.\n    # Store both register and voting round ranges to global state.\n    # Store Asset ID to global state\n    on_creation = Seq([\n        App.globalPut(Bytes(\"Creator\"), Txn.sender()),\n        Assert(Txn.application_args.length() == Int(5)),\n        App.globalPut(Bytes(\"RegBegin\"), Btoi(Txn.application_args[0])),\n        App.globalPut(Bytes(\"RegEnd\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"VoteBegin\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"VoteEnd\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"AssetID\"), Btoi(Txn.application_args[4])),\n        Return(Int(1))\n    ])\n\n    # Always verify that the RekeyTo property of any transaction is set to the ZeroAddress\n    # unless the contract is specifically involved ina rekeying operation.\n    no_rekey_addr = Txn.rekey_to() == Global.zero_address()\n\n    # Checks whether the sender is creator.\n    is_creator = Txn.sender() == App.globalGet(Bytes(\"Creator\"))\n\n    # Checks whether sender has voted before or not.\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n\n    on_closeout = Seq([\n        get_vote_of_sender,\n        If(And(Global.round() <= App.globalGet(Bytes(\"VoteEnd\")), get_vote_of_sender.hasValue()),\n            App.globalPut(get_vote_of_sender.value(), App.globalGet(get_vote_of_sender.value()) - Int(1))\n        ),\n        Return(Int(1))\n    ])\n\n    # Checks that the first argument to the smart contract is the word \u201cregister\u201d.\n    # Verifies that the round is currently between registration begin and end rounds.\n    on_register = Return(\n        And(\n        no_rekey_addr,\n        Txn.application_args[0] == Bytes(\"register\"),\n        Global.round() >= App.globalGet(Bytes(\"RegBegin\")),\n        Global.round() <= App.globalGet(Bytes(\"RegEnd\")))\n    )\n\n    # Verifies the first application argument contains the string \u201cvote\u201d.\n    # Verifies the vote call is between the beginning and end of the voting round ranges.\n    # Verifies that two transactions are in the group.\n    # Checks that the second transaction is an asset transfer, and the token transferred is the vote token.\n    # Checks that the second transaction receiver is the creator of the application.\n    # Checks if the account has already voted, and if so, just returns true with no change to global state.\n    # Verifies that the user is either voting for candidate A or B.\n    # Reads the candidate\u2019s current total from the global state and increments the value.\n    # Stores the candidate choice to the user\u2019s local state.\n    choice = Txn.application_args[1]\n    choice_tally = App.globalGet(choice)\n    on_vote = Seq([\n        Assert(And(\n            no_rekey_addr,\n            Global.round() >= App.globalGet(Bytes(\"VoteBegin\")),\n            Global.round() <= App.globalGet(Bytes(\"VoteEnd\"))\n        )),\n        Assert(And(\n            Global.group_size() == Int(2),\n            Gtxn[1].type_enum() == TxnType.AssetTransfer,\n            Gtxn[1].asset_receiver() == App.globalGet(Bytes(\"Creator\")),\n            Gtxn[1].xfer_asset() == App.globalGet(Bytes(\"AssetID\")),\n            Gtxn[1].asset_amount() == Int(1),\n            Or(choice == Bytes(\"candidatea\"), choice == Bytes(\"candidateb\"))\n        )),\n        get_vote_of_sender,\n        If(get_vote_of_sender.hasValue(),\n            Return(Int(0))\n        ),\n        App.globalPut(choice, choice_tally + Int(1)),\n        App.localPut(Int(0), Bytes(\"voted\"), choice),\n        Return(Int(1))\n    ])\n\n    # Verfies that the application_id is 0, jumps to on_creation.\n    # Verifies that DeleteApplication is used and verifies that sender is creator.\n    # Verifies that UpdateApplication is used and verifies that sender is creator.\n    # Verifies that closeOut is used and jumps to on_closeout.\n    # Verifies that the account has opted in and jumps to on_register.\n    # Verifies that first argument is \"vote\" and jumps to on_vote.\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, on_register],\n        [Txn.application_args[0] == Bytes(\"vote\"), on_vote]\n    )\n\n    return program\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(approval_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"file_path": "https://github.com/Algofiorg/smart-contracts/blob/64b8995a81e7ccbb080ee4401b1dbe7a9ac181ef/contracts/governance/voting_escrow.py", "code": "\"\"\"Vote Escrow Contract\"\"\"\n\nfrom pyteal import *\n\nfrom contracts.governance.constants import *\nfrom contracts.governance.contract_strings import VotingEscrowStrings\nfrom contracts.governance.subroutines import (\n    MagicAssert,\n    decrement,\n    increment,\n    opt_into_asa,\n    send_asa,\n    verify_txn_is_sending_asa_to_contract,\n)\nfrom contracts.utils.wrapped_var import *\n\n\nclass VotingEscrowUser:\n    \"\"\"Data structure for user state in the voting escrow contract\"\"\"\n\n    def __init__(self, user_index):\n        # LOCAL STATE\n        self.amount_locked = WrappedVar(\n            VotingEscrowStrings.user_amount_locked, LOCAL_VAR, user_index\n        )\n        self.lock_start_time = WrappedVar(\n            VotingEscrowStrings.user_lock_start_time,\n            LOCAL_VAR,\n            user_index,\n        )\n        self.lock_duration = WrappedVar(\n            VotingEscrowStrings.user_lock_duration, LOCAL_VAR, user_index\n        )\n        self.amount_vebank = WrappedVar(\n            VotingEscrowStrings.user_amount_vebank, LOCAL_VAR, user_index\n        )\n        self.boost_multiplier = WrappedVar(\n            VotingEscrowStrings.user_boost_multiplier,\n            LOCAL_VAR,\n            user_index,\n        )\n        self.update_time = WrappedVar(\n            VotingEscrowStrings.user_last_update_time,\n            LOCAL_VAR,\n            user_index,\n        )\n\n    def get_lock_end_time(self):\n        \"\"\"Get the time at which the lock expires\"\"\"\n        return self.lock_start_time.get() + self.lock_duration.get()\n\n\nclass VotingEscrow:\n    \"\"\"Vote Escrow Contract\"\"\"\n\n    def __init__(self):\n        # GLOBAL STATE\n        self.dao_address = WrappedVar(\n            VotingEscrowStrings.dao_address, GLOBAL_VAR\n        )\n        self.emergency_dao_address = WrappedVar(\n            VotingEscrowStrings.emergency_dao_address, GLOBAL_VAR\n        )\n        self.asset_id = WrappedVar(\n            VotingEscrowStrings.asset_id, GLOBAL_VAR\n        )\n        self.total_locked = WrappedVar(\n            VotingEscrowStrings.total_locked, GLOBAL_VAR\n        )\n        self.total_vebank = WrappedVar(\n            VotingEscrowStrings.total_vebank, GLOBAL_VAR\n        )\n        self.admin_contract_app_id = WrappedVar(\n            VotingEscrowStrings.admin_contract_app_id, GLOBAL_VAR\n        )\n\n        # HELPER CLASSES\n        self.sending_user = VotingEscrowUser(Int(0))\n        self.target_user = VotingEscrowUser(Int(1))\n\n    # CREATION\n\n    def on_creation(self):\n        \"\"\"Creates the voting escrow contract\"\"\"\n        dao_address = Txn.accounts[1]\n        emergency_dao_address = Txn.accounts[2]\n\n        return Seq(\n            # set dao address\n            self.dao_address.put(dao_address),\n            # set emergency dao address\n            self.emergency_dao_address.put(emergency_dao_address),\n            self.total_vebank.put(ZERO_AMOUNT),\n            self.total_locked.put(ZERO_AMOUNT),\n            Approve(),\n        )\n\n    # ADMIN\n\n    def on_set_admin_contract_app_id(self):\n        \"\"\"Sets the admin contract app id\"\"\"\n        admin_contract_app_id = Txn.applications[1]\n\n        return Seq(\n            # set new rewards manager app id\n            self.admin_contract_app_id.put(admin_contract_app_id),\n            Approve(),\n        )\n\n    def on_set_gov_token_id(self):\n        \"\"\"Sets the gov token id\"\"\"\n        return Seq(\n            # set gov token id\n            self.asset_id.put(Txn.assets[0]),\n            # opt into gov asset\n            opt_into_asa(self.asset_id.get()),\n            Approve(),\n        )\n\n    # OPT IN / CLOSE OUT\n\n    def on_opt_in(self):\n        \"\"\"Called on opt in\"\"\"\n        return Seq(\n            MagicAssert(Gtxn[PREVIOUS_TRANSACTION].sender() == Txn.sender()),\n            MagicAssert(\n                Gtxn[PREVIOUS_TRANSACTION].application_id()\n                == self.admin_contract_app_id.get()\n            ),\n            MagicAssert(\n                Gtxn[PREVIOUS_TRANSACTION].on_completion() == OnComplete.OptIn\n            ),\n            Approve(),\n        )\n\n    def on_close_out(self):\n        \"\"\"Called on close out\"\"\"\n        return Seq(\n            # assert user has no locked bank\n            MagicAssert(self.sending_user.amount_locked.get() == ZERO_AMOUNT),\n            Approve(),\n        )\n\n    # HELPER FUNCTIONS\n\n    def calculate_vebank_amount(self, amount_locked, time_remaining):\n        \"\"\"Calculates the amount of veBANK a user has\"\"\"\n        return WideRatio([amount_locked, time_remaining], [SECONDS_PER_YEAR])\n\n    def update_boost(self, user: VotingEscrowUser):\n        \"\"\"Updates the user's boost\"\"\"\n        return Seq(\n            [\n                If(self.total_vebank.get() > ZERO_AMOUNT)\n                .Then(\n                    user.boost_multiplier.put(\n                        WideRatio(\n                            [user.amount_vebank.get(), FIXED_12_SCALE_FACTOR],\n                            [self.total_vebank.get()],\n                        )\n                    )\n                )\n                .Else(user.boost_multiplier.put(ZERO_AMOUNT))\n            ]\n        )\n\n    def update_vebank_data(self, user: VotingEscrowUser):\n        \"\"\"Updates a user's veBANK data\"\"\"\n        current_time = Global.latest_timestamp()\n        time_delta = current_time - user.update_time.get()\n        lock_end_time = user.get_lock_end_time()\n        lock_time_remaining = lock_end_time - current_time\n\n        on_update = Seq(\n            # update user state if time_delta is non zero\n            If(time_delta > ZERO_AMOUNT).Then(\n                Seq(\n                    # decrement user vebank from total\n                    decrement(self.total_vebank, user.amount_vebank.get()),\n                    # recalculate user vebank amount\n                    If(current_time > lock_end_time)\n                    .Then(\n                        user.amount_vebank.put(ZERO_AMOUNT),\n                    )\n                    .Else(\n                        Seq(\n                            user.amount_vebank.put(\n                                self.calculate_vebank_amount(\n                                    user.amount_locked.get(),\n                                    lock_time_remaining,\n                                )\n                            ),\n                            # increment new user vebank to total\n                            increment(\n                                self.total_vebank, user.amount_vebank.get()\n                            ),\n                        ),\n                    ),\n                    # recalculate user boost\n                    self.update_boost(user),\n                    # update user latest update time\n                    user.update_time.put(current_time),\n                ),\n            ),\n        )\n\n        return on_update\n\n    # USER FUNCTIONS\n\n    def on_lock(self):\n        \"\"\"\n        Locks user's BANK and grants veBANK (stored in local state)\n        veBANK = BANK * (lock_duration / 4 years)\n        Locking for 4 years grants maximum weight. Min lock duration is 7 days\n        \"\"\"\n        gov_token_txn_index = PREVIOUS_TRANSACTION\n        current_timestamp = Global.latest_timestamp()\n\n        lock_duration = Btoi(Txn.application_args[1])\n        lock_amount = Gtxn[gov_token_txn_index].asset_amount()\n        vebank_amount = self.calculate_vebank_amount(\n            lock_amount, lock_duration\n        )\n\n        return Seq(\n            # verify asset being sent to voting escrow contract\n            verify_txn_is_sending_asa_to_contract(\n                gov_token_txn_index, self.asset_id.get()\n            ),\n            # verify user has zero existing locked amount\n            MagicAssert(self.sending_user.amount_locked.get() == ZERO_AMOUNT),\n            # verify lock duration\n            MagicAssert(lock_duration >= MIN_LOCK_TIME_SECONDS),\n            MagicAssert(lock_duration <= MAX_LOCK_TIME_SECONDS),\n            # verify non zero ve bank amount\n            MagicAssert(vebank_amount > ZERO_AMOUNT),\n            # set amount locked\n            self.sending_user.amount_locked.put(lock_amount),\n            # set lock start time\n            self.sending_user.lock_start_time.put(current_timestamp),\n            # set lock duration\n            self.sending_user.lock_duration.put(lock_duration),\n            # set vebank amount\n            self.sending_user.amount_vebank.put(vebank_amount),\n            # set update time\n            self.sending_user.update_time.put(current_timestamp),\n            # update global totals\n            increment(self.total_locked, lock_amount),\n            increment(self.total_vebank, vebank_amount),\n            # recalculate user boost\n            self.update_boost(self.sending_user),\n            Approve(),\n        )\n\n    def on_update_vebank_data(self):\n        \"\"\"\n        Update a user's and global veBANK and lock state\n        Anyone can call this for any user\n        \"\"\"\n\n        return Seq(\n            [\n                # update target user vebank data\n                self.update_vebank_data(self.target_user),\n                Approve(),\n            ]\n        )\n\n    def on_claim(self):\n        \"\"\"Sends back user's locked BANK after the lock expires\"\"\"\n        lock_end_time = self.sending_user.get_lock_end_time()\n        current_time = Global.latest_timestamp()\n\n        return Seq(\n            # verify amount locked is non zero\n            MagicAssert(self.sending_user.amount_locked.get() > ZERO_AMOUNT),\n            # verify lock has expired\n            MagicAssert(current_time > lock_end_time),\n            # return asset to user\n            send_asa(\n                self.asset_id.get(),\n                self.sending_user.amount_locked.get(),\n                Txn.sender(),\n            ),\n            # decrement user amount from total\n            decrement(\n                self.total_locked, self.sending_user.amount_locked.get()\n            ),\n            # set user amount locked to zero\n            self.sending_user.amount_locked.put(ZERO_AMOUNT),\n            # reset user lock start time to\n            self.sending_user.lock_start_time.put(UNSET),\n            # reset user lock duration\n            self.sending_user.lock_duration.put(UNSET),\n            # reset user update time\n            self.sending_user.update_time.put(UNSET),\n            Approve(),\n        )\n\n    def on_extend_lock(self):\n        \"\"\"Adds time to existing user lock.\"\"\"\n        extend_duration_seconds = Btoi(Txn.application_args[1])\n        current_time = Global.latest_timestamp()\n        lock_end_time = self.sending_user.get_lock_end_time()\n        duration_remaining = (\n            If(current_time < lock_end_time)\n            .Then(lock_end_time - current_time)\n            .Else(Int(0))\n        )\n        total_new_duration = duration_remaining + extend_duration_seconds\n        current_vebank_balance = self.sending_user.amount_vebank.get()\n        locked_amount = self.sending_user.amount_locked.get()\n\n        new_vebank_balance = self.calculate_vebank_amount(\n            locked_amount, total_new_duration\n        )\n\n        return Seq(\n            # verify user has non zero locked amount\n            MagicAssert(locked_amount > ZERO_AMOUNT),\n            # verify extend duration is non zero\n            MagicAssert(extend_duration_seconds > ZERO_AMOUNT),\n            # validate new total duration\n            MagicAssert(total_new_duration >= MIN_LOCK_TIME_SECONDS),\n            MagicAssert(total_new_duration <= MAX_LOCK_TIME_SECONDS),\n            # update global total vebank\n            decrement(self.total_vebank, current_vebank_balance),\n            increment(self.total_vebank, new_vebank_balance),\n            # set new user vebank amount\n            self.sending_user.amount_vebank.put(new_vebank_balance),\n            # set new user lock duration\n            self.sending_user.lock_duration.put(total_new_duration),\n            # set new user lock start time\n            self.sending_user.lock_start_time.put(current_time),\n            # recalculate user boost\n            self.update_boost(self.sending_user),\n            Approve(),\n        )\n\n    def on_increase_lock_amount(self):\n        \"\"\"Increases the amount of BANK locked, without changing lock duration\"\"\"\n        gov_token_txn_index = PREVIOUS_TRANSACTION\n        current_time = Global.latest_timestamp()\n        lock_end_time = self.sending_user.get_lock_end_time()\n        lock_duration = lock_end_time - current_time\n        additional_amount_to_lock = Gtxn[gov_token_txn_index].asset_amount()\n        existing_amount_locked = self.sending_user.amount_locked.get()\n        new_vebank = self.calculate_vebank_amount(\n            existing_amount_locked + additional_amount_to_lock, lock_duration\n        )\n\n        return Seq(\n            # verify previous transaction is payment to this contract\n            verify_txn_is_sending_asa_to_contract(\n                gov_token_txn_index, self.asset_id.get()\n            ),\n            # verify the users current amount locked is non zero\n            MagicAssert(self.sending_user.amount_locked.get() > ZERO_AMOUNT),\n            # verify remaining lock duration is greater than minimum\n            MagicAssert(lock_duration >= MIN_LOCK_TIME_SECONDS),\n            # verify additional amount to lock is non zero\n            MagicAssert(additional_amount_to_lock > ZERO_AMOUNT),\n            # verify additional vebank amount is non zero\n            MagicAssert(new_vebank > self.sending_user.amount_vebank.get()),\n            # increment total locked\n            increment(self.total_locked, additional_amount_to_lock),\n            # increment user locked\n            increment(\n                self.sending_user.amount_locked, additional_amount_to_lock\n            ),\n            decrement(\n                self.total_vebank, self.sending_user.amount_vebank.get()\n            ),\n            # increment total vebank\n            increment(self.total_vebank, new_vebank),\n            # increment user vebank\n            self.sending_user.amount_vebank.put(new_vebank),\n            # recalculate user boost\n            self.update_boost(self.sending_user),\n            Approve(),\n        )\n\n    def approval_program(self):\n        \"\"\"Voting escrow approval program.\"\"\"\n        # sender checks\n        sender_is_dao = Or(\n            Txn.sender() == self.dao_address.get(),\n            Txn.sender() == self.emergency_dao_address.get(),\n        )\n        # check on complete\n        is_no_op = Txn.on_completion() == OnComplete.NoOp\n        is_opt_in = Txn.on_completion() == OnComplete.OptIn\n        is_close_out = Txn.on_completion() == OnComplete.CloseOut\n        # on call method\n        on_call_method = Txn.application_args[0]\n\n        return Cond(\n            [Txn.application_id() == Int(0), self.on_creation()],\n            [Txn.on_completion() == OnComplete.DeleteApplication, Reject()],\n            [is_opt_in, self.on_opt_in()],\n            [is_close_out, self.on_close_out()],\n            # admin functions\n            [\n                sender_is_dao,\n                Cond(\n                    [\n                        is_no_op,\n                        Cond(\n                            [\n                                on_call_method\n                                == Bytes(\n                                    VotingEscrowStrings.set_gov_token_id\n                                ),\n                                self.on_set_gov_token_id(),\n                            ],\n                            [\n                                on_call_method\n                                == Bytes(\n                                    VotingEscrowStrings.set_admin_contract_app_id\n                                ),\n                                self.on_set_admin_contract_app_id(),\n                            ],\n                        ),\n                    ]\n                ),\n            ],\n            # user functions\n            [\n                is_no_op,\n                Cond(\n                    # target user\n                    [\n                        on_call_method\n                        == Bytes(VotingEscrowStrings.update_vebank_data),\n                        self.on_update_vebank_data(),\n                    ],\n                    # lock (does not require vebank update)\n                    [\n                        on_call_method\n                        == Bytes(VotingEscrowStrings.lock),\n                        self.on_lock(),\n                    ],\n                    # user\n                    [\n                        TRUE,\n                        Seq(\n                            self.update_vebank_data(self.sending_user),\n                            Cond(\n                                [\n                                    on_call_method\n                                    == Bytes(\n                                        VotingEscrowStrings.extend_lock\n                                    ),\n                                    self.on_extend_lock(),\n                                ],\n                                [\n                                    on_call_method\n                                    == Bytes(\n                                        VotingEscrowStrings.increase_lock_amount\n                                    ),\n                                    self.on_increase_lock_amount(),\n                                ],\n                                [\n                                    on_call_method\n                                    == Bytes(VotingEscrowStrings.claim),\n                                    self.on_claim(),\n                                ],\n                            ),\n                        ),\n                    ],\n                ),\n            ],\n        )\n\n    def clear_state_program(self):\n        \"\"\"Clear state program for the voting escrow contract.\"\"\"\n        return Seq(\n            # decrement user vebank amount from total\n            decrement(\n                self.total_vebank, self.sending_user.amount_vebank.get()\n            ),\n            # decrement user locked amount from total\n            decrement(\n                self.total_locked, self.sending_user.amount_locked.get()\n            ),\n            Approve(),\n        )"}
{"file_path": "https://github.com/GoraNetwork/algokit_default_template/blob/38a15bdfe2fff9820b1abb9b01c8a4a278c32d9d/template_content/protocol/assets/helpers/voting_base.py", "code": "from pyteal import *\nfrom .key_map import key_map\nimport sys\nimport pathlib\nimport os\nfrom voting_approval import hash_type\nsys.path.append(os.path.join(pathlib.Path(__file__).parent.resolve(),'../..'))\nfrom utils.abi_types import LocalHistoryEntry,ProposalsEntry\nfrom utils.gora_pyteal_utils import calc_box_cost,SmartAssert\nglobal_keys = key_map[\"voting_global\"]\nmain_local_keys = key_map[\"main_local\"]\n\ndef on_clear_logic():\n    MAIN_APP = App.globalGet(global_keys[\"main_app\"])\n    current_round = App.globalGet(global_keys[\"round\"])\n    local_stake_account_pk = App.localGetEx(Txn.accounts[1], MAIN_APP, main_local_keys[\"local_public_key\"])\n\n    return Seq([\n        local_stake_account_pk,\n        SmartAssert(local_stake_account_pk.value() == Txn.sender()),\n        (previous_vote_bytes := App.box_get(Txn.accounts[1])),\n        previous_vote_bytes,\n        (previous_vote := LocalHistoryEntry()).decode(previous_vote_bytes.value()),\n        (previous_proposal_entry := ProposalsEntry()).set(previous_vote.proposal_entry),\n        (sender_vote_round := abi.Uint64()).set(previous_proposal_entry.vote_round),\n        (sender_vote_hash := abi.make(hash_type)).set(previous_proposal_entry.vote_hash),\n        If(sender_vote_round.get() == current_round)\n        .Then(\n            Approve()\n        )\n        .ElseIf(\n            sender_vote_round.get() < current_round\n        )\n        .Then(\n            Seq([\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields({\n                    TxnField.type_enum: TxnType.Payment,\n                    TxnField.receiver: Txn.sender(),\n                    TxnField.amount: calc_box_cost(abi.size_of(hash_type),abi.size_of(ProposalsEntry))\n                }),\n                InnerTxnBuilder.Submit(),\n                App.box_delete(sender_vote_hash.get())\n                # TODO: do we want to delete their previous vote box here too?\n            ])\n        ),\n        Approve()\n    ])"}
{"file_path": "https://github.com/bytesdruid/Voting/blob/805017f6b4cd126daa77c4bc9b9f894faf333f87/voting_contract.py", "code": "from pyteal import *\n\ndef approval_program():\n    on_creation = Seq(\n        [\n            # name of this application\n            App.globalPut(Bytes(\"AppName\"), Bytes(\"Community 1 Governance Application\")),\n            # choice A\n            App.globalPut(Bytes(\"Option A\"), Bytes(\"Description for option one.\")),\n            # choice B\n            App.globalPut(Bytes(\"Option B\"), Bytes(\"Description for option two.\")),\n            # creator is set to the contract creator\n            App.globalPut(Bytes(\"Creator\"), Txn.sender()),\n            # expecting four arguments for the registration and voting time frames\n            Assert(Txn.application_args.length() == Int(4)),\n            # registration begins blockround\n            App.globalPut(Bytes(\"RegBegin\"), Btoi(Txn.application_args[0])),\n            # registration ending blockround\n            App.globalPut(Bytes(\"RegEnd\"), Btoi(Txn.application_args[1])),\n            # vote begining blockround\n            App.globalPut(Bytes(\"VoteBegin\"), Btoi(Txn.application_args[2])),\n            # vote ending blockround\n            App.globalPut(Bytes(\"VoteEnd\"), Btoi(Txn.application_args[3])),\n            Return(Int(1)),\n        ]\n    )\n\n    # checks to see if txn sender is the contract creator\n    is_creator = Txn.sender() == App.globalGet(Bytes(\"Creator\"))\n\n    # this gets the sender vote from an external application's local state\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n\n    # when delete app is called get vote of sender is called and the if statement is called\n    on_closeout = Seq(\n        [\n            get_vote_of_sender,\n            # if vote hasnt ended and the user has voted, we delete their vote\n            If(\n                And(\n                    Global.round() <= App.globalGet(Bytes(\"VoteEnd\")),\n                    get_vote_of_sender.hasValue(),\n                ),\n                App.globalPut(\n                    get_vote_of_sender.value(),\n                    App.globalGet(get_vote_of_sender.value()) - Int(1),\n                ),\n            ),\n            # otherwise we just approve the app deletion\n            Return(Int(1)),\n        ]\n    )\n\n    # checks that the registration period is active before approving opt in\n    on_register = Return(\n        And(\n            Global.round() >= App.globalGet(Bytes(\"RegBegin\")),\n            Global.round() <= App.globalGet(Bytes(\"RegEnd\")),\n        )\n    )\n\n    # first app arg is assigned to choice variable\n    choice = Txn.application_args[1]\n    # gets the current choice count value\n    choice_tally = App.globalGet(choice)\n\n    # this is the only noop call in this application\n    on_vote = Seq(\n        [\n            # first we check that the voting period is active\n            Assert(\n                And(\n                    Global.round() >= App.globalGet(Bytes(\"VoteBegin\")),\n                    Global.round() <= App.globalGet(Bytes(\"VoteEnd\")),\n                )\n            ),\n            # next the vote of the txn sender is retrieved\n            get_vote_of_sender,\n            # if the vote exists then we continue executing the sequence\n            If(get_vote_of_sender.hasValue(), Return(Int(0))),\n            # the choice key is accessed and the tally is updated by adding one \n            App.globalPut(choice, choice_tally + Int(1)),\n            # records the voter's choice in the voted key of the voter's local state\n            App.localPut(Int(0), Bytes(\"voted\"), choice),\n            Return(Int(1)),\n        ]\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, on_register],\n        [Txn.application_args[0] == Bytes(\"vote\"), on_vote],\n    )\n\n    return program\n\n\ndef clear_state_program():\n    # gets the vote of the voted value from the external app\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n    program = Seq(\n        [\n            get_vote_of_sender,\n            # if the vote has not ended, then remove the account's vote\n            If(\n                And(\n                    Global.round() <= App.globalGet(Bytes(\"VoteEnd\")),\n                    get_vote_of_sender.hasValue(),\n                ),\n                App.globalPut(\n                    get_vote_of_sender.value(),\n                    App.globalGet(get_vote_of_sender.value()) - Int(1),\n                ),\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    return program\n\n\nif __name__ == \"__main__\":\n    with open(\"vote_approval.teal\", \"w\") as f:\n        compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)\n        f.write(compiled)\n\n    with open(\"vote_clear_state.teal\", \"w\") as f:\n        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)\n        f.write(compiled)"}
{"file_path": "https://github.com/0xBitzz/Algo-Smart-DAO-Encode-Project/blob/4db7b98e9f2f1e60b86ed92849da38c9521f24c9/voting-contract/src/Beaker/voting.py", "code": "from pyteal import *\nfrom typing import Final\nfrom beaker import Application, AccountStateValue, ApplicationStateValue, Authorize, bare_external, external, create, opt_in\n\n\nclass Voting(Application):\n    proposal: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    start_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    end_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    result: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    num_of_yays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    num_of_nays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    vote_choice: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.bytes\n    )\n    has_vote: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.uint64\n    )\n\n    @create\n    def create(self):\n        return self.initialize_application_state()\n\n    @opt_in\n    def optin(self):\n        return self.initialize_account_state()\n\n    @external(authorize=Authorize.only(Global.creator_address()))\n    def create_proposal(self, proposal: abi.String, end_time: abi.Uint64):\n        return Seq(\n            self.proposal.set(proposal.get()),\n            self.start_time.set(Global.latest_timestamp()),\n            self.end_time.set(Global.latest_timestamp() + end_time.get())\n            # yes no set\n        )\n\n    @external(authorize=Authorize.opted_in(Global.current_application_id()))\n    def vote(\n        self,\n        vote_choice: abi.String,\n        key: abi.String,\n        app: abi.Application # type: ignore[assignment]\n    ):\n        return Seq(\n            (is_staking := App.localGetEx(account=Txn.sender(), app=app.application_id(), key=key.get())),\n            Assert(is_staking.hasValue()),\n            Assert(\n                And(\n                    Global.latest_timestamp() >= self.start_time,\n                    Global.latest_timestamp() <= self.end_time\n                )\n            ),\n            Assert(is_staking.value() == Int(1)),\n            Assert(self.has_vote == Int(0)),\n            If(vote_choice.get() == Bytes(\"yes\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"yes\")),\n                self.num_of_yays.increment()\n            )\n            .ElseIf(vote_choice.get() == Bytes(\"no\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"no\")),\n                self.num_of_nays.increment()\n            ),\n            self.has_vote.set(Int(1))\n        )\n\n    @external(authorize=Authorize.only(Global.creator_address()))\n    def get_vote_result(self, *, output: abi.String):\n        return Seq(\n            Assert(Global.latest_timestamp() > self.end_time),\n            If(self.num_of_yays > self.num_of_nays)\n            .Then(self.result.set(Bytes(\"passed\")))\n            .ElseIf(self.num_of_yays < self.num_of_nays)\n            .Then(self.result.set(Bytes(\"rejected\")))\n            .Else(self.result.set(Bytes(\"undecided\"))),\n            output.set(self.result)\n        )\n\n    @bare_external(close_out=CallConfig.CALL, clear_state=CallConfig.CALL)\n    def clear_vote(self):\n        return Seq(\n            Assert(self.has_vote == Int(1)),\n            If(self.vote_choice == Bytes(\"yes\"))\n            .Then(\n                Assert(self.num_of_yays > Int(0)),\n                self.num_of_yays.decrement()\n            )\n            .ElseIf(self.vote_choice == Bytes(\"no\")).\n            Then(\n                Assert(self.num_of_nays > Int(0)),\n                self.num_of_nays.decrement()\n            ),\n            self.vote_choice.set(Bytes(\"\")),\n            self.has_vote.set(Int(0))\n        )\n\n\nVoting().dump()"}
{"file_path": "https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py", "code": "# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913\nimport json\nimport sys\nimport os\nfrom pyteal import *\nfrom .abi_types import *\nfrom .inline import InlineAssembly\nfrom assets.abi import ABI_PATH,system_delima\n\n\n\nmain_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}main-contract.json\"))\nvoting_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}voting-contract.json\"))\nsmart_assert_errors = json.load(open(ABI_PATH + f\"{system_delima}..{system_delima}smart_assert_errors.json\"))\n\n# This is not used as it hard codes the costs of a box\n# But is kept here as a record of how it is calculated\n# The current method is by checking min balances before\n# and after the box is created.\n# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):\n#     # (2500 per box) + (400 * (key size + box size))\n#     if key_size_bytes > 64:\n#         raise Exception(\"key size is over 64 bytes\")\n#     cost = (\n#         Int(2500) + Int(400) * \n#         (\n#             Int(key_size_bytes) +\n#             Int(box_size_bytes)\n#         )\n#     )\n#     return cost\n\ndef get_abi_method(method_name,contract:str):\n    method_dict = {\n        \"main\": main_contract_abi[\"methods\"],\n        \"voting\": voting_contract_abi[\"methods\"]\n    }\n    method_list = method_dict[contract]\n    for method in method_list:\n        if method[\"name\"] == method_name:\n            return method\n    return None\n\ndef get_method_signature(method_name, contract:str):\n    method = get_abi_method(method_name,contract)\n    if method is None:\n        raise RuntimeError\n    signature = method_name + \"(\"\n    num_args = len(method[\"args\"])\n    for index, arg in enumerate(method[\"args\"]):\n        signature += arg[\"type\"] \n        if index < num_args - 1:\n            signature += \",\"\n        else:\n            signature += f'){method[\"returns\"][\"type\"]}'\n            return signature\n\n@ABIReturnSubroutine\ndef create_source_tuple(\n    source_id: Expr, #Int\n    source_arg_list: Expr, #Bytes\n    max_age: Expr,\n    *,\n    output: SourceSpec\n) -> Expr: #Int\n    return Seq([\n        (source_id_param := abi.Uint32()).set(source_id),\n        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),\n        (max_age_param := abi.Uint64()).set(max_age),\n        output.set(\n            source_id_param,\n            source_arg_list_param,\n            max_age_param\n        ),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request(\n    source_specs: abi.DynamicArray[SourceSpec],\n    aggregation: Expr, #Int\n    user_data: Expr, #Bytes\n    app_id: Expr, #Int\n    method_signature: Expr, #Bytes\n    goracle_main_app_id: Expr,  #Int\n    request_type: Expr,\n    key: Expr,\n    app_refs: Expr, #static array of uint64\n    asset_refs: Expr, #static array of uint64\n    account_refs: Expr, #static array of byte[32]\n    box_refs: Expr # dynamic array of  (byte[],uint64)\n): # Int\n\n    request_tuple = abi.make(RequestSpec)\n    destination_tuple = abi.make(DestinationSpec)\n\n    return Seq([\n        (user_data_param := abi.DynamicBytes()).set(user_data),\n        (agg_param := abi.Uint32()).set(aggregation),\n        (app_id_param := abi.Uint64()).set(app_id),\n        (request_type_param := abi.Uint64()).set(request_type),\n        (method_sig_param := abi.DynamicBytes()).set(method_signature),\n        (key_abi := abi.DynamicBytes()).set(key),\n\n        request_tuple.set(\n            source_specs,\n            agg_param,\n            user_data_param\n        ),\n\n        destination_tuple.set(\n            app_id_param,\n            method_sig_param\n        ),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_tuple.encode(),\n                destination_tuple.encode(),\n                request_type_param.encode(),\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request_constructed(\n    request_args_encoded: Expr,\n    destination_encoded: Expr,\n    request_type_encoded: Expr,\n    goracle_main_app_id: Expr,\n    key: Expr,\n    app_refs: Expr,\n    asset_refs: Expr,\n    account_refs: Expr,\n    box_refs: Expr\n):\n    return Seq([\n        (key_abi := abi.DynamicBytes()).set(key),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_args_encoded,\n                destination_encoded,\n                request_type_encoded,\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ]\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in(goracle_main_app_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.ApplicationCall,\n            TxnField.application_id: goracle_main_app_id,\n            TxnField.on_completion: OnComplete.OptIn,\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in_asset(asset_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: asset_id,\n            TxnField.asset_receiver: Global.current_application_address(),\n            TxnField.asset_amount: Int(0),\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit()\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_deposit, account_to_deposit_to):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_deposit,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_token\",\"main\"),\n            args=[\n                asset_transfer,\n                gora_token_id,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_algo(goracle_main_app_address, goracle_main_app_id, amount_to_deposit, account_to_deposit_to):\n    algo_transfer = \\\n    {\n        TxnField.type_enum: TxnType.Payment,\n        TxnField.amount: amount_to_deposit,\n        TxnField.receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_algo\",\"main\"),\n            args=[\n                algo_transfer,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\nnew_key: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef register_key(goracle_main_app_id, new_key):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"register_participation_account\",\"main\"),\n            args=[\n                new_key,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_token(goracle_main_app_id, gora_token_id, amount_to_withdraw):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_token\",\"main\"),\n            args=[\n                amount_to_withdraw,\n                gora_token_id,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_algo(goracle_main_app_id, amount_to_withdraw):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_algo\",\"main\"),\n            args=[\n                amount_to_withdraw\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef stake_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_stake):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_stake,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Global.min_txn_fee()\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('stake', 'main'),\n            args=[\n                asset_transfer,\n            ],\n            extra_fields={\n                TxnField.fee: Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef unstake_token(goracle_main_app_id, gora_token_id, amount_to_unstake):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('unstake', 'main'),\n            args=[\n                amount_to_unstake,\n                gora_token_id\n            ],\n            extra_fields={\n                TxnField.fee : Int(2)*Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\n\"\"\"\nAssert with a number to indentify it in API error message. The message will be:\n\"shr arg too big, (%d)\" where in \"%d\" 6 lowest decinals are the line number and\nany above that are the error code. Error types are defined \"error_codes.json\"\n\"\"\"\ndef SmartAssert(cond, err_type = 0):\n    if type(err_type) == str:\n        err_type = smart_assert_errors.index(err_type) # map mnemonic to code\n    err_line = sys._getframe().f_back.f_lineno # calling line number\n    return If(Not(cond)).Then(\n        InlineAssembly(\"int 0\\nint {}\\nshr\\n\".format(err_type * 1000000 + err_line))\n    )"}
{"file_path": "https://github.com/gconnect/voting-dapp-pyteal-react/blob/829a74626f934ebb9778b431ce9d7662e6897f85/venv/bin/pip", "code": "#!/Users/glory/projects/pyteal-voting-system/voting-dapp/venv/bin/python3\n# -*- coding: utf-8 -*-\nimport re\nimport sys\nfrom pip._internal.cli.main import main\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\\.pyw|\\.exe)?$', '', sys.argv[0])\n    sys.exit(main())"}
{"file_path": "https://github.com/algorandfoundation/ExtendableDAO/blob/0e8c974683130d681e2cd88c671fede52154e031/contracts.py", "code": "#!/usr/bin/env python3\n\nfrom configparser import NoOptionError\nimport json\n\nfrom pyteal import * \n\nrouter = Router(\"ExtendableDAO\")\n\n\n@router.method(no_op=CallConfig.CREATE)\ndef deploy(name: abi.String, *, output: abi.Bool) -> Expr:\n    return Seq(\n        App.globalPut(Bytes(\"uninitialised\"), Int(1)),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef initialise(token: abi.Asset, *, output: abi.Bool) -> Expr:\n    return Seq(\n        Assert(App.globalGet(Bytes(\"uninitialised\"))),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: Global.current_application_address(),\n                TxnField.xfer_asset: token.asset_id(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(Bytes(\"asset_id\"), token.asset_id()),\n        App.globalDel(Bytes(\"uninitialised\")),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef activate(app: abi.Application, *, output: abi.Uint64) -> Expr:\n    proposal_for = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_for\"),\n    )\n    proposal_against = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_against\"),\n    )\n    return Seq(\n        votes_for := App.globalGetEx(Global.current_application_id(), proposal_for),\n        votes_against := App.globalGetEx(Global.current_application_id(), proposal_against),\n        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),\n        Assert(Not(voting_allowed.hasValue())),\n        Assert(votes_for.hasValue()),\n        Assert(votes_against.hasValue()),\n        Assert(votes_for.value() > votes_against.value()),\n        app_approval := AppParam.approvalProgram(app.application_id()),\n        Assert(app_approval.hasValue()),\n        app_clearstate := AppParam.clearStateProgram(app.application_id()),\n        Assert(app_clearstate.hasValue()),\n        app_global_byteslices := AppParam.globalNumByteSlice(app.application_id()),\n        app_global_ints := AppParam.globalNumUint(app.application_id()),\n        app_local_byteslices := AppParam.localNumByteSlice(app.application_id()),\n        app_local_ints := AppParam.localNumUint(app.application_id()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.ApplicationCall,\n                TxnField.application_args: [MethodSignature(\"deploy()bool\")],\n                TxnField.approval_program: app_approval.value(),\n                TxnField.clear_state_program: app_clearstate.value(),\n                TxnField.global_num_byte_slices: app_global_byteslices.value(),\n                TxnField.global_num_uints: app_global_ints.value(),\n                TxnField.local_num_byte_slices: app_local_byteslices.value(),\n                TxnField.local_num_uints: app_local_ints.value(),\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalDel(proposal_for),\n        App.globalDel(proposal_against),\n        output.set(InnerTxn.created_application_id()),\n    )\n\n\n@router.method(delete_application=CallConfig.CALL)\ndef deactivate(*, output: abi.Bool) -> Expr:\n    return output.set(True)\n\n\n@router.method(no_op=CallConfig.CALL,opt_in=CallConfig.CALL)\ndef vote(\n    app: abi.Application, votes: abi.AssetTransferTransaction, for_or_against: abi.Bool, *, output: abi.Bool\n) -> Expr:\n    prop_for_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_for\"),\n    )\n    prop_against_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_against\"),\n    )\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        (proposal_for := ScratchVar()).store(prop_for_bytes),\n        (proposal_against := ScratchVar()).store(prop_against_bytes),\n        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),\n        Assert(voting_allowed.hasValue()),\n        Assert(votes.get().asset_receiver() == Global.current_application_address()),\n        Assert(votes.get().xfer_asset() == asset_id),\n        If(for_or_against.get(), Seq(\n            App.localPut(Int(0), proposal_for.load(), App.localGet(Int(0), proposal_for.load()) + votes.get().asset_amount()),\n            App.globalPut(proposal_for.load(), App.globalGet(proposal_for.load()) + votes.get().asset_amount()),\n        ), Seq(\n            App.localPut(Int(0), proposal_against.load(), App.localGet(Int(0), proposal_against.load()) + votes.get().asset_amount()),\n            App.globalPut(proposal_against.load(), App.globalGet(proposal_against.load()) + votes.get().asset_amount()),\n        )),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef reclaim(app: abi.Application, asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    prop_for_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_for\"),\n    )\n    prop_against_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_against\"),\n    )\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        Assert(asset_id == asset.asset_id()),\n        (total := ScratchVar(TealType.uint64)).store(\n            App.localGet(Int(0), prop_for_bytes) + App.localGet(Int(0), prop_against_bytes)\n        ),\n        Assert(total.load()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.xfer_asset: asset_id,\n                TxnField.asset_amount: total.load(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        votes_for := App.globalGetEx(Global.current_application_id(), prop_for_bytes),\n        votes_against := App.globalGetEx(Global.current_application_id(), prop_against_bytes),\n        # Reduce global for\n        If(votes_for.hasValue()).Then(\n            App.globalPut(prop_for_bytes, App.globalGet(prop_for_bytes) - App.localGet(Int(0), prop_for_bytes)),\n        ),\n        # Reduce global against\n        If(votes_against.hasValue()).Then(\n            App.globalPut(prop_against_bytes, App.globalGet(prop_against_bytes) - App.localGet(Int(0), prop_against_bytes)),\n        ),\n        # Delete local amounts\n        App.localDel(Int(0), prop_for_bytes),\n        App.localDel(Int(0), prop_against_bytes),\n        output.set(total.load()),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef propose(appl: abi.ApplicationCallTransaction, *, output: abi.Uint64) -> Expr:\n    proposal_for = Concat(\n        Bytes(\"proposal_\"),\n        Itob(appl.get().created_application_id()),\n        Bytes(\"_for\"),\n    )\n    proposal_against = Concat(\n        Bytes(\"proposal_\"),\n        Itob(appl.get().created_application_id()),\n        Bytes(\"_against\"),\n    )\n    return Seq(\n        Assert(appl.get().type_enum() == TxnType.ApplicationCall),\n        Assert(Not(appl.get().application_id())),\n        Assert(appl.get().on_completion() == OnComplete.NoOp),\n        (new_app_pages := AppParam.extraProgramPages(appl.get().created_application_id())),\n        Assert(Not(new_app_pages.value())),\n        Comment(\"TODO: Some sort of validation on proposed app\"),\n        (new_app_approval := AppParam.approvalProgram(appl.get().created_application_id())),\n        Assert(Extract(new_app_approval.value(), Int(1), Int(4)) == Bytes(\"base16\", \"0x20020100\")),\n        Comment(\"TODO: Some sort of validation on proposed app\"),\n        (new_app_clearstate := AppParam.clearStateProgram(appl.get().created_application_id())),\n        Assert(new_app_clearstate.hasValue()),\n        App.globalPut(proposal_for, Int(0)),\n        App.globalPut(proposal_against, Int(0)),\n        App.globalPut(Itob(GeneratedID(appl.index())), Global.round()),\n        output.set(appl.get().created_application_id()),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef end_voting(app: abi.Application, *, output: abi.Bool) -> Expr:\n    return Seq(\n        (app_params := AppParam.creator(app.application_id())),\n        Assert(Txn.sender() == app_params.value()),\n        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),\n        Assert(voting_allowed.hasValue()),\n        Assert(Global.round() > voting_allowed.value()),\n        App.globalDel(Itob(app.application_id())),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef invoke(app: abi.Application, *, output: abi.Bool) -> Expr:\n    i = ScratchVar(TealType.uint64)\n    return Seq(\n        (app_creator := AppParam.creator(app.application_id())),\n        (app_addr := AppParam.address(app.application_id())),\n        Assert(app_creator.value() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.ApplicationCall,\n                TxnField.application_id: app.application_id(),\n                TxnField.application_args: [ MethodSignature(\"invoke()bool\") ],\n                TxnField.rekey_to: app_addr.value(),\n            }\n        ),\n        Comment(\"Add all assets\"),\n        For(i.store(Int(0)), i.load() < Txn.assets.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.assets, [Txn.assets[i.load()]]),\n        ),\n        Comment(\"Add all apps\"),\n        For(i.store(Int(2)), i.load() <= Txn.applications.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.applications, [Txn.applications[i.load()]]),\n        ),\n        Comment(\"Add all accounts\"),\n        For(i.store(Int(1)), i.load() < Txn.accounts.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.accounts, [Txn.accounts[i.load()]]),\n        ),\n        Comment(\"Add all args\"),\n        For(i.store(Int(2)), i.load() < Txn.application_args.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.application_args, [Txn.application_args[i.load()]]),\n        ),\n        InnerTxnBuilder.Submit(),\n        Comment(\"Check we've been rekeyed back to our own account\"),\n        (acct_auth := AccountParam.authAddr(Global.current_application_address())),\n        Assert(acct_auth.value() == Global.zero_address()),\n        output.set(True),\n    )\n\n\n@router.method(clear_state=CallConfig.CALL)\ndef clear_state() -> Expr:\n    return Approve()\n\n\napproval, clearstate, abi = router.compile_program(\n    version=7,\n    optimize=OptimizeOptions(scratch_slots=True),\n)\n\nif __name__ == \"__main__\":\n    with open(\"dao_approval.teal\", \"w\") as f:\n        f.write(approval)\n    \n    with open(\"dao_clearstate.teal\", \"w\") as f:\n        f.write(clearstate)\n\n    with open(\"dao_abi.json\", \"w\") as f:\n        f.write(json.dumps(abi.dictify()))"}
{"file_path": "https://github.com/0EFB6/blockchain-voting-system/blob/5d3bab077ab260c2e99bb3561a48d7c2b234712d/voting_area_initialisation/voting_area_initialisation.py", "code": "from pyteal import *\n\n# init_dun = State seats inforamtion (DUN, DUN number, state)\n# init_dun_candidate = State seats candidate information\n# \t\t\t\t\t\t(candidate name, party)\n\nk_dun = Bytes(\"dun\")\nk_dun_no = Bytes(\"dun_no\")\nk_parliament = Bytes(\"parliament\")\nk_parliament_no = Bytes(\"parliament_no\")\nk_state = Bytes(\"state\")\nk_c_name = Bytes(\"c_name\")\nk_party = Bytes(\"party\")\n\nrouter = Router(\n\t\"voting_area_initialisation\",\n\tBareCallActions(\n\t\tno_op=OnCompleteAction.create_only(Approve()),\n\t\topt_in=OnCompleteAction.call_only(Approve())\n\t)\n)\n\n@router.method\ndef init_dun(dun: abi.String, n: abi.Uint8, state: abi.String):\n\tis_valid_dun = And(\n\t\tLen(dun.get()) >= Int(0),\n\t\tLen(dun.get()) <= Int(20)\n\t)\n\tis_valid_dun_no = And(\n\t\tn.get() > Int(0),\n\t\tn.get() < Int(83)\n\t)\n\tis_valid_state = And(\n\t\tLen(state.get()) >= Int(0),\n\t\tLen(state.get()) <= Int(15)\n\t)\n\tcheck = And(\n\t\tis_valid_dun,\n\t\tis_valid_dun_no,\n\t\tis_valid_state\n\t)\n\tret = If(\n\t\tcheck,\n\t\tSeq(\n\t\t\tApp.localPut(Txn.sender(), k_dun, dun.get()),\n\t\t\tApp.localPut(Txn.sender(), k_dun_no, n.get()),\n\t\t\tApp.localPut(Txn.sender(), k_state, state.get())\n\t\t)\n\t)\n\treturn ret\n\n@router.method\ndef init_parliament(parliamen: abi.String, n: abi.Uint8, state: abi.String):\n\tis_valid_parliamen = And(\n\t\tLen(parliamen.get()) >= Int(0),\n\t\tLen(parliamen.get()) <= Int(20)\n\t)\n\tis_valid_parliamen_no = And(\n\t\tn.get() > Int(0),\n\t\tn.get() < Int(223)\n\t)\n\tis_valid_state = And(\n\t\tLen(state.get()) >= Int(0),\n\t\tLen(state.get()) <= Int(15)\n\t)\n\tcheck = And(\n\t\tis_valid_parliamen,\n\t\tis_valid_parliamen_no,\n\t\tis_valid_state\n\t)\n\tret = If(\n\t\tcheck,\n\t\tSeq(\n\t\t\tApp.localPut(Txn.sender(), k_parliament, parliamen.get()),\n\t\t\tApp.localPut(Txn.sender(), k_parliament_no, n.get()),\n\t\t\tApp.localPut(Txn.sender(), k_state, state.get())\n\t\t)\n\t)\n\treturn ret\n\n@router.method\ndef init_candidate(name: abi.String, party: abi.String):\n\tis_valid_name = And(\n\t\tLen(name.get()) >= Int(0),\n\t\tLen(name.get()) <= Int(40)\n\t)\n\tis_valid_party = And(\n\t\tLen(party.get()) >= Int(0),\n\t\tLen(party.get()) <= Int(20)\n\t)\n\tcheck = And(\n\t\tis_valid_name,\n\t\tis_valid_party\n\t)\n\tret = If(\n\t\tcheck,\n\t\tSeq(\n\t\t\tApp.localPut(Txn.sender(), k_c_name, name.get()),\n\t\t\tApp.localPut(Txn.sender(), k_party, party.get())\n\t\t)\n\t)\n\treturn ret\n\n@router.method\ndef read_dun(*, output: abi.String):\n\tret = App.localGet(Txn.sender(), k_dun)\n\treturn output.set(ret)\n\n@router.method\ndef read_dun_no(*, output: abi.Uint8):\n\tret = App.localGet(Txn.sender(), k_dun_no)\n\treturn output.set(ret)\n\n@router.method\ndef read_parliament(*, output: abi.String):\n\tret = App.localGet(Txn.sender(), k_parliament)\n\treturn output.set(ret)\n\n@router.method\ndef read_parliament_no(*, output: abi.Uint8):\n\tret = App.localGet(Txn.sender(), k_parliament_no)\n\treturn output.set(ret)\n\n@router.method\ndef read_state(*, output: abi.String):\n\tret = App.localGet(Txn.sender(), k_state)\n\treturn output.set(ret)\n\n@router.method\ndef read_c_name(*, output: abi.String):\n\tret = App.localGet(Txn.sender(), k_c_name)\n\treturn output.set(ret)\n\n@router.method\ndef read_party(*, output: abi.String):\n\tret = App.localGet(Txn.sender(), k_party)\n\treturn output.set(ret)\n\nif __name__ == \"__main__\":\n\timport os\n\timport json\n\n\tpath = os.path.dirname(os.path.abspath(__file__))\n\tapproval, clear, contract = router.compile_program(version=8)\n\n\t# Write out the approval & clear program\n\twith open(os.path.join(path, \"artifacts/approval.teal\"), \"w\") as f:\n\t\tf.write(approval)\n\n\twith open(os.path.join(path, \"artifacts/clear.teal\"), \"w\") as f:\n\t\tf.write(clear)\n\n\t# Dump out the contract as JSON to be used by any SDKs\n\twith open(os.path.join(path, \"artifacts/contract.json\"), \"w\") as f:\n\t\tf.write(json.dumps(contract.dictify(), indent=2))"}
