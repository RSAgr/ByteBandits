{"file_path": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/asa/assets/pyteal/5-clear.py", "code": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/asa/assets/pyteal/5-clear.py"}
{"file_path": "https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/kcoin_vault_pyteal.py", "code": "from pyteal import *\n\ndef clear_state_program():\n    return Return(Int(1))\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(clear_state_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"file_path": "https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py", "code": "https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/kcoin_vault_pyteal.py"}
{"file_path": "https://github.com/runvnc/genpyteal/blob/f4db17ad54c0746f25d28d2ebf5ee2ebe21be961/tstclass5.pyteal.py", "code": "from typing import Tuple\n\nfrom algosdk.abi import Contract\nfrom pyteal import (\n    App,\n    Approve,\n    Assert,\n    BareCallActions,\n    Bytes,\n    Div,\n    Expr,\n    Global,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Mul,\n    OnCompleteAction,\n    Router,\n    Seq,\n    Subroutine,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n)\nfrom pyteal.compiler.optimizer import optimizer\n\nASSET_TOTAL = 1000000000\nASSET_DECIMALS = 3\nINITIAL_EXCHANGE_RATE = 2000\nSCALING_FACTOR = 1000\n\n# The PyTeal router\nrouter = Router(\n    name=\"K-Coin-Vault\",\n    bare_calls=BareCallActions(\n        no_op=OnCompleteAction.create_only(Approve()),\n        update_application=OnCompleteAction.never(),\n        delete_application=OnCompleteAction.never(),\n        clear_state=OnCompleteAction.never(),\n    ),\n)\n\n\n@router.method\ndef init_asset(*, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Create the K Coin asset\n\n    Can only be executed by the contract's creator\n\n    Returns: created asset id\n\n    \"\"\"\n    return Seq(\n        Assert(Txn.sender() == Global.creator_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(ASSET_TOTAL),\n                TxnField.config_asset_decimals: Int(ASSET_DECIMALS),\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n                TxnField.config_asset_name: Bytes(\"K Coin\"),\n                TxnField.config_asset_unit_name: Bytes(\"microK\"),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(Bytes(\"asset_id\"), InnerTxn.created_asset_id()),\n        App.globalPut(Bytes(\"exchange_rate\"), Int(INITIAL_EXCHANGE_RATE)),\n        output.set(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.uint64)\ndef algos_to_kcoin(algo_amount: Expr) -> Expr:\n    \"\"\"\n    Convert microalgos to microKs:\n\n    microKs = microAlgos * EXCHANGE_RATE / SCALING_FACTOR\n    \"\"\"\n    return Div(Mul(algo_amount, App.globalGet(Bytes(\"exchange_rate\"))), Int(SCALING_FACTOR))\n\n\n@Subroutine(TealType.uint64)\ndef kcoin_to_algos(asset_amount: Expr) -> Expr:\n    \"\"\"\n    Convert microKs to microalgos\n\n    microAlgos = microKs * SCALING_FACTOR / EXCHANGE_RATE\n    \"\"\"\n    return Mul(Div(asset_amount, App.globalGet(Bytes(\"exchange_rate\"))), Int(SCALING_FACTOR))\n\n\n@router.precondition(expr='payment.get().amount() >= Int(10000)')\n@router.precondition(expr='payment.get().amount() <= Int(20000)')\n@router.postcondition(\n    expr=f'output.get() == payment.get().amount() * Int({INITIAL_EXCHANGE_RATE}) / Int({SCALING_FACTOR})'\n)\n@router.hoare_method\n@router.method\ndef mint(payment: abi.PaymentTransaction, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Mint K Coins, issuing an inner asset transfer transaction to sender if successful\n\n    Args:\n        payment: A payment transaction containing the amount of Algos the user wishes to mint with.\n            The receiver of this transaction must be this app's escrow account.\n\n    Returns: minted amount of K Coins that the user gets\n    \"\"\"\n    amount_to_mint = algos_to_kcoin(payment.get().amount())\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        Assert(payment.get().receiver() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset_id,\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: amount_to_mint,\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        output.set(amount_to_mint),\n    )\n\n\n@router.precondition(expr='asset_transfer.get().amount() >= Int(10000)')\n@router.precondition(expr='asset_transfer.get().amount() <= Int(20000)')\n@router.postcondition(\n    expr=f'output.get() == asset_transfer.get().amount() * Int({SCALING_FACTOR}) / Int({INITIAL_EXCHANGE_RATE})'\n)\n@router.hoare_method\n@router.method\ndef burn(asset_transfer: abi.AssetTransferTransaction, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Burn K Coins, issuing an inner payment transaction to sender if successful\n\n    Args:\n        asset_transfer: An asset transfer transaction containing the amount of K Coins (in microKs) the user wishes to burn.\n            The receiver of this transaction must be this app's escrow account.\n\n    Returns: amount of microalgos the users gets\n    \"\"\"\n    microalgos_output = kcoin_to_algos(asset_transfer.get().asset_amount())\n    return Seq(\n        Assert(asset_transfer.get().asset_receiver() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.Payment,\n                TxnField.receiver: Txn.sender(),\n                TxnField.amount: microalgos_output,\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        output.set(microalgos_output),\n    )\n\n\ndef compile_to_teal() -> Tuple[str, str, Contract]:\n    \"\"\"Compile approval and clear programs, and generate the contract description object\"\"\"\n    approval, clear, contract = router.compile_program(\n        version=6, optimize=optimizer.OptimizeOptions(scratch_slots=True)\n    )\n    return approval, clear, contract"}
{"file_path": "https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/lib/iter.py", "code": "https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py"}
{"file_path": "https://github.com/algorand/pyteal-utils/blob/c4976887ddd959d285894cf7d3e0feddef3821ba/pytealutils/strings/string.py", "code": "# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913\nimport json\nimport sys\nimport os\nfrom pyteal import *\nfrom .abi_types import *\nfrom .inline import InlineAssembly\nfrom assets.abi import ABI_PATH,system_delima\n\n\n\nmain_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}main-contract.json\"))\nvoting_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}voting-contract.json\"))\nsmart_assert_errors = json.load(open(ABI_PATH + f\"{system_delima}..{system_delima}smart_assert_errors.json\"))\n\n# This is not used as it hard codes the costs of a box\n# But is kept here as a record of how it is calculated\n# The current method is by checking min balances before\n# and after the box is created.\n# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):\n#     # (2500 per box) + (400 * (key size + box size))\n#     if key_size_bytes > 64:\n#         raise Exception(\"key size is over 64 bytes\")\n#     cost = (\n#         Int(2500) + Int(400) * \n#         (\n#             Int(key_size_bytes) +\n#             Int(box_size_bytes)\n#         )\n#     )\n#     return cost\n\ndef get_abi_method(method_name,contract:str):\n    method_dict = {\n        \"main\": main_contract_abi[\"methods\"],\n        \"voting\": voting_contract_abi[\"methods\"]\n    }\n    method_list = method_dict[contract]\n    for method in method_list:\n        if method[\"name\"] == method_name:\n            return method\n    return None\n\ndef get_method_signature(method_name, contract:str):\n    method = get_abi_method(method_name,contract)\n    if method is None:\n        raise RuntimeError\n    signature = method_name + \"(\"\n    num_args = len(method[\"args\"])\n    for index, arg in enumerate(method[\"args\"]):\n        signature += arg[\"type\"] \n        if index < num_args - 1:\n            signature += \",\"\n        else:\n            signature += f'){method[\"returns\"][\"type\"]}'\n            return signature\n\n@ABIReturnSubroutine\ndef create_source_tuple(\n    source_id: Expr, #Int\n    source_arg_list: Expr, #Bytes\n    max_age: Expr,\n    *,\n    output: SourceSpec\n) -> Expr: #Int\n    return Seq([\n        (source_id_param := abi.Uint32()).set(source_id),\n        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),\n        (max_age_param := abi.Uint64()).set(max_age),\n        output.set(\n            source_id_param,\n            source_arg_list_param,\n            max_age_param\n        ),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request(\n    source_specs: abi.DynamicArray[SourceSpec],\n    aggregation: Expr, #Int\n    user_data: Expr, #Bytes\n    app_id: Expr, #Int\n    method_signature: Expr, #Bytes\n    goracle_main_app_id: Expr,  #Int\n    request_type: Expr,\n    key: Expr,\n    app_refs: Expr, #static array of uint64\n    asset_refs: Expr, #static array of uint64\n    account_refs: Expr, #static array of byte[32]\n    box_refs: Expr # dynamic array of  (byte[],uint64)\n): # Int\n\n    request_tuple = abi.make(RequestSpec)\n    destination_tuple = abi.make(DestinationSpec)\n\n    return Seq([\n        (user_data_param := abi.DynamicBytes()).set(user_data),\n        (agg_param := abi.Uint32()).set(aggregation),\n        (app_id_param := abi.Uint64()).set(app_id),\n        (request_type_param := abi.Uint64()).set(request_type),\n        (method_sig_param := abi.DynamicBytes()).set(method_signature),\n        (key_abi := abi.DynamicBytes()).set(key),\n\n        request_tuple.set(\n            source_specs,\n            agg_param,\n            user_data_param\n        ),\n\n        destination_tuple.set(\n            app_id_param,\n            method_sig_param\n        ),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_tuple.encode(),\n                destination_tuple.encode(),\n                request_type_param.encode(),\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request_constructed(\n    request_args_encoded: Expr,\n    destination_encoded: Expr,\n    request_type_encoded: Expr,\n    goracle_main_app_id: Expr,\n    key: Expr,\n    app_refs: Expr,\n    asset_refs: Expr,\n    account_refs: Expr,\n    box_refs: Expr\n):\n    return Seq([\n        (key_abi := abi.DynamicBytes()).set(key),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_args_encoded,\n                destination_encoded,\n                request_type_encoded,\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ]\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in(goracle_main_app_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.ApplicationCall,\n            TxnField.application_id: goracle_main_app_id,\n            TxnField.on_completion: OnComplete.OptIn,\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in_asset(asset_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: asset_id,\n            TxnField.asset_receiver: Global.current_application_address(),\n            TxnField.asset_amount: Int(0),\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit()\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_deposit, account_to_deposit_to):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_deposit,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_token\",\"main\"),\n            args=[\n                asset_transfer,\n                gora_token_id,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_algo(goracle_main_app_address, goracle_main_app_id, amount_to_deposit, account_to_deposit_to):\n    algo_transfer = \\\n    {\n        TxnField.type_enum: TxnType.Payment,\n        TxnField.amount: amount_to_deposit,\n        TxnField.receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_algo\",\"main\"),\n            args=[\n                algo_transfer,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\nnew_key: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef register_key(goracle_main_app_id, new_key):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"register_participation_account\",\"main\"),\n            args=[\n                new_key,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_token(goracle_main_app_id, gora_token_id, amount_to_withdraw):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_token\",\"main\"),\n            args=[\n                amount_to_withdraw,\n                gora_token_id,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_algo(goracle_main_app_id, amount_to_withdraw):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_algo\",\"main\"),\n            args=[\n                amount_to_withdraw\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef stake_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_stake):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_stake,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Global.min_txn_fee()\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('stake', 'main'),\n            args=[\n                asset_transfer,\n            ],\n            extra_fields={\n                TxnField.fee: Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef unstake_token(goracle_main_app_id, gora_token_id, amount_to_unstake):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('unstake', 'main'),\n            args=[\n                amount_to_unstake,\n                gora_token_id\n            ],\n            extra_fields={\n                TxnField.fee : Int(2)*Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\n\"\"\"\nAssert with a number to indentify it in API error message. The message will be:\n\"shr arg too big, (%d)\" where in \"%d\" 6 lowest decinals are the line number and\nany above that are the error code. Error types are defined \"error_codes.json\"\n\"\"\"\ndef SmartAssert(cond, err_type = 0):\n    if type(err_type) == str:\n        err_type = smart_assert_errors.index(err_type) # map mnemonic to code\n    err_line = sys._getframe().f_back.f_lineno # calling line number\n    return If(Not(cond)).Then(\n        InlineAssembly(\"int 0\\nint {}\\nshr\\n\".format(err_type * 1000000 + err_line))\n    )"}
{"file_path": "https://github.com/ulamlabs/pytealext/blob/203a5f70e204b8fb8d684bf158c9e2cb734f7d41/pytealext/state.py", "code": "https://github.com/runvnc/genpyteal/blob/f4db17ad54c0746f25d28d2ebf5ee2ebe21be961/tstclass5.pyteal.py"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/examples/printers/cfg.py", "code": "from pyteal import *\n\nglobals().update(TealType.__members__)\n\ndef verbatim(x):\n  return x\n\nclass Senior:\n  \n  @verbatim\n  def __init__(self, name, age):\n    self.age = age\n    self.name = name\n  \n  \n  def isEligible(self):\n    return ( self.age > Int(65) )\n  \n  \n  def evalAndPrint(self):\n    a = ScratchVar(TealType.uint64)\n    return  Seq(\n    \ta.store(Int(10)),\n    \tIf( self.isEligible(), \n          Log(Concat(self.name,Concat(Bytes(\" is eligible. \"),Itob(a.load()))))\n        , \n          Log(Concat(self.name,Bytes(\" is too young.\")))\n       ) )\n  \n  \n  \ndef app():\n    mary = Senior(Bytes('Mary'), Int(62))\n    tom = Senior(Bytes('Tom'), Int(75))\n    return  Seq(\n    \tmary.evalAndPrint(),\n    \ttom.evalAndPrint(),\n    \tReturn( Int(1) ) )\n\n\nif __name__ == \"__main__\":\n    print(compileTeal(app(), mode=Mode.Application, version=7))"}
{"file_path": "https://github.com/codomposer/pyteal/blob/b196f5b4c48d0ef579c70e53a21dd02a60694ef9/pyteal/types.py", "code": "https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/lib/iter.py"}
{"file_path": "https://github.com/MarcelloPonzi/TesinaAlgorand-Dev/blob/83f5cfdce3a4f0af4a1a4c125eaa5d8ce4851568/algovenv/Lib/site-packages/pyteal/ast/gload.py", "code": "from pyteal import Expr, For, Int, ScratchVar\n\n__all__ = [\n    \"Iterate\",\n]\n\n\ndef Iterate(sub: Expr, n: Int, i: ScratchVar | None = None) -> Expr:\n    \"\"\"Iterate provides a convenience method for calling a method n times\n\n    Args:\n        sub: A PyTEAL Expr to call, should not return anything\n        n: The number of times to call the expression\n        i: (Optional) A ScratchVar to use for iteration, passed if the caller wants to access the iterator\n\n    Returns:\n        A Subroutine expression to be passed directly into an Expr tree\n    \"\"\"\n\n    i = i or ScratchVar()\n    init = i.store(Int(0))\n    cond = i.load() < n\n    step = i.store(i.load() + Int(1))\n    return For(init, cond, step).Do(sub)"}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py", "code": "https://github.com/algorand/pyteal-utils/blob/c4976887ddd959d285894cf7d3e0feddef3821ba/pytealutils/strings/string.py"}
{"file_path": "https://github.com/algorand/py-algorand-sdk/blob/a2d610c2f7f7b3b0c19945d0c44ccc88d7bb1888/examples/atc.py", "code": "from pyteal import (\n    Assert,\n    BitLen,\n    Btoi,\n    Bytes,\n    BytesDiv,\n    BytesGt,\n    BytesMod,\n    Concat,\n    Extract,\n    GetByte,\n    If,\n    Int,\n    Itob,\n    Len,\n    ScratchVar,\n    Seq,\n    Subroutine,\n    Substring,\n    TealType,\n)\n\nfrom pytealutils.math import pow10\n\n# Magic number to convert between ascii chars and integers\n_ascii_zero = 48\n_ascii_nine = _ascii_zero + 9\nascii_zero = Int(_ascii_zero)\nascii_nine = Int(_ascii_nine)\n\n\n@Subroutine(TealType.uint64)\ndef ascii_to_int(arg):\n    \"\"\"ascii_to_int converts the integer representing a character in ascii to the actual integer it represents\n\n    Args:\n        arg: uint64 in the range 48-57 that is to be converted to an integer\n\n    Returns:\n        uint64 that is the value the ascii character passed in represents\n\n    \"\"\"\n    return Seq(Assert(arg >= ascii_zero), Assert(arg <= ascii_nine), arg - ascii_zero)\n\n\n@Subroutine(TealType.bytes)\ndef int_to_ascii(arg):\n    \"\"\"int_to_ascii converts an integer to the ascii byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), arg, Int(1))\n\n\n@Subroutine(TealType.uint64)\ndef atoi(a):\n    \"\"\"atoi converts a byte string representing a number to the integer value it represents\"\"\"\n    return If(\n        Len(a) > Int(0),\n        (ascii_to_int(GetByte(a, Int(0))) * pow10(Len(a) - Int(1)))\n        + atoi(Substring(a, Int(1), Len(a))),\n        Int(0),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i):\n    \"\"\"itoa converts an integer to the ascii byte string it represents\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            int_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef witoa(i):\n    \"\"\"witoa converts an byte string interpreted as an integer to the ascii byte string it represents\"\"\"\n    return If(\n        BitLen(i) == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(\n                BytesGt(BytesDiv(i, Bytes(\"base16\", \"A0\")), Bytes(\"base16\", \"A0\")),\n                witoa(BytesDiv(i, Bytes(\"base16\", \"A0\"))),\n                Bytes(\"\"),\n            ),\n            int_to_ascii(Btoi(BytesMod(i, Bytes(\"base16\", \"A0\")))),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef head(s):\n    \"\"\"head gets the first byte from a bytestring, returns as bytes\"\"\"\n    return Extract(s, Int(0), Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef tail(s):\n    \"\"\"tail returns the string with the first character removed\"\"\"\n    return Substring(s, Int(1), Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef suffix(s, n):\n    \"\"\"suffix returns the last n bytes of a given byte string\"\"\"\n    return Substring(s, Len(s) - n, Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef prefix(s, n):\n    \"\"\"prefix returns the first n bytes of a given byte string\"\"\"\n    return Substring(s, Int(0), n)\n\n\n@Subroutine(TealType.bytes)\ndef rest(s, n):\n    \"\"\"prefix returns the first n bytes of a given byte string\"\"\"\n    return Substring(s, n, Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef encode_uvarint(val, b):\n    \"\"\"\n    Returns the uvarint encoding of an integer\n\n    Useful in the case that the bytecode for a contract is being populated, since\n    integers in a contract are uvarint encoded\n\n    This subroutine is recursive, the first call should include\n    the integer to be encoded and an empty bytestring\n\n    \"\"\"\n    buff = ScratchVar()\n    return Seq(\n        buff.store(b),\n        Concat(\n            buff.load(),\n            If(\n                val >= Int(128),\n                encode_uvarint(\n                    val >> Int(7),\n                    Extract(Itob((val & Int(255)) | Int(128)), Int(7), Int(1)),\n                ),\n                Extract(Itob(val & Int(255)), Int(7), Int(1)),\n            ),\n        ),\n    )"}
{"file_path": "https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/tinyman/compat.py", "code": "https://github.com/ulamlabs/pytealext/blob/203a5f70e204b8fb8d684bf158c9e2cb734f7d41/pytealext/state.py"}
{"file_path": "https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/consts.py", "code": "from pyteal import App, Bytes, Concat, Expr, Int, Itob, MaybeValue, Seq, TealType\nfrom pyteal.types import require_type\n\n\nclass State:\n    \"\"\"\n    Wrapper around state vars.\n    \"\"\"\n\n    def __init__(self, name: str | Expr, type_hint: TealType = TealType.anytype):\n        \"\"\"\n        Args:\n            name: a key in the global state, if it's a string it will be converted to Bytes\n            type_hint: a type which is expected to be stored, will be checked with each put()\n        \"\"\"\n        self._name: Expr\n        self.type_hint = type_hint\n        if isinstance(name, str):\n            self._name = Bytes(name)\n        else:\n            self._name = name\n\n    def put(self, value: Expr) -> App:\n        \"\"\"\n        Store a value in state schema\n        \"\"\"\n        raise NotImplementedError\n\n    def get(self) -> App:\n        \"\"\"\n        Get a value from a state schema\n        \"\"\"\n        raise NotImplementedError\n\n    def exists(self) -> Expr:\n        \"\"\"\n        Check if the key of this state variable is present in current app's schema.\n        \"\"\"\n        raise NotImplementedError\n\n    def add_assign(self, value_to_add: Expr) -> App:\n        \"\"\"\n        Replace the stored value with stored_value + value_to_add.\n        Equivalent to:\n            stored_value += value_to_add\n        \"\"\"\n        if not isinstance(value_to_add, Expr):\n            raise ValueError(\"value_to_add must be an instance of Expr or Expr subclass\")\n        return self.put(self.get() + value_to_add)\n\n    def sub_assign(self, value_to_subtract: Expr) -> App:\n        \"\"\"\n        Replace the stored value with stored_value - value_to_subtract.\n        Equivalent to:\n            stored_value -= value_to_subtract\n        \"\"\"\n        if not isinstance(value_to_subtract, Expr):\n            raise ValueError(\"value_to_subtract must be an instance of Expr or Expr subclass\")\n        return self.put(self.get() - value_to_subtract)\n\n\nclass LocalState(State):\n    \"\"\"\n    Wrapper for accessing local state\n    \"\"\"\n\n    def put(self, value: Expr) -> App:\n        require_type(value, self.type_hint)\n        return App.localPut(Int(0), self._name, value)\n\n    def get(self) -> App:\n        return App.localGet(Int(0), self._name)\n\n    def exists(self) -> Expr:\n        ex = App.localGetEx(Int(0), Int(0), self._name)\n        return Seq(ex, ex.hasValue())\n\n\nclass GlobalState(State):\n    \"\"\"\n    Wrapper for accessing global state\n    \"\"\"\n\n    def put(self, value: Expr) -> App:\n        require_type(value, self.type_hint)\n        return App.globalPut(self._name, value)\n\n    def get(self) -> App:\n        return App.globalGet(self._name)\n\n    def exists(self) -> Expr:\n        ex = App.globalGetEx(Int(0), self._name)\n        return Seq(ex, ex.hasValue())\n\n\ndef get_global_state_ex(foreign_id: int, key: str) -> MaybeValue:\n    \"\"\"\n    Wrapper for global state getter.\n    External state variables need to be evaluated before use.\n\n    https://pyteal.readthedocs.io/en/stable/state.html#external-global\n    \"\"\"\n    return App.globalGetEx(Int(foreign_id), Bytes(key))\n\n\nclass StateArray:\n    \"\"\"\n    Wrapper for state access which utilizes multiple slots\n    \"\"\"\n\n    def __init__(self, prefix: str | Expr, type_hint: TealType = TealType.anytype):\n        \"\"\"\n        Args:\n            prefix: a key prefix in the global state, if it's a string it will be converted to Bytes.\n            Prefix should be unique to avoid naming conflicts.\n        \"\"\"\n        self._prefix = prefix\n        self.type_hint = type_hint\n\n    def key_at_index(self, index: int | Expr) -> Expr:\n        \"\"\"\n        Get the actual key (bytes) that will be used to access the state information\n        \"\"\"\n        if isinstance(index, int):  # pylint: disable=no-else-return\n            if isinstance(self._prefix, str):\n                # index: int, prefix: str\n                return Bytes(self._prefix.encode(\"utf-8\") + index.to_bytes(8, \"big\"))\n            # index: int, prefix: Expr\n            return Concat(self._prefix, Bytes(index.to_bytes(8, \"big\")))\n        else:  # isinstance(index, Expr)\n            if isinstance(self._prefix, str):\n                # index: Expr, prefix: str\n                return Concat(Bytes(self._prefix), Itob(index))\n            # index: Expr, prefix: Expr (u64)\n            return Concat(self._prefix, Itob(index))\n\n    def __getitem__(self, index: int | Expr):\n        raise NotImplementedError\n\n\nclass LocalStateArray(StateArray):\n    \"\"\"\n    Wrapper for local state access which utilizes multiple slots in local state\n    \"\"\"\n\n    def __getitem__(self, index: int | Expr):\n        return LocalState(self.key_at_index(index), self.type_hint)\n\n\nclass LocalStateArray2D(StateArray):\n    \"\"\"\n    Wrapper for local state access which utilizes multiple slots in local state organized in 2D array\n    \"\"\"\n\n    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):  # type: ignore\n        length, width = indices\n        return LocalStateArray(self.key_at_index(length), self.type_hint)[width]\n\n\nclass GlobalStateArray(StateArray):\n    \"\"\"\n    Wrapper for global state access which utilizes multiple slots in global state\n    \"\"\"\n\n    def __getitem__(self, index: int | Expr):\n        return GlobalState(self.key_at_index(index), self.type_hint)\n\n\nclass GlobalStateArray2D(StateArray):\n    \"\"\"\n    Wrapper for global state access which utilizes multiple slots in global state organized in 2D array\n    \"\"\"\n\n    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):  # type: ignore\n        length, width = indices\n        return GlobalStateArray(self.key_at_index(length), self.type_hint)[width]"}
{"file_path": "https://github.com/algorand-devrel/demo-abi/blob/3e6985f89c58b5531adb2ac2436ace7d722edb36/py/abi.py", "code": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/examples/printers/cfg.py"}
{"file_path": "https://github.com/Hipo/algojig/blob/71a1bf83204fb70198850024306d91bd041da7d4/algojig/check.py", "code": "# pylint: disable=undefined-variable\n# type: ignore[name-defined]\nfrom pyteal import *  # pylint: disable=wildcard-import,unused-wildcard-import\n\nrouter = Router(\n    name=\"CFGExample\",\n    bare_calls=BareCallActions(),\n)\n\n\n@router.method(no_op=CallConfig.CREATE)\ndef create() -> Expr:\n    return Return()\n\n\n@router.method(opt_in=CallConfig.CALL)\ndef opt_in() -> Expr:\n    return Return()\n\n\npragma(compiler_version=\"0.22.0\")\napplication_approval_program, _, _ = router.compile_program(version=7)\n\nif __name__ == \"__main__\":\n    print(application_approval_program)"}
{"file_path": "https://github.com/Vilijan/TicTacToe_Algorand/blob/61bfd59696f7fec4f2127cb746d7c5470fff95d8/app.py", "code": "https://github.com/codomposer/pyteal/blob/b196f5b4c48d0ef579c70e53a21dd02a60694ef9/pyteal/types.py"}
{"file_path": "https://github.com/hyplabs/AlgoSwap/blob/4e3f9a977461cd34c246847a0f0d5dbbae5e5ee7/deploy.py", "code": "import re\nfrom enum import Enum\nfrom typing import Any\n\nfrom .errors import TealTypeError, TealInputError\n\n\nclass TealType(Enum):\n    \"\"\"Teal type enum.\"\"\"\n\n    \"\"\"Unsigned 64 bit integer type.\"\"\"\n    uint64 = 0\n\n    \"\"\"Byte string type.\"\"\"\n    bytes = 1\n\n    \"\"\"Any type that is not none.\"\"\"\n    anytype = 2\n\n    \"\"\"Represents no value.\"\"\"\n    none = 3\n\n\nTealType.__module__ = \"pyteal\"\n\n\ndef require_type(input: Any, expected: TealType):\n    try:\n        actual = input.type_of()\n    except AttributeError:\n        raise TypeError(f\"Expected a {expected} object, but got a {type(input)}\")\n\n    if actual != expected and (\n        expected == TealType.none\n        or actual == TealType.none\n        or (actual != TealType.anytype and expected != TealType.anytype)\n    ):\n        raise TealTypeError(actual, expected)\n\n\ndef types_match(type1: TealType, type2: TealType) -> bool:\n    if (type1 == TealType.none or type2 == TealType.none) and type1 != type2:\n        return False\n\n    if type1 == TealType.anytype or type2 == TealType.anytype:\n        return True\n\n    return type1 == type2\n\n\ndef valid_address(address: str):\n    \"\"\"check if address is a valid address with checksum\"\"\"\n    if type(address) is not str:\n        raise TealInputError(\"An address needs to be a string\")\n\n    if len(address) != 58:\n        raise TealInputError(\n            \"Address length is not correct. Should \"\n            + \"be a base 32 string encoded 32 bytes public key + 4 bytes checksum\"\n        )\n\n    valid_base32(address)\n\n\ndef valid_base32(s: str):\n    \"\"\"check if s is a valid base32 encoding string\"\"\"\n    pattern = re.compile(\n        r\"^(?:[A-Z2-7]{8})*(?:([A-Z2-7]{2}([=]{6})?)|([A-Z2-7]{4}([=]{4})?)|([A-Z2-7]{5}([=]{3})?)|([A-Z2-7]{7}([=]{1})?))?\"\n    )\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 32 string\".format(s))\n\n\ndef valid_base64(s: str):\n    \"\"\"check if s is a valid base64 encoding string\"\"\"\n    pattern = re.compile(\n        r\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\"\n    )\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 64 string\".format(s))\n\n\ndef valid_base16(s: str):\n    \"\"\"check if s is a valid hex encoding string\"\"\"\n    pattern = re.compile(r\"[0-9A-Fa-f]*\")\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 16 string\".format(s))\n\n\ndef valid_tmpl(s: str):\n    \"\"\"check if s is valid template name\"\"\"\n    pattern = re.compile(r\"TMPL_[A-Z0-9_]+\")\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid template variable\".format(s))"}
{"file_path": "https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/sandbox.py", "code": "https://github.com/MarcelloPonzi/TesinaAlgorand-Dev/blob/83f5cfdce3a4f0af4a1a4c125eaa5d8ce4851568/algovenv/Lib/site-packages/pyteal/ast/gload.py"}
{"file_path": "https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/utils.py", "code": "from typing import cast, Union, TYPE_CHECKING\n\nfrom ..types import TealType, require_type\nfrom ..ir import TealOp, Op, TealBlock\nfrom ..errors import TealInputError, verifyTealVersion\nfrom ..config import MAX_GROUP_SIZE, NUM_SLOTS\nfrom .expr import Expr\nfrom .int import Int\nfrom .leafexpr import LeafExpr\n\nif TYPE_CHECKING:\n    from ..compiler import CompileOptions\n\n\nclass ImportScratchValue(LeafExpr):\n    \"\"\"An expression to load a scratch value created by another transaction in the current group\"\"\"\n\n    def __init__(self, txnIndex: Union[int, Expr], slotId: int) -> None:\n        \"\"\"Create an expression to load a scratch space slot from a transaction in the current group.\n\n        Requires TEAL version 4 or higher. This operation is only permitted in application mode.\n\n        Args:\n            txnIndex: The index of the transaction from which the created ID should be obtained.\n                This index may be a Python int, or it may be a PyTeal expression that evaluates at\n                runtime. If it's an expression, it must evaluate to a uint64. In all cases, the index\n                must be less than the index of the current transaction.\n            slotId: The index of the scratch slot that should be loaded. The index must be a Python int\n                in the range [0-256).\n        \"\"\"\n        super().__init__()\n        if type(txnIndex) is int:\n            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:\n                raise TealInputError(\n                    \"Invalid transaction index {}, shoud be in [0, {})\".format(\n                        txnIndex, MAX_GROUP_SIZE\n                    )\n                )\n        else:\n            require_type(cast(Expr, txnIndex).type_of(), TealType.uint64)\n        if slotId < 0 or slotId >= NUM_SLOTS:\n            raise TealInputError(\n                \"Invalid slot ID {}, shoud be in [0, {})\".format(slotId, NUM_SLOTS)\n            )\n\n        self.txnIndex = txnIndex\n        self.slotId = slotId\n\n    def __str__(self) -> str:\n        return \"(Gload {} {})\".format(self.txnIndex, self.slotId)\n\n    def __teal__(self, options: \"CompileOptions\"):\n        verifyTealVersion(\n            Op.gload.min_version,\n            options.version,\n            \"TEAL version too low to use Gload expression\",\n        )\n\n        if type(self.txnIndex) is int:\n            op = TealOp(self, Op.gload, self.txnIndex, self.slotId)\n            return TealBlock.FromOp(options, op)\n\n        op = TealOp(self, Op.gloads, self.slotId)\n        return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))\n\n    def type_of(self):\n        return TealType.anytype\n\n\nImportScratchValue.__module__ = \"pyteal\""}
{"file_path": "https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py", "code": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py"}
{"file_path": "https://github.com/khoilr/blockchain-consensus/blob/57eeab4287a05b511b370e2e7258b96687f1f6e8/Algorand.py", "code": "#Choice Coin Governance Rewards Code.\n#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nfrom algorand_demo import choice_trade\nimport json\nimport urllib3\nchoice_id  = 42771692\n\nvoter_1_address = \nvoter_1_mnemonic = \nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\n\t# now we will open a file for writing\n\t\tdata_file = open('file.csv', 'w')\n\n\t# create the csv writer object\n\t\tcsv_writer = csv.writer(data_file)\n\n\t# Counter variable used for writing\n\t# headers to the CSV file\n\t\tcount = 0\n\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\n\t\t        # Writing headers of CSV file\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\n\t\t    # Writing data of CSV file\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t    # pass the file object to reader() to get the reader object\n\t\t\t\t\tdata = json.load(json_file)\n\t\t\t\t\ttransaction_data = data['transactions']\n\t\t\t\t\tfor transaction in transaction_data:\n\t\t\t\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\t\t\t\tamount = int(amount)\n\t\t\t\t\t\tamount = amount + amount * 0.12 #Rewards rate hardcoded\n\t\t\t\t\t\taddress = transaction['sender']\n\t\t\t\t\t\tid = transaction['id']\n\t\t\t\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"file_path": "https://github.com/zalkikar/AlgoRand_Covid/blob/fe6a060440ec515bfdee2caf35286312d55d833a/py_algorand.py", "code": "https://github.com/algorand/py-algorand-sdk/blob/a2d610c2f7f7b3b0c19945d0c44ccc88d7bb1888/examples/atc.py"}
{"file_path": "https://github.com/gitcoinco/web/blob/7c66485f75dbe5ca072892862ff6c9754baf889a/app/grants/utils.py", "code": "import base64\nfrom algosdk import transaction, abi\nfrom utils import get_accounts, get_algod_client, deploy_calculator_app\n\nfrom algosdk.atomic_transaction_composer import (\n    AtomicTransactionComposer,\n    AccountTransactionSigner,\n    TransactionWithSigner,\n)\n\n\n# example: ATC_CREATE\natc = AtomicTransactionComposer()\n# example: ATC_CREATE\n\naccts = get_accounts()\nacct = accts.pop()\n\nalgod_client = get_algod_client()\n\n# example: ATC_ADD_TRANSACTION\naddr, sk = acct.address, acct.private_key\n\n# Create signer object\nsigner = AccountTransactionSigner(sk)\n\n# Get suggested params from the client\nsp = algod_client.suggested_params()\n\n# Create a transaction\nptxn = transaction.PaymentTxn(addr, sp, addr, 10000)\n\n# Construct TransactionWithSigner\ntws = TransactionWithSigner(ptxn, signer)\n\n# Pass TransactionWithSigner to ATC\natc.add_transaction(tws)\n# example: ATC_ADD_TRANSACTION\n\n\napp_id = deploy_calculator_app(algod_client, acct)\n\n# example: ATC_CONTRACT_INIT\nwith open(\"calculator/contract.json\") as f:\n    js = f.read()\ncontract = abi.Contract.from_json(js)\n# example: ATC_CONTRACT_INIT\n\n# example: ATC_ADD_METHOD_CALL\n\n# Simple call to the `add` method, method_args can be any type but _must_\n# match those in the method signature of the contract\natc.add_method_call(\n    app_id,\n    contract.get_method_by_name(\"add\"),\n    addr,\n    sp,\n    signer,\n    method_args=[1, 1],\n)\n# example: ATC_ADD_METHOD_CALL\n\n\n# example: ATC_RESULTS\n# Other options:\n# txngroup = atc.build_group()\n# txids = atc.submit(client)\nresult = atc.execute(algod_client, 4)\nfor res in result.abi_results:\n    print(res.return_value)\n# example: ATC_RESULTS\n\n\nmy_method = abi.Method(\n    name=\"box_ref_demo\", args=[], returns=abi.Returns(\"void\")\n)\n# example: ATC_BOX_REF\natc = AtomicTransactionComposer()\natc.add_method_call(\n    app_id,\n    my_method,\n    addr,\n    sp,\n    signer,\n    boxes=[[app_id, b\"key\"]],\n)\n# example: ATC_BOX_REF"}
{"file_path": "https://github.com/VincenzoImp/utils/blob/b797a1d6b71e212e430df3554bf94f9e67cd206d/parser_utils.py", "code": "https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/tinyman/compat.py"}
{"file_path": "https://github.com/Argonaut5000/algorand-arc19-python-example/blob/be35e0c5b48b98a74c7ae70e32531502d6a5e37d/algorand_utils.py", "code": "# flake8: noqa\n\ntry:\n    from algosdk.transaction import (\n        ApplicationClearStateTxn,\n        ApplicationOptInTxn,\n        ApplicationNoOpTxn,\n        AssetTransferTxn,\n        AssetCreateTxn,\n        AssetOptInTxn,\n        assign_group_id,\n        LogicSigAccount,\n        LogicSigTransaction,\n        PaymentTxn,\n        SuggestedParams,\n        Transaction,\n        OnComplete,\n        wait_for_confirmation,\n    )\nexcept ImportError:\n    from algosdk.future.transaction import (\n        ApplicationClearStateTxn,\n        ApplicationOptInTxn,\n        ApplicationNoOpTxn,\n        AssetTransferTxn,\n        AssetCreateTxn,\n        AssetOptInTxn,\n        assign_group_id,\n        LogicSigAccount,\n        LogicSigTransaction,\n        PaymentTxn,\n        SuggestedParams,\n        Transaction,\n        OnComplete,\n        wait_for_confirmation,\n    )"}
{"file_path": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py", "code": "https://github.com/algorandfoundation/beaker/blob/8650a29dd20bfb60a07f64082814658bca2de36c/beaker/consts.py"}
{"file_path": "https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/examples/exodus.py", "code": "from math import ceil\nfrom typing import Final\n\nfrom algosdk.constants import APP_PAGE_MAX_SIZE\nfrom pyteal import Int\n\n#: number of microalgos in 1 Algo\nalgo: Final[int] = int(1e6)\n#: number of microalgos in 1 MilliAlgo\nmilli_algo: Final[int] = int(1e3)\n\n#: Used for runtime algo calculations `Txn.amount()==Algo`\nAlgo: Final[Int] = Int(algo)\n#: Used for runtime algo calculations `Txn.fee()==MilliAlgo`\nMilliAlgo: Final[Int] = Int(milli_algo)\n\n\n#: Used for shorthand for Int(10*algo) like Algos(10)\ndef Algos(v: int | float) -> Int:  # noqa: N802\n    return Int(int(v * algo))\n\n\n#: Used for shorthand for Int(10*milli_algo) like MilliAlgos(10)\ndef MilliAlgos(v: int | float) -> Int:  # noqa: N802\n    return Int(int(v * milli_algo))\n\n\n#: Max number of inner transactions that may be called\nMAX_INNERS = 255\n#: Single app call opcode budget\nAPP_CALL_BUDGET = 700\n#: Max possible opcode budget\nMAX_OPS = MAX_INNERS * APP_CALL_BUDGET\n\n#: Single app call budget\nAppCallBudget = Int(APP_CALL_BUDGET)\n#: Max app call budget possible\nMaxOps = Int(MAX_OPS)\n\n\n#: TRUE used as an alias for 1\nTRUE: Final[Int] = Int(1)\n#: FALSE used as an alias for 0\nFALSE: Final[Int] = Int(0)\n\n#: The max number of local state values that may be declared\nMAX_LOCAL_STATE = 16\n#: The max number of global state values that may be declared\nMAX_GLOBAL_STATE = 64\n\n#: The maximum number of args that may be included in an lsig\nLSIG_MAX_ARGS = 255\n\n#: The prefix used when hashing bytecode to produce a unique hash\nPROGRAM_DOMAIN_SEPARATOR = \"Program\"\n\n#: The min balance increase per box created\nBOX_FLAT_MIN_BALANCE = 2500\n\n#: The min balance increase per byte of boxes (key included)\nBOX_BYTE_MIN_BALANCE = 400\n\n#: The min balance increase for each asset opted into\nASSET_MIN_BALANCE = 100000\n\n\ndef num_extra_program_pages(approval: bytes, clear: bytes) -> int:\n    return ceil(((len(approval) + len(clear)) - APP_PAGE_MAX_SIZE) / APP_PAGE_MAX_SIZE)"}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py", "code": "https://github.com/algorand-devrel/demo-abi/blob/3e6985f89c58b5531adb2ac2436ace7d722edb36/py/abi.py"}
{"file_path": "https://github.com/N3koSempai/searching_algorand/blob/adb01b6981504f6a9df47966cec5b30348cbaca1/search-algorand.py", "code": "from algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import (\n    AccountTransactionSigner,\n    AtomicTransactionComposer,\n    TransactionWithSigner,\n)\nfrom algosdk.transaction import PaymentTxn, AssetCreateTxn\nfrom algosdk.abi import Contract\nfrom algosdk.logic import get_application_address\n\nfrom sandbox import get_accounts\n\nclient = AlgodClient(\"a\" * 64, \"http://localhost:4001\")\n\n\naddr, sk = get_accounts()[0]\n\nwith open(\"../contract.json\") as f:\n    js = f.read()\n\nwith open(\"../.app_id\") as f:\n    app_id = int(f.read())\n\napp_addr = get_application_address(app_id)\n\nc = Contract.from_json(js)\n\nsigner = AccountTransactionSigner(sk)\nsp = client.suggested_params()\n\n\nbox_comp = AtomicTransactionComposer()\nbox_name = b\"cool_box\"\nbox_comp.add_transaction(\n    TransactionWithSigner(PaymentTxn(addr, sp, app_addr, 1_000_000_000), signer=signer),\n)\nbox_comp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"box_write\"),\n    addr,\n    sp,\n    signer,\n    method_args=[box_name, (123, 456)],\n    boxes=[(0, box_name)],\n)\nbox_comp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"box_read\"),\n    addr,\n    sp,\n    signer,\n    method_args=[box_name],\n    # technically not needed since we already ref it in\n    # the previous txn in the same group\n    boxes=[(0, box_name)],\n)\nbox_result = box_comp.execute(client, 4)\nprint(f\"box_read returned: {box_result.abi_results[-1].return_value}\")\n\n\ncomp = AtomicTransactionComposer()\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"add\"), addr, sp, signer, method_args=[1, 1]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"sub\"), addr, sp, signer, method_args=[3, 1]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"div\"), addr, sp, signer, method_args=[4, 2]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"mul\"), addr, sp, signer, method_args=[3, 2]\n)\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"qrem\"), addr, sp, signer, method_args=[27, 5]\n)\n\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"reverse\"),\n    addr,\n    sp,\n    signer,\n    method_args=[\"desrever yllufsseccus\"],\n)\n\nptxn = TransactionWithSigner(PaymentTxn(addr, sp, addr, 10000), signer)\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"txntest\"),\n    addr,\n    sp,\n    signer,\n    method_args=[10000, ptxn, 1000],\n)\n\ncomp.add_method_call(\n    app_id, c.get_method_by_name(\"manyargs\"), addr, sp, signer, method_args=[2] * 20\n)\n\n\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"min_bal\"),\n    addr,\n    sp,\n    signer,\n    method_args=[\"SKCBRBKPIGY5LI2OU63IE5LMNQ5BVVOKPHWTPPWFQOI4NG4TI35SLAA3JQ\"],\n)\n\ncomp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"concat_strings\"),\n    addr,\n    sp,\n    signer,\n    method_args=[[\"this\", \"string\", \"is\", \"joined\"]],\n)\n\n# Useable with abi_types.py contract\n# comp.add_method_call(\n#     app_id,\n#     c.get_method_by_name(\"concat_dynamic_arrays\"),\n#     addr,\n#     sp,\n#     signer,\n#     method_args=[[1, 2, 3], [4, 5, 6]],\n# )\n#\n# comp.add_method_call(\n#     app_id,\n#     c.get_method_by_name(\"concat_static_arrays\"),\n#     addr,\n#     sp,\n#     signer,\n#     method_args=[[1, 2, 3], [4, 5, 6]],\n# )\n#\n#\n# comp.add_method_call(\n#     app_id,\n#     c.get_method_by_name(\"concat_dynamic_string_arrays\"),\n#     addr,\n#     sp,\n#     signer,\n#     method_args=[[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]],\n# )\n\n\n# drr = comp.dryrun(client)\n# for txn in drr.trace.txns:\n#    if txn.app_call_rejected():\n#        print(txn.app_trace())\n\nresp = comp.execute(client, 2)\nfor result in resp.abi_results:\n    # print(result.decode_error)\n    # print(result.raw_value.hex())\n    print(f\"{result.method.name} => {result.return_value}\")"}
{"file_path": "https://github.com/major/fedora-rpm-specs/blob/28cd4e4325ce70550cb235b8c2e28beefbf09fe5/specs/python-py-algorand-sdk.spec", "code": "https://github.com/Hipo/algojig/blob/71a1bf83204fb70198850024306d91bd041da7d4/algojig/check.py"}
{"file_path": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py", "code": "from algojig import get_suggested_params, generate_accounts, dump\nfrom algojig.ledger import JigLedger\nfrom algosdk.transaction import PaymentTxn\n\nsecrets, addresses = generate_accounts(2)\n\nsp = get_suggested_params()\n\nledger = JigLedger()\nledger.set_account_balance(addresses[0], 1_000_000)\n\ntransactions = [\n    PaymentTxn(\n        sender=addresses[0],\n        sp=sp,\n        receiver=addresses[1],\n        amt=200_000,\n    ).sign(secrets[0]),\n]\nblock = ledger.eval_transactions(transactions)\nprint(\"Looks like it works!\")"}
{"file_path": "https://github.com/algorandfoundation/docs/blob/85a8af923b2377a6037652372caad238f7f26803/scripts/import_examples.py", "code": "https://github.com/Vilijan/TicTacToe_Algorand/blob/61bfd59696f7fec4f2127cb746d7c5470fff95d8/app.py"}
{"file_path": "https://github.com/demining/CryptoDeepTools/blob/206484942dbcf4b9996fa5bcc14181138c557697/17BTCRecoverCryptoGuide/utilities/algorand_recovery.py", "code": "import streamlit as st\nfrom src.blockchain_utils.credentials import get_client, get_account_credentials, get_indexer\nfrom src.services.game_engine_service import GameEngineService\nimport algosdk\n\nclient = get_client()\nindexer = get_indexer()\n\nacc_pk, acc_address = algosdk.account.generate_account()\nplayer_x_pk, player_x_address = algosdk.account.generate_account()\nplayer_o_pk, player_o_address = algosdk.account.generate_account()\n\nif \"submitted_transactions\" not in st.session_state:\n    st.session_state.submitted_transactions = []\n\nif \"player_turn\" not in st.session_state:\n    st.session_state.player_turn = \"X\"\n\nif \"game_state\" not in st.session_state:\n    st.session_state.game_state = ['-'] * 9\n\nif \"x_state\" not in st.session_state:\n    st.session_state.x_state = 0\n\nif \"o_state\" not in st.session_state:\n    st.session_state.o_state = 0\n\nif \"game_state\" not in st.session_state:\n    st.session_state.game_state = ['-'] * 9\n\nif \"game_engine\" not in st.session_state:\n    st.session_state.game_engine = GameEngineService(app_creator_pk=acc_pk,\n                                                     app_creator_address=acc_address,\n                                                     player_x_pk=player_x_pk,\n                                                     player_x_address=player_x_address,\n                                                     player_o_pk=player_o_pk,\n                                                     player_o_address=player_o_address)\n\nif \"game_status\" not in st.session_state:\n    st.session_state.game_status = 0\n\nif \"is_app_deployed\" not in st.session_state:\n    st.session_state.is_app_deployed = False\n\nif \"is_game_started\" not in st.session_state:\n    st.session_state.is_game_started = False\n\nst.title(\"Addresses\")\nst.write(f\"app_creator: {acc_address}\")\nst.write(f\"player_x: {player_x_address}\")\nst.write(f\"player_o: {player_o_address}\")\n\nst.write(\"You need to fund those accounts on the following link: https://bank.testnet.algorand.network/\")\n\n\n# Step 1: App deployment.\n\ndef deploy_application():\n    if st.session_state.is_app_deployed:\n        return\n\n    app_deployment_txn_log = st.session_state.game_engine.deploy_application(client)\n    st.session_state.submitted_transactions.append(app_deployment_txn_log)\n    st.session_state.is_app_deployed = True\n\n\nst.title(\"Step 1: App deployment\")\nst.write(\"In this step we deploy the Tic-Tac-Toe Stateful Smart Contract to the Algorand TestNetwork\")\n\nif st.session_state.is_app_deployed:\n    st.success(f\"The app is deployed on TestNet with the following app_id: {st.session_state.game_engine.app_id}\")\nelse:\n    st.error(f\"The app is not deployed! Press the button below to deploy the application.\")\n    _ = st.button(\"Deploy App\", on_click=deploy_application)\n\n# Step 2: Start of the game\nst.title(\"Step 2: Mark the start of the game\")\nst.write(\"In this step we make atomic transfer of 3 transactions that marks the start of the game.\")\n\n\ndef start_game():\n    if st.session_state.is_game_started:\n        return\n\n    start_game_txn_log = st.session_state.game_engine.start_game(client)\n    st.session_state.submitted_transactions.append(start_game_txn_log)\n    st.session_state.is_game_started = True\n\n\nif st.session_state.is_game_started:\n    st.success(\"The game has started\")\nelse:\n    st.error(f\"The game has not started! Press the button below to start the game.\")\n    _ = st.button(\"Start game\", on_click=start_game)\n\nst.title(\"Step 3: Execute game actions\")\n\nif st.session_state.player_turn == \"X\":\n    st.warning(f\"Current player: {st.session_state.player_turn}\")\nelse:\n    st.success(f\"Current player: {st.session_state.player_turn}\")\n\nmark_position_idx = st.number_input(f'Action position',\n                                    value=0,\n                                    step=1)\n\n\ndef to_binary(integer):\n    return format(integer, 'b').zfill(9)\n\n\ndef get_game_status(indexer, app_id):\n    response = indexer.search_applications(application_id=app_id)\n    game_status_key = \"R2FtZVN0YXRl\"\n\n    for global_variable in response['applications'][0]['params']['global-state']:\n        if global_variable['key'] == game_status_key:\n            return global_variable['value']['uint']\n\n\ndef play_action(action_idx):\n    try:\n        play_action_txn = st.session_state.game_engine.play_action(client,\n                                                                   player_id=st.session_state.player_turn,\n                                                                   action_position=action_idx)\n    except:\n        st.session_state.submitted_transactions.append(f\"Rejected transaction. Tried to put \"\n                                                       f\"{st.session_state.player_turn} at {action_idx}\")\n        return\n\n    st.session_state.game_state[action_idx] = st.session_state.player_turn\n    st.session_state.submitted_transactions.append(play_action_txn)\n    if st.session_state.player_turn == \"X\":\n        st.session_state.x_state = st.session_state.x_state | (1 << action_idx)\n        st.session_state.player_turn = \"O\"\n    else:\n        st.session_state.o_state = st.session_state.o_state | (1 << action_idx)\n        st.session_state.player_turn = \"X\"\n\n\n_ = st.button('Play Action', on_click=play_action,\n              args=(mark_position_idx,))\n\nst.title(\"Game state\")\n\nfor i in range(3):\n    cols = st.columns(3)\n    for j in range(3):\n        idx = i * 3 + j\n        if st.session_state.game_state[idx] == '-':\n            cols[j].info('-')\n        elif st.session_state.game_state[idx] == 'X':\n            cols[j].warning('X')\n        else:\n            cols[j].success('O')\n\nst.subheader(\"Binary states\")\nst.write(f\"x_state: {st.session_state.x_state} == {to_binary(st.session_state.x_state)}\")\nst.write(f\"o_state: {st.session_state.o_state} == {to_binary(st.session_state.o_state)}\")\n\n# Step 4:\n\nst.title(\"Step 4: Withdraw funds\")\n\n\ndef check_game_status():\n    if st.session_state.is_game_started:\n        game_status = get_game_status(indexer, app_id=st.session_state.game_engine.app_id)\n        st.session_state.game_status = game_status\n\n\nst.write(\"Press the button below to use the indexer to query the global state of the application.\")\n_ = st.button(\"Check the game status\", on_click=check_game_status)\n\n\ndef withdraw_funds(winner):\n    if winner is None:\n        try:\n            fund_escrow_txn = st.session_state.game_engine.fund_escrow(client=client)\n            st.session_state.submitted_transactions.append(fund_escrow_txn)\n\n            txn_description = st.session_state.game_engine.tie_money_refund(client)\n            st.session_state.submitted_transactions.append(txn_description)\n        except:\n            st.session_state.submitted_transactions.append(\"Rejected transaction. Unsuccessful withdrawal.\")\n    else:\n        try:\n            fund_escrow_txn = st.session_state.game_engine.fund_escrow(client=client)\n            st.session_state.submitted_transactions.append(fund_escrow_txn)\n\n            txn_description = st.session_state.game_engine.win_money_refund(client, player_id=winner)\n            st.session_state.submitted_transactions.append(txn_description)\n        except:\n            st.session_state.submitted_transactions.append(\"Rejected transaction. Unsuccessful withdrawal.\")\n\n\nif st.session_state.game_status == 0:\n    st.write(\"The game is still active.\")\nelse:\n    winner = None\n    if st.session_state.game_status == 1:\n        st.balloons()\n        st.success(\"Player X won the game.\")\n        winner = \"X\"\n    elif st.session_state.game_status == 2:\n        st.balloons()\n        st.success(\"Player O won the game.\")\n        winner = \"O\"\n    elif st.session_state.game_status == 3:\n        st.warning(\"The game has ended with a tie.\")\n\n    _ = st.button('Withdraw funds', on_click=withdraw_funds,\n                  args=(winner,))\n\nst.title(\"Submitted transactions\")\n\nfor txn in st.session_state.submitted_transactions:\n    if \"Rejected transaction.\" in txn:\n        st.error(txn)\n    else:\n        st.success(txn)"}
{"file_path": "https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/bip_utils/algorand/mnemonic/algorand_mnemonic_encoder.py", "code": "https://github.com/hyplabs/AlgoSwap/blob/4e3f9a977461cd34c246847a0f0d5dbbae5e5ee7/deploy.py"}
{"file_path": "https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/algod.py", "code": "import os\nimport base64\nimport time\n\nfrom algosdk.v2client import algod, indexer\nfrom algosdk.future import transaction\nfrom algosdk import encoding, account, mnemonic, error\nfrom pyteal import compileTeal, Mode\n\nfrom contracts import manager\n\nALGOD_ENDPOINT = os.environ['ALGOD_ENDPOINT']\nALGOD_TOKEN = os.environ['ALGOD_TOKEN']\nINDEXER_ENDPOINT = os.environ['INDEXER_ENDPOINT']\nINDEXER_TOKEN = os.environ['INDEXER_TOKEN']\n\nDEVELOPER_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(\n    os.environ['DEVELOPER_ACCOUNT_PRIVATE_KEY'])\nDEVELOPER_ACCOUNT_ADDRESS = account.address_from_private_key(\n    DEVELOPER_ACCOUNT_PRIVATE_KEY)\nZERO_ADDRESS = encoding.encode_address(bytes(32))\n\nTEST_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(\n    os.environ['TEST_ACCOUNT_PRIVATE_KEY'])\nTEST_ACCOUNT_ADDRESS = account.address_from_private_key(\n    TEST_ACCOUNT_PRIVATE_KEY)\n\nTOKEN1_UNIT_NAME = \"TOKEN1\"\nTOKEN1_ASSET_NAME = \"AlgoSwap Token 1 Test Asset\"\nTOKEN1_AMOUNT = 2**64 - 1\nTOKEN1_DECIMALS = 6\nTOKEN2_UNIT_NAME = \"TOKEN2\"\nTOKEN2_ASSET_NAME = \"AlgoSwap Token 2 Test Asset\"\nTOKEN2_AMOUNT = 2**64 - 1\nTOKEN2_DECIMALS = 6\nLIQUIDITY_TOKEN_UNIT_NAME = \"T1T2\"\nLIQUIDITY_TOKEN_ASSET_NAME = \"AlgoSwap Token1/Token2\"\nLIQUIDITY_TOKEN_AMOUNT = 2**64 - 1\nLIQUIDITY_TOKEN_DECIMALS = 6\n\n\nalgod_client = algod.AlgodClient(ALGOD_TOKEN, ALGOD_ENDPOINT, headers={\n    \"x-api-key\": ALGOD_TOKEN})\nindexer_client = indexer.IndexerClient(INDEXER_TOKEN, INDEXER_ENDPOINT, headers={\n    \"x-api-key\": INDEXER_TOKEN})\n\n\ndef wait_for_transaction(transaction_id):\n    suggested_params = algod_client.suggested_params()\n    algod_client.status_after_block(suggested_params.first + 4)\n    result = indexer_client.search_transactions(txid=transaction_id)\n    assert len(result['transactions']) == 1, result\n    return result['transactions'][0]\n\n\ndef compile_exchange_validator():\n    from contracts import validator\n\n    print(\"Compiling exchange validator application...\")\n\n    validator_approve_teal_code = compileTeal(\n        validator.approval_program(), Mode.Application)\n    compile_response = algod_client.compile(validator_approve_teal_code)\n    validator_approve_code = base64.b64decode(compile_response['result'])\n    VALIDATOR_APPROVE_BYTECODE_LEN = len(validator_approve_code)\n    VALIDATOR_APPROVE_ADDRESS = compile_response['hash']\n\n    validator_clear_teal_code = compileTeal(\n        validator.clear_program(), Mode.Application)\n    compile_response = algod_client.compile(validator_clear_teal_code)\n    validator_clear_code = base64.b64decode(compile_response['result'])\n    VALIDATOR_CLEAR_BYTECODE_LEN = len(validator_clear_code)\n    VALIDATOR_CLEAR_ADDRESS = compile_response['hash']\n\n    print(\n        f\"Exchange Validator | Approval: {VALIDATOR_APPROVE_BYTECODE_LEN}/1024 bytes ({VALIDATOR_APPROVE_ADDRESS}) | Clear: {VALIDATOR_CLEAR_BYTECODE_LEN}/1024 bytes ({VALIDATOR_CLEAR_ADDRESS})\")\n\n    with open('./build/validator_approval.teal', 'w') as f:\n        f.write(validator_approve_teal_code)\n    with open('./build/validator_clear.teal', 'w') as f:\n        f.write(validator_clear_teal_code)\n\n    print()\n\n    return validator_approve_code, validator_clear_code\n\n\ndef compile_exchange_manager():\n    print(\"Compiling exchange manager application...\")\n\n    manager_approve_teal_code = compileTeal(\n        manager.approval_program(), Mode.Application)\n    compile_response = algod_client.compile(manager_approve_teal_code)\n    manager_approve_code = base64.b64decode(compile_response['result'])\n    MANAGER_APPROVE_BYTECODE_LEN = len(manager_approve_code)\n    MANAGER_APPROVE_ADDRESS = compile_response['hash']\n\n    manager_clear_teal_code = compileTeal(\n        manager.clear_program(), Mode.Application)\n    compile_response = algod_client.compile(manager_clear_teal_code)\n    manager_clear_code = base64.b64decode(compile_response['result'])\n    MANAGER_CLEAR_BYTECODE_LEN = len(manager_clear_code)\n    MANAGER_CLEAR_ADDRESS = compile_response['hash']\n\n    print(\n        f\"Exchange Manager | Approval: {MANAGER_APPROVE_BYTECODE_LEN}/1024 bytes ({MANAGER_APPROVE_ADDRESS}) | Clear: {MANAGER_CLEAR_BYTECODE_LEN}/1024 bytes ({MANAGER_CLEAR_ADDRESS})\")\n\n    with open('./build/manager_approval.teal', 'w') as f:\n        f.write(manager_approve_teal_code)\n    with open('./build/manager_clear.teal', 'w') as f:\n        f.write(manager_clear_teal_code)\n\n    print()\n\n    return manager_approve_code, manager_clear_code\n\n\ndef compile_exchange_escrow():\n    from contracts import escrow\n\n    print(\"Compiling exchange escrow logicsig...\")\n    escrow_logicsig_teal_code = compileTeal(\n        escrow.logicsig(), Mode.Application)\n    compile_response = algod_client.compile(escrow_logicsig_teal_code)\n    escrow_logicsig = compile_response['result']\n    escrow_logicsig_bytes = base64.b64decode(escrow_logicsig)\n    ESCROW_BYTECODE_LEN = len(escrow_logicsig_bytes)\n    ESCROW_ADDRESS = compile_response['hash']\n    print(\n        f\"Exchange Escrow | {ESCROW_BYTECODE_LEN}/1000 bytes ({ESCROW_ADDRESS})\")\n\n    with open('./build/escrow.teal', 'w') as f:\n        f.write(escrow_logicsig_teal_code)\n\n    with open(\"./build/escrow_logicsig\", \"w\") as f:\n        f.write(escrow_logicsig)\n\n    print(f\"Escrow logicsig compiled with address {ESCROW_ADDRESS}\")\n\n    print()\n\n    return escrow_logicsig\n\n\ndef deploy_exchange_validator(validator_approve_code, validator_clear_code):\n    print(\"Deploying exchange validator application...\")\n\n    create_validator_transaction = transaction.ApplicationCreateTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        on_complete=transaction.OnComplete.NoOpOC,\n        approval_program=validator_approve_code,\n        clear_program=validator_clear_code,\n        global_schema=transaction.StateSchema(num_uints=0, num_byte_slices=1),\n        local_schema=None,\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(create_validator_transaction)\n    validator_app_id = wait_for_transaction(tx_id)['created-application-index']\n    print(\n        f\"Exchange Validator deployed with Application ID: {validator_app_id} (Txn ID: https://testnet.algoexplorer.io/tx/{tx_id})\"\n    )\n\n    print()\n\n    return validator_app_id\n\n\ndef deploy_exchange_manager(manager_approve_code, manager_clear_code):\n    print(\"Deploying exchange manager application...\")\n\n    create_manager_transaction = transaction.ApplicationCreateTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        on_complete=transaction.OnComplete.NoOpOC,\n        approval_program=manager_approve_code,\n        clear_program=manager_clear_code,\n        global_schema=transaction.StateSchema(num_uints=0, num_byte_slices=1),\n        local_schema=transaction.StateSchema(num_uints=10, num_byte_slices=0),\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n    tx_id = algod_client.send_transaction(create_manager_transaction)\n    manager_app_id = wait_for_transaction(tx_id)['created-application-index']\n    print(\n        f\"Exchange Manager deployed with Application ID: {manager_app_id} (Txn ID: https://testnet.algoexplorer.io/tx/{tx_id})\"\n    )\n\n    print()\n\n    return manager_app_id\n\n\ndef deploy_token1_token2():\n    print(\n        f\"Deploying tokens {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) and {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME})...\"\n    )\n\n    txn_1 = transaction.AssetConfigTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        total=TOKEN1_AMOUNT,\n        default_frozen=False,\n        unit_name=TOKEN1_UNIT_NAME,\n        asset_name=TOKEN1_ASSET_NAME,\n        manager=DEVELOPER_ACCOUNT_ADDRESS,\n        reserve=DEVELOPER_ACCOUNT_ADDRESS,\n        freeze=DEVELOPER_ACCOUNT_ADDRESS,\n        clawback=DEVELOPER_ACCOUNT_ADDRESS,\n        url=f\"https://algoswap.io/{TOKEN1_UNIT_NAME}\",\n        decimals=TOKEN1_DECIMALS\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    txn_2 = transaction.AssetConfigTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        total=TOKEN2_AMOUNT,\n        default_frozen=False,\n        unit_name=TOKEN2_UNIT_NAME,\n        asset_name=TOKEN2_ASSET_NAME,\n        manager=DEVELOPER_ACCOUNT_ADDRESS,\n        reserve=DEVELOPER_ACCOUNT_ADDRESS,\n        freeze=DEVELOPER_ACCOUNT_ADDRESS,\n        clawback=DEVELOPER_ACCOUNT_ADDRESS,\n        url=f\"https://algoswap.io/{TOKEN2_UNIT_NAME}\",\n        decimals=TOKEN2_DECIMALS\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id_1 = algod_client.send_transaction(txn_1)\n    tx_id_2 = algod_client.send_transaction(txn_2)\n\n    token_1_asset_id = wait_for_transaction(tx_id_1)['created-asset-index']\n    token_2_asset_id = wait_for_transaction(tx_id_2)['created-asset-index']\n\n    print(\n        f\"Deployed {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token_1_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_1}\"\n    )\n    print(\n        f\"Deployed {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token_2_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_2}\"\n    )\n\n    print()\n\n    return token_1_asset_id, token_2_asset_id\n\n\ndef deploy_liquidity_pair_token():\n    print(\n        f\"Deploying token {LIQUIDITY_TOKEN_ASSET_NAME} ({LIQUIDITY_TOKEN_UNIT_NAME})...\"\n    )\n\n    txn = transaction.AssetConfigTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        total=LIQUIDITY_TOKEN_AMOUNT,\n        default_frozen=False,\n        unit_name=LIQUIDITY_TOKEN_UNIT_NAME,\n        asset_name=LIQUIDITY_TOKEN_ASSET_NAME,\n        manager=DEVELOPER_ACCOUNT_ADDRESS,\n        reserve=DEVELOPER_ACCOUNT_ADDRESS,\n        freeze=DEVELOPER_ACCOUNT_ADDRESS,\n        clawback=DEVELOPER_ACCOUNT_ADDRESS,\n        url=f\"https://algoswap.io/{LIQUIDITY_TOKEN_UNIT_NAME}\",\n        decimals=LIQUIDITY_TOKEN_DECIMALS\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    liquidity_token_asset_id = int(\n        wait_for_transaction(tx_id)['created-asset-index'])\n\n    print(\n        f\"Deployed {LIQUIDITY_TOKEN_ASSET_NAME} ({LIQUIDITY_TOKEN_UNIT_NAME}) with Asset ID: {liquidity_token_asset_id} | Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n    return liquidity_token_asset_id\n\n\ndef opt_escrow_into_token(escrow_logicsig, token_idx):\n    print(\n        f\"Opting Escrow into Token with Asset ID: {token_idx}...\"\n    )\n    program = base64.b64decode(escrow_logicsig)\n\n    lsig = transaction.LogicSig(program)\n\n    txn = transaction.AssetTransferTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        receiver=lsig.address(),\n        amt=0,\n        index=token_idx,\n    )\n\n    lsig_txn = transaction.LogicSigTransaction(txn, lsig)\n\n    tx_id = algod_client.send_transaction(lsig_txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted Escrow into Token with Asset ID: {token_idx} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef opt_escrow_into_manager(escrow_logicsig, manager_app_id, liquidity_token_asset_id, token1_asset_id, token2_asset_id):\n    print(\"Opting Escrow into Manager contract...\")\n\n    program = base64.b64decode(escrow_logicsig)\n\n    lsig = transaction.LogicSig(program)\n\n    args = [\n        liquidity_token_asset_id.to_bytes(8, 'big'),\n        token1_asset_id.to_bytes(8, 'big'),\n        token2_asset_id.to_bytes(8, 'big')\n    ]\n\n    txn = transaction.ApplicationOptInTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        index=manager_app_id,\n        app_args=args\n    )\n\n    lsig_txn = transaction.LogicSigTransaction(txn, lsig)\n\n    tx_id = algod_client.send_transaction(lsig_txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted Escrow into Manager contract successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef opt_user_into_contract(app_id):\n    print(\n        f\"Opting user into contract with App ID: {app_id}...\"\n    )\n\n    txn = transaction.ApplicationOptInTxn(\n        sender=TEST_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        index=app_id\n    ).sign(TEST_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted user into contract with App ID: {app_id} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef opt_user_into_token(asset_id):\n    print(\n        f\"Opting user into token with Asset ID: {asset_id}...\"\n    )\n\n    txn = transaction.AssetTransferTxn(\n        sender=TEST_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=TEST_ACCOUNT_ADDRESS,\n        amt=0,\n        index=asset_id\n    ).sign(TEST_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted user into token with Asset ID: {asset_id} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef transfer_liquidity_token_to_escrow(liquidity_token_asset_id, escrow_logicsig):\n    print(\n        f\"Transferring {LIQUIDITY_TOKEN_AMOUNT} liquidity token with Asset ID: {liquidity_token_asset_id} to Escrow...\"\n    )\n\n    program = base64.b64decode(escrow_logicsig)\n\n    lsig = transaction.LogicSig(program)\n\n    txn = transaction.AssetTransferTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=lsig.address(),\n        amt=LIQUIDITY_TOKEN_AMOUNT,\n        index=liquidity_token_asset_id\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id = algod_client.send_transaction(txn)\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Transferred {LIQUIDITY_TOKEN_AMOUNT} liquidity token with Asset ID: {liquidity_token_asset_id} to Escrow successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n\n\ndef transfer_token1_token2_to_user(token1_asset_id, token2_asset_id):\n    print(\n        f\"Transferring {int(TOKEN1_AMOUNT/2)} {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token1_asset_id} and {int(TOKEN2_AMOUNT/2)} {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token2_asset_id} to User...\"\n    )\n\n    txn_1 = transaction.AssetTransferTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=TEST_ACCOUNT_ADDRESS,\n        amt=int(TOKEN1_AMOUNT/2),\n        index=token1_asset_id\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    txn_2 = transaction.AssetTransferTxn(\n        sender=DEVELOPER_ACCOUNT_ADDRESS,\n        sp=algod_client.suggested_params(),\n        receiver=TEST_ACCOUNT_ADDRESS,\n        amt=int(TOKEN2_AMOUNT/2),\n        index=token2_asset_id\n    ).sign(DEVELOPER_ACCOUNT_PRIVATE_KEY)\n\n    tx_id_1 = algod_client.send_transaction(txn_1)\n    tx_id_2 = algod_client.send_transaction(txn_2)\n\n    wait_for_transaction(tx_id_1)\n    wait_for_transaction(tx_id_2)\n\n    print(\n        f\"Transferred {int(TOKEN1_AMOUNT/2)} {TOKEN1_ASSET_NAME} ({TOKEN1_UNIT_NAME}) with Asset ID: {token1_asset_id} to User successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_1}\"\n    )\n\n    print(\n        f\"Transferred {int(TOKEN2_AMOUNT/2)} {TOKEN2_ASSET_NAME} ({TOKEN2_UNIT_NAME}) with Asset ID: {token2_asset_id} to User successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id_2}\"\n    )   \n\n    print()\n\nif __name__ == \"__main__\":\n    print(\"Starting deployment process...\")\n\n    manager_approve_code, manager_clear_code = compile_exchange_manager()\n\n    manager_app_id = deploy_exchange_manager(\n         manager_approve_code, manager_clear_code)\n\n    input(f\"Update Manager Index in Validator = {manager_app_id}\")\n\n    validator_approve_code, validator_clear_code = compile_exchange_validator()\n\n    validator_app_id = deploy_exchange_validator(\n        validator_approve_code, validator_clear_code)\n\n    token1_asset_id, token2_asset_id = deploy_token1_token2()\n\n    liquidity_token_asset_id = deploy_liquidity_pair_token()\n\n    params = algod_client.suggested_params()\n\n    print(\"Please update the Escrow contract with the following:\")\n    input(f\"Manager App ID = {manager_app_id}\")\n    input(f\"Validator App ID = {validator_app_id}\")\n    input(f\"Token 1 Asset ID = {token1_asset_id}\")\n    input(f\"Token 2 Asset ID = {token2_asset_id}\")\n    input(f\"Liquidity Token Asset ID = {liquidity_token_asset_id}\")\n    input(f\"Last Valid Round = {params.last + 100}\")\n\n    escrow_logicsig = compile_exchange_escrow()\n\n    input(\"Please fund the Escrow account with $ALGO to continue\")\n\n    opt_escrow_into_token(escrow_logicsig, token1_asset_id)\n    opt_escrow_into_token(escrow_logicsig, token2_asset_id)\n    opt_escrow_into_token(escrow_logicsig, liquidity_token_asset_id)\n\n    opt_escrow_into_manager(escrow_logicsig, manager_app_id,\n                            liquidity_token_asset_id, token1_asset_id, token2_asset_id)\n\n    opt_user_into_contract(validator_app_id)\n    opt_user_into_contract(manager_app_id)\n\n    opt_user_into_token(token1_asset_id)\n    opt_user_into_token(token2_asset_id)\n    opt_user_into_token(liquidity_token_asset_id)\n\n    transfer_liquidity_token_to_escrow(liquidity_token_asset_id, escrow_logicsig)\n    transfer_token1_token2_to_user(token1_asset_id, token2_asset_id)\n\n    print(\"Deployment completed successfully!\")"}
{"file_path": "https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/setup.py", "code": "https://github.com/runtimeverification/kavm-demo/blob/e1352959fd389ee98f393a3b25062d87bb2aa65f/kcoin_vault/sandbox.py"}
{"file_path": "https://github.com/ChoiceCoin/Voting_DApp/blob/1cd5d81c8c6c96fdb542e399e184abe1512a2045/rewards/rewards.py", "code": "import algosdk\n\nKMD_ADDRESS = \"http://localhost:4002\"\nKMD_TOKEN = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\nKMD_WALLET_NAME = \"unencrypted-default-wallet\"\nKMD_WALLET_PASSWORD = \"\"\n\n\ndef get_accounts():\n    kmd = algosdk.kmd.KMDClient(KMD_TOKEN, KMD_ADDRESS)\n    wallets = kmd.list_wallets()\n\n    walletID = None\n    for wallet in wallets:\n        if wallet[\"name\"] == KMD_WALLET_NAME:\n            walletID = wallet[\"id\"]\n            break\n\n    if walletID is None:\n        raise Exception(\"Wallet not found: {}\".format(KMD_WALLET_NAME))\n\n    walletHandle = kmd.init_wallet_handle(walletID, KMD_WALLET_PASSWORD)\n\n    try:\n        addresses = kmd.list_keys(walletHandle)\n        privateKeys = [kmd.export_key(walletHandle, KMD_WALLET_PASSWORD, addr) for addr in addresses]\n        kmdAccounts = [(addresses[i], privateKeys[i]) for i in range(len(privateKeys))]\n    finally:\n        kmd.release_wallet_handle(walletHandle)\n\n    return kmdAccounts"}
{"file_path": "https://github.com/algorand/indexer/blob/f64303b6b373ac30d57577f056e3dad8e956a009/misc/liveindextest.py", "code": "https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/utils.py"}
{"file_path": "https://github.com/peterkrull/algorand_vanity_farm/blob/16dcbc387892798e1522d3dda39118f990f51ad4/vanity_browse.py", "code": "import base64\nfrom collections import namedtuple\nfrom inspect import get_annotations\nfrom typing import Union\nfrom algosdk import constants\nfrom algosdk.future import transaction\nfrom algosdk.v2client import algod\nfrom smart_asa_asc import SmartASAConfig as PyTealSmartASAConfig\n\n\ndef decode_state(state) -> dict[str, Union[int, bytes]]:\n    return {\n        # We are assuming that global space `key` are printable.\n        # If that's not necessarily true, we can change that.\n        base64.b64decode(s[\"key\"]).decode(): base64.b64decode(s[\"value\"][\"bytes\"])\n        if s[\"value\"][\"type\"] == 1\n        else int(s[\"value\"][\"uint\"])\n        for s in state\n    }\n\n\ndef get_global_state(\n    algod_client: algod.AlgodClient, asc_idx: int\n) -> dict[str, Union[bytes, int]]:\n    global_state = algod_client.application_info(asc_idx)[\"params\"][\"global-state\"]\n    global_state = decode_state(global_state)\n    return global_state\n\n\ndef get_local_state(\n    algod_client: algod.AlgodClient, account_address: str, asc_idx: int\n) -> dict[str, Union[bytes, int]]:\n    local_states = algod_client.account_info(account_address)[\"apps-local-state\"]\n    local_state = [s for s in local_states if s[\"id\"] == asc_idx][0].get(\n        \"key-value\", {}\n    )\n    local_state = decode_state(local_state)\n    return local_state\n\n\ndef get_params(\n    algod_client: algod.AlgodClient, fee: int = None\n) -> transaction.SuggestedParams:\n    params = algod_client.suggested_params()\n    params.flat_fee = True\n    params.fee = fee or constants.MIN_TXN_FEE\n    return params\n\n\ndef get_last_round(algod_client: algod.AlgodClient):\n    return algod_client.status()[\"last-round\"]\n\n\ndef get_last_timestamp(algod_client: algod.AlgodClient):\n    return algod_client.block_info(get_last_round(algod_client))[\"block\"][\"ts\"]\n\n\ndef assemble_program(algod_client: algod.AlgodClient, source_code: str) -> bytes:\n    compile_response = algod_client.compile(source_code)\n    return base64.b64decode(compile_response[\"result\"])\n\n\nSmartASAConfig = namedtuple(\n    PyTealSmartASAConfig.__class__.__name__,\n    list(get_annotations(PyTealSmartASAConfig)),\n)\n\n\ndef normalize_getter_params(getter_params: list) -> SmartASAConfig:\n    return SmartASAConfig(*getter_params)"}
{"file_path": "https://github.com/AustP/arc72/blob/7e67dd5486a1dd98ffc20b9f1063da7cd9869a1a/arc72.py", "code": "https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py"}
{"file_path": "https://github.com/cloud-travelx/workshop-labitconf-22/blob/4d4ddddeaafd6d59947202b7199f6684714d54a9/assets/nfticket/NFTicketManager.py", "code": "#\nimport base64\n\n#\nfrom typing import Optional\nfrom dataclasses import dataclass\n\n#\nfrom algosdk import account, mnemonic, transaction, logic\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import PaymentTxn, SignedTransaction\nfrom algosdk.transaction import ApplicationCreateTxn, ApplicationCallTxn\n\n\n#\n@dataclass\nclass AlgoUser:\n    pk: str\n    address: int\n    mnemonic: float\n\n    def __str__(self):\n        return \"Private Key - {}\\nAddress - {}\\nMnemonic - {}\".format(\n                    self.pk,\n                    self.address,\n                    self.mnemonic\n                )\n\n\n#\nclass Algorand:\n    \"\"\"\n    Algorand object for interacting with algosdk\n    \"\"\"\n\n    # global and local schema parameters\n    GLOBAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)\n    LOCAL_SCHEMA = transaction.StateSchema(num_uints=4, num_byte_slices=4)\n\n    #\n    def __init__(self, algo_token: str, algo_address: str) -> None:\n        \"\"\"\n        Constructor\n\n        :param algo_token: token for connecting algorand testnet\n        :param algo_address: algorand testnet address\n\n        :returns: None\n        \"\"\"\n        self.__token = algo_token\n        self.__address = algo_address\n        self.__headers = {\"X-API-Key\": self.token}\n        self.__client = self.__get_client()\n        self.__params = self.client.suggested_params()\n\n    #\n    def __get_client(self) -> Optional[AlgodClient]:\n        \"\"\"\n        create AlgodClient object from given token and address\n\n        :returns: AlgodClient object\n        \"\"\"\n        return AlgodClient(self.token, self.address, self.headers)\n\n    #\n    @property\n    def headers(self) -> dict:\n        \"\"\"\n        Getter for header private field\n\n        :returns: headers field value\n        \"\"\"\n        return self.__headers\n\n    #\n    @property\n    def token(self) -> str:\n        \"\"\"\n        Getter for token private field\n\n        :returns: token field value\n        \"\"\"\n        return self.__token\n\n    #\n    @property\n    def address(self) -> str:\n        \"\"\"\n        Getter for address private field\n\n        :returns: address field value\n        \"\"\"\n        return self.__address\n\n    #\n    @property\n    def params(self) -> str:\n        \"\"\"\n        Getter for params private field\n\n        :returns: params field value\n        \"\"\"\n        return self.__params\n\n    #\n    @property\n    def client(self) -> Optional[AlgodClient]:\n        \"\"\"\n        Getter for client private field\n\n        :returns: client field value\n        \"\"\"\n        return self.__client\n\n    #\n    def get_balance(self, address: str) -> int:\n        \"\"\"\n        Get balance of given account\n\n        :params address: address of account\n\n        :returns: amount balance\n        \"\"\"\n        return self.client.account_info(address).get(\"amount\")\n\n    #\n    def get_transaction_info(self, tx_id: str):\n        \"\"\"\n        Get transaction information\n\n        :param tx_id: transaction id\n\n        :returns: transaction information\n        \"\"\"\n        return self.client.pending_transaction_info(tx_id)\n\n    #\n    def generate_new_account(self) -> dict:\n        \"\"\"\n        Generate new account for algorand testnet\n\n        :returns: new generated account key, address and mnemonic\n        \"\"\"\n        private_key, address = account.generate_account()\n        mnem = mnemonic.from_private_key(private_key)\n\n        return AlgoUser(private_key, address, mnem)\n\n    #\n    def get_application_id(self, tx_id: str) -> int:\n        \"\"\"\n        Get application id from transaction id\n\n        :param tx_id: transaction id\n\n        :returns: application id\n        \"\"\"\n        transaction_info = self.get_transaction_info(tx_id)\n        app_id = transaction_info.get(\"application-index\")\n        return app_id\n\n    #\n    def get_application_address(self, app_id: int) -> str:\n        \"\"\"\n        Get application address from id\n\n        :param app_id: id of application\n\n        :returns: address of application\n        \"\"\"\n        app_address = logic.get_application_address(app_id)\n        return app_address\n\n    #\n    def build_payment_transaction(\n                self,\n                sender: str,\n                receiver: str,\n                amount: int,\n                note: str\n            ) -> Optional[PaymentTxn]:\n        \"\"\"\n        Build payment transaction from sender to receiver\n\n        :param sender: sender address\n        :param receiver: receiver address\n        ;param amount: amount which should be transferred\n        :param note: note for transaction\n\n        :returns: payment transaction\n        \"\"\"\n        txn = transaction.PaymentTxn(\n            sender=sender,\n            sp=self.params,\n            receiver=receiver,\n            amt=amount,\n            note=note,\n        )\n        return txn\n\n    #\n    def create_application_transaction(\n                self,\n                sender: str,\n                approval_teal: bytes,\n                clear_teal: bytes\n            ) -> Optional[ApplicationCreateTxn]:\n        \"\"\"\n        Create transaction that interacts with the application system\n\n        :param sender: address\n        :param approval_teal: transaction smart contract in bytes\n        :param clear_teal: clear smart contract in bytes\n\n        :returns: application transaction\n        \"\"\"\n        app_create_txn = transaction.ApplicationCreateTxn(\n            sender=sender,\n            sp=self.params,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            approval_program=approval_teal,\n            clear_program=clear_teal,\n            global_schema=self.GLOBAL_SCHEMA,\n            local_schema=self.LOCAL_SCHEMA\n        )\n        return app_create_txn\n\n    #\n    def sign_transaction(\n                self,\n                sender: str,\n                txn: Optional[ApplicationCreateTxn]\n            ) -> Optional[SignedTransaction]:\n        \"\"\"\n        Sign created transaction\n\n        :param sender: sender private key\n        :param txn: transaction which should be signed\n\n        :returns: signed transaction\n        \"\"\"\n        signed_txn = txn.sign(sender)\n        return signed_txn\n\n    #\n    def send_transaction(self, signed_txn: Optional[SignedTransaction]) -> str:\n        \"\"\"\n        Send already signed transaction\n\n        :param signed_txn: signed transaction which should be sent\n\n        :returns: transaction id\n        \"\"\"\n        tx_id = self.client.send_transaction(signed_txn)\n        return tx_id\n\n    #\n    def wait_for_confirmation(self, tx_id: str) -> None:\n        \"\"\"\n        Block until a pending transaction is confirmed by the network\n\n        :param tx_id: transaction id\n\n        :returns None\n        \"\"\"\n        return transaction.wait_for_confirmation(self.client, tx_id, 4)\n\n    #\n    def call_application_transaction(\n                self,\n                sender: str,\n                app_id: int,\n                app_args: list,\n                receiver: str=None,\n                asset: int=None\n            ) -> Optional[ApplicationCallTxn]:\n        \"\"\"\n        Create Application call transaction object\n\n        :param sender: sender address\n        :param app_id: application id for which transaction is made\n        :param app_args: arguments for application smart contract\n        :param receiver: receiver address\n\n        :returns: ApplicationCallTxn objects\n        \"\"\"\n\n        accounts = []\n        if receiver:\n            accounts.append(receiver)\n\n        assets = []\n        if asset:\n            assets.append(asset)\n        \n        app_call_txn = transaction.ApplicationCallTxn(\n            sender=sender,\n            sp=self.params,\n            index=app_id,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            app_args=app_args,\n            accounts=accounts,\n            foreign_assets=assets\n        )\n        return app_call_txn\n\n    #\n    def call_application_transaction_foreign_asset(\n                self,\n                sender: str,\n                app_id: int,\n                app_args: list,\n                asset_id: str=None\n            ) -> Optional[ApplicationCallTxn]:\n        \"\"\"\n        Create Application call transaction object\n\n        :param sender: sender address\n        :param app_id: application id for which transaction is made\n        :param app_args: arguments for application smart contract\n        :param receiver: receiver address\n\n        :returns: ApplicationCallTxn objects\n        \"\"\"\n\n        app_call_txn = transaction.ApplicationCallTxn(\n            sender=sender.address,\n            sp=self.params,\n            index=app_id,\n            on_complete=transaction.OnComplete.NoOpOC.real,\n            app_args=app_args,\n            foreign_assets=[asset_id]\n        )\n        return app_call_txn\n    #\n    def create_application_no_op_transaction(self, sender, app_id, app_args, receiver=None):\n        accounts = []\n        if receiver:\n            accounts.append(receiver.address)\n        \n        txn = transaction.ApplicationNoOpTxn(\n                sender=sender.address,\n                sp=self.params,\n                index=app_id,\n                app_args=app_args,\n                accounts=accounts\n        )\n\n        return txn\n\n    #\n    def create_asset(self, creator):\n        txn = transaction.AssetConfigTxn(\n                sender=creator.address,\n                sp=self.params,\n                total=1000000,\n                default_frozen=False,\n                unit_name=\"LSCOIN\",\n                asset_name=\"LS Coin\",\n                manager=creator.address,\n                reserve=creator.address,\n                freeze=creator.address,\n                clawback=creator.address,\n                decimals=0\n        )\n        signed_txn = self.sign_transaction(creator.pk, txn)\n        tx_id = self.send_transaction(signed_txn)\n        self.wait_for_confirmation(tx_id)\n        response = self.client.pending_transaction_info(tx_id)\n        return response['asset-index']\n\n    #\n    def opt_in_to_asset(self, sender, asset_id):\n        txn = transaction.AssetTransferTxn(\n                sender=sender.address,\n                sp=self.params,\n                receiver=sender.address,\n                amt=0,\n                index=asset_id\n            )\n        signed_txn = self.sign_transaction(sender.pk, txn)\n        tx_id = self.send_transaction(signed_txn)\n        self.wait_for_confirmation(tx_id)\n\n\n    \n    #\n    def get_application_global_state(self, app_id: int) -> dict:\n        \"\"\"\n        Get application global state info\n\n        :param app_id: application id\n\n        :returns: info about application global state\n        \"\"\"\n        app_info = self.client.application_info(app_id)\n        global_state = app_info['params']['global-state']\n        state = {}\n        for item in global_state:\n            key = base64.b64decode(item['key']).decode('utf-8')\n            value = item['value']\n            state[key] = value\n        return state"}
{"file_path": "https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/dao.py", "code": "https://github.com/khoilr/blockchain-consensus/blob/57eeab4287a05b511b370e2e7258b96687f1f6e8/Algorand.py"}
{"file_path": "https://github.com/Sam2much96/algorand_python_Scripts/blob/8c9356be983ffb4b3d0f3221d33eaf4a7d118b6a/contracts/escrow/Box_storage_escrow_3.py", "code": "import hashlib\nimport math\nimport time\nimport random\nfrom typing import List\n\nfrom ecdsa import SECP256k1, SigningKey, VerifyingKey\n\nfrom transaction import Transaction\n\n\nclass Block:\n    def __init__(\n        self,\n        txns: List[Transaction],\n        previous_hash: str,\n        vrf_proof,\n        verify_key: VerifyingKey,\n    ):\n        self.txns = txns\n        self.previous_hash = previous_hash\n        self.timestamp = int(time.time())\n        self.vrf_proof = vrf_proof\n        self.verify_key = verify_key\n        self.hash = self.calculate_hash()\n\n    def calculate_hash(self) -> str:\n        block_data = f\"{self.txns}{self.previous_hash}{self.timestamp}{self.vrf_proof}{self.verify_key}\"\n        return hashlib.sha256(block_data.encode()).hexdigest()\n\n    def is_valid(self, previous_hash: str):\n        return (\n            self.hash == self.calculate_hash() and self.previous_hash == previous_hash\n        )\n\n    def __repr__(self):\n        return f\"Block (timestamp={self.timestamp}, hash={self.hash[:8]}, previous_hash={self.previous_hash[:8]}, num_txns={len(self.txns)})\"\n\n\nclass Blockchain:\n    def __init__(self):\n        self.chain: List[Block] = []\n\n        self.create_genesis_block()\n\n    def create_genesis_block(self) -> None:\n        genesis_block = Block([], \"0\", \"0\", \"0\")\n        self.chain.append(genesis_block)\n\n    def add_block(self, block: Block) -> None:\n        if block.is_valid(self.get_last_block().hash):\n            self.chain.append(block)\n\n    def get_last_block(self) -> Block:\n        return self.chain[-1]\n\n    def get_new_block_index(self) -> int:\n        return len(self.chain)\n\n    def is_valid(self) -> bool:\n        return all(\n            self.chain[i].is_valid(\n                target=self.target_from_difficulty(),\n                previous_hash=self.chain[i - 1].hash,\n            )\n            for i in range(1, len(self.chain))\n        )\n\n\nclass Account:\n    def __init__(self, stake):\n        self.signing_key = SigningKey.generate(curve=SECP256k1)\n        self.verify_key = self.signing_key.verifying_key\n        self.stake = stake\n        self.total_rewards = 0\n\n    def generate_key_pair(self):\n        return self.signing_key.to_string().hex(), self.verify_key.to_string().hex()\n\n    def prove(self, message):\n        # Hash the message\n        message_hash = hashlib.sha256(message).digest()\n\n        # Sign the hash\n        signature = self.signing_key.sign(message_hash)\n\n        return signature.hex(), self.verify_key\n\n    def verify(self, message: bytes, signature, verify_key):\n        verify_key = VerifyingKey.from_string(\n            bytes.fromhex(verify_key.to_string().hex()), curve=SECP256k1\n        )\n        message_hash = hashlib.sha256(message).digest()\n        try:\n            return verify_key.verify(bytes.fromhex(signature), message_hash)\n        except Exception:\n            return False\n\n    def __repr__(self):\n        return f\"Account(verify_key={self.verify_key.to_string().hex()})\"\n\n\nclass Algorand(Blockchain):\n    def __init__(\n        self,\n        accounts: List[Account],\n        initial_supply: float,\n        inflation_rate: float,\n    ):\n        super().__init__()\n\n        self.accounts = accounts\n        self.total_supply = initial_supply\n        self.inflation_rate = inflation_rate\n        self.current_round = 0\n        self.base_reward = (self.total_supply * self.inflation_rate) / (\n            365 * 24 * 60\n        )  # Per minute\n\n        # Calculate thresholds after committee and proposers sizes are defined\n        self.proposer_threshold = 20 / len(accounts)\n        self.committee_threshold = self.committee_size / len(accounts)\n\n    @property\n    def total_stake(self):\n        return sum(account.stake for account in self.accounts)\n\n    @property\n    def committee_size(self):\n        return max(math.isqrt(len(self.accounts)), 100)\n\n    @property\n    def proposers_size(self):\n        return max(math.isqrt(len(self.accounts)), 10)\n\n    def select_accounts(\n        self,\n        seed: bytes,\n        threshold: float,\n        is_select_proposers: bool,\n    ) -> List[Account]:\n        weights = [account.stake for account in self.accounts]\n        total_weight = sum(weights)\n\n        # Normalize weights\n        normalized_weights = [w / total_weight for w in weights]\n\n        # Use VRF to determine eligibility\n        eligible_accounts = []\n        for account, weight in zip(self.accounts, normalized_weights):\n            signature, verify_key = account.prove(seed)\n            vrf_output = int(signature, 16)\n            if vrf_output / (2**256) < weight * threshold:\n                eligible_accounts.append(account)\n\n        # If not enough eligible accounts, add more based on stake weight\n        size = self.proposers_size if is_select_proposers else self.committee_size\n        if len(eligible_accounts) < size:\n            additional_accounts = random.choices(\n                self.accounts,\n                weights=weights,\n                k=size - len(eligible_accounts),\n            )\n            eligible_accounts.extend(additional_accounts)\n\n        # If more than needed, randomly select the required number\n        if len(eligible_accounts) > size:\n            eligible_accounts = random.sample(eligible_accounts, size)\n\n        return eligible_accounts\n\n    def propose_block(\n        self,\n        proposer: Account,\n        txns: List[Transaction],\n    ) -> Block:\n        previous_hash = self.get_last_block().hash\n        vrf_proof, verify_key = proposer.prove(previous_hash.encode())\n        return Block(txns, previous_hash, vrf_proof, verify_key)\n\n    def validate_block(\n        self, block: Block, proposer: Account, previous_block: Block\n    ) -> bool:\n        if block.previous_hash != previous_block.hash:\n            return False\n        if not proposer.verify(\n            block.previous_hash.encode(),\n            block.vrf_proof,\n            block.verify_key,\n        ):\n            return False\n\n        return True\n\n    def byzantine_agreement(\n        self,\n        proposed_blocks: List[Block],\n        committee: List[Account],\n    ) -> Block:\n        if not proposed_blocks:\n            return None\n\n        total_stake = sum(member.stake for member in committee)\n        threshold = total_stake * 2 / 3\n\n        # Step 1: Soft Vote\n        votes = {block.hash: 0 for block in proposed_blocks}\n\n        for member in committee:\n            chosen_block = max(\n                proposed_blocks,\n                key=lambda b: hash(b.hash + str(member.stake)),\n            )\n            votes[chosen_block.hash] += member.stake\n\n        winner = max(votes, key=votes.get)\n        winner_stake = 0\n\n        for member in committee:\n            propose = random.choices([True, False], weights=[0.8, 0.2], k=1)[0]\n            if propose:\n                winner_stake += member.stake\n\n        if winner_stake > threshold:\n            return next(block for block in proposed_blocks if block.hash == winner)\n\n        return None\n\n    def distribute_rewards(self, block: Block, committee: List[Account]):\n        total_reward = self.base_reward\n        proposer_reward = total_reward * 0.8  # 80% to proposer\n        committee_reward = total_reward * 0.2  # 20% split among committee\n\n        proposer = next(\n            account\n            for account in self.accounts\n            if account.verify_key == block.verify_key\n        )\n        proposer.stake += proposer_reward\n        proposer.total_rewards += proposer_reward\n\n        for member in committee:\n            reward = committee_reward / len(committee)\n            member.stake += reward\n            member.total_rewards += reward\n\n        self.total_supply += total_reward\n\n    def mine_block(self, transactions: List[Transaction]) -> Block:\n        seed = hashlib.sha256(\n            f\"{self.get_last_block().hash}{self.current_round}\".encode()\n        ).digest()\n\n        proposers = self.select_accounts(\n            seed + b\"proposer\", self.proposer_threshold, True\n        )\n        committee = self.select_accounts(\n            seed + b\"committee\", self.committee_threshold, False\n        )\n\n        proposed_blocks = []\n        for proposer in proposers:\n            block = self.propose_block(proposer, transactions)\n            if self.validate_block(block, proposer, self.get_last_block()):\n                proposed_blocks.append(block)\n\n        self.current_round += 1\n\n        winner = self.byzantine_agreement(proposed_blocks, committee)\n\n        if winner:\n            self.add_block(winner)\n            self.distribute_rewards(winner, committee)\n            return winner\n\n        return None\n\n    def simulate_51_percent_attack(self, attacker: Account):\n        print(\"Simulating 51% attack...\")\n        attacker_stake = attacker.stake\n        honest_stake = self.total_stake - attacker_stake\n\n        if attacker_stake > honest_stake:\n            print(\n                f\"Attacker has {attacker_stake / self.total_stake:.2%} of the total stake.\"\n            )\n\n            proposer_successes = 0\n            committee_controls = 0\n            rounds = 1000\n\n            for _ in range(rounds):\n                seed = hashlib.sha256(str(random.random()).encode()).digest()\n                proposers = self.select_accounts(\n                    seed + b\"proposer\",\n                    self.proposer_threshold,\n                    True,\n                )\n                committee = self.select_accounts(\n                    seed + b\"committee\",\n                    self.committee_threshold,\n                    False,\n                )\n\n                if attacker in proposers:\n                    proposer_successes += 1\n\n                attacker_committee_stake = sum(\n                    member.stake for member in committee if member == attacker\n                )\n                if (\n                    attacker_committee_stake\n                    > sum(member.stake for member in committee) * 2 / 3\n                ):\n                    committee_controls += 1\n\n            print(f\"Probability of being a proposer: {proposer_successes / rounds:.2%}\")\n            print(\n                f\"Probability of controlling committee: {committee_controls / rounds:.2%}\"\n            )\n            print(\n                \"Even with majority stake, the attacker cannot consistently control the protocol.\"\n            )\n        else:\n            print(\"Attacker doesn't have enough stake for a 51% attack.\")\n\n        return False\n\n    def simulate_nothing_at_stake(self, attacker: Account):\n        print(\"Simulating Nothing-at-Stake attack...\")\n\n        seed = hashlib.sha256(str(random.random()).encode()).digest()\n        proposers = self.select_accounts(\n            seed + b\"proposer\",\n            self.proposer_threshold,\n            True,\n        )\n        committee = self.select_accounts(\n            seed + b\"committee\",\n            self.committee_threshold,\n            False,\n        )\n\n        if attacker in proposers:\n            block1 = self.propose_block(attacker, [Transaction(\"main\", \"chain\", 1)])\n            block2 = self.propose_block(attacker, [Transaction(\"fork\", \"chain\", 1)])\n\n            winner = self.byzantine_agreement([block1, block2], committee)\n\n            print(\"In Algorand:\")\n            print(\n                \"1. Only one block can be finalized per round through Byzantine agreement.\"\n            )\n            print(\"2. Proposing multiple blocks doesn't increase chances of reward.\")\n            print(\n                f\"3. Result: {'Two blocks proposed, but only one finalized' if winner else 'No block finalized due to conflicting proposals'}\"\n            )\n        else:\n            print(\"Attacker was not selected as a proposer in this round.\")\n\n        return False\n\n    def simulate_long_range_attack(self, attacker: Account):\n        print(\"Simulating Long-Range attack...\")\n        fork_point = max(0, len(self.chain) - 100)  # Try to fork from 1000 blocks ago\n        honest_chain = self.chain[:]\n        attacker_chain = self.chain[:fork_point]\n\n        if not attacker_chain:\n            print(\"Not enough blocks in the chain to perform a long-range attack.\")\n            return False\n\n        for i in range(fork_point, len(honest_chain)):\n            seed = hashlib.sha256(f\"{attacker_chain[-1].hash}{i}\".encode()).digest()\n            proposers = self.select_accounts(\n                seed + b\"proposer\",\n                self.proposer_threshold,\n                True,\n            )\n            committee = self.select_accounts(\n                seed + b\"committee\",\n                self.committee_threshold,\n                False,\n            )\n\n            if attacker in proposers:\n                fake_block = self.propose_block(\n                    attacker, [Transaction(\"fake\", \"transaction\", 1)]\n                )\n                if self.byzantine_agreement([fake_block], committee):\n                    attacker_chain.append(fake_block)\n                else:\n                    print(f\"Failed to reach consensus on attacker's block at round {i}\")\n                    break\n            else:\n                print(f\"Attacker not selected as proposer for round {i}\")\n                break\n\n        if len(attacker_chain) > len(honest_chain):\n            print(\"In a longest-chain protocol, this attack might succeed.\")\n\n        print(\"In Algorand:\")\n        print(\n            \"1. Blocks are final after Byzantine agreement, preventing reorganization.\"\n        )\n        print(\"2. Attacker can't reconstruct historical committees or proposers.\")\n        print(\"3. State proofs provide additional security against long-range attacks.\")\n\n        return False\n\n    def simulate_sybil_attack(self, attacker: Account):\n        print(\"Simulating Sybil attack...\")\n        original_stake = attacker.stake\n        sybil_accounts = [Account(original_stake / 10) for _ in range(10)]\n\n        def measure_influence(accounts):\n            proposer_selections = 0\n            committee_selections = 0\n            rounds = 1000\n\n            for _ in range(rounds):\n                seed = hashlib.sha256(str(random.random()).encode()).digest()\n                proposers = self.select_accounts(\n                    seed + b\"proposer\",\n                    self.proposer_threshold,\n                    True,\n                )\n                committee = self.select_accounts(\n                    seed + b\"committee\",\n                    self.committee_threshold,\n                    False,\n                )\n\n                proposer_selections += sum(1 for acc in accounts if acc in proposers)\n                committee_selections += sum(1 for acc in accounts if acc in committee)\n\n            return proposer_selections / rounds, committee_selections / rounds\n\n        original_proposer_influence, original_committee_influence = measure_influence(\n            [attacker]\n        )\n        sybil_proposer_influence, sybil_committee_influence = measure_influence(\n            sybil_accounts\n        )\n\n        print(f\"Original proposer influence: {original_proposer_influence:.2%}\")\n        print(f\"Sybil proposer influence: {sybil_proposer_influence:.2%}\")\n        print(f\"Original committee influence: {original_committee_influence:.2%}\")\n        print(f\"Sybil committee influence: {sybil_committee_influence:.2%}\")\n        print(\"In Algorand:\")\n        print(\"1. Influence is directly proportional to stake, not number of accounts.\")\n        print(\n            \"2. Splitting stake across multiple accounts doesn't increase overall influence.\"\n        )\n\n        return False\n\n    def simulate_attacks(self):\n        attacker = max(self.accounts, key=lambda a: a.stake)\n        attacks = [\n            self.simulate_51_percent_attack,\n            self.simulate_nothing_at_stake,\n            self.simulate_long_range_attack,\n            self.simulate_sybil_attack,\n        ]\n        attack = random.choice(attacks)\n        attack(attacker)\n        print()\n\n    def validate_chain(self) -> bool:\n        # Start from the second block (index 1) since the genesis block has no previous hash\n        for i in range(1, len(self.chain)):\n            current_block = self.chain[i]\n            previous_block = self.chain[i - 1]\n\n            # Check if the current block's previous hash matches the hash of the previous block\n            if current_block.previous_hash != previous_block.hash:\n                print(f\"Invalid previous hash in block {i}\")\n                return False\n\n            # Validate the block's integrity\n            proposer = next(\n                (\n                    account\n                    for account in self.accounts\n                    if account.verify_key == current_block.verify_key\n                ),\n                None,\n            )\n            if not proposer:\n                print(f\"Proposer not found for block {i}\")\n                return False\n\n            if not self.validate_block(current_block, proposer, previous_block):\n                print(f\"Block {i} failed validation\")\n                return False\n\n        print(\"Blockchain is valid\")\n        return True\n\n\ndef main():\n    accounts = [Account(random.uniform(100, 10000)) for _ in range(100)]\n    algorand = Algorand(accounts, initial_supply=1000000, inflation_rate=0.05)\n\n    # Mine 100 blocks\n    for i in range(100):\n        transactions = [\n            Transaction(\n                f\"account_{i}\",\n                f\"account_{(i+1)%100}\",\n                random.uniform(1, 100),\n                random.uniform(1, 100),\n            )\n            for i in range(5)\n        ]\n        block = algorand.mine_block(transactions)\n        # print(block)\n        # if i % 10 == 0:\n        #     algorand.simulate_attacks()\n\n    algorand.validate_chain()\n    print(algorand)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"file_path": "https://github.com/Sotatek-NguyenNguyen/gs-sc-algo/blob/04452faf44e9472fd718b9a50c13a5c4b83a564a/contract/nftContracts.py", "code": "https://github.com/zalkikar/AlgoRand_Covid/blob/fe6a060440ec515bfdee2caf35286312d55d833a/py_algorand.py"}
{"file_path": "https://github.com/CupStakes/cupstakes-smart-contracts/blob/2155155985eb525f111458e0c237b0aaed642c39/draw/sc.py", "code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport algosdk\nimport math\nimport time\n\nclass Algorand_IReportScrape():\n    \n    def __init__(self, api_key):\n        self.purestake_api_key = api_key\n        self.connectMainnet()\n        self.client_check()\n        \n        # For retrieving the real covid data from mainnet\n        self.address = \"COVIDR5MYE757XMDCFOCS5BXFF4SKD5RTOF4RTA67F47YTJSBR5U7TKBNU\"\n        self.fromRound = 5646000\n        self.maxTxnPerCall = 500 # max transactions in a batch\n        self.batchSize = 512 #Read the transactions from the blockchain in 512-block installations\n        self.params = self.algod_client.suggested_params()\n        self.lastRound = self.params['lastRound']\n        #self.lastRound = self.fromRound + 20*self.batchSize # for testing\n        \n        print(\"\\n total rounds:\",self.lastRound - self.fromRound)\n        \n        self.txns = []\n        self.batch_limit = math.ceil((self.lastRound - self.fromRound)/self.maxTxnPerCall)\n        \n        tot_rounds_div = math.floor((self.lastRound - self.fromRound)/self.batchSize)\n        marker_dict = dict(zip([math.floor(tot_rounds_div*(per/10))*self.batchSize + self.fromRound for per in list(range(1,10))],\n                               [per/10 for per in list(range(1,10))]))\n        \n        rnd = self.fromRound\n        while rnd < self.lastRound:\n            toRnd = rnd + self.batchSize\n            if toRnd in marker_dict.keys():\n                print(\"{}% complete\".format(marker_dict[toRnd]*100))\n            if toRnd > self.lastRound:\n                toRnd = self.lastRound\n            self.txns.extend(self.getTransactionBatch(rnd,toRnd)) # Fetch transactions for these rounds \n            rnd += self.batchSize\n            time.sleep(0.1)\n\n        print(\"found {} transactions\".format(len(self.txns)))\n                             \n    def connectMainnet(self):\n        algod_address_mainnet = \"https://mainnet-algorand.api.purestake.io/ps1\"\n        port = \"\"\n        token = {\n            'X-API-key' : self.purestake_api_key,\n        }\n        # Initialize the algod client\n        self.algod_client = algosdk.algod.AlgodClient(port, algod_address_mainnet, token) \n    \n    def client_check(self):\n        try:\n            status = self.algod_client.status()\n        except Exception as e:\n            print(\"Failed to get algod status: {}\".format(e))\n\n        if status:\n            print(\"algod last round: {}\".format(status.get(\"lastRound\")))\n            print(\"algod time since last round: {}\".format(status.get(\"timeSinceLastRound\")))\n            print(\"algod catchup: {}\".format(status.get(\"catchupTime\")))\n            print(\"algod latest version: {}\".format(status.get(\"lastConsensusVersion\")))\n\n        # Retrieve latest block information                                                                                                                                               \n        last_round = self.algod_client.status().get(\"lastRound\")\n        print(\"####################\")\n        block = self.algod_client.block_info(last_round)\n        print(block)\n                             \n    def getTransactionBatch(self,fromRnd,lastRnd):\n        if (fromRnd > lastRnd):# sanity check\n            return []\n        txs = self.algod_client.transactions_by_address(self.address,fromRnd,lastRnd,self.maxTxnPerCall) \n        # make an API call to get the transactions - 500 at a time\n\n        #  A recursive function for getting a batch of transactions, to overcome\n        # the limitation of maxTxnPerCall transaction per call to the API\n        # If we got all the transactions, just return them\n        if ((fromRnd == lastRnd) | (len(txs['transactions']) < self.maxTxnPerCall)):\n            return txs['transactions']\n\n            # FIXME: If a single block contains more than maxTxnPerCall\n            # transactions for the target address, the code above will return\n            # only maxTxnPerCall of them.\n            # This is an unlikely case, and not easy to handle. The only way to\n            # handle it is to call algod.block(round#), then go over all the\n            # transactions in this block and take only the ones corresponding\n            # to the target address.\n\n        else: # recursive call to get them in two smaller chunks\n            midRnd = math.floor((fromRnd+toRnd) / 2)\n            txns1 = getTransactionBatch(fromRnd, midRnd)\n            txns2 = getTransactionBatch(midRnd+1, toRnd)\n            # return the concatenation of the two chunks\n            return txns1.concat(txns2)\n                             \n    def get_txns(self):\n        return self.txns"}
{"file_path": "https://github.com/summitbajaj/AlDonate/blob/1a0fd9ad0b0a036508c40a10d2432f0213f17f61/donate.py", "code": "https://github.com/gitcoinco/web/blob/7c66485f75dbe5ca072892862ff6c9754baf889a/app/grants/utils.py"}
{"file_path": "https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/mint_nfts.py", "code": "# -*- coding: utf-8 -*-\n\"\"\"Define the Grant utilities.\n\nCopyright (C) 2021 Gitcoin Core\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published\nby the Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nimport json\nimport logging\nimport math\nimport os\nimport re\nimport urllib.request\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom random import randint, seed\nfrom secrets import token_hex\n\nfrom django.utils import timezone\n\nimport numpy as np\nimport pandas as pd\nfrom app.settings import BASE_URL, MEDIA_URL, NOTION_API_KEY, NOTION_SYBIL_DB\nfrom app.utils import notion_write\nfrom avatar.utils import convert_img\nfrom economy.utils import ConversionRateNotFoundError, convert_amount\nfrom gas.utils import eth_usd_conv_rate\nfrom grants.sync.algorand import sync_algorand_payout\nfrom grants.sync.binance import sync_binance_payout\nfrom grants.sync.celo import sync_celo_payout\nfrom grants.sync.cosmos import sync_cosmos_payout\nfrom grants.sync.harmony import sync_harmony_payout\nfrom grants.sync.polkadot import sync_polkadot_payout\nfrom grants.sync.rsk import sync_rsk_payout\nfrom grants.sync.zcash import sync_zcash_payout\nfrom grants.sync.zil import sync_zil_payout\nfrom perftools.models import StaticJsonEnv\nfrom PIL import Image, ImageDraw, ImageOps\nfrom townsquare.models import SquelchProfile\n\nlogger = logging.getLogger(__name__)\n\nblock_codes = ('\u2596', '\u2597', '\u2598', '\u2599', '\u259a', '\u259b', '\u259c', '\u259d', '\u259e', '\u259f')\nemoji_codes = ('\ud83c\udf89', '\ud83c\udf88', '\ud83c\udf81', '\ud83c\udf8a', '\ud83d\ude4c', '\ud83e\udd42', '\ud83c\udf86', '\ud83d\udd25', '\u26a1', '\ud83d\udc4d')\n\n\ntenant_payout_mapper = {\n    'ZCASH': sync_zcash_payout,\n    'CELO': sync_celo_payout,\n    'ZIL': sync_zil_payout,\n    'HARMONY': sync_harmony_payout,\n    'POLKADOT': sync_polkadot_payout,\n    'BINANCE': sync_binance_payout,\n    'KUSAMA': sync_polkadot_payout,\n    'RSK': sync_rsk_payout,\n    'ALGORAND': sync_algorand_payout,\n    'COSMOS': sync_cosmos_payout\n}\n\ndef get_clr_rounds_metadata():\n    '''\n        Fetches default CLR round metadata for stats/marketing flows.\n        This is configured when multiple rounds are running\n    '''\n    try:\n        CLR_ROUND_DATA = StaticJsonEnv.objects.get(key='CLR_ROUND').data\n\n        clr_round = CLR_ROUND_DATA['round_num']\n        start_date = CLR_ROUND_DATA['round_start']\n        end_date = CLR_ROUND_DATA['round_end']\n        show_round_banner = json.loads(CLR_ROUND_DATA['show_round_banner'])\n        claim_start_date = CLR_ROUND_DATA.get('claim_start_date')\n        claim_end_date = CLR_ROUND_DATA.get('claim_end_date')\n        banner_round_name = CLR_ROUND_DATA.get('banner_round_name')\n\n        # timezones are in UTC (format example: 2021-06-16:15.00.00)\n        round_start_date = datetime.strptime(start_date, '%Y-%m-%d:%H.%M.%S')\n        round_end_date = datetime.strptime(end_date, '%Y-%m-%d:%H.%M.%S')\n\n        now = datetime.now()\n\n        if claim_start_date and claim_end_date:\n            claim_start_date = datetime.strptime(claim_start_date, '%Y-%m-%d:%H.%M.%S')\n            claim_end_date = datetime.strptime(claim_end_date, '%Y-%m-%d:%H.%M.%S')\n\n        if round_start_date > now:\n            round_status = 'upcoming'\n        elif round_start_date <= now <= round_end_date:\n            round_status = 'active'\n        elif claim_start_date and claim_end_date and claim_start_date <= now <= claim_end_date:\n            round_status = 'claim'\n        else:\n            round_status = 'done'\n\n    except:\n        # setting defaults\n        clr_round=1\n        round_start_date = timezone.now()\n        round_end_date = timezone.now() + timezone.timedelta(days=14)\n        show_round_banner = False\n        claim_start_date = None\n        claim_end_date = None\n        round_status = 'done'\n        banner_round_name = ''\n\n    return {\n        'clr_round': clr_round,\n        'round_start_date': round_start_date,\n        'round_end_date': round_end_date,\n        'show_round_banner': show_round_banner,\n        'claim_start_date': claim_start_date,\n        'claim_end_date': claim_end_date,\n        'round_status': round_status,\n        'banner_round_name': banner_round_name\n    }\n\n\ndef get_upload_filename(instance, filename):\n    salt = token_hex(16)\n    file_path = os.path.basename(filename)\n    return f\"grants/{getattr(instance, '_path', '')}/{salt}/{file_path}\"\n\n\ndef is_grant_team_member(grant, profile):\n    \"\"\"Checks to see if profile is a grant team member\n\n    Args:\n        grant (grants.models.Grant): The grant in question.\n        profile (dashboard.models.Profile): The current user's profile.\n\n    \"\"\"\n    if not profile:\n        return False\n    is_team_member = False\n    if grant.admin_profile == profile:\n        is_team_member = True\n    else:\n        for team_member in grant.team_members.all():\n            if team_member.id == profile.id:\n                is_team_member = True\n                break\n    return is_team_member\n\n\ndef amount_in_wei(tokenAddress, amount):\n    from dashboard.tokens import addr_to_token\n    token = addr_to_token(tokenAddress)\n    decimals = token['decimals'] if token else 18\n    return float(amount) * 10**decimals\n\n\ndef get_converted_amount(amount, token_symbol):\n    try:\n        if token_symbol == \"ETH\" or token_symbol == \"WETH\":\n            return Decimal(float(amount) * float(eth_usd_conv_rate()))\n        else:\n            value_token_to_eth = Decimal(convert_amount(\n                amount,\n                token_symbol,\n                \"ETH\")\n            )\n\n        value_eth_to_usdt = Decimal(eth_usd_conv_rate())\n        value_usdt = value_token_to_eth * value_eth_to_usdt\n        return value_usdt\n\n    except ConversionRateNotFoundError as e:\n        try:\n            return Decimal(convert_amount(\n                amount,\n                token_symbol,\n                \"USDT\"))\n        except ConversionRateNotFoundError as no_conversion_e:\n            logger.info(no_conversion_e)\n            return None\n\n\ndef get_user_code(user_id, grant, coding_set=block_codes, length=6):\n    seed(user_id ** grant.id)\n    coding_id = [coding_set[randint(0, 9)] for _ in range(length)]\n\n    return ''.join(coding_id)\n\n\ndef generate_collection_thumbnail(collection, width, heigth):\n    grants = collection.grants.all()\n    profile = collection.profile\n    return generate_img_thumbnail_helper(grants, profile, width, heigth)\n\n\ndef generate_img_thumbnail_helper(grants, profile, width, heigth):\n    MARGIN = int(width / 30)\n    MID_MARGIN = int(width / 90)\n    BG = (111, 63, 245)\n    DISPLAY_GRANTS_LIMIT = 4\n    PROFILE_WIDTH = PROFILE_HEIGHT = int(width / 3.5)\n    GRANT_WIDTH = int(width / 2) - MARGIN - MID_MARGIN\n    GRANT_HEIGHT = int(heigth / 2) - MARGIN - MID_MARGIN\n    IMAGE_BOX = (width, heigth)\n    LOGO_SIZE_DIFF = int(GRANT_WIDTH / 5)\n    HALF_LOGO_SIZE_DIFF = int(LOGO_SIZE_DIFF / 2)\n    PROFILE_BOX = (PROFILE_WIDTH - LOGO_SIZE_DIFF, PROFILE_HEIGHT - LOGO_SIZE_DIFF)\n    GRANT_BOX = (GRANT_WIDTH, GRANT_HEIGHT)\n    media_url = '' if 'media' not in MEDIA_URL else BASE_URL[:-1]\n\n    logos = []\n    for grant in grants:\n        if grant.logo:\n            if len(logos) > DISPLAY_GRANTS_LIMIT:\n                break\n            grant_url = f'{media_url}{grant.logo.url}'\n            print(f'Trying to get: ${grant_url}')\n            fd = urllib.request.urlopen(grant_url)\n            logos.append(fd)\n        else:\n            static_file = f'assets/v2/images/grants/logos/{grant.id % 3}.png'\n            logos.append(static_file)\n\n    for logo in range(len(logos), 4):\n        logos.append(None)\n\n    thumbail = Image.new('RGBA', IMAGE_BOX, color=BG)\n    avatar_url = f'{media_url}{profile.avatar_url}'\n    fd = urllib.request.urlopen(avatar_url)\n\n    # Make rounder profile avatar img\n    mask = Image.new('L', PROFILE_BOX, 0)\n    draw = ImageDraw.Draw(mask)\n    draw.ellipse((0, 0) + PROFILE_BOX, fill=255)\n    profile_thumbnail = Image.open(fd)\n\n    profile_thumbnail.thumbnail(PROFILE_BOX, Image.ANTIALIAS)\n    profile_circle = ImageOps.fit(profile_thumbnail, mask.size, centering=(0.5, 0.5))\n\n    try:\n        applied_mask = profile_circle.copy()\n        applied_mask.putalpha(mask)\n        profile_circle.paste(applied_mask, (0, 0), profile_circle)\n    except ValueError:\n        profile_circle.putalpha(mask)\n\n\n    CORNERS = [\n        [MARGIN, MARGIN],  # Top left grant\n        [width - GRANT_WIDTH - MARGIN, MARGIN],  # Top right grant\n        [MARGIN, heigth - GRANT_HEIGHT - MARGIN],  # bottom left grant\n        [width - GRANT_WIDTH - MARGIN, heigth - GRANT_HEIGHT - MARGIN]  # bottom right grant\n    ]\n\n    for index in range(4):\n        if logos[index] is None:\n            grant_bg = Image.new('RGBA', GRANT_BOX, color='white')\n            thumbail.paste(grant_bg, CORNERS[index], grant_bg)\n            continue\n\n        if type(logos[index]) is not str and re.match(r'.*\\.svg', logos[index].url):\n            grant_img = convert_img(logos[index])\n            grant_thumbail = Image.open(grant_img)\n        else:\n            try:\n                grant_thumbail = Image.open(logos[index])\n            except ValueError:\n                grant_thumbail = Image.open(logos[index]).convert(\"RGBA\")\n\n        grant_thumbail.thumbnail(GRANT_BOX, Image.ANTIALIAS)\n\n        grant_bg = Image.new('RGBA', GRANT_BOX, color='white')\n\n        try:\n            grant_bg.paste(grant_thumbail, (int(GRANT_WIDTH / 2 - grant_thumbail.size[0] / 2),\n                                            int(GRANT_HEIGHT / 2 - grant_thumbail.size[1] / 2)), grant_thumbail)\n        except ValueError:\n            grant_bg.paste(grant_thumbail, (int(GRANT_WIDTH / 2 - grant_thumbail.size[0] / 2),\n                                            int(GRANT_HEIGHT / 2 - grant_thumbail.size[1] / 2)))\n\n        thumbail.paste(grant_bg, CORNERS[index], grant_bg)\n\n    draw_on_thumbnail = ImageDraw.Draw(thumbail)\n    draw_on_thumbnail.ellipse([\n        (int(width / 2 - PROFILE_WIDTH / 2), int(heigth / 2 - PROFILE_HEIGHT / 2)),\n        (int(width / 2 + PROFILE_WIDTH / 2), int(heigth / 2 + PROFILE_HEIGHT / 2))\n    ], fill=\"#6F3FF5\")\n\n    try:\n        thumbail.paste(profile_circle, (int(width / 2 - PROFILE_WIDTH / 2) + HALF_LOGO_SIZE_DIFF, int(heigth / 2 - PROFILE_HEIGHT / 2) + HALF_LOGO_SIZE_DIFF),\n                       profile_circle)\n    except ValueError:\n        thumbail.paste(profile_circle, (int(width / 2 - PROFILE_WIDTH / 2) + HALF_LOGO_SIZE_DIFF, int(heigth / 2 - PROFILE_HEIGHT / 2) + HALF_LOGO_SIZE_DIFF))\n\n    return thumbail\n\n\ndef sync_payout(contribution):\n    if not contribution:\n        return None\n\n    subscription = contribution.subscription\n\n    if not subscription:\n        return None\n\n    tenant_payout_mapper[subscription.tenant](contribution)\n\n\ndef save_grant_to_notion(grant):\n    \"\"\"Post an insert to notions sybil-db table\"\"\"\n    # check for notion credentials before attempting insert\n    if NOTION_SYBIL_DB and NOTION_API_KEY:\n        # fully qualified url\n        fullUrl = BASE_URL.rstrip('/') + grant.url\n        grant_tags = []\n        for tag in grant.tags_requested.all():\n            grant_tags.append(str(tag))\n\n        # write to NOTION_SYBIL_DB following the defined schema (returns dict of new object)\n        return notion_write(NOTION_SYBIL_DB, {\n            \"Platform Status\":{\n                \"id\": \"qwNU\",\n                \"type\": \"select\",\n                \"select\":\n                {\n                    \"id\": \"f38a5236-d1d7-4e63-ada0-e52a4e56d06f\",\n                    \"name\": \"NEEDS REVIEW\",\n                    \"color\": \"default\"\n                }\n            },\n            \"Grant Name\": {\n                \"id\": \"title\",\n                \"type\": \"title\",\n                \"title\": [{\n                    \"type\": \"text\",\n                    \"text\": {\n                        \"content\": fullUrl,\n                        \"link\": {\n                            \"url\": fullUrl\n                        }\n                    },\n                    \"plain_text\": fullUrl,\n                    \"href\": fullUrl\n                }]\n            },\n             \"Requested Rounds\": {\n                \"id\": \"qBXH\",\n                \"type\": \"rich_text\",\n                \"rich_text\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": {\n                            \"content\": \", \".join(grant_tags),\n                            \"link\": None\n                        },\n                        \"annotations\": {\n                            \"bold\": False,\n                            \"italic\": False,\n                            \"strikethrough\": False,\n                            \"underline\": False,\n                            \"code\": False,\n                            \"color\": \"default\"\n                        },\n                        \"plain_text\": \", \".join(grant_tags),\n                        \"href\": None\n                    }\n                ]\n            },\n            \"Eligibility Tag Reasoning\": {\n                \"id\": \"Q]?]\",\n                \"type\": \"rich_text\",\n                \"rich_text\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": {\n                            \"content\": grant.tag_eligibility_reason,\n                            \"link\": None\n                        },\n                        \"annotations\": {\n                            \"bold\": False,\n                            \"italic\": False,\n                            \"strikethrough\": False,\n                            \"underline\": False,\n                            \"code\": False,\n                            \"color\": \"default\"\n                        },\n                        \"plain_text\": grant.tag_eligibility_reason,\n                        \"href\": None\n                    }\n                ]\n            }\n        })\n\n\ndef toggle_user_sybil(sybil_users, non_sybil_users):\n    '''util function which marks users as sybil/not'''\n\n    from dashboard.models import Profile\n\n    squelched_profiles = SquelchProfile.objects.all()\n    if sybil_users:\n        # iterate through users which need to be packed as sybil\n        for user in sybil_users:\n            try:\n                # get user profile. note\n                profile = Profile.objects.filter(handle=user.get('handle')).first()\n                if profile:\n                    label = user.get('label')\n                    comment = user.get('comment')\n\n                    if not comment or comment and isNaN(comment):\n                        comment = 'added by bsci'\n\n                    # check if user has entry in SquelchProfile\n                    if (\n                        not squelched_profiles.filter(profile=profile).first() and\n                        label and comment\n                    ):\n                        # mark user as sybil\n                        SquelchProfile.objects.create(\n                            profile=profile,\n                            label=label,\n                            comments=comment\n                        )\n                else:\n                    print(f\"error: profile not found for {user.get('handle')} as sybil.\")\n            except Exception as e:\n                print(f\"error: unable to mark user {user.get('handle')} as sybil. {e}\")\n\n    if non_sybil_users:\n        # exclude squelches added by manual\n        squelched_profiles = squelched_profiles.exclude(label='Manual')\n        # iterate and remove sybil from user\n        for user in non_sybil_users:\n            try:\n                profile = Profile.objects.filter(handle=user.get('handle')).first()\n                squelched_profiles.filter(profile=profile).delete()\n            except Exception as e:\n                print(f\"error: unable to mark {user.get('handle')} as non sybil. {e}\")\n\n\ndef bsci_script(csv: str) -> tuple:\n    \"\"\"\n    Generate records of sybil / non-sybil users based\n    on the CSV output as provided by BSci detection pipeline.\n    \"\"\"\n\n    # Assumptions\n    RENAME_MAP = {'notes': 'comment'}\n    ML_THRESHOLD = 0.8\n    EVAL_THRESHOLD = 0.8\n    HEURISTIC_THRESHOLD = 0.5\n\ndef bsci_script(csv: str) -> tuple:\n    \"\"\"\n    Generate records of sybil / non-sybil users based\n    on the CSV output as provided by BSci detection pipeline.\n    \"\"\"\n\n    # Assumptions\n    RENAME_MAP = {'notes': 'comment'}\n    ML_THRESHOLD = 0.8\n    EVAL_THRESHOLD = 0.8\n    HEURISTIC_THRESHOLD = 0.5\n\n    # Read CSV\n\n    try:\n        df = (pd.read_csv(csv)\n                .assign(is_sybil=None)\n                .assign(label=None)\n                .rename(columns=RENAME_MAP))\n\n        # Get label domains\n        rows_with_evaluation = ~pd.isnull(df.evaluation_score)\n        rows_with_heuristic = ~pd.isnull(df.heuristic_score)\n        rows_with_prediction = ~pd.isnull(df.prediction_score)\n\n        labels_by_evaluation = rows_with_evaluation\n        labels_by_heuristic = (rows_with_heuristic & (rows_with_heuristic\n                                                    ^ labels_by_evaluation))\n        labels_by_prediction = (rows_with_prediction & (rows_with_prediction\n                                                        ^ (labels_by_heuristic |\n                                                        labels_by_evaluation)))\n\n        # Assign final `is_sybil` markings according to a priorization criteria\n        df.loc[labels_by_evaluation, 'is_sybil'] = df[labels_by_evaluation].evaluation_score > EVAL_THRESHOLD\n        df.loc[labels_by_evaluation, 'label'] = \"Human Evaluation\"\n\n        df.loc[labels_by_heuristic, 'is_sybil'] = df[labels_by_heuristic].heuristic_score > HEURISTIC_THRESHOLD\n        df.loc[labels_by_heuristic, 'label'] = \"Heuristics\"\n\n        df.loc[labels_by_prediction, 'is_sybil'] = df[labels_by_prediction].prediction_score > ML_THRESHOLD\n        df.loc[labels_by_prediction, 'label'] = \"ML Prediction\"\n\n        # Generate dict records\n        sybil_records = df.query('is_sybil == True').to_dict('records')\n        non_sybil_records = df.query('is_sybil == False').to_dict('records')\n\n        # Output\n        return (sybil_records, non_sybil_records)\n    except Exception as e:\n        logger.error(f'error: bsci_sybil_script - {e}')\n        return None\n\n\ndef isNaN(string):\n    return string != string\n\ndef is_valid_eip_1271_signature(web3, address, hash, signature) -> bool:\n    from grants.abi.eip_1271_abi import EIP_1271_ABI\n    try:\n        eip_1271_contract = web3.eth.contract(address=address, abi=EIP_1271_ABI)\n        retval = eip_1271_contract.functions.isValidSignature(hash, signature).call()\n        return web3.toInt(retval) == 0x1626ba7e\n    except Exception as e:\n        return False"}
{"file_path": "https://github.com/sagaranand015/algorand-smart-asa/blob/68eb9b7f07b93c5fd52ddcd29a73633f82e2f520/contracts/emission_control.py", "code": "https://github.com/VincenzoImp/utils/blob/b797a1d6b71e212e430df3554bf94f9e67cd206d/parser_utils.py"}
{"file_path": "https://github.com/bytesdruid/Pure-NFT/blob/03143e8f897f930c481ec640d142087d8ed30a4c/asset_contract/asset.py", "code": "# deprecated\n\nimport re\nimport numpy as np\nimport pandas as pd\n\n# use only:\n# get_links\n# clear_html\n# get_emails\n# get_addresses \n# get_url_info\n# get_url_df_info\n\ntlds = [\"aaa\", \"aarp\", \"abarth\", \"abb\", \"abbott\", \"abbvie\", \"abc\", \"able\", \"abogado\", \"abudhabi\", \"ac\", \"academy\", \"accenture\", \"accountant\", \"accountants\", \"aco\", \"actor\", \"ad\", \"ads\", \"adult\", \"ae\", \"aeg\", \"aero\", \"aetna\", \"af\", \"afl\", \"africa\", \"ag\", \"agakhan\", \"agency\", \"ai\", \"aig\", \"airbus\", \"airforce\", \"airtel\", \"akdn\", \"al\", \"alfaromeo\", \"alibaba\", \"alipay\", \"allfinanz\", \"allstate\", \"ally\", \"alsace\", \"alstom\", \"am\", \"amazon\", \"americanexpress\", \"americanfamily\", \"amex\", \"amfam\", \"amica\", \"amsterdam\", \"analytics\", \"android\", \"anquan\", \"anz\", \"ao\", \"aol\", \"apartments\", \"app\", \"apple\", \"aq\", \"aquarelle\", \"ar\", \"arab\", \"aramco\", \"archi\", \"army\", \"arpa\", \"art\", \"arte\", \"as\", \"asda\", \"asia\", \"associates\", \"at\", \"athleta\", \"attorney\", \"au\", \"auction\", \"audi\", \"audible\", \"audio\", \"auspost\", \"author\", \"auto\", \"autos\", \"avianca\", \"aw\", \"aws\", \"ax\", \"axa\", \"az\", \"azure\", \"ba\", \"baby\", \"baidu\", \"banamex\", \"bananarepublic\", \"band\", \"bank\", \"bar\", \"barcelona\", \"barclaycard\", \"barclays\", \"barefoot\", \"bargains\", \"baseball\", \"basketball\", \"bauhaus\", \"bayern\", \"bb\", \"bbc\", \"bbt\", \"bbva\", \"bcg\", \"bcn\", \"bd\", \"be\", \"beats\", \"beauty\", \"beer\", \"bentley\", \"berlin\", \"best\", \"bestbuy\", \"bet\", \"bf\", \"bg\", \"bh\", \"bharti\", \"bi\", \"bible\", \"bid\", \"bike\", \"bing\", \"bingo\", \"bio\", \"biz\", \"bj\", \"black\", \"blackfriday\", \"blockbuster\", \"blog\", \"bloomberg\", \"blue\", \"bm\", \"bms\", \"bmw\", \"bn\", \"bnpparibas\", \"bo\", \"boats\", \"boehringer\", \"bofa\", \"bom\", \"bond\", \"boo\", \"book\", \"booking\", \"bosch\", \"bostik\", \"boston\", \"bot\", \"boutique\", \"box\", \"br\", \"bradesco\", \"bridgestone\", \"broadway\", \"broker\", \"brother\", \"brussels\", \"bs\", \"bt\", \"build\", \"builders\", \"business\", \"buy\", \"buzz\", \"bv\", \"bw\", \"by\", \"bz\", \"bzh\", \"ca\", \"cab\", \"cafe\", \"cal\", \"call\", \"calvinklein\", \"cam\", \"camera\", \"camp\", \"canon\", \"capetown\", \"capital\", \"capitalone\", \"car\", \"caravan\", \"cards\", \"care\", \"career\", \"careers\", \"cars\", \"casa\", \"case\", \"cash\", \"casino\", \"cat\", \"catering\", \"catholic\", \"cba\", \"cbn\", \"cbre\", \"cbs\", \"cc\", \"cd\", \"center\", \"ceo\", \"cern\", \"cf\", \"cfa\", \"cfd\", \"cg\", \"ch\", \"chanel\", \"channel\", \"charity\", \"chase\", \"chat\", \"cheap\", \"chintai\", \"christmas\", \"chrome\", \"church\", \"ci\", \"cipriani\", \"circle\", \"cisco\", \"citadel\", \"citi\", \"citic\", \"city\", \"cityeats\", \"ck\", \"cl\", \"claims\", \"cleaning\", \"click\", \"clinic\", \"clinique\", \"clothing\", \"cloud\", \"club\", \"clubmed\", \"cm\", \"cn\", \"co\", \"coach\", \"codes\", \"coffee\", \"college\", \"cologne\", \"com\", \"comcast\", \"commbank\", \"community\", \"company\", \"compare\", \"computer\", \"comsec\", \"condos\", \"construction\", \"consulting\", \"contact\", \"contractors\", \"cooking\", \"cookingchannel\", \"cool\", \"coop\", \"corsica\", \"country\", \"coupon\", \"coupons\", \"courses\", \"cpa\", \"cr\", \"credit\", \"creditcard\", \"creditunion\", \"cricket\", \"crown\", \"crs\", \"cruise\", \"cruises\", \"cu\", \"cuisinella\", \"cv\", \"cw\", \"cx\", \"cy\", \"cymru\", \"cyou\", \"cz\", \"dabur\", \"dad\", \"dance\", \"data\", \"date\", \"dating\", \"datsun\", \"day\", \"dclk\", \"dds\", \"de\", \"deal\", \"dealer\", \"deals\", \"degree\", \"delivery\", \"dell\", \"deloitte\", \"delta\", \"democrat\", \"dental\", \"dentist\", \"desi\", \"design\", \"dev\", \"dhl\", \"diamonds\", \"diet\", \"digital\", \"direct\", \"directory\", \"discount\", \"discover\", \"dish\", \"diy\", \"dj\", \"dk\", \"dm\", \"dnp\", \"do\", \"docs\", \"doctor\", \"dog\", \"domains\", \"dot\", \"download\", \"drive\", \"dtv\", \"dubai\", \"dunlop\", \"dupont\", \"durban\", \"dvag\", \"dvr\", \"dz\", \"earth\", \"eat\", \"ec\", \"eco\", \"edeka\", \"edu\", \"education\", \"ee\", \"eg\", \"email\", \"emerck\", \"energy\", \"engineer\", \"engineering\", \"enterprises\", \"epson\", \"equipment\", \"er\", \"ericsson\", \"erni\", \"es\", \"esq\", \"estate\", \"et\", \"etisalat\", \"eu\", \"eurovision\", \"eus\", \"events\", \"exchange\", \"expert\", \"exposed\", \"express\", \"extraspace\", \"fage\", \"fail\", \"fairwinds\", \"faith\", \"family\", \"fan\", \"fans\", \"farm\", \"farmers\", \"fashion\", \"fast\", \"fedex\", \"feedback\", \"ferrari\", \"ferrero\", \"fi\", \"fiat\", \"fidelity\", \"fido\", \"film\", \"final\", \"finance\", \"financial\", \"fire\", \"firestone\", \"firmdale\", \"fish\", \"fishing\", \"fit\", \"fitness\", \"fj\", \"fk\", \"flickr\", \"flights\", \"flir\", \"florist\", \"flowers\", \"fly\", \"fm\", \"fo\", \"foo\", \"food\", \"foodnetwork\", \"football\", \"ford\", \"forex\", \"forsale\", \"forum\", \"foundation\", \"fox\", \"fr\", \"free\", \"fresenius\", \"frl\", \"frogans\", \"frontdoor\", \"frontier\", \"ftr\", \"fujitsu\", \"fun\", \"fund\", \"furniture\", \"futbol\", \"fyi\", \"ga\", \"gal\", \"gallery\", \"gallo\", \"gallup\", \"game\", \"games\", \"gap\", \"garden\", \"gay\", \"gb\", \"gbiz\", \"gd\", \"gdn\", \"ge\", \"gea\", \"gent\", \"genting\", \"george\", \"gf\", \"gg\", \"ggee\", \"gh\", \"gi\", \"gift\", \"gifts\", \"gives\", \"giving\", \"gl\", \"glass\", \"gle\", \"global\", \"globo\", \"gm\", \"gmail\", \"gmbh\", \"gmo\", \"gmx\", \"gn\", \"godaddy\", \"gold\", \"goldpoint\", \"golf\", \"goo\", \"goodyear\", \"goog\", \"google\", \"gop\", \"got\", \"gov\", \"gp\", \"gq\", \"gr\", \"grainger\", \"graphics\", \"gratis\", \"green\", \"gripe\", \"grocery\", \"group\", \"gs\", \"gt\", \"gu\", \"guardian\", \"gucci\", \"guge\", \"guide\", \"guitars\", \"guru\", \"gw\", \"gy\", \"hair\", \"hamburg\", \"hangout\", \"haus\", \"hbo\", \"hdfc\", \"hdfcbank\", \"health\", \"healthcare\", \"help\", \"helsinki\", \"here\", \"hermes\", \"hgtv\", \"hiphop\", \"hisamitsu\", \"hitachi\", \"hiv\", \"hk\", \"hkt\", \"hm\", \"hn\", \"hockey\", \"holdings\", \"holiday\", \"homedepot\", \"homegoods\", \"homes\", \"homesense\", \"honda\", \"horse\", \"hospital\", \"host\", \"hosting\", \"hot\", \"hoteles\", \"hotels\", \"hotmail\", \"house\", \"how\", \"hr\", \"hsbc\", \"ht\", \"hu\", \"hughes\", \"hyatt\", \"hyundai\", \"ibm\", \"icbc\", \"ice\", \"icu\", \"id\", \"ie\", \"ieee\", \"ifm\", \"ikano\", \"il\", \"im\", \"imamat\", \"imdb\", \"immo\", \"immobilien\", \"in\", \"inc\", \"industries\", \"infiniti\", \"info\", \"ing\", \"ink\", \"institute\", \"insurance\", \"insure\", \"int\", \"international\", \"intuit\", \"investments\", \"io\", \"ipiranga\", \"iq\", \"ir\", \"irish\", \"is\", \"ismaili\", \"ist\", \"istanbul\", \"it\", \"itau\", \"itv\", \"jaguar\", \"java\", \"jcb\", \"je\", \"jeep\", \"jetzt\", \"jewelry\", \"jio\", \"jll\", \"jm\", \"jmp\", \"jnj\", \"jo\", \"jobs\", \"joburg\", \"jot\", \"joy\", \"jp\", \"jpmorgan\", \"jprs\", \"juegos\", \"juniper\", \"kaufen\", \"kddi\", \"ke\", \"kerryhotels\", \"kerrylogistics\", \"kerryproperties\", \"kfh\", \"kg\", \"kh\", \"ki\", \"kia\", \"kids\", \"kim\", \"kinder\", \"kindle\", \"kitchen\", \"kiwi\", \"km\", \"kn\", \"koeln\", \"komatsu\", \"kosher\", \"kp\", \"kpmg\", \"kpn\", \"kr\", \"krd\", \"kred\", \"kuokgroup\", \"kw\", \"ky\", \"kyoto\", \"kz\", \"la\", \"lacaixa\", \"lamborghini\", \"lamer\", \"lancaster\", \"lancia\", \"land\", \"landrover\", \"lanxess\", \"lasalle\", \"lat\", \"latino\", \"latrobe\", \"law\", \"lawyer\", \"lb\", \"lc\", \"lds\", \"lease\", \"leclerc\", \"lefrak\", \"legal\", \"lego\", \"lexus\", \"lgbt\", \"li\", \"lidl\", \"life\", \"lifeinsurance\", \"lifestyle\", \"lighting\", \"like\", \"lilly\", \"limited\", \"limo\", \"lincoln\", \"link\", \"lipsy\", \"live\", \"living\", \"lk\", \"llc\", \"llp\", \"loan\", \"loans\", \"locker\", \"locus\", \"lol\", \"london\", \"lotte\", \"lotto\", \"love\", \"lpl\", \"lplfinancial\", \"lr\", \"ls\", \"lt\", \"ltd\", \"ltda\", \"lu\", \"lundbeck\", \"luxe\", \"luxury\", \"lv\", \"ly\", \"ma\", \"madrid\", \"maif\", \"maison\", \"makeup\", \"man\", \"management\", \"mango\", \"map\", \"market\", \"marketing\", \"markets\", \"marriott\", \"marshalls\", \"maserati\", \"mattel\", \"mba\", \"mc\", \"mckinsey\", \"md\", \"me\", \"med\", \"media\", \"meet\", \"melbourne\", \"meme\", \"memorial\", \"men\", \"menu\", \"merckmsd\", \"mg\", \"mh\", \"miami\", \"microsoft\", \"mil\", \"mini\", \"mint\", \"mit\", \"mitsubishi\", \"mk\", \"ml\", \"mlb\", \"mls\", \"mm\", \"mma\", \"mn\", \"mo\", \"mobi\", \"mobile\", \"moda\", \"moe\", \"moi\", \"mom\", \"monash\", \"money\", \"monster\", \"mormon\", \"mortgage\", \"moscow\", \"moto\", \"motorcycles\", \"mov\", \"movie\", \"mp\", \"mq\", \"mr\", \"ms\", \"msd\", \"mt\", \"mtn\", \"mtr\", \"mu\", \"museum\", \"music\", \"mutual\", \"mv\", \"mw\", \"mx\", \"my\", \"mz\", \"nan\", \"nab\", \"nagoya\", \"name\", \"natura\", \"navy\", \"nba\", \"nc\", \"ne\", \"nec\", \"net\", \"netbank\", \"netflix\", \"network\", \"neustar\", \"new\", \"news\", \"next\", \"nextdirect\", \"nexus\", \"nf\", \"nfl\", \"ng\", \"ngo\", \"nhk\", \"ni\", \"nico\", \"nike\", \"nikon\", \"ninja\", \"nissan\", \"nissay\", \"nl\", \"no\", \"nokia\", \"northwesternmutual\", \"norton\", \"now\", \"nowruz\", \"nowtv\", \"np\", \"nr\", \"nra\", \"nrw\", \"ntt\", \"nu\", \"nyc\", \"nz\", \"obi\", \"observer\", \"office\", \"okinawa\", \"olayan\", \"olayangroup\", \"oldnavy\", \"ollo\", \"om\", \"omega\", \"one\", \"ong\", \"onl\", \"online\", \"ooo\", \"open\", \"oracle\", \"orange\", \"org\", \"organic\", \"origins\", \"osaka\", \"otsuka\", \"ott\", \"ovh\", \"pa\", \"page\", \"panasonic\", \"paris\", \"pars\", \"partners\", \"parts\", \"party\", \"passagens\", \"pay\", \"pccw\", \"pe\", \"pet\", \"pf\", \"pfizer\", \"pg\", \"ph\", \"pharmacy\", \"phd\", \"philips\", \"phone\", \"photo\", \"photography\", \"photos\", \"physio\", \"pics\", \"pictet\", \"pictures\", \"pid\", \"pin\", \"ping\", \"pink\", \"pioneer\", \"pizza\", \"pk\", \"pl\", \"place\", \"play\", \"playstation\", \"plumbing\", \"plus\", \"pm\", \"pn\", \"pnc\", \"pohl\", \"poker\", \"politie\", \"porn\", \"post\", \"pr\", \"pramerica\", \"praxi\", \"press\", \"prime\", \"pro\", \"prod\", \"productions\", \"prof\", \"progressive\", \"promo\", \"properties\", \"property\", \"protection\", \"pru\", \"prudential\", \"ps\", \"pt\", \"pub\", \"pw\", \"pwc\", \"py\", \"qa\", \"qpon\", \"quebec\", \"quest\", \"racing\", \"radio\", \"re\", \"read\", \"realestate\", \"realtor\", \"realty\", \"recipes\", \"red\", \"redstone\", \"redumbrella\", \"rehab\", \"reise\", \"reisen\", \"reit\", \"reliance\", \"ren\", \"rent\", \"rentals\", \"repair\", \"report\", \"republican\", \"rest\", \"restaurant\", \"review\", \"reviews\", \"rexroth\", \"rich\", \"richardli\", \"ricoh\", \"ril\", \"rio\", \"rip\", \"ro\", \"rocher\", \"rocks\", \"rodeo\", \"rogers\", \"room\", \"rs\", \"rsvp\", \"ru\", \"rugby\", \"ruhr\", \"run\", \"rw\", \"rwe\", \"ryukyu\", \"sa\", \"saarland\", \"safe\", \"safety\", \"sakura\", \"sale\", \"salon\", \"samsclub\", \"samsung\", \"sandvik\", \"sandvikcoromant\", \"sanofi\", \"sap\", \"sarl\", \"sas\", \"save\", \"saxo\", \"sb\", \"sbi\", \"sbs\", \"sc\", \"sca\", \"scb\", \"schaeffler\", \"schmidt\", \"scholarships\", \"school\", \"schule\", \"schwarz\", \"science\", \"scot\", \"sd\", \"se\", \"search\", \"seat\", \"secure\", \"security\", \"seek\", \"select\", \"sener\", \"services\", \"seven\", \"sew\", \"sex\", \"sexy\", \"sfr\", \"sg\", \"sh\", \"shangrila\", \"sharp\", \"shaw\", \"shell\", \"shia\", \"shiksha\", \"shoes\", \"shop\", \"shopping\", \"shouji\", \"show\", \"showtime\", \"si\", \"silk\", \"sina\", \"singles\", \"site\", \"sj\", \"sk\", \"ski\", \"skin\", \"sky\", \"skype\", \"sl\", \"sling\", \"sm\", \"smart\", \"smile\", \"sn\", \"sncf\", \"so\", \"soccer\", \"social\", \"softbank\", \"software\", \"sohu\", \"solar\", \"solutions\", \"song\", \"sony\", \"soy\", \"spa\", \"space\", \"sport\", \"spot\", \"sr\", \"srl\", \"ss\", \"st\", \"stada\", \"staples\", \"star\", \"statebank\", \"statefarm\", \"stc\", \"stcgroup\", \"stockholm\", \"storage\", \"store\", \"stream\", \"studio\", \"study\", \"style\", \"su\", \"sucks\", \"supplies\", \"supply\", \"support\", \"surf\", \"surgery\", \"suzuki\", \"sv\", \"swatch\", \"swiss\", \"sx\", \"sy\", \"sydney\", \"systems\", \"sz\", \"tab\", \"taipei\", \"talk\", \"taobao\", \"target\", \"tatamotors\", \"tatar\", \"tattoo\", \"tax\", \"taxi\", \"tc\", \"tci\", \"td\", \"tdk\", \"team\", \"tech\", \"technology\", \"tel\", \"temasek\", \"tennis\", \"teva\", \"tf\", \"tg\", \"th\", \"thd\", \"theater\", \"theatre\", \"tiaa\", \"tickets\", \"tienda\", \"tiffany\", \"tips\", \"tires\", \"tirol\", \"tj\", \"tjmaxx\", \"tjx\", \"tk\", \"tkmaxx\", \"tl\", \"tm\", \"tmall\", \"tn\", \"to\", \"today\", \"tokyo\", \"tools\", \"top\", \"toray\", \"toshiba\", \"total\", \"tours\", \"town\", \"toyota\", \"toys\", \"tr\", \"trade\", \"trading\", \"training\", \"travel\", \"travelchannel\", \"travelers\", \"travelersinsurance\", \"trust\", \"trv\", \"tt\", \"tube\", \"tui\", \"tunes\", \"tushu\", \"tv\", \"tvs\", \"tw\", \"tz\", \"ua\", \"ubank\", \"ubs\", \"ug\", \"uk\", \"unicom\", \"university\", \"uno\", \"uol\", \"ups\", \"us\", \"uy\", \"uz\", \"va\", \"vacations\", \"vana\", \"vanguard\", \"vc\", \"ve\", \"vegas\", \"ventures\", \"verisign\", \"versicherung\", \"vet\", \"vg\", \"vi\", \"viajes\", \"video\", \"vig\", \"viking\", \"villas\", \"vin\", \"vip\", \"virgin\", \"visa\", \"vision\", \"viva\", \"vivo\", \"vlaanderen\", \"vn\", \"vodka\", \"volkswagen\", \"volvo\", \"vote\", \"voting\", \"voto\", \"voyage\", \"vu\", \"vuelos\", \"wales\", \"walmart\", \"walter\", \"wang\", \"wanggou\", \"watch\", \"watches\", \"weather\", \"weatherchannel\", \"webcam\", \"weber\", \"website\", \"wed\", \"wedding\", \"weibo\", \"weir\", \"wf\", \"whoswho\", \"wien\", \"wiki\", \"williamhill\", \"win\", \"windows\", \"wine\", \"winners\", \"wme\", \"wolterskluwer\", \"woodside\", \"work\", \"works\", \"world\", \"wow\", \"ws\", \"wtc\", \"wtf\", \"xbox\", \"xerox\", \"xfinity\", \"xihuan\", \"xin\", \"xn--11b4c3d\", \"xn--1ck2e1b\", \"xn--1qqw23a\", \"xn--2scrj9c\", \"xn--30rr7y\", \"xn--3bst00m\", \"xn--3ds443g\", \"xn--3e0b707e\", \"xn--3hcrj9c\", \"xn--3pxu8k\", \"xn--42c2d9a\", \"xn--45br5cyl\", \"xn--45brj9c\", \"xn--45q11c\", \"xn--4dbrk0ce\", \"xn--4gbrim\", \"xn--54b7fta0cc\", \"xn--55qw42g\", \"xn--55qx5d\", \"xn--5su34j936bgsg\", \"xn--5tzm5g\", \"xn--6frz82g\", \"xn--6qq986b3xl\", \"xn--80adxhks\", \"xn--80ao21a\", \"xn--80aqecdr1a\", \"xn--80asehdb\", \"xn--80aswg\", \"xn--8y0a063a\", \"xn--90a3ac\", \"xn--90ae\", \"xn--90ais\", \"xn--9dbq2a\", \"xn--9et52u\", \"xn--9krt00a\", \"xn--b4w605ferd\", \"xn--bck1b9a5dre4c\", \"xn--c1avg\", \"xn--c2br7g\", \"xn--cck2b3b\", \"xn--cckwcxetd\", \"xn--cg4bki\", \"xn--clchc0ea0b2g2a9gcd\", \"xn--czr694b\", \"xn--czrs0t\", \"xn--czru2d\", \"xn--d1acj3b\", \"xn--d1alf\", \"xn--e1a4c\", \"xn--eckvdtc9d\", \"xn--efvy88h\", \"xn--fct429k\", \"xn--fhbei\", \"xn--fiq228c5hs\", \"xn--fiq64b\", \"xn--fiqs8s\", \"xn--fiqz9s\", \"xn--fjq720a\", \"xn--flw351e\", \"xn--fpcrj9c3d\", \"xn--fzc2c9e2c\", \"xn--fzys8d69uvgm\", \"xn--g2xx48c\", \"xn--gckr3f0f\", \"xn--gecrj9c\", \"xn--gk3at1e\", \"xn--h2breg3eve\", \"xn--h2brj9c\", \"xn--h2brj9c8c\", \"xn--hxt814e\", \"xn--i1b6b1a6a2e\", \"xn--imr513n\", \"xn--io0a7i\", \"xn--j1aef\", \"xn--j1amh\", \"xn--j6w193g\", \"xn--jlq480n2rg\", \"xn--jvr189m\", \"xn--kcrx77d1x4a\", \"xn--kprw13d\", \"xn--kpry57d\", \"xn--kput3i\", \"xn--l1acc\", \"xn--lgbbat1ad8j\", \"xn--mgb9awbf\", \"xn--mgba3a3ejt\", \"xn--mgba3a4f16a\", \"xn--mgba7c0bbn0a\", \"xn--mgbaakc7dvf\", \"xn--mgbaam7a8h\", \"xn--mgbab2bd\", \"xn--mgbah1a3hjkrd\", \"xn--mgbai9azgqp6j\", \"xn--mgbayh7gpa\", \"xn--mgbbh1a\", \"xn--mgbbh1a71e\", \"xn--mgbc0a9azcg\", \"xn--mgbca7dzdo\", \"xn--mgbcpq6gpa1a\", \"xn--mgberp4a5d4ar\", \"xn--mgbgu82a\", \"xn--mgbi4ecexp\", \"xn--mgbpl2fh\", \"xn--mgbt3dhd\", \"xn--mgbtx2b\", \"xn--mgbx4cd0ab\", \"xn--mix891f\", \"xn--mk1bu44c\", \"xn--mxtq1m\", \"xn--ngbc5azd\", \"xn--ngbe9e0a\", \"xn--ngbrx\", \"xn--node\", \"xn--nqv7f\", \"xn--nqv7fs00ema\", \"xn--nyqy26a\", \"xn--o3cw4h\", \"xn--ogbpf8fl\", \"xn--otu796d\", \"xn--p1acf\", \"xn--p1ai\", \"xn--pgbs0dh\", \"xn--pssy2u\", \"xn--q7ce6a\", \"xn--q9jyb4c\", \"xn--qcka1pmc\", \"xn--qxa6a\", \"xn--qxam\", \"xn--rhqv96g\", \"xn--rovu88b\", \"xn--rvc1e0am3e\", \"xn--s9brj9c\", \"xn--ses554g\", \"xn--t60b56a\", \"xn--tckwe\", \"xn--tiq49xqyj\", \"xn--unup4y\", \"xn--vermgensberater-ctb\", \"xn--vermgensberatung-pwb\", \"xn--vhquv\", \"xn--vuq861b\", \"xn--w4r85el8fhu5dnra\", \"xn--w4rs40l\", \"xn--wgbh1c\", \"xn--wgbl6a\", \"xn--xhq521b\", \"xn--xkc2al3hye2a\", \"xn--xkc2dl3a5ee0h\", \"xn--y9a3aq\", \"xn--yfro4i67o\", \"xn--ygbi2ammx\", \"xn--zfr164b\", \"xxx\", \"xyz\", \"yachts\", \"yahoo\", \"yamaxun\", \"yandex\", \"ye\", \"yodobashi\", \"yoga\", \"yokohama\", \"you\", \"youtube\", \"yt\", \"yun\", \"za\", \"zappos\", \"zara\", \"zero\", \"zip\", \"zm\", \"zone\", \"zuerich\", \"zw\", \"onion\"]\n\ndef remove_hastag(url):\n    # Remove 'https://' or 'http://'\n    head = ''\n    if url.startswith('https://'):\n        head = 'https://'\n        url = url[8:]\n    elif url.startswith('http://'):\n        head = 'http://'\n        url = url[7:]\n    index = url.rfind('/')\n    if index != -1:\n        index2 = url.rfind('#')\n        if index2 > index:\n            url = url[:index2]\n    return head + url\n\ndef get_extension(url, extensions):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    index = url.rfind('/')\n    extension = ''\n    if index != -1:\n        index2 = url.rfind('.')\n        if index2 > index:\n            extension = url[index2+1:].lower()\n            for ext in extensions:\n                if extension.startswith(ext):\n                    return ext\n    return np.nan\n\ndef remove_not_isalnum(url):\n    while len(url) > 0 and not url[-1].isalnum():\n        url = url[:-1]\n    while len(url) > 0 and not url[0].isalnum():\n        url = url[1:]\n    return url\ndef is_tld(url):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    index = url.find('/')\n    if index != -1:\n        url = url[:index]\n    if '@' in url:\n        return False\n    index = url.rfind('.')\n    if index != -1:\n        url = url[index+1:]\n        if url.lower() in tlds:\n            return True\n    return False\ndef remove_head(url):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    # remove 'www.'\n    if url.startswith('www.'):\n        url = url[4:]\n    return url\n\ndef is_still_valid(url):\n    # se \u00e8 vuoto ritorna False\n    if url == '':\n        return False\n    # se non ha un punto ritorna False\n    if '.' not in url:\n        return False\n    # se ha due punti consecutivi ritorna False\n    if '..' in url:\n        return False\n    return True\n\ndef get_links(text):\n    # text = 'You can view more details at https://uibakery.io, or just ping via email. You can view more details at uibakery.io or just ping via email.'\n    urls = []\n    # Extract URL from a string\n    url_extract_pattern = \"https?:\\\\/\\\\/(?:www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)\"\n    urls += re.findall(url_extract_pattern, text)\n    for url in urls:\n        text = text.replace(url, ' ')\n    url_extract_pattern = \"[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)\"\n    urls += re.findall(url_extract_pattern, text)\n    urls_cleaned = []\n    for url in urls:\n        if is_tld(url):\n            url = remove_not_isalnum(url)\n            if is_still_valid(url):\n                urls_cleaned.append(url)\n    return urls_cleaned\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef clear_html(html_string):\n    def clear_tag(html_string, tag):\n        if html_string.find(f'<{tag}') == -1 or html_string.find(f'</{tag}>') == -1:\n            return html_string\n        start = html_string.find(f'<{tag}')\n        end = start + html_string[start:].find(f'</{tag}>') + len(tag)+3\n        html_string = html_string[:start] + ' ' + html_string[end:]\n        return html_string\n    tags = ['iframe', 'template', 'script', 'style']\n    for tag in tags:\n        while True:\n            new_html_string = clear_tag(html_string, tag)\n            if new_html_string == html_string:\n                break\n            html_string = new_html_string\n    html_string = re.sub(r'<[^>]*?>', ' ', html_string)\n    html_string = re.sub(r'\\s+', ' ', html_string)\n    html_string = html_string.strip()\n    return html_string\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblockchains = [\n        'bitcoin',\n        'ethereum',\n        'litecoin',\n        'dogecoin',\n        'monero',\n        'dash',\n        'cardano',\n        'cosmos',\n        'iota',\n        'lisk',\n        'polkadot',\n        'ripple',\n        'stellar',\n        'neo',\n        'bitcoin-cash',\n        'ethereum-classic',\n        'binance-smart-chain',\n        'binance-beacon-chain',\n        'solana',\n        'tron',\n        'algorand',\n        'vechain'\n    ]\n\ndef bitcoin(address):\n    def taproot(address):\n        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,89}))$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def segwit(address):\n        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,87}))$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def script(address):\n        schema = '^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def legacy(address):\n        schema = '^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    if taproot(address):\n        return True\n    if segwit(address):\n        return True\n    if script(address):\n        return True\n    if legacy(address):\n        return True\n    return False\n\ndef ethereum(address):\n    schema = '^((0x)([0-9a-fA-F]{40}))$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef litecoin(address):\n    schema = '^([LM3]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}||ltc1[a-z0-9]{39,59})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef dogecoin(address):\n    schema = '^D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}'\n    schema2 = 'D[a-zA-Z0-9_.-]{33}'\n    if re.match(schema, address) is None and re.match(schema2, address) is None:\n        return False\n    return True\n\ndef monero(address):\n    schema = '[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef dash(address):\n    schema = 'X[1-9A-HJ-NP-Za-km-z]{33}'\n    if re.match(schema, address) is None:\n        return False\n    return True  \n\ndef cardano(address):\n    schema = 'addr1[a-z0-9]+'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef cosmos(address):\n    schema = 'cosmos[a-zA-Z0-9_.-]{10,}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef iota(address):\n    schema = 'iota[a-z0-9]{10,}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef lisk(address):\n    schema = '[0-9]{19}L'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef nem(address):\n    schema = '[N][A-Za-z0-9-]{37,52}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef neo(address):\n    schema = 'A[0-9a-zA-Z]{33}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef polkadot(address):\n    schema = '1[0-9a-zA-Z]{47}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef ripple(address):\n    schema = '^([r])([1-9A-HJ-NP-Za-km-z]{24,34})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef stellar(address):\n    schema = 'G[0-9A-Z]{40,60}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef ethereum_classic(address):\n    return ethereum(address)\n\ndef binance_smart_chain(address):\n    return ethereum(address)\n\ndef binance_beacon_chain(address):\n    schema = '^((bnb1)[0-9a-z]{38})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef bitcoin_cash(address):\n    legacy = '[13][a-km-zA-HJ-NP-Z1-9]{33}'\n    cashaddr = '((bitcoincash):)?(q|p)[a-z0-9]{41}'\n    if re.match(legacy, address) is None and re.match(cashaddr, address) is None:\n        return False\n    return True\n\ndef solana(address):\n    schema = '^[1-9A-HJ-NP-Za-km-z]{32,44}$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef tron(address):\n    schema = '^((T)[a-zA-Z0-9]{33})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef algorand(address):\n    schema = '^[A-Z2-7]{58}$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef vechain(address):\n    return ethereum(address)\n\ndef get_addresses(text):\n    foo = {\n        'bitcoin': bitcoin,\n        'ethereum': ethereum,\n        'litecoin': litecoin,\n        'dogecoin': dogecoin,\n        'monero': monero,\n        'dash': dash,\n        'cardano': cardano,\n        'cosmos': cosmos,\n        'iota': iota,\n        'lisk': lisk,\n        'polkadot': polkadot,\n        'ripple': ripple,\n        'stellar': stellar,\n        'neo': neo,\n        'bitcoin-cash': bitcoin_cash,\n        'ethereum-classic': ethereum_classic,\n        'binance-smart-chain': binance_smart_chain,\n        'binance-beacon-chain': binance_beacon_chain,\n        'solana': solana,\n        'tron': tron,\n        'algorand': algorand,\n        'vechain': vechain,\n    }\n    crypto = {key : [] for key in foo.keys()}\n    text = re.sub(r'\\W', ' ', text)\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    for address in text.split():\n        for key in foo.keys():\n            if foo[key](address):\n                crypto[key].append(address)\n    for key in crypto.keys():\n        crypto[key] = list(set(crypto[key]))\n    for key in crypto.copy():\n        if crypto[key] == []:\n            del crypto[key]\n    return crypto\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef email(address):\n    # remove all no alphanumeric char from the beginning and the end\n    address = re.sub(r'^[^a-zA-Z0-9]*', '', address)\n    address = re.sub(r'[^a-zA-Z0-9]*$', '', address)\n    schema = \"^[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*@(?:[A-Z0-9-]+\\.)+[A-Z]{2,6}$\"\n    if re.match(schema, address.upper()) is None:\n        return None\n    return address\n\ndef get_emails(text):\n    emails = []\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    for string in text.split():\n        address = email(string)\n        if address is not None:\n            emails.append(address)\n    return emails\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef foo1(x):\n    if x.startswith('http://www.'):\n        return x[11:]\n    if x.startswith('https://www.'):\n        return x[12:]\n    if x.startswith('http://'):\n        return x[7:]\n    if x.startswith('https://'):\n        return x[8:]\n    return x\n\ndef foo2(x):\n    return x.split('/')[0].lower()\n\ndef foo3(x):\n    return x.split('.')[-1].lower()\n\ndef foo4(x):\n    return '.'.join(x.split('.')[:-1]).lower()\n\ndef foo5(x):\n    x = x.split('/')\n    if len(x) > 1:\n        y = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]\n        x = '/'.join(x[1:-1])+'/'+y\n        return x.strip('/')\n    return np.nan\n\ndef foo6(x):\n    x = x.split('/')\n    if len(x) > 1:\n        x = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]\n        x = x.split('.')\n        if len(x) > 1:\n            return x[-1].lower()\n    return np.nan\n\ndef get_url_info(url):\n    url_df = pd.DataFrame({'url': [url]})\n    url_df = get_url_df_info(url_df)\n    info = {\n        'apex': url_df['apex'][0],\n        'domain': url_df['domain'][0],\n        'tld': url_df['tld'][0],\n        'path': url_df['path'][0],\n        'extention': url_df['extention'][0],\n        'normalized_url': url_df['normalized_url'][0],\n        'normalized_url_lower': url_df['normalized_url_lower'][0],\n    }\n    return info \n\ndef get_url_df_info(df):\n    df['apex'] = df['url'].apply(lambda x: foo2(foo1(x)))\n    df['domain'] = df['url'].apply(lambda x: foo4(foo2(foo1(x))))\n    df['tld'] = df['url'].apply(lambda x: foo3(foo2(foo1(x))))\n    df['path'] = df['url'].apply(lambda x: foo5(foo1(x)))\n    df['extention'] = df['url'].apply(lambda x: foo6(foo1(x)))\n    df['normalized_url'] = df['apex'] + '/' + df['path']\n    df['normalized_url'] = df['normalized_url'].fillna(df['apex'])\n    df['normalized_url_lower'] = df['normalized_url'].str.lower()\n    return df"}
{"file_path": "https://github.com/algorandfoundation/puya/blob/6d27f657ce8fddaedc33e778daa8799546778d1b/stubs/algopy-stubs/_contract.pyi", "code": "https://github.com/Argonaut5000/algorand-arc19-python-example/blob/be35e0c5b48b98a74c7ae70e32531502d6a5e37d/algorand_utils.py"}
{"file_path": "https://github.com/geghamjivanyan/algorand/blob/e0f1cf63859591a1a9434e45d3b0411a05eaf8e7/src/algorand.py", "code": "from itsdangerous import json\n\n\nimport json\n\n\"\"\"\nStriaght ripped from https://github.com/algorand/docs Algorand Dev Documentation\n\nThank you for the util functions!\n\"\"\"\n\n#   Utility function used to print asset holding for account and assetid\ndef print_asset_holding(algodclient, account, assetid):\n    # note: if you have an indexer instance available it is easier to just use this\n    # response = myindexer.accounts(asset_id = assetid)\n    # then loop thru the accounts returned and match the account you are looking for\n    account_info = algodclient.account_info(account)\n    idx = 0\n    for my_account_info in account_info['assets']:\n        scrutinized_asset = account_info['assets'][idx]\n        idx = idx + 1        \n        if (scrutinized_asset['asset-id'] == assetid):\n            print(\"Asset ID: {}\".format(scrutinized_asset['asset-id']))\n            print(json.dumps(scrutinized_asset, indent=4))\n            break\n\n# utility for waiting on a transaction confirmation\ndef wait_for_confirmation( algod_client, txid, timeout=2000):\n    start_round = algod_client.status()[\"last-round\"] + 1\n    current_round = start_round\n\n    while current_round < start_round + timeout:\n        try:\n            pending_txn = algod_client.pending_transaction_info(txid)\n        except Exception:\n            return \n        if pending_txn.get(\"confirmed-round\", 0) > 0:\n            return pending_txn\n        elif pending_txn[\"pool-error\"]:  \n            raise Exception(\n                'pool error: {}'.format(pending_txn[\"pool-error\"]))\n        algod_client.status_after_block(current_round)                   \n        current_round += 1\n    raise Exception(\n        'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))"}
{"file_path": "https://github.com/KOSASIH/pi-nexus-autonomous-banking-network/blob/aad37ae96f34f3088f33692b3eaae503e53ee1eb/projects/piguardian/smart_contracts/incident_response_contract.py", "code": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py"}
{"file_path": "https://github.com/marotipatre/Escrow-Mechanism-on-Algorand/blob/0ed1b564a678a60028558082832e3bec46afdc61/projects/escrow_mechanism/smart_contracts/artifacts/escrow_contract/escrow_client.py", "code": "#!/usr/bin/env python3\n\nimport setuptools\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"pyteal\",\n    version=\"0.27.0\",\n    author=\"Algorand\",\n    author_email=\"pypiservice@algorand.com\",\n    description=\"Algorand Smart Contracts in Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/algorand/pyteal\",\n    packages=setuptools.find_packages(\n        include=(\n            \"feature_gates\",\n            \"pyteal\",\n            \"pyteal.*\",\n        )\n    ),\n    install_requires=[\n        # when changing this list, also update docs/requirements.txt\n        \"docstring-parser==0.14.1\",\n        \"executing==2.0.1\",\n        \"py-algorand-sdk>=2.0.0,<3.0.0\",\n        \"semantic-version>=2.9.0,<3.0.0\",\n        \"tabulate>=0.9.0,<0.10.0\",\n    ],\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    package_data={\"pyteal\": [\"*.pyi\", \"py.typed\"]},\n    python_requires=\">=3.10\",\n)"}
{"file_path": "https://github.com/algorandfoundation/ARCs/blob/2f3df5821265291f49710f58e53324ac4405d0e9/assets/arc-0062/smart_contracts/artifacts/circulating_supply/circulating_supply_client.py", "code": "https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/examples/exodus.py"}
{"file_path": "https://github.com/Keshabkjha/LotteryContract/blob/964bd66aa545308c496198cd32b56e5a2907fd61/smart_contracts/artifacts/lottery/lottery_client.py", "code": "\"\"\"\nExample of keys derivation for ed25519 or nist256p1 based coins like Exodus wallet.\n\nBasically, Exodus always uses the secp256k1 curve to derive the BIP44 path, even for coins that are not based on secp256k1.\nThen, for coins based on other curves (e.g. Algorand, Solana, Stellar, Neo ...), it uses the last derived private key as a master key to compute the public key and address.\nIt's not the only wallet doing this (Atomic Wallet does the same), because in this way the developers don't have to implement other derivation schemes beside secp256k1.\n\"\"\"\n\nfrom bip_utils import Bip32Slip10Secp256k1, Bip39SeedGenerator, Bip44, Bip44Coins, Bip44ConfGetter\n\n\n# Mnemonic\nmnemonic = \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\n# Generate seed from mnemonic\nseed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n\n# Example with Solana (ed25519-based coin) and Neo (nist256p1-based coin)\nfor coin_type in (Bip44Coins.SOLANA, Bip44Coins.NEO):\n    # Get coin index from configuration\n    coin_idx = Bip44ConfGetter.GetConfig(coin_type).CoinIndex()\n\n    # Derive the standard BIP44 path using secp256k1\n    bip32_ctx = Bip32Slip10Secp256k1.FromSeed(seed_bytes).DerivePath(f\"m/44'/{coin_idx}'/0'/0/0\")\n    priv_key_bytes = bip32_ctx.PrivateKey().Raw().ToBytes()\n\n    # Use the last private key as a master key, we can use Bip44 to simplify the address computation\n    bip44_ctx = Bip44.FromPrivateKey(priv_key_bytes, coin_type)\n    # Same address of Exodus\n    print(f\"Address for {coin_type}: {bip44_ctx.PublicKey().ToAddress()}\")"}
{"file_path": "https://github.com/algorandlabs/smart-asa/blob/4351b4d28ee157d5254a69bb75a4f3117610b982/smart_asa_asc.py", "code": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Rewards/rewards.py"}
{"file_path": "https://github.com/McEazy2700/vericert-backend/blob/52c53f1ee2ae599117a50436675833bfbf614441/veecert_backend/apps/common/smart_contract_client.py", "code": "#Choice Coin Governance Rewards Code.\n#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nfrom algorand_demo import choice_trade\nimport json\nimport urllib3\nchoice_id  = 42771692\n\nvoter_1_address = \nvoter_1_mnemonic = \nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\n\t# now we will open a file for writing\n\t\tdata_file = open('file.csv', 'w')\n\n\t# create the csv writer object\n\t\tcsv_writer = csv.writer(data_file)\n\n\t# Counter variable used for writing\n\t# headers to the CSV file\n\t\tcount = 0\n\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\n\t\t        # Writing headers of CSV file\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\n\t\t    # Writing data of CSV file\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t    # pass the file object to reader() to get the reader object\n\t\t\t\t\tdata = json.load(json_file)\n\t\t\t\t\ttransaction_data = data['transactions']\n\t\t\t\t\tfor transaction in transaction_data:\n\t\t\t\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\t\t\t\tamount = int(amount)\n\t\t\t\t\t\tamount = amount + amount * 0.12 #Rewards rate hardcoded\n\t\t\t\t\t\taddress = transaction['sender']\n\t\t\t\t\t\tid = transaction['id']\n\t\t\t\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"file_path": "https://github.com/lexycole/pay-rent-ng/blob/d572a34a39087e5fd775f8eb3bf88b024379dcd3/projects/pay-rent-ng-contracts/smart_contracts/__main__.py", "code": "https://github.com/N3koSempai/searching_algorand/blob/adb01b6981504f6a9df47966cec5b30348cbaca1/search-algorand.py"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/is_updatable.py", "code": "from methods import online\n\nimport threading\n\nimport re\nimport conn\nimport con_postg\nimport report\n\n\n\nclass Coinbot():\n\n    def __init__(self, select_coin, select_db):\n        \"\"\"set the initial variable\"\"\"\n        #initialize the database\n        if select_db == 'postgresql':\n            self.db = con_postg.DB()\n        else:\n            self.db = conn.DB()\n        self.db.start()\n        self.report = report.Report()\n        self.online = online.Online_method()\n        if select_coin == \"Algorand\":\n            from generators import algorand\n            self.crypto = algorand.Algobot()\n\n\n\n\n\n    def manager(self, iter, method):\n        \"\"\"The main method managed the iteration ,call other methods and save the result in the BD calling a Bd module\"\"\"\n        #result = self.check_method_online()\n\n        # vaiable for statistics\n        temp_match = 0\n        temp_nf = 0\n        temp_error = 0\n        temp_critical_error = 0\n        #how much iterations\n\n        if method == 'online':\n            for i in range(0,iter):\n                \n                #make call to the api online\n                keys = self.crypto.generate_keypair()\n                if keys[0] == False:\n                    print('critical error')\n                    exit()\n\n                result = self.online.check_method_online(keys)\n                \n                \n                # the answer is ok\n                if result[0] == 'ok':\n\n                    #the answer have amount or assets > 0\n                    print(result[1]['acuracy'])\n                    if result[1]['acuracy'] == 'good':\n                        self.db.added_match(200, result[1]['acuracy'], result[1]['direction'][0],result[1]['direction'][1],result[1]['amount'],result[1]['assets'])\n\n                    elif result[1]['acuracy'] == 'bad':\n                        self.db.added_match(200, result[1]['acuracy'], result[1]['direction'][0],result[1]['direction'][1])\n                    temp_match = temp_match + 1\n                elif result[0] == 'error_not_handler':\n                    try:\n                        self.db.added_error(result[1], result[2])\n                    except Exception as err:\n                        self.db.added_error('999', 'internal error when try to save error not handler: {miss}'.format(miss = err) )\n                    temp_error = temp_error + 1\n                elif result[0] == 'error':\n                    if result[1] == 'not_content':\n                        print('Critical error, not content found in the response of the api online \\n Are you connected to internet?')\n                        print('\\n status code: ', result[2])\n                        temp_critical_error = temp_critical_error + 1\n                        #remove this\n                        self.db.added_error(900, result[2])\n                        \n                    elif result[1] == 'Not Found':\n                        #normal error when the account is new\n                        #100 is for new address\n                        # not make nothing for now\n                        temp_nf = temp_nf + 1\n                        # \n                        self.db.added_error(900, result[2])\n                    \n                    elif result[1] == 'undeterminate for now':\n                        #900 for unidentified error\n\n                        # !!Atention!! . THIS CONDITIONAL WORK WITH ERROR. MAKE THE SAME OF 'NOT FOUND' COINDITIONAL\n                        \n\n                        # disable for make less petition to the database. now dont save the not found results, only stdistics save\n                        #print(self.db.added_error(900, result[2]['message']))\n                        \n                        temp_nf = temp_nf + 1\n\n\n                    # Area for insert new logs\n                    # determine if is the first 100 request (stadistics is save after 100 request)\n                if i == 100:\n\n                    self.db.added_std(False, temp_match,temp_nf,temp_error,temp_critical_error)\n                    self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n\n                    #more that 100 need update the session , not create a new session\n                elif i % 100 == 0 and i > 100:\n\n                    print(self.db.added_std(True, temp_match,temp_nf,temp_error,temp_critical_error))\n                    self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n\n\n            #send stadistics to the database when the loop is finished and iteration < 100\n            if iter < 100:\n                self.db.added_std(False, temp_match,temp_nf,temp_error,temp_critical_error)\n                self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n\n            elif iter > 100 and (iter - 1) % 100 != 0:\n                self.db.added_std(True, temp_match,temp_nf,temp_error,temp_critical_error)\n                self.report.reporting(temp_nf,temp_match,temp_error,temp_critical_error)\n            \n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # options for get results in database or\n    options = []\n    print('Select your action \\n 1. search \\n 2. get report \\n 3. get match \\n 4. get_error')\n    x = int(input('write: '))\n    if x == 1:\n        options.append(1)\n    elif x == 2:\n        options.append(2)\n\n    elif x == 3:\n        options.append(3)\n\n    elif x == 4:\n        options.append(4)\n    else:\n        print('error')\n        exit()\n\n    if options[0] == 1:\n        print('Write the number of your objetive blockchain \\n 1. Algorand ')\n        x = int(input('number: '))\n        if x == 1:\n            options.append('Algorand')\n        else:\n            print('error')\n            exit()\n\n        print('Write the number of your database \\n 1. postgresql \\n 2. sqlite3')\n        x = int(input('number: '))\n        if x == 1:\n            options.append('postgresql')\n        elif x == 2:\n            options.append('sqlite')\n        else:\n            print('error')\n            exit()\n\n        print('Write the number of your method \\n 1. Online')\n        x = int(input('number: '))\n        if x == 1:\n            options.append('online')\n        else:\n            print('error')\n            exit()\n\n        print(\"set the iter number\")\n        try:\n            itern = int(input(\"max iter :  \"))\n        except:\n            print(\"write only integer numbers\")\n\n        Coin = Coinbot(options[1],options[2])\n        print(options)\n        Coin.manager(itern, options[3])\n        exit()\n\n\n    Coin = Coinbot('Algorand','postgresql')\n\n\n    if options[0] == 2:\n        print(Coin.db.getter_report())\n        exit()\n    elif options[0] == 3:\n        print(Coin.db.getter_match())\n        exit()\n    elif options[0] == 4:\n        print(Coin.db.getter_error())\n        exit()"}
{"file_path": "https://github.com/cusma/pe-de-manga/blob/4b2fde7681ff06232d071a60c7fb9ee83b356d57/pe_de_manga_smart_contract.py", "code": "https://github.com/major/fedora-rpm-specs/blob/28cd4e4325ce70550cb235b8c2e28beefbf09fe5/specs/python-py-algorand-sdk.spec"}
{"file_path": "https://github.com/seetadev/RoadOps/blob/347105e2c5df3247c9bd9ef0a669444b7c13b281/dev/algorand/arc-0020/smart_asa_asc.py", "code": "%global pypi_name py-algorand-sdk\nName:           python-%{pypi_name}\nVersion:        2.8.0\nRelease:        1%{?dist}\nSummary:        Algorand Python SDK\nLicense:        MIT\n\nURL:            https://github.com/algorand/py-algorand-sdk\nSource0:        https://github.com/algorand/py-algorand-sdk/archive/v%{version}/py-algorand-sdk-%{version}.tar.gz\nSource1:        https://raw.githubusercontent.com/algorand/py-algorand-sdk/develop/LICENSE\n\nBuildArch:      noarch\n\nBuildRequires:  python3-devel\nBuildRequires:  python3-setuptools\nBuildRequires:  python3-pynacl\nBuildRequires:  python3-pycryptodomex\nBuildRequires:  python3-msgpack\n\n\n%description\nA python library for interacting with the Algorand network.\n\n%package -n python3-%{pypi_name}\nSummary:        %{summary}\n\n%description -n python3-%{pypi_name}\nA python library for interacting with the Algorand network.\n\n%prep\n%setup -q -n %{pypi_name}-%{version}\n\n\n%build\n%py3_build\n\ncp %{SOURCE1} .\n\n%install\n%py3_install\n\n%files -n python3-%{pypi_name}\n%license LICENSE\n%doc README.md\n%{python3_sitelib}/algosdk\n%{python3_sitelib}/py_algorand_sdk-%{version}-py%{python3_version}.egg-info\n\n%changelog\n* Fri Feb 14 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.8.0-1\n- 2.8.0\n\n* Sat Jan 18 2025 Fedora Release Engineering <releng@fedoraproject.org> - 2.7.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_42_Mass_Rebuild\n\n* Wed Jan 15 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.7.0-1\n- 2.7.0\n\n* Fri Jul 19 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.6.1-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_41_Mass_Rebuild\n\n* Wed Jun 12 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.1-1\n- 2.6.1\n\n* Sat Jun 08 2024 Python Maint <python-maint@redhat.com> - 2.6.0-2\n- Rebuilt for Python 3.13\n\n* Wed Jun 05 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.0-1\n- 2.6.0\n\n* Fri Jan 26 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild\n\n* Mon Jan 22 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild\n\n* Wed Sep 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.5.0-1\n- 2.5.0\n\n* Thu Aug 17 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.4.0-1\n- 2.4.0\n\n* Fri Jul 21 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.3.0-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_39_Mass_Rebuild\n\n* Thu Jun 15 2023 Python Maint <python-maint@redhat.com> - 2.3.0-2\n- Rebuilt for Python 3.12\n\n* Wed Jun 14 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.3.0-1\n- 2.3.0\n\n* Mon May 08 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.2.0-1\n- 2.2.0\n\n* Thu Mar 23 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.2-1\n- 2.1.2\n\n* Mon Mar 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.1-1\n- 2.1.1\n\n* Wed Mar 15 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.0-1\n- 2.1.0\n\n* Fri Mar 03 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-3\n- migrated to SPDX license\n\n* Fri Jan 20 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.0.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_38_Mass_Rebuild\n\n* Wed Jan 04 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-1\n- 2.0.0\n\n* Mon Dec 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.2-1\n- 1.20.2\n\n* Thu Nov 10 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.1-1\n- 1.20.1\n\n* Wed Nov 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.0-1\n- 1.20.0\n\n* Wed Oct 12 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.19.0-1\n- 1.19.0\n\n* Mon Sep 19 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.18.0-1\n- 1.18.0\n\n* Thu Aug 18 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.1-1\n- 1.16.1\n\n* Mon Jul 25 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.0-1\n- 1.16.0\n\n* Fri Jul 22 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.15.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_37_Mass_Rebuild\n\n* Wed Jul 06 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.15.0-1\n- 1.15.0\n\n* Mon Jun 13 2022 Python Maint <python-maint@redhat.com> - 1.13.1-2\n- Rebuilt for Python 3.11\n\n* Thu May 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.1-1\n- 1.13.1\n\n* Mon May 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.0-1\n- 1.13.0\n\n* Thu Apr 21 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.12.0-1\n- 1.12.0\n\n* Fri Jan 21 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.8.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_36_Mass_Rebuild\n\n* Wed Oct 06 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.8.0-1\n- 1.8.0\n\n* Wed Aug 04 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.7.0-1\n- 1.7.0\n\n* Fri Jul 23 2021 Fedora Release Engineering <releng@fedoraproject.org> - 1.6.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_35_Mass_Rebuild\n\n* Thu Jun 24 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.6.0-1\n- 1.6.0\n\n* Fri Jun 04 2021 Python Maint <python-maint@redhat.com> - 1.5.0-2\n- Rebuilt for Python 3.10\n\n* Thu Apr 22 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.5.0-1\n- 1.5.0\n\n* Tue Mar 09 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.4.1-1\n- Initial package."}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/voting_process/voting.py", "code": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/setup.py"}
{"file_path": "https://github.com/Ecosteer-SRL/dvco-algorand/blob/00c9b22b07980fe9f6ced4363862aa7d05c6c416/worker/worker_algorand.py", "code": "#!/usr/bin/env python3\n\nimport setuptools\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"pyteal\",\n    version=\"0.27.0\",\n    author=\"Algorand\",\n    author_email=\"pypiservice@algorand.com\",\n    description=\"Algorand Smart Contracts in Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/algorand/pyteal\",\n    packages=setuptools.find_packages(\n        include=(\n            \"feature_gates\",\n            \"pyteal\",\n            \"pyteal.*\",\n        )\n    ),\n    install_requires=[\n        # when changing this list, also update docs/requirements.txt\n        \"docstring-parser==0.14.1\",\n        \"executing==2.0.1\",\n        \"py-algorand-sdk>=2.0.0,<3.0.0\",\n        \"semantic-version>=2.9.0,<3.0.0\",\n        \"tabulate>=0.9.0,<0.10.0\",\n    ],\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    package_data={\"pyteal\": [\"*.pyi\", \"py.typed\"]},\n    python_requires=\">=3.10\",\n)"}
{"file_path": "https://github.com/Fracture-Labs/FractureDAO/blob/c41923fed2b894e4fde9b7dc1c687917beff4d5a/contract/contract.py", "code": "https://github.com/algorandfoundation/docs/blob/85a8af923b2377a6037652372caad238f7f26803/scripts/import_examples.py"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/is_deletable.py", "code": "#!/usr/bin/env python3\n\nimport os\nimport textwrap\nfrom dataclasses import dataclass\n\nSKIP_DIRS = [\".venv\", \"__pycache__\", \"node_modules\"]\n\n\n@dataclass\nclass ExampleSource:\n    \"\"\"Represents a source for examples\"\"\"\n\n    #: url to the github repo\n    github_url: str\n    #: branch name where examples can be found\n    git_branch: str\n    #: where to find the local repo\n    local_dir: str\n    #: where to find the example files\n    example_dir: str\n    #: full name of language\n    language_name: str\n    #: what to look for as a prefix in source examples\n    src_comment_flag: str\n    #: what file extensions to consider\n    file_extension: str\n    #: name for example source\n    name: str\n\n    def doc_comment_flag(self) -> str:\n        return f\"<!-- ==={self.name}_\"\n\n    def clone_url(self) -> str:\n        return f\"{self.github_url}.git\"\n\n    def file_url(self, file_name: str) -> str:\n        if file_name.startswith(self.example_path()):\n            file_name = file_name[len(self.example_path()) + 1 :]\n\n        return (\n            f\"{self.github_url}/blob/{self.git_branch}/{self.example_dir}/{file_name}\"\n        )\n\n    def example_path(self) -> str:\n        return f\"{self.local_dir}/{self.example_dir}\"\n\n\n@dataclass\nclass Example:\n    \"\"\"Represents a tagged example in source file\"\"\"\n\n    path: str\n    line_start: int\n    lines: list[str]\n    matches: int\n\n\n@dataclass\nclass DocExampleMatch:\n    \"\"\"Represents a match between source and docs\"\"\"\n\n    name: str\n    apply_tabs: bool\n    line_start: int\n    line_stop: int\n\n    @staticmethod\n    def empty() -> \"DocExampleMatch\":\n        return DocExampleMatch(\"\", False, 0, 0)\n\n\n# Example Name => source lines\nSDKExamples = dict[str, Example]\n\nsources: list[ExampleSource] = [\n    ExampleSource(\n        github_url=\"https://github.com/algorand/py-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../py-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"PYSDK\",\n        file_extension=\".py\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/js-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../js-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"javascript\",\n        src_comment_flag=\"// example: \",\n        name=\"JSSDK\",\n        file_extension=\".ts\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/go-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../go/src/github.com/algorand/go-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"go\",\n        src_comment_flag=\"\\t// example: \",\n        name=\"GOSDK\",\n        file_extension=\".go\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/java-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../java-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"java\",\n        src_comment_flag=\"// example: \",\n        name=\"JAVASDK\",\n        file_extension=\".java\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand-devrel/algorand-teal-examples\",\n        git_branch=\"examples\",\n        local_dir=\"../../algorand-teal-examples\",\n        example_dir=\"examples\",\n        language_name=\"teal\",\n        src_comment_flag=\"// example: \",\n        name=\"TEAL\",\n        file_extension=\".teal\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/barnjamin/pyteal\",\n        git_branch=\"examples\",\n        local_dir=\"../../pyteal\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"PYTEAL\",\n        file_extension=\".py\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand-devrel/beaker\",\n        git_branch=\"examples\",\n        local_dir=\"../../beaker\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"BEAKER\",\n        file_extension=\".py\",\n    ),\n]\n\n\ndef find_examples_in_sdk(dir: str, prefix: str, lang: str, ext: str) -> SDKExamples:\n    directory = os.listdir(dir)\n\n    name_to_src: SDKExamples = {}\n    for fname in directory:\n        if fname in SKIP_DIRS:\n            continue\n\n        path = os.path.join(dir, fname)\n        if not os.path.isfile(path):\n            name_to_src |= find_examples_in_sdk(path, prefix, lang, ext)\n        elif os.path.splitext(path)[-1] == ext:\n            local_example: list[str] = []\n            with open(path, \"r\") as f:\n                content = f.read()\n                if prefix not in content:\n                    continue\n\n                lines = content.splitlines()\n                for lno, line in enumerate(lines):\n                    if prefix in line:\n                        name = line.strip(prefix)\n                        formatted_example = textwrap.dedent(\n                            \"\\n\".join(local_example)\n                        ).split(\"\\n\")\n                        name_to_src[name] = Example(\n                            path=path,\n                            line_start=lno - len(local_example),\n                            lines=formatted_example,\n                            matches=0,\n                        )\n                        local_example = []\n                    else:\n                        local_example.append(line)\n\n    return name_to_src\n\n\ndef replace_matches_in_docs(\n    dir: str, prefix: str, examples: SDKExamples, src: ExampleSource\n):\n    \"\"\"recursively search in directory for string prefix\"\"\"\n    directory = os.listdir(dir)\n    for fname in directory:\n        path = os.path.join(dir, fname)\n        if not os.path.isfile(path):\n            # recurse through directories\n            replace_matches_in_docs(path, prefix, examples, src)\n            continue\n        elif path[-2:] != \"md\":\n            continue\n\n        page_lines: list[str] = []\n        matches: list[DocExampleMatch] = []\n        current_match = DocExampleMatch.empty()\n\n        with open(path, \"r\") as f:\n            content = f.read()\n            if prefix not in content:\n                continue\n\n            page_lines = content.splitlines()\n            for lno, line in enumerate(page_lines):\n                if prefix not in line:\n                    continue\n\n                # First time finding this one\n                if current_match.name == \"\":\n                    # Its in the tabbed multilanguage section\n                    if \"===\" in page_lines[lno - 1]:\n                        current_match.apply_tabs = True\n\n                    current_match.name = line.strip()[len(prefix) :].strip(\"= ->_\")\n                    current_match.line_start = lno + 1\n                # Second time finding it, add it to matches and wipe current\n                else:\n                    current_match.line_stop = lno\n                    matches.append(current_match)\n                    current_match = DocExampleMatch.empty()\n\n        if len(matches) == 0:\n            continue\n\n        # Need to track the offset here so we dont write to the\n        # wrong spot in the doc file if the example is longer or shorter\n        # than the current set of lines in the docs\n        offset = 0\n        for match in matches:\n\n            if match.name not in examples:\n                print(\n                    f\"Missing {match.name} in {prefix.strip(' -<!=_')} \"\n                    f\"examples (in {path}:{match.line_start})\"\n                )\n                continue\n\n            src_example = examples[match.name]\n\n            example_link = (\n                src.file_url(src_example.path)\n                + f\"#L{src_example.line_start}-\"\n                + f\"L{src_example.line_start + len(src_example.lines)}\"\n            )\n\n            example_lines = [\n                \"```\" + src.language_name,\n                *src_example.lines,\n                \"```\",\n                f\"[Snippet Source]({example_link})\",\n            ]\n\n            if match.apply_tabs:\n                example_lines = [\"\\t\" + l for l in example_lines]\n\n            page_lines[\n                match.line_start + offset : match.line_stop + offset\n            ] = example_lines\n\n            offset += len(example_lines) - (match.line_stop - match.line_start)\n\n            examples[match.name].matches += 1\n\n        with open(path, \"w\") as f:\n            f.write(\"\\n\".join(page_lines))\n\n    return examples\n\n\ndef ensure_source(src: ExampleSource):\n    import git\n\n    if not os.path.isdir(src.local_dir):\n        git.Repo.clone_from(src.clone_url(), src.local_dir, branch=src.git_branch)\n    else:\n        repo = git.Repo(src.local_dir)\n        repo.git.checkout(src.git_branch)\n\n\nif __name__ == \"__main__\":\n\n    names = [src.name for src in sources]\n\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Gather examples from source repos\")\n    parser.add_argument(\n        \"--src\",\n        metavar=\"name\",\n        type=str,\n        nargs=\"*\",\n        choices=names,\n        help=\"source names to pull (default: all)\",\n    )\n\n    args = parser.parse_args()\n    choices = args.src\n    if choices is None:\n        choices = names\n\n    for src in sources:\n        if src.name not in choices:\n            continue\n\n        ensure_source(src)\n\n        sdk_examples = find_examples_in_sdk(\n            src.example_path(),\n            src.src_comment_flag,\n            src.language_name,\n            src.file_extension,\n        )\n\n        replace_matches_in_docs(\"../docs\", src.doc_comment_flag(), sdk_examples, src)\n\n        for name, example in sdk_examples.items():\n            if example.matches == 0:\n                print(\n                    f\"Missing {name} for {src.language_name} in docs \"\n                    f\"(in: {example.path}:{example.line_start})\"\n                )"}
{"file_path": "https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/adaptors/algod_application.py", "code": "https://github.com/demining/CryptoDeepTools/blob/206484942dbcf4b9996fa5bcc14181138c557697/17BTCRecoverCryptoGuide/utilities/algorand_recovery.py"}
{"file_path": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/permissioned-voting/assets/permissioned-voting-approval.py", "code": "# A really basic Algorand seed recovery script used in an assisted recovery. (May be incorporated to BTCRecover at some time)\n# Usage: Clone the py-algorand-sdk and place this file in the folder. Edit the test_seed_cut to match your seed.\n# Example below uses a seed with two words missing.\n\nfrom algosdk import mnemonic\n\ntest_seed = (\"dumb essay favorite judge punch hood anger under \"\n             \"talk earn anxiety follow scheme sea future response \"\n             \"asset drum size concert sand loan cupboard above bread\")\n\ntest_seed_cut = (\"dumb essay favorite judge punch hood anger under \"\n            \"talk earn anxiety follow scheme sea future response \"\n            \"asset drum size concert sand loan cupboard\")\n\n\ntest_address = \"LZW5ASZP2DQQGM77EFFUGXUF4DUQPUJEOC5HSQ2TOXKQZQM5H6M2OGK6QY\"\n\n\nif __name__ == \"__main__\":\n    word_list = mnemonic.wordlist.word_list_raw().split(\"\\n\")\n    word_list2 = mnemonic.wordlist.word_list_raw().split(\"\\n\")\n    print(\"Partial Seed: \" + test_seed_cut)\n    print(\"Searching for: \" + test_address)\n    for word in word_list:\n        for word2 in word_list2:\n            try:\n                if(mnemonic.to_public_key(test_seed_cut + \" \" + word + \" \" + word2) == test_address):\n                    print(\"Found At:\")\n                    print(test_seed_cut + \" \" + word + \" \" + word2)\n                    print()\n                    exit()\n            except:\n                pass"}
{"file_path": "https://github.com/defimono/algorand_asset_price_oracle/blob/8a2d410737d0795ea2f5a7e497b03f39e84af00c/handler.py", "code": "https://github.com/ebellocchia/bip_utils/blob/05ebc890133f135401980bb8ac0da3d9e172482f/bip_utils/algorand/mnemonic/algorand_mnemonic_encoder.py"}
{"file_path": "https://github.com/aldur/tc-asa/blob/3570860ecc32d92ace483e2f3472b0a301f4cdc2/tc_asa.py", "code": "# Copyright (c) 2021 Emanuele Bellocchia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\"\"\"\nModule for Algorand mnemonic encoding.\nReference: https://github.com/algorand/py-algorand-sdk\n\"\"\"\n\n# Imports\nfrom typing import List\n\nfrom bip_utils.algorand.mnemonic.algorand_entropy_generator import AlgorandEntropyGenerator\nfrom bip_utils.algorand.mnemonic.algorand_mnemonic import AlgorandLanguages, AlgorandMnemonic\nfrom bip_utils.algorand.mnemonic.algorand_mnemonic_utils import AlgorandMnemonicUtils\nfrom bip_utils.bip.bip39.bip39_mnemonic_utils import Bip39WordsListGetter\nfrom bip_utils.utils.mnemonic import Mnemonic, MnemonicEncoderBase\n\n\nclass AlgorandMnemonicEncoder(MnemonicEncoderBase):\n    \"\"\"\n    Algorand mnemonic encoder class.\n    It encodes bytes to the mnemonic phrase.\n    \"\"\"\n\n    def __init__(self,\n                 lang: AlgorandLanguages = AlgorandLanguages.ENGLISH) -> None:\n        \"\"\"\n        Construct class.\n\n        Args:\n            lang (AlgorandLanguages, optional): Language (default: English)\n\n        Raises:\n            TypeError: If the language is not a AlgorandLanguages enum\n            ValueError: If loaded words list is not valid\n        \"\"\"\n        if not isinstance(lang, AlgorandLanguages):\n            raise TypeError(\"Language is not an enumerative of AlgorandLanguages\")\n        super().__init__(lang.value, Bip39WordsListGetter)\n\n    def Encode(self,\n               entropy_bytes: bytes) -> Mnemonic:\n        \"\"\"\n        Encode bytes to mnemonic phrase.\n\n        Args:\n            entropy_bytes (bytes): Entropy bytes\n\n        Returns:\n            Mnemonic object: Encoded mnemonic\n\n        Raises:\n            ValueError: If bytes length is not valid\n        \"\"\"\n\n        # Check entropy length\n        entropy_byte_len = len(entropy_bytes)\n        if not AlgorandEntropyGenerator.IsValidEntropyByteLen(entropy_byte_len):\n            raise ValueError(f\"Entropy byte length ({entropy_byte_len}) is not valid\")\n\n        # Compute checksum word\n        chksum_word_idx = AlgorandMnemonicUtils.ComputeChecksumWordIndex(entropy_bytes)\n        # Convert entropy bytes to a list of word indexes\n        word_indexes = AlgorandMnemonicUtils.ConvertBits(entropy_bytes, 8, 11)\n        # Cannot be None by converting bytes from 8-bit to 11-bit\n        assert word_indexes is not None\n        # Get mnemonic\n        return AlgorandMnemonic.FromList(self.__IndexesToWords(word_indexes + [chksum_word_idx]))\n\n    def __IndexesToWords(self,\n                         indexes: List[int]) -> List[str]:\n        \"\"\"\n        Get a list of words from a list of indexes.\n\n        Args:\n            indexes (list[int]): List of indexes\n\n        Returns:\n            list[str]: List of words\n        \"\"\"\n        return [self.m_words_list.GetWordAtIdx(idx) for idx in indexes]"}
{"file_path": "https://github.com/natyrix/algorand/blob/2bd1d8ee68e74cbc6a0e6d35ff83fef89b2dac08/scripts/smart_contract.py", "code": "https://github.com/runtimeverification/avm-semantics/blob/5cd370b7a14bab2ad64d554908f6b6ac62c027e5/kavm/src/kavm/algod.py"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/plugin_example/rekey_plugin/tealer_rekey_plugin/detectors/rekeyto_stateless.py", "code": "import json\nimport logging\nimport os\nfrom base64 import b64encode\nfrom pathlib import Path\nfrom pprint import PrettyPrinter\nfrom typing import Any, Dict, Final, Iterable, List, Optional, cast\n\nimport msgpack\nfrom algosdk import encoding\nfrom algosdk.atomic_transaction_composer import (\n    ABI_RETURN_HASH,\n    ABIResult,\n    AtomicTransactionComposer,\n    AtomicTransactionComposerStatus,\n    AtomicTransactionResponse,\n    abi,\n    base64,\n    error,\n    transaction,\n)\nfrom algosdk.error import AlgodHTTPError\nfrom algosdk.future.transaction import PaymentTxn, Transaction\nfrom algosdk.v2client import algod\nfrom pyk.kore.syntax import Pattern\n\nfrom kavm import constants\nfrom kavm.adaptors.algod_account import KAVMAccount\nfrom kavm.adaptors.algod_transaction import KAVMTransaction\nfrom kavm.kavm import KAVM\nfrom kavm.scenario import KAVMScenario, _sort_dict\n\n_LOGGER: Final = logging.getLogger(__name__)\n\n\ndef msgpack_decode_txn_list(enc: bytes) -> List[Transaction]:\n    \"\"\"\n    Decode a msgpack encoded object from a string.\n    Args:\n        enc (str): string to be decoded\n    Returns:\n        []Transaction, []SignedTransaction, []Multisig, []Bid, or []SignedBid:\\\n            decoded object\n\n    Note: This is the missing list decoder from py-algorand-sdk\n    \"\"\"\n    unpacker = msgpack.Unpacker()\n    unpacker.feed(enc)\n    deserialized = []\n    while unpacker.tell() < len(enc):\n        decoded = encoding.future_msgpack_decode(unpacker.unpack())\n        deserialized.append(decoded)\n    return deserialized\n\n\nclass KAVMClient(algod.AlgodClient):\n    \"\"\"\n    Mock class for algod. Forwards all requests to KAVM\n\n    Instead of establishing a connection with algod:\n    * initialize KAVM,\n    * pretend it is algod.\n    \"\"\"\n\n    def __init__(\n        self,\n        faucet_address: str,\n        algod_token: Optional[str] = None,\n        algod_address: Optional[str] = None,\n        log_level: Optional[int] = None,\n    ) -> None:\n        super().__init__(algod_token, algod_address)\n        self.pretty_printer = PrettyPrinter(width=41, compact=True)\n\n        # self._apps = AppCellMap()\n        self._committed_txns: Dict[str, Dict[str, Any]] = {}\n        self._faucet_address = faucet_address\n        self._accounts: Dict[str, KAVMAccount] = {\n            self._faucet_address: KAVMAccount(address=faucet_address, amount=constants.FAUCET_ALGO_SUPPLY)\n        }\n        self._decompiled_teal_dir_path = Path('./.decompiled-teal').resolve()\n        self._decompiled_teal_dir_path.mkdir(exist_ok=True)\n\n        self._app_creators: Dict[int, str] = {}\n        # Initialize KAVM, fetching the K definition dir from the environment\n        definition_dir = os.environ.get('KAVM_DEFINITION_DIR')\n        if definition_dir is not None:\n            self.kavm = KAVM(definition_dir=Path(definition_dir))\n            self.kavm.definition\n        else:\n            _LOGGER.critical('Cannot initialize KAVM: KAVM_DEFINITION_DIR env variable is not set')\n            exit(1)\n\n    def set_log_level(self, log_level: Any) -> None:\n        \"\"\"\n        Set log level for algod requests\n        \"\"\"\n        _LOGGER.setLevel(log_level)\n\n    def algod_request(\n        self,\n        method: str,\n        requrl: str,\n        params: Optional[List[str]] = None,\n        data: Optional[bytes] = None,\n        headers: Optional[List[str]] = None,\n        response_format: str = 'Json',\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Log requests made to algod, but execute local actions instead\n\n        Need to override this method, and the more specific methods using it can remain the same.\n        \"\"\"\n\n        if method == 'GET':\n            return self._handle_get_requests(requrl)\n        elif method == 'POST':\n            return self._handle_post_requests(requrl, data)\n        else:\n            raise NotImplementedError(f'{method} {requrl}')\n\n    def _handle_get_requests(self, requrl: str) -> Dict[str, Any]:\n        \"\"\"\n        Handle GET requests to algod with KAVM\n        \"\"\"\n        _, endpoint, *params = requrl.split('/')\n\n        if endpoint == 'transactions':\n            if params[0] == 'params':\n                return {\n                    'consensus-version': 31,\n                    'fee': 1000,\n                    'genesis-id': 'pyteal-eval',\n                    'genesis-hash': 'pyteal-evalpyteal-evalpyteal-evalpyteal-eval',\n                    'last-round': 1,\n                    'min-fee': 1000,\n                }\n            elif params[0] == 'pending':\n                if len(params) >= 2:\n                    try:\n                        return self._committed_txns[params[1]]\n                    # hack to temporarily make py-algorand-sdk happy:\n                    # if the txn id is not found, return the last committed txn\n                    except KeyError:\n                        (_, txn) = sorted(self._committed_txns.items())[-1]\n                        return txn\n                else:\n                    raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n            else:\n                raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n        elif endpoint == 'accounts':\n            if len(params) == 1:\n                address = params[0]\n                try:\n                    return self._accounts[address].dictify()\n                except KeyError:\n                    _LOGGER.warning(\n                        f'Account {address} is unknown to KAVM. Returing an account with the requested address and 0 balance to the client'\n                    )\n                    return KAVMAccount(address=address, amount=0).dictify()\n            else:\n                raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n        elif endpoint == 'applications':\n            app_id = int(params[0])\n            try:\n                creator_address = self._app_creators[app_id]\n            except KeyError as e:\n                raise ValueError(f'Cannot find creator of app {app_id}') from e\n            try:\n                result = list(filter(lambda app: app['id'] == app_id, self._accounts[creator_address].created_apps))\n                return result[0]\n            except (KeyError, IndexError) as e:\n                raise ValueError(\n                    f'Cannot find app with id {app_id} in account {self._accounts[creator_address]}'\n                ) from e\n        elif endpoint == 'status':\n            return {\n                'catchup-time': 0,\n                'last-round': 1000000000000000,\n                'last-version': 'kavm',\n                'next-version': 'kavm',\n                'next-version-round': 0,\n                'next-version-supported': True,\n                'stopped-at-unsupported-round': True,\n                'time-since-last-round': 0,\n                'last-catchpoint': 'kavm',\n                'catchpoint': 'kavm',\n                'catchpoint-total-accounts': 0,\n                'catchpoint-processed-accounts': 0,\n                'catchpoint-verified-accounts': 0,\n                'catchpoint-total-blocks': 0,\n                'catchpoint-acquired-blocks': 0,\n            }\n        else:\n            _LOGGER.debug(requrl.split('/'))\n            raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n    def _pending_transaction_info(self, txid: int) -> Dict[str, Any]:\n        \"\"\"\n        Fetch info about a pending transaction from KAVM\n\n        Fow now, we return any transction as confirmed\n\n        returns:\n            PendingTransactionResponse https://github.com/algorand/go-algorand/tree/master/daemon/algod/api/algod.oas2.json#L2600\n\n        \"\"\"\n        return {'confirmed-round': 1}\n\n    def _handle_post_requests(self, requrl: str, data: Optional[bytes]) -> Dict[str, Any]:\n        \"\"\"\n        Handle POST requests to algod with KAVM\n        \"\"\"\n        # handle transaction group submission\n        if requrl == '/transactions':\n            assert data is not None, 'attempt to submit an empty transaction group!'\n            # decode signed transactions from binary into py-algorand-sdk objects\n            txns = [t.transaction for t in msgpack_decode_txn_list(data)]\n            txn_msg = self.pretty_printer.pformat(txns)\n            f'POST {requrl} {txn_msg}'\n            # log decoded transaction as submitted\n\n            return self._eval_transactions(txns)\n\n            # _LOGGER.debug(proc_result.stdout)\n            # assert False\n\n            # return self.kavm.eval_transactions(kavm_txns, known_addresses)\n        elif requrl == '/teal/compile':\n            assert data is not None, 'attempt to compile an empty TEAL program!'\n            # we do not actually compile the program since KAVM needs the source code\n            return {'result': b64encode(data)}\n        else:\n            raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n    def intermediate_k_state(self) -> Pattern:\n        # Construct a json scenario with no transactions and execute just the setup-network stage\n        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=[])\n        final_state, kavm_stderr = self.kavm.run_avm_json(\n            scenario=scenario, existing_decompiled_teal_dir=self._decompiled_teal_dir_path, check=False, output=\"pretty\"\n        )\n        return final_state\n\n    def _eval_transactions(self, txns: List[Transaction]) -> Dict[str, str]:\n        \"\"\"\n        Evaluate a transaction group\n        Parameters\n        ----------\n        txns\n            List[Transaction]\n\n        Construct a simulation scenario, serialize it into JSON and submit to KAVM.\n        Parse KAVM's resulting configuration and update the account state in KAVMClient.\n        \"\"\"\n\n        # we'll need too keep track of all addresses the transactions mention to\n        # make KAVM aware of the new ones, so we preprocess the transactions\n        # to dicover new addresses and initialize them with 0 balance\n        for txn in txns:\n            if not txn.sender in self._accounts.keys():\n                self._accounts[txn.sender] = KAVMAccount(address=txn.sender, amount=0)\n            if hasattr(txn, 'receiver'):\n                txn = cast(PaymentTxn, txn)\n                if not txn.receiver in self._accounts.keys():\n                    self._accounts[txn.receiver] = KAVMAccount(address=txn.receiver, amount=0)\n\n        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=txns)\n        self._last_scenario = scenario\n\n        try:\n            final_state, kavm_stderr = self.kavm.run_avm_json(\n                scenario=scenario,\n                existing_decompiled_teal_dir=self._decompiled_teal_dir_path,\n            )\n        except RuntimeError as e:\n            _LOGGER.critical(\n                f'Transaction group evaluation failed, last generated scenario was: {json.dumps(scenario.dictify(), indent=4)}'\n            )\n            raise AlgodHTTPError(\n                msg='KAVM has failed, rerun witn --log-level=ERROR to see the executed JSON scenario'\n            ) from e\n\n        try:\n            # on succeful execution, the final state will be serialized and prineted to stderr\n            state_dump = json.loads(kavm_stderr)\n            assert type(state_dump) is dict\n        except json.decoder.JSONDecodeError as e:\n            _LOGGER.critical(f'Failed to parse the final state JSON: {e}')\n            raise AlgodHTTPError(msg='KAVM has failed, see logs for reasons') from e\n\n        _LOGGER.debug(f'Successfully parsed final state JSON: {json.dumps(state_dump, indent=4)}')\n        # substitute the tracked accounts by KAVM's state\n        self._accounts = {}\n        for acc_dict in KAVMScenario.sanitize_accounts(state_dump['accounts']):\n            acc_dict_translated = {KAVMAccount.inverted_attribute_map[k]: v for k, v in acc_dict.items()}\n            self._accounts[acc_dict_translated['address']] = KAVMAccount(**acc_dict_translated)\n            # update app creators\n            for addr, acc in self._accounts.items():\n                for app in acc.created_apps:\n                    self._app_creators[app['id']] = addr\n        # merge confirmed transactions with the ones received from KAVM\n        for txn in state_dump['transactions']:\n            self._committed_txns[txn['id']] = txn['params']\n        return {'txId': state_dump['transactions'][0]['id']}\n\n    def _construct_scenario(self, accounts: Iterable[KAVMAccount], transactions: Iterable[Transaction]) -> KAVMScenario:\n        \"\"\"Construct a JSON simulation scenario to run on KAVM\"\"\"\n        scenario = KAVMScenario.from_json(\n            scenario_json_str=json.dumps(\n                {\n                    \"stages\": [\n                        {\"stage-type\": \"setup-network\", \"data\": {\"accounts\": [acc.dictify() for acc in accounts]}},\n                        {\n                            \"stage-type\": \"submit-transactions\",\n                            \"data\": {\n                                \"transactions\": [\n                                    KAVMTransaction.sanitize_byte_fields(_sort_dict(txn.dictify()))\n                                    for txn in transactions\n                                ]\n                            },\n                            \"expected-returncode\": 0,\n                        },\n                    ]\n                }\n            ),\n            teal_sources_dir=self._decompiled_teal_dir_path,\n        )\n        return scenario\n\n\nclass KAVMAtomicTransactionComposer(AtomicTransactionComposer):\n    \"\"\"\n    This class overrides the 'execute' method of the base AtomicTransactionComposer class\n    by only introducing two lines of code which override the transactions IDs with\n    sequential integers (converted to strings). This is a requirement of KAVM's K implementation.\n    However, if a vanilla 'AlgodClient' is passed as 'clinet', the default transctions ids will be used\n    to maintain compatibility with go-algorand.\n    \"\"\"\n\n    def execute(self, client: algod.AlgodClient, wait_rounds: int) -> \"AtomicTransactionResponse\":\n        \"\"\"\n        Send the transaction group to the network and wait until it's committed\n        to a block. An error will be thrown if submission or execution fails.\n        The composer's status must be SUBMITTED or lower before calling this method,\n        since execution is only allowed once. If submission is successful,\n        this composer's status will update to SUBMITTED.\n        If the execution is also successful, this composer's status will update to COMMITTED.\n        Note: a group can only be submitted again if it fails.\n        Args:\n            client (AlgodClient): Algod V2 client\n            wait_rounds (int): maximum number of rounds to wait for transaction confirmation\n        Returns:\n            AtomicTransactionResponse: Object with confirmed round for this transaction,\n                a list of txIDs of the submitted transactions, and an array of\n                results for each method call transaction in this group. If a\n                method has no return value (void), then the method results array\n                will contain None for that method's return value.\n        \"\"\"\n        if self.status > AtomicTransactionComposerStatus.SUBMITTED:  # type: ignore\n            raise error.AtomicTransactionComposerError(\n                \"AtomicTransactionComposerStatus must be submitted or lower to execute a group\"\n            )\n\n        self.submit(client)\n        self.status = AtomicTransactionComposerStatus.SUBMITTED\n\n        # HACK: override the real transaction ids with sequential integers if running with KAVM\n        # leave them as is otherwise\n        if isinstance(client, KAVMClient):\n            self.tx_ids = [str(idx) for idx, _ in enumerate(self.txn_list)]\n\n        resp = transaction.wait_for_confirmation(client, self.tx_ids[0], wait_rounds)\n\n        self.status = AtomicTransactionComposerStatus.COMMITTED\n\n        confirmed_round = resp[\"confirmed-round\"]\n        method_results = []\n\n        for i, tx_id in enumerate(self.tx_ids):\n            raw_value = None\n            return_value = None\n            decode_error = None\n            tx_info = None\n\n            if i not in self.method_dict:\n                continue\n\n            # Parse log for ABI method return value\n            try:\n                tx_info = client.pending_transaction_info(tx_id)\n                if self.method_dict[i].returns.type == abi.Returns.VOID:\n                    method_results.append(\n                        ABIResult(\n                            tx_id=tx_id,\n                            raw_value=raw_value,\n                            return_value=return_value,\n                            decode_error=decode_error,\n                            tx_info=tx_info,\n                            method=self.method_dict[i],\n                        )\n                    )\n                    continue\n\n                logs = tx_info[\"logs\"] if \"logs\" in tx_info else []\n\n                # Look for the last returned value in the log\n                if not logs:\n                    raise error.AtomicTransactionComposerError(\"app call transaction did not log a return value\")\n                result = logs[-1]\n                # Check that the first four bytes is the hash of \"return\"\n                result_bytes = base64.b64decode(result)\n                if len(result_bytes) < 4 or result_bytes[:4] != ABI_RETURN_HASH:\n                    raise error.AtomicTransactionComposerError(\"app call transaction did not log a return value\")\n                raw_value = result_bytes[4:]\n                return_value = self.method_dict[i].returns.type.decode(raw_value)\n            except Exception as e:\n                decode_error = e\n                raise\n\n            abi_result = ABIResult(\n                tx_id=tx_id,\n                raw_value=raw_value,\n                return_value=return_value,\n                decode_error=decode_error,\n                tx_info=tx_info,\n                method=self.method_dict[i],\n            )\n            method_results.append(abi_result)\n\n        return AtomicTransactionResponse(\n            confirmed_round=confirmed_round,\n            tx_ids=self.tx_ids,\n            results=method_results,\n        )"}
{"file_path": "https://github.com/ChoiceCoin/Voting/blob/abd2cb42d89861560491ca3e88a16991ae276b19/Choice_Coin_Voting/vote.py", "code": "https://github.com/tinymanorg/tinyman-py-sdk/blob/2ab9836b468ee40cce02e4c712a7c7383f116fd3/setup.py"}
{"file_path": "https://github.com/Ecosteer-SRL/dvco-algorand/blob/00c9b22b07980fe9f6ced4363862aa7d05c6c416/worker/worker_algorand.py", "code": "import setuptools\n\n\nwith open(\"README.md\", \"r\") as f:\n    long_description = f.read()\n\nsetuptools.setup(\n    name=\"tinyman-py-sdk\",\n    description=\"Tinyman Python SDK\",\n    author=\"Tinyman\",\n    author_email=\"hello@tinyman.org\",\n    version=\"2.1.1\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n    project_urls={\n        \"Source\": \"https://github.com/tinyman/tinyman-py-sdk\",\n    },\n    install_requires=[\"py-algorand-sdk >= 1.10.0\", \"requests >= 2.0.0\"],\n    packages=setuptools.find_packages(),\n    python_requires=\">=3.8\",\n    package_data={\n        \"tinyman.v1\": [\"asc.json\"],\n        \"tinyman.v2\": [\"amm_approval.map.json\", \"swap_router_approval.map.json\"],\n    },\n    include_package_data=True,\n)"}
{"file_path": "https://github.com/Tao242dn/algo-rpg-cli/blob/75e5ce829abd131fe964909785110608999a66ee/contents.py", "code": "https://github.com/ChoiceCoin/Voting_DApp/blob/1cd5d81c8c6c96fdb542e399e184abe1512a2045/rewards/rewards.py"}
{"file_path": "https://github.com/gwumex/choice/blob/0821bddd5da1f1a4c5710fb0c8372a857600f338/vote.py", "code": "# Choice Coin Governance Rewards Code.\n\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nimport json\nimport urllib3\n\nchoice_id  = 297995609\nvoter_1_address = \"\"\nvoter_1_mnemonic = \"\"\nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\nalgod_client = algod.AlgodClient(\n    algod_token=\"\",\n    algod_address=\"https://api.algoexplorer.io\",\n    # see https://github.com/algorand/py-algorand-sdk/issues/169\n    headers={\"User-Agent\": \"DoYouLoveMe?\"}\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\t\tdata_file = open('file.csv', 'w')\n\t\tcsv_writer = csv.writer(data_file)\n\t\tcount = 0\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\t\tfor transaction in transaction_data:\n\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\tamount = int(amount)\n\t\t\tamount = amount + amount * 0.186 #Edit to match percentage\n\t\t\taddress = transaction['sender']\n\t\t\tid = transaction['id']\n\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"file_path": "https://github.com/ChoiceCoin/Smart_Contracts/blob/785460d5ed406ef3fb7acfaeaa4cf2f8dd54cbfd/Smarter_Contracts_Bash/jessika_Smarter_Contracts_Bash/game.py", "code": "https://github.com/algorand/indexer/blob/f64303b6b373ac30d57577f056e3dad8e956a009/misc/liveindextest.py"}
{"file_path": "https://github.com/crytic/tealer/blob/957ffd63e363fa1a3d68b1b40a8efdd050673fe1/tealer/detectors/fee_check.py", "code": "#!/usr/bin/env python3\n#\n# usage:\n#  python3 misc/liveindextest.py\n#\n# Requires go-algorand to be checked out on GOPATH.\n# Requires local postgresql and `createdb` `dropdb` standard utils.\n# `goal` etc should be built on PATH\n# `algorand-indexer` can be installed on PATH or at its development location from `make` or `go build` at cmd/algorand-indexer/algorand-indexer\n# pip install py-algorand-sdk\n#\n# The Test:\n# Create a local private Algorand network\n# Create a temporary postgres database for indexer\n# Run indexer following the primary algod\n# Submit a txn using py-algorand-sdk\n# Checks that indexer reports that txn by searching for it by txid.\n#\n# Runs in about 30 seconds on my macbook\n\nimport atexit\nimport base64\nimport glob\nimport logging\nimport os\nimport random\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport time\n\nimport algosdk\nimport algosdk.v2client\n\nfrom e2e_common.util import xrun, atexitrun, find_indexer, ensure_test_db\n\nlogger = logging.getLogger(__name__)\n\n\ndef find_go_algorand():\n    gopath = os.getenv(\"GOPATH\")\n    for path in gopath.split(\":\"):\n        goa = os.path.join(path, \"src\", \"github.com\", \"algorand\", \"go-algorand\")\n        if os.path.isdir(goa):\n            return goa\n    return None\n\n\nalready_stopped = False\nalready_deleted = False\n\n\ndef goal_network_stop(netdir, normal_cleanup=False):\n    global already_stopped, already_deleted\n    if already_stopped or already_deleted:\n        return\n\n    logger.info(\"stop network in %s\", netdir)\n    try:\n        xrun([\"goal\", \"network\", \"stop\", \"-r\", netdir], timeout=10)\n    except Exception as e:\n        logger.error(\"error stopping network\", exc_info=True)\n        if normal_cleanup:\n            raise e\n    already_stopped = True\n\n\ndef openkmd(algodata):\n    kmdnetpath = sorted(glob.glob(os.path.join(algodata, \"kmd-*\", \"kmd.net\")))[-1]\n    kmdnet = open(kmdnetpath, \"rt\").read().strip()\n    kmdtokenpath = sorted(glob.glob(os.path.join(algodata, \"kmd-*\", \"kmd.token\")))[-1]\n    kmdtoken = open(kmdtokenpath, \"rt\").read().strip()\n    kmd = algosdk.kmd.KMDClient(kmdtoken, \"http://\" + kmdnet)\n    return kmd\n\n\ndef openalgod(algodata):\n    algodnetpath = os.path.join(algodata, \"algod.net\")\n    algodnet = open(algodnetpath, \"rt\").read().strip()\n    algodtokenpath = os.path.join(algodata, \"algod.token\")\n    algodtoken = open(algodtokenpath, \"rt\").read().strip()\n    algod = algosdk.algod.AlgodClient(algodtoken, \"http://\" + algodnet)\n    return algod\n\n\nclass RunContext:\n    def __init__(self, env):\n        self.env = env\n        self.kmd = None\n        self.algod = None\n        self.lock = threading.Lock()\n        self.pubw = None\n        self.maxpubaddr = None\n\n    def connect(self):\n        with self.lock:\n            self._connect()\n            return self.algod, self.kmd\n\n    def _connect(self):\n        if self.algod and self.kmd:\n            return\n        # should run from inside self.lock\n        xrun([\"goal\", \"kmd\", \"start\", \"-t\", \"200\"], env=self.env, timeout=5)\n        algodata = self.env[\"ALGORAND_DATA\"]\n        self.kmd = openkmd(algodata)\n        self.algod = openalgod(algodata)\n\n    def get_pub_wallet(self):\n        with self.lock:\n            self._connect()\n            if not (self.pubw and self.maxpubaddr):\n                # find private test node public wallet and its richest account\n                wallets = self.kmd.list_wallets()\n                pubwid = None\n                for xw in wallets:\n                    if xw[\"name\"] == \"unencrypted-default-wallet\":\n                        pubwid = xw[\"id\"]\n                pubw = self.kmd.init_wallet_handle(pubwid, \"\")\n                pubaddrs = self.kmd.list_keys(pubw)\n                pubbalances = []\n                maxamount = 0\n                maxpubaddr = None\n                for pa in pubaddrs:\n                    pai = self.algod.account_info(pa)\n                    if pai[\"amount\"] > maxamount:\n                        maxamount = pai[\"amount\"]\n                        maxpubaddr = pai[\"address\"]\n                self.pubw = pubw\n                self.maxpubaddr = maxpubaddr\n            return self.pubw, self.maxpubaddr\n\n    def do_txn(self):\n        pubw, maxpubaddr = self.get_pub_wallet()\n        algod, kmd = self.connect()\n\n        # create a wallet with an addr to send to\n        walletname = base64.b16encode(os.urandom(16)).decode()\n        winfo = kmd.create_wallet(walletname, \"\")\n        handle = kmd.init_wallet_handle(winfo[\"id\"], \"\")\n        addr = kmd.generate_key(handle)\n\n        # send one million Algos to the test wallet's account\n        params = algod.suggested_params()\n        round = params[\"lastRound\"]\n        txn = algosdk.transaction.PaymentTxn(\n            sender=maxpubaddr,\n            fee=params[\"minFee\"],\n            first=round,\n            last=round + 100,\n            gh=params[\"genesishashb64\"],\n            receiver=addr,\n            amt=1000000000000,\n            flat_fee=True,\n        )\n        stxn = kmd.sign_transaction(pubw, \"\", txn)\n        txid = algod.send_transaction(stxn)\n        for i in range(50):\n            txinfo = algod.pending_transaction_info(txid)\n            if txinfo.get(\"round\"):\n                break\n            time.sleep(0.1)\n        return txid, txinfo\n\n\ndef main():\n    start = time.time()\n    import argparse\n\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--go-algorand\", help=\"path to go-algorand checkout\")\n    ap.add_argument(\n        \"--keep-temps\",\n        default=False,\n        action=\"store_true\",\n        help=\"if set, keep all the test files\",\n    )\n    ap.add_argument(\n        \"--indexer-bin\",\n        default=None,\n        help=\"path to algorand-indexer binary, otherwise search PATH\",\n    )\n    ap.add_argument(\n        \"--indexer-port\",\n        default=None,\n        type=int,\n        help=\"port to run indexer on. defaults to random in [4000,30000]\",\n    )\n    ap.add_argument(\n        \"--connection-string\",\n        help=\"Use this connection string instead of attempting to manage a local database.\",\n    )\n    ap.add_argument(\"--verbose\", default=False, action=\"store_true\")\n    args = ap.parse_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        logging.basicConfig(level=logging.INFO)\n\n    indexer_bin = find_indexer(args.indexer_bin)\n    goalgorand = args.go_algorand or find_go_algorand()\n\n    # env for child processes\n    env = dict(os.environ)\n\n    tempdir = os.getenv(\"TEMPDIR\")\n    if not tempdir:\n        tempdir = tempfile.mkdtemp()\n        env[\"TEMPDIR\"] = tempdir\n        logger.info(\"created TEMPDIR %r\", tempdir)\n        if not args.keep_temps:\n            # If we created a tmpdir and we're not keeping it, clean it up.\n            # If an outer process specified $TEMPDIR, let them clean it up.\n            atexit.register(shutil.rmtree, tempdir, onerror=logger.error)\n        else:\n            atexit.register(\n                print, \"keeping temps. to clean up:\\nrm -rf {}\".format(tempdir)\n            )\n\n    netdir = os.path.join(tempdir, \"net\")\n    env[\"NETDIR\"] = netdir\n\n    template = os.path.join(\n        goalgorand, \"test/testdata/nettemplates/TwoNodes50EachFuture.json\"\n    )\n    xrun(\n        [\"goal\", \"network\", \"create\", \"-r\", netdir, \"-n\", \"tbd\", \"-t\", template],\n        timeout=30,\n    )\n    xrun([\"goal\", \"network\", \"start\", \"-r\", netdir], timeout=30)\n    atexit.register(goal_network_stop, netdir)\n\n    algodata = os.path.join(netdir, \"Node\")\n    env[\"ALGORAND_DATA\"] = algodata\n\n    psqlstring = ensure_test_db(args.connection_string, args.keep_temps)\n    primary = os.path.join(netdir, \"Primary\")\n    aiport = args.indexer_port or random.randint(4000, 30000)\n    indexer_token = \"security-theater\"\n    indexerp = subprocess.Popen(\n        [\n            indexer_bin,\n            \"daemon\",\n            \"--algod\",\n            primary,\n            \"--postgres\",\n            psqlstring,\n            \"--dev-mode\",\n            \"--server\",\n            \":{}\".format(aiport),\n            \"--token\",\n            indexer_token,\n        ]\n    )\n    atexit.register(indexerp.kill)\n\n    rc = RunContext(env)\n    txid, txinfo = rc.do_txn()\n    logger.debug(\"submitted txid %s, %r\", txid, txinfo)\n\n    indexer = algosdk.v2client.indexer.IndexerClient(\n        indexer_token, \"http://localhost:{}\".format(aiport)\n    )\n    ok = False\n    retcode = 1\n    for i in range(30):\n        result = indexer.search_transactions(txid=txid)\n        logger.debug(\"seacrh_transactions: %r\", result)\n        they = result.get(\"transactions\")\n        if they and they[0].get(\"confirmed-round\"):\n            logger.info(\"OK: Got txn\")\n            ok = True\n            retcode = 0\n            break\n        time.sleep(1.0)\n\n    dt = time.time() - start\n    ok = (ok and \"OK\") or \"FAIL\"\n    sys.stdout.write(\"indexer live test {} ({:.1f}s)\\n\".format(ok, dt))\n    return retcode\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())"}
{"file_path": "https://github.com/ChoiceCoin/Choice-V1/blob/6597152bea3dc46545d7c969b76ead8d1ebf7c9d/contracts/Democratic_Rewards.py", "code": "https://github.com/peterkrull/algorand_vanity_farm/blob/16dcbc387892798e1522d3dda39118f990f51ad4/vanity_browse.py"}
{"file_path": "https://github.com/arty-arty/thefairrandomizer/blob/aa040d0fd50fe85a7e640a05a0b1419490b8a1ff/contract/mainWithNumber.py", "code": "# vanity_browser.py - lets you browse through the addresses found with vanity_farmer.py\n#\n# Depends on py-algorand-sdk which can be installed with:\n#\n# pip3 install py-algorand-sdk\n#\n# If you don't have pip3 you can install it with:\n#\n# apt install python3-pip\n\nimport json\nimport algosdk\n\ndef program():\n    open_file()\n    present_names()\n    user_input = present_publics()\n    present_privates(user_input)\n\ndef open_file():\n    global file_data\n    file_data = \"\"\n    try:\n        file_data = json.load(open(\"vanity_addresses\",'r'))\n    except FileNotFoundError as e:\n        print(\"No 'vanity_addresses' file found, exiting.\")\n        exit()\n\ndef present_names():\n    print(\"The following vanity addresses were generated.\")\n    print(\"Type the name of a vanity to view the addresses.\")\n    print(\"\")\n    names = []\n    for vanity in file_data:\n        names.append(vanity)\n    for i in range(len(names)):\n        length = []\n        try:\n            length.append(len(file_data[names[i]][\"A\"]))\n        except KeyError:\n            pass\n        try:\n            length.append(len(file_data[names[i]][\"E\"]))\n        except KeyError:\n            pass\n        try:\n            length.append(len(file_data[names[i]][\"B\"]))\n        except KeyError:\n            pass\n\n        sum_is = 0\n        for g in range(len(length)):\n            sum_is += length[g]\n        print(\"Found :\",names[i],sum_is,\"times\")\n\ndef present_publics():\n    user_input = input().upper()\n    names = []\n    print(\"\")\n    if user_input not in file_data:\n        print(\"The vanity '\",user_input,\"' was not an option. Exiting.\",sep=\"\")\n        exit() \n    for vanity in file_data:\n        names.append(vanity)\n        if user_input == vanity:\n            try:\n                temp = file_data[vanity][\"A\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' anywhere.\")\n                for i in range(len(temp)):\n                    print(\"A\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n\n            try:\n                temp = file_data[vanity][\"E\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' at the end.\")\n                for i in range(len(temp)):\n                    print(\"E\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n\n            try:\n                temp = file_data[vanity][\"B\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' at the beginning.\")\n                for i in range(len(temp)):\n                    print(\"B\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n            \n    return user_input\n\ndef present_privates(vanity):\n    print(\"\\nPlease type the letter and number in front your wanted address.\")\n    user_input = input()\n    try:\n        key = file_data[vanity][str(user_input[0]).upper()][str(user_input[1:])][\"private key\"]\n        print(\"\\nThe private mnemonic will now be shown. Make sure noone is watching\")\n        print(\"Press the enter key to continue\")\n        user_input_2 = input()\n        if user_input_2 != None:\n            print(\"--------------------------------------------------------------\")\n            print(algosdk.mnemonic.from_private_key(key))\n            print(\"\\n\",key,sep=\"\")\n            print(\"--------------------------------------------------------------\")\n            print(\"\\nREMEMBER! Keep these safe and private. Anyone with your keys can spend your money.\")\n            print(\"It is advised to write the mnemonic on a piece of paper and hide it somewhere safe.\")\n            print(\"\")\n            print(\"Press the enter key to exit program.\")\n        user_input_2 = input()\n        if user_input_2 != None:\n            pass\n            \n    except KeyError as e:\n        print(\"The input {} was not an option. Exiting.\".format(e))\n    except IndexError as e:\n         print(\"No valid input was given. Exiting.\")\n\nprogram()"}
{"file_path": "https://github.com/ChoiceCoin/Algorand-Protocol/blob/1f920b76c6c31eff23ed07b2248aabee32c821ae/AtomicTransfers/MoonX_Atomic_Transfer_Bash/transfer.py", "code": "https://github.com/AustP/arc72/blob/7e67dd5486a1dd98ffc20b9f1063da7cd9869a1a/arc72.py"}
{"file_path": "https://github.com/algorandfoundation/algokit-cli/blob/d7fdc1207d443c056d5bf6a616ec01b253ea25e2/src/algokit/cli/tasks/transfer.py", "code": "from pathlib import Path\n\nfrom Crypto.Hash import SHA512\nfrom pyteal import *\nfrom pyteal.ast.expr import Expr\nfrom pyteal.ir import TealSimpleBlock\n\nversion = \"v0.5.0\"\n\n################################################################################\n# Constants\n################################################################################\n\n\nHI4GE = Addr(\"HI4GEV4ZU32TGWUPKC5FKNCK6DZOLX2RRX4BVB3QG6WUHQ2UAS4GM3CN5U\")\nLAUNCH = Addr(\"LAUNCHPHD5NWWTDNVHOCFORJRFQYSY7UJWRF6A35LYMIDG4QHSHLGTMIEY\")\n\nBOOL_FALSE = Bytes(\"base16\", \"0x00\")\nBOOL_TRUE = Bytes(\"base16\", \"0x80\")\n\nBYTES_ONE = Bytes(\"base16\", \"0x01\")\nBYTES_ZERO = Bytes(\"base16\", \"0x00\")\n\nEVENT_APPROVAL = \"arc72_Approval(address,address,uint256)\"\nEVENT_APPROVAL_FOR_ALL = \"arc72_ApprovalForAll(address,address,bool)\"\nEVENT_MINT = \"highforge_Mint(address,uint256,uint64,uint64,uint64)\"\nEVENT_REVEAL = \"highforge_Reveal(uint256,byte[256])\"\nEVENT_TRANSFER = \"arc72_Transfer(address,address,uint256)\"\nEVENT_UPDATE_URI = \"highforge_UpdateURI(uint256,byte[256])\"\n\nINTERFACE_ARC72_CORE = Bytes(\"base16\", \"0x53f02a40\")\nINTERFACE_ARC72_ENUMERATION = Bytes(\"base16\", \"0xa57d4679\")\nINTERFACE_ARC72_MANAGEMENT = Bytes(\"base16\", \"0xb9c6f696\")\nINTERFACE_ARC72_METADATA = Bytes(\"base16\", \"0xc3c1fc00\")\nINTERFACE_MASK = Bytes(\"base16\", \"0xffffffff\")\nINTERFACE_SUPPORTS_INTERFACE = Bytes(\"base16\", \"0x4e22a3ba\")\n\nPREFIX_RETURN = Bytes(\"base16\", \"0x151f7c75\")\n\nLENGTH_ADDRESS = Int(32)\nLENGTH_BALANCE_BOX = Int(32)\nLENGTH_BOOL = Int(1)\nLENGTH_INDEX_BOX = Int(32)\nLENGTH_METADATA_URI = Int(256)\nLENGTH_NFT_BOX = Int(320)\nLENGTH_UINT256 = Int(32)\nLENGTH_UINT64 = Int(8)\nLENGTH_UINT8 = Int(1)\n\nMIN_BALANCE_APPROVAL_BOX = Int(2500 + (((2 * 32) + 1) * 400))\nMIN_BALANCE_INDEX_BOX = Int(2500 + (((1 + 32) + 32) * 400))\nMIN_BALANCE_NFT_BOX = Int(2500 + (((1 + 32) + 320) * 400))\nMIN_BALANCE_BALANCE_BOX = Int(2500 + (((1 + 32) + 32) * 400))\n\nLAUNCH_FEES = Global.min_txn_fee()\n\n################################################################################\n# Helper Functions\n################################################################################\n\n\nclass ABI_Method:\n    def __init__(self, abi, handler):\n        self._abi = abi\n        self._handler = handler\n\n        self._signature = (\n            abi[\"name\"]\n            + \"(\"\n            + \",\".join([arg[\"type\"] for arg in abi[\"args\"]])\n            + \")\"\n            + abi[\"returns\"][\"type\"]\n        )\n        self.selector = abi_method(self._signature)\n\n        print(abi[\"name\"], self.selector)\n\n    def handler(self):\n        args = {}\n        commands = []\n\n        length_map = {\n            \"account\": LENGTH_UINT8,\n            \"address\": LENGTH_ADDRESS,\n            \"asset\": LENGTH_UINT8,\n            \"bool\": LENGTH_BOOL,\n            \"byte[4]\": Int(4),\n            \"byte[256]\": Int(256),\n            \"uint256\": LENGTH_UINT256,\n            \"uint64\": LENGTH_UINT64,\n        }\n\n        for i, arg in enumerate(self._abi[\"args\"]):\n            args[arg[\"name\"]] = ScratchVar(\n                TealType.uint64 if arg[\"type\"] == \"asset\" else TealType.bytes\n            )\n\n            commands.append(\n                Assert(Len(Txn.application_args[i + 1]) == length_map[arg[\"type\"]])\n            )\n            commands.append(\n                args[arg[\"name\"]].store(\n                    Txn.accounts[Btoi(Txn.application_args[i + 1])]\n                    if arg[\"type\"] == \"account\"\n                    else (\n                        Txn.assets[Btoi(Txn.application_args[i + 1])]\n                        if arg[\"type\"] == \"asset\"\n                        else Txn.application_args[i + 1]\n                    )\n                )\n            )\n\n        return Seq(\n            *commands,\n            self._handler(args),\n        )\n\n\nclass EmptyExpr(Expr):\n    def __str__(self):\n        return \"\"\n\n    def __teal__(self, _):\n        start = TealSimpleBlock([])\n        end = start\n        return start, end\n\n    def has_return(self):\n        return False\n\n    def type_of(self):\n        return TealType.none\n\n\nclass NFT(EmptyExpr):\n    # NFT Box Structure\n    # owner - 32 bytes\n    # operator - 32 bytes\n    # metadata_uri - 256 bytes\n    box_length = LENGTH_NFT_BOX\n\n    field_indices = {\n        \"owner\": Int(0),\n        \"operator\": Int(32),\n        \"metadata_uri\": Int(64),\n    }\n\n    field_lengths = {\n        \"owner\": LENGTH_ADDRESS,\n        \"operator\": LENGTH_ADDRESS,\n        \"metadata_uri\": LENGTH_METADATA_URI,\n    }\n\n    def __init__(self, token_id):\n        self.box_name = Concat(Bytes(\"n\"), token_id)\n        self.token_id = token_id\n\n    def _emit(self, event, bytes):\n        return abi_event(event, bytes)\n\n    def approve(self, operator):\n        return Seq(\n            self.set(\"operator\", operator),\n            self.emit_approval(self.get(\"owner\"), operator),\n        )\n\n    def burn(self):\n        owner = ScratchVar(TealType.bytes)\n\n        return Seq(\n            owner.store(self.get(\"owner\")),\n            self.transfer(owner.load(), Global.zero_address()),\n            Assert(App.box_delete(self.box_name)),\n            send_algo(MIN_BALANCE_NFT_BOX, owner.load()),\n        )\n\n    def create(self, owner):\n        return Seq(\n            # create the NFT\n            Assert(Not(self.exists())),\n            Assert(App.box_create(self.box_name, self.box_length)),\n            self.transfer(Global.zero_address(), owner),\n        )\n\n    def emit_approval(self, owner, approved):\n        return self._emit(EVENT_APPROVAL, Concat(owner, approved, self.token_id))\n\n    def emit_transfer(self, from_, to):\n        return self._emit(\n            EVENT_TRANSFER,\n            Concat(\n                from_,\n                to,\n                self.token_id,\n            ),\n        )\n\n    def exists(self):\n        return Seq(length := App.box_length(self.box_name), length.hasValue())\n\n    def get(self, key):\n        return App.box_extract(\n            self.box_name, self.field_indices[key], self.field_lengths[key]\n        )\n\n    def is_revealed(self):\n        return self.get(\"metadata_uri\") != BytesZero(LENGTH_METADATA_URI)\n\n    def set(self, key, value):\n        return Seq(\n            Assert(Len(value) == self.field_lengths[key]),\n            App.box_replace(self.box_name, self.field_indices[key], value),\n        )\n\n    def transfer(self, from_, to):\n        return Seq(\n            self.set(\"owner\", to),\n            self.set(\"operator\", Global.zero_address()),\n            If(\n                from_ != Global.zero_address(),\n                Seq(\n                    contents := App.box_get(Concat(Bytes(\"b\"), from_)),\n                    Assert(contents.hasValue()),\n                    App.box_put(\n                        Concat(Bytes(\"b\"), from_),\n                        Btou256(BytesMinus(contents.value(), BYTES_ONE)),\n                    ),\n                ),\n            ),\n            Seq(\n                contents := App.box_get(Concat(Bytes(\"b\"), to)),\n                App.box_put(\n                    Concat(Bytes(\"b\"), to),\n                    Btou256(\n                        BytesAdd(\n                            If(contents.hasValue(), contents.value(), BYTES_ZERO),\n                            BYTES_ONE,\n                        )\n                    ),\n                ),\n            ),\n            self.emit_transfer(from_, to),\n        )\n\n\ndef Btou256(bytes):\n    return Concat(BytesZero(LENGTH_UINT256 - Len(bytes)), bytes)\n\n\ndef Itou256(int):\n    return Concat(BytesZero(LENGTH_UINT256 - LENGTH_UINT64), Itob(int))\n\n\ndef U256toi(bytes):\n    return Btoi(Extract(bytes, LENGTH_UINT256 - LENGTH_UINT64, LENGTH_UINT64))\n\n\ndef abi_event(signature, bytes):\n    return Log(Concat(abi_method(signature), bytes))\n\n\ndef abi_method(signature):\n    hash = SHA512.new(truncate=\"256\")\n    hash.update(signature.encode(\"utf-8\"))\n    selector = hash.hexdigest()[0:8]\n    return Bytes(\"base16\", \"0x\" + selector)\n\n\ndef abi_return(bytes=None):\n    return (\n        Seq(\n            Log(Concat(PREFIX_RETURN, bytes)),\n            Approve(),\n        )\n        if bytes is not None\n        else Approve()\n    )\n\n\ndef assert_is_creator():\n    return Assert(Txn.sender() == Global.creator_address())\n\n\ndef assert_is_launch():\n    return Assert(Txn.sender() == LAUNCH)\n\n\n@Subroutine(TealType.none)\ndef assert_mint_funding(index):\n    return Assert(\n        is_algo_txn(\n            index,\n            MIN_BALANCE_NFT_BOX  # for NFT storage\n            + MIN_BALANCE_INDEX_BOX  # for NFT lookup by index\n            + LAUNCH_FEES,  # to pay for LAUNCH's txn fees\n            Global.current_application_address(),\n        )\n    )\n\n\n@Subroutine(TealType.none)\ndef build_send_asset(assetID, amount, receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, assetID),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, receiver),\n    )\n\n\ndef closeout_algo(receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.amount, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.close_remainder_to, receiver),\n        InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef closeout_asset_to_creator(assetID):\n    assetCreator = AssetParam.creator(assetID)\n\n    return Seq(\n        assetCreator,\n        build_send_asset(assetID, Int(0), assetCreator.value()),\n        InnerTxnBuilder.SetField(TxnField.asset_close_to, assetCreator.value()),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef closeout_asset(assetID, receiver):\n    return Seq(\n        build_send_asset(assetID, Int(0), receiver),\n        InnerTxnBuilder.SetField(TxnField.asset_close_to, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef create_asset(assetName, unitName, total, assetURL, hash, manager, reserve):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetConfig),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.config_asset_total, total),\n        InnerTxnBuilder.SetField(TxnField.config_asset_decimals, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.config_asset_name, assetName),\n        InnerTxnBuilder.SetField(\n            TxnField.config_asset_unit_name,\n            unitName,\n        ),\n        InnerTxnBuilder.SetField(TxnField.config_asset_url, assetURL),\n        InnerTxnBuilder.SetField(TxnField.config_asset_metadata_hash, hash),\n        InnerTxnBuilder.SetField(TxnField.config_asset_manager, manager),\n        InnerTxnBuilder.SetField(TxnField.config_asset_reserve, reserve),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef distribute_payments(assetID, total):\n    artistAmount = ScratchVar(TealType.uint64)\n    charityAmount = ScratchVar(TealType.uint64)\n    launchpadAmount = ScratchVar(TealType.uint64)\n\n    return Seq(\n        # figure out how much charity gets\n        charityAmount.store(\n            If(\n                And(\n                    App.globalGet(Bytes(\"charityAddress\"))\n                    != Global.current_application_address(),\n                    App.globalGet(Bytes(\"charityPoints\")) > Int(0),\n                ),\n                get_cut(total, App.globalGet(Bytes(\"charityPoints\"))),\n                Int(0),\n            )\n        ),\n        # figure out how much the launchpad gets\n        launchpadAmount.store(get_cut(total, App.globalGet(Bytes(\"launchpadFee\")))),\n        artistAmount.store(total - launchpadAmount.load()),\n        If(\n            assetID == Int(0),\n            Seq(\n                # only payout to charity if it doesn't cause any errors\n                If(\n                    And(\n                        charityAmount.load(),\n                        artistAmount.load() >= charityAmount.load(),\n                        Or(\n                            charityAmount.load() >= Global.min_balance(),\n                            Balance(App.globalGet(Bytes(\"charityAddress\")))\n                            >= Global.min_balance(),\n                        ),\n                    ),\n                    Seq(\n                        artistAmount.store(artistAmount.load() - charityAmount.load()),\n                        send_algo(\n                            charityAmount.load(), App.globalGet(Bytes(\"charityAddress\"))\n                        ),\n                    ),\n                ),\n                send_algo(artistAmount.load(), Global.creator_address()),\n                send_algo(launchpadAmount.load(), HI4GE),\n            ),\n            Seq(\n                # only payout to charity if it doesn't cause any errors\n                If(\n                    And(\n                        charityAmount.load(),\n                        artistAmount.load() >= charityAmount.load(),\n                        Seq(\n                            opted_in := AssetHolding.balance(\n                                App.globalGet(Bytes(\"charityAddress\")),\n                                assetID,\n                            ),\n                            opted_in.hasValue(),\n                        ),\n                    ),\n                    Seq(\n                        artistAmount.store(artistAmount.load() - charityAmount.load()),\n                        send_asset(\n                            assetID,\n                            charityAmount.load(),\n                            App.globalGet(Bytes(\"charityAddress\")),\n                        ),\n                    ),\n                ),\n                send_asset(\n                    assetID,\n                    artistAmount.load(),\n                    Global.creator_address(),\n                ),\n                send_asset(assetID, launchpadAmount.load(), HI4GE),\n            ),\n        ),\n    )\n\n\n@Subroutine(TealType.uint64)\ndef get_cut(total, points):\n    return Btoi(BytesDiv(BytesMul(Itob(total), Itob(points)), Itob(Int(10000))))\n\n\n@Subroutine(TealType.uint64)\ndef is_algo_txn(index, amount, receiver):\n    return And(\n        Gtxn[index].type_enum() == TxnType.Payment,\n        Gtxn[index].close_remainder_to() == Global.zero_address(),\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].amount() == amount,\n        Gtxn[index].receiver() == receiver,\n    )\n\n\n@Subroutine(TealType.uint64)\ndef is_asset_txn(index, assetID, amount, receiver):\n    return And(\n        Gtxn[index].type_enum() == TxnType.AssetTransfer,\n        Gtxn[index].asset_close_to() == Global.zero_address(),\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].xfer_asset() == assetID,\n        Gtxn[index].asset_amount() == amount,\n        Gtxn[index].asset_receiver() == receiver,\n    )\n\n\ndef is_noop_txn(index, appID, method):\n    return And(\n        Gtxn[index].type_enum() == TxnType.ApplicationCall,\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].application_id() == appID,\n        Gtxn[index].on_completion() == OnComplete.NoOp,\n        Gtxn[index].application_args[0] == method,\n    )\n\n\n@Subroutine(TealType.bytes)\ndef nibble_to_ascii(nibble):\n    return Extract(\n        Itob(If(nibble < Int(10), Int(48) + nibble, Int(87) + nibble)), Int(7), Int(1)\n    )\n\n\ndef optin_asset(assetID):\n    return Seq(\n        build_send_asset(assetID, Int(0), Global.current_application_address()),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef send_algo(amount, receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.amount, amount),\n        InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef send_algo_cover_fee(amount, receiver):\n    return If(\n        And(\n            amount > Global.min_txn_fee(),\n            Balance(receiver) + amount - Global.min_txn_fee() >= Global.min_balance(),\n        ),\n        Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n            InnerTxnBuilder.SetField(TxnField.amount, amount - Global.min_txn_fee()),\n            InnerTxnBuilder.SetField(TxnField.fee, Global.min_txn_fee()),\n            InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n            InnerTxnBuilder.Submit(),\n        ),\n    )\n\n\ndef send_asset(assetID, amount, receiver):\n    return Seq(build_send_asset(assetID, amount, receiver), InnerTxnBuilder.Submit())\n\n\ndef sha_to_token_id(sha256):\n    byte = ScratchVar(TealType.uint64)\n    i = ScratchVar(TealType.uint64)\n    value = ScratchVar(TealType.bytes)\n\n    # todo:\n    # for each byte,\n    # mod it by 10\n    # convert that to ascii\n    # should be 32 bytes long\n    return Seq(\n        value.store(Bytes(\"\")),\n        i.store(Int(0)),\n        While(i.load() < Int(16)).Do(\n            Seq(\n                byte.store(GetByte(sha256, i.load())),\n                value.store(\n                    Concat(\n                        value.load(),\n                        nibble_to_ascii(byte.load() / Int(16)),\n                        nibble_to_ascii(byte.load() & Int(15)),\n                    )\n                ),\n                i.store(i.load() + Int(1)),\n            )\n        ),\n        value.load(),\n    )\n\n\n################################################################################\n# NoOp Branches\n################################################################################\n\n\ndef on_claim_algo():\n    claimableAlgo = Balance(Global.current_application_address()) - MinBalance(\n        Global.current_application_address()\n    )\n\n    return Seq(\n        assert_is_creator(),\n        send_algo(claimableAlgo, Global.creator_address()),\n        Approve(),\n    )\n\n\ndef on_claim_asset(assetID):\n    amount = AssetHolding.balance(Global.current_application_address(), assetID)\n\n    return Seq(\n        assert_is_creator(),\n        amount,\n        send_asset(\n            assetID,\n            amount.value(),\n            Global.creator_address(),\n        ),\n        Approve(),\n    )\n\n\ndef on_claim_wl_alt():\n    return on_claim_asset(App.globalGet(Bytes(\"wlAltID\")))\n\n\ndef on_claim_wl_token():\n    return on_claim_asset(App.globalGet(Bytes(\"wlTokenID\")))\n\n\ndef on_disable_whitelist():\n    return Seq(\n        assert_is_creator(),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            closeout_asset_to_creator(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        App.globalPut(Bytes(\"wlLaunchStart\"), Int(0)),\n        App.globalPut(Bytes(\"wlTokenID\"), Int(0)),\n        App.globalPut(Bytes(\"wlPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltID\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltPrice\"), Int(0)),\n        Approve(),\n    )\n\n\ndef on_enable_whitelist():\n    hash = ScratchVar(TealType.bytes)\n    i = ScratchVar(TealType.uint64)\n    name = ScratchVar(TealType.bytes)\n\n    return Seq(\n        assert_is_creator(),\n        Assert(Btoi(Txn.application_args[1]) < App.globalGet(Bytes(\"launchStart\"))),\n        App.globalPut(Bytes(\"wlLaunchStart\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"wlPrice\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"wlAltID\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"wlAltPrice\"), Btoi(Txn.application_args[4])),\n        App.globalPut(Bytes(\"wlMax\"), Btoi(Txn.application_args[5])),\n        hash.store(Sha256(Itob(Global.current_application_id()))),\n        name.store(Bytes(\"High Forge EA Token: 12345678901\")),\n        For(i.store(Int(0)), i.load() < Int(11), i.store(i.load() + Int(1))).Do(\n            name.store(\n                SetByte(\n                    name.load(),\n                    i.load() + Int(21),\n                    (GetByte(hash.load(), i.load()) % Int(26)) + Int(65),\n                ),\n            )\n        ),\n        create_asset(\n            name.load(),\n            Bytes(\"EARLY\"),\n            App.globalGet(Bytes(\"maxSupply\")) * Int(10),\n            Bytes(\"https://highforge.io\"),\n            Global.zero_address(),\n            Global.current_application_address(),\n            Global.current_application_address(),\n        ),\n        App.globalPut(Bytes(\"wlTokenID\"), InnerTxn.created_asset_id()),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            optin_asset(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        Approve(),\n    )\n\n\ndef on_set_charity():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"charityAddress\"), Txn.application_args[1]),\n        App.globalPut(Bytes(\"charityPoints\"), Btoi(Txn.application_args[2])),\n        Approve(),\n    )\n\n\ndef on_set_launch_dates():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"launchStart\"), Btoi(Txn.application_args[1])),\n        If(\n            Txn.application_args.length() == Int(3),\n            Seq(\n                Assert(App.globalGet(Bytes(\"wlTokenID\"))),\n                Assert(Btoi(Txn.application_args[2]) < Btoi(Txn.application_args[1])),\n                App.globalPut(Bytes(\"wlLaunchStart\"), Btoi(Txn.application_args[2])),\n            ),\n        ),\n        Approve(),\n    )\n\n\ndef on_set_launch_details():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"price\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"maxSupply\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"launchStart\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"launchEnd\"), Int(0)),  # for now, don't allow end date\n        # App.globalPut(Bytes(\"launchEnd\"), Btoi(Txn.application_args[4])),\n        Approve(),\n    )\n\n\ndef on_set_launch_paused():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"launchPaused\"), Btoi(Txn.application_args[1])),\n        Approve(),\n    )\n\n\ndef on_set_launchpad_fee():\n    return Seq(\n        assert_is_launch(),\n        App.globalPut(Bytes(\"launchpadFee\"), Btoi(Txn.application_args[1])),\n        Approve(),\n    )\n\n\ndef approveHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(Txn.sender() == nft.get(\"owner\")),\n        nft.approve(args[\"approved\"].load()),\n        abi_return(),\n    )\n\n\napprove = ABI_Method(\n    {\n        \"name\": \"arc72_approve\",\n        \"desc\": \"Approve a controller for a single NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"address\",\n                \"name\": \"approved\",\n                \"desc\": \"Approved controller address\",\n            },\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    approveHandler,\n)\n\n\ndef balanceOfHandler(args):\n    return Seq(\n        contents := App.box_get(Concat(Bytes(\"b\"), args[\"owner\"].load())),\n        abi_return(\n            If(contents.hasValue(), contents.value(), BytesZero(LENGTH_UINT256))\n        ),\n    )\n\n\nbalanceOf = ABI_Method(\n    {\n        \"name\": \"arc72_balanceOf\",\n        \"desc\": \"Returns the number of NFTs owned by an address\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"owner\"},\n        ],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    balanceOfHandler,\n)\n\n\ndef burnHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(Txn.sender() == nft.get(\"owner\")),\n        nft.burn(),\n        abi_return(),\n    )\n\n\nburn = ABI_Method(\n    {\n        \"name\": \"burn\",\n        \"desc\": \"Burns the specified NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    burnHandler,\n)\n\n\ndef getApprovedHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        abi_return(nft.get(\"operator\")),\n    )\n\n\ngetApproved = ABI_Method(\n    {\n        \"name\": \"arc72_getApproved\",\n        \"desc\": \"Get the current approved address for a single NFT\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"address\", \"desc\": \"address of approved user or zero\"},\n    },\n    getApprovedHandler,\n)\n\n\ndef isApprovedForAllHandler(args):\n    return Seq(\n        isOperator := App.box_length(\n            Concat(args[\"owner\"].load(), args[\"operator\"].load())\n        ),\n        abi_return(Itob(isOperator.hasValue())),\n    )\n\n\nisApprovedForAll = ABI_Method(\n    {\n        \"name\": \"arc72_isApprovedForAll\",\n        \"desc\": \"Query if an address is an authorized operator for another address\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"owner\"},\n            {\"type\": \"address\", \"name\": \"operator\"},\n        ],\n        \"returns\": {\n            \"type\": \"bool\",\n            \"desc\": \"whether operator is authorized for all NFTs of owner\",\n        },\n    },\n    isApprovedForAllHandler,\n)\n\n\ndef mintHandler(args):\n    assetID = ScratchVar(TealType.uint64)\n    paidAmount = ScratchVar(TealType.uint64)\n    receiptBox = ScratchVar(TealType.bytes)\n    receiptContent = ScratchVar(TealType.bytes)\n\n    return Seq(\n        # make sure the max supply has not been reached\n        Assert(App.globalGet(Bytes(\"totalMinted\")) < App.globalGet(Bytes(\"maxSupply\"))),\n        If(\n            # if creator is calling, ignore price, period, and paused status\n            Txn.sender() == Global.creator_address(),\n            Seq(\n                assetID.store(Int(0)),\n                paidAmount.store(Int(0)),\n                assert_mint_funding(Txn.group_index() - Int(1)),\n            ),\n            Seq(\n                # make sure the launch is not paused\n                Assert(App.globalGet(Bytes(\"launchPaused\")) == Int(0)),\n                # make sure the mint is not over. launchEnd == 0 means it never ends\n                Assert(\n                    Or(\n                        App.globalGet(Bytes(\"launchEnd\")) == Int(0),\n                        Global.latest_timestamp() < App.globalGet(Bytes(\"launchEnd\")),\n                    )\n                ),\n                If(\n                    # if the time is after the launch start, it's a normal mint\n                    Global.latest_timestamp() >= App.globalGet(Bytes(\"launchStart\")),\n                    Seq(\n                        # make sure they pay the mint price\n                        If(\n                            is_algo_txn(\n                                Txn.group_index() - Int(1),\n                                App.globalGet(Bytes(\"price\")),\n                                Global.current_application_address(),\n                            ),\n                            Seq(\n                                assetID.store(Int(0)),\n                                paidAmount.store(App.globalGet(Bytes(\"price\"))),\n                            ),\n                            Reject(),\n                        ),\n                        assert_mint_funding(Txn.group_index() - Int(2)),\n                    ),\n                    Seq(\n                        # make sure whitelist is enabled\n                        Assert(App.globalGet(Bytes(\"wlTokenID\"))),\n                        # make sure we are in the whitelist window\n                        Assert(\n                            Global.latest_timestamp()\n                            >= App.globalGet(Bytes(\"wlLaunchStart\"))\n                        ),\n                        # make sure white list is not maxed out\n                        Assert(\n                            Or(\n                                # wlMax == 0 means no limit\n                                App.globalGet(Bytes(\"wlMax\")) == Int(0),\n                                App.globalGet(Bytes(\"wlMinted\"))\n                                < App.globalGet(Bytes(\"wlMax\")),\n                            )\n                        ),\n                        # make sure they pay the whitelist token\n                        Assert(\n                            is_asset_txn(\n                                Txn.group_index() - Int(2),\n                                App.globalGet(Bytes(\"wlTokenID\")),\n                                Int(1),\n                                Global.current_application_address(),\n                            )\n                        ),\n                        # make sure they pay the mint price\n                        If(\n                            is_algo_txn(\n                                Txn.group_index() - Int(1),\n                                App.globalGet(Bytes(\"wlPrice\")),\n                                Global.current_application_address(),\n                            ),\n                            Seq(\n                                assetID.store(Int(0)),\n                                paidAmount.store(App.globalGet(Bytes(\"wlPrice\"))),\n                            ),\n                            If(\n                                And(\n                                    App.globalGet(Bytes(\"wlAltID\")),\n                                    is_asset_txn(\n                                        Txn.group_index() - Int(1),\n                                        App.globalGet(Bytes(\"wlAltID\")),\n                                        App.globalGet(Bytes(\"wlAltPrice\")),\n                                        Global.current_application_address(),\n                                    ),\n                                ),\n                                Seq(\n                                    assetID.store(App.globalGet(Bytes(\"wlAltID\"))),\n                                    paidAmount.store(\n                                        App.globalGet(Bytes(\"wlAltPrice\"))\n                                    ),\n                                ),\n                                Reject(),\n                            ),\n                        ),\n                        assert_mint_funding(Txn.group_index() - Int(3)),\n                        App.globalPut(\n                            Bytes(\"wlMinted\"), App.globalGet(Bytes(\"wlMinted\")) + Int(1)\n                        ),\n                    ),\n                ),\n            ),\n        ),\n        # send out everyone's cuts\n        distribute_payments(assetID.load(), paidAmount.load()),\n        # send algo to cover the revealing of the NFT\n        send_algo(LAUNCH_FEES, LAUNCH),\n        # create the receipt box and make sure it doesn't already exist\n        receiptBox.store(Concat(Bytes(\"r\"), args[\"tempTokenId\"].load())),\n        length := App.box_length(receiptBox.load()),\n        Assert(Not(length.hasValue())),\n        # we make the receipt box the same size as an NFT box\n        # that way the user covers the min-balance cost\n        # and during the reveal we can just replace the receipt box with the NFT box\n        Assert(App.box_create(receiptBox.load(), LENGTH_NFT_BOX)),\n        Assert(\n            App.box_create(\n                Concat(Bytes(\"t\"), args[\"tempTokenId\"].load()), LENGTH_INDEX_BOX\n            )\n        ),\n        receiptContent.store(\n            Concat(\n                Txn.sender(),\n                Itou256(App.globalGet(Bytes(\"nextMintID\"))),\n                Itob(assetID.load()),\n                Itob(paidAmount.load()),\n                Itob(Global.latest_timestamp()),\n            )\n        ),\n        App.box_replace(\n            receiptBox.load(),\n            Int(0),\n            receiptContent.load(),\n        ),\n        # emit the mint event\n        abi_event(EVENT_MINT, receiptContent.load()),\n        # update variables for next mint\n        App.globalPut(Bytes(\"nextMintID\"), App.globalGet(Bytes(\"nextMintID\")) + Int(1)),\n        App.globalPut(\n            Bytes(\"totalMinted\"), App.globalGet(Bytes(\"totalMinted\")) + Int(1)\n        ),\n        abi_return(Itou256(App.globalGet(Bytes(\"nextMintID\")) - Int(1))),\n    )\n\n\nmint = ABI_Method(\n    {\n        \"name\": \"highforge_mint\",\n        \"desc\": \"Attempts to mint an NFT for the user\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tempTokenId\",\n                \"desc\": \"A unique temporary token ID for the NFT\",\n            },\n        ],\n        \"returns\": {\n            \"type\": \"uint256\",\n            \"desc\": \"tokenId - The ID of the NFT that was minted\",\n        },\n    },\n    mintHandler,\n)\n\n\ndef ownerOfHandler(args):\n    nft = NFT(args[\"tokenId\"].load())\n\n    return abi_return(\n        If(\n            nft.exists(),\n            nft.get(\"owner\"),\n            Global.zero_address(),\n        )\n    )\n\n\nownerOf = ABI_Method(\n    {\n        \"name\": \"arc72_ownerOf\",\n        \"desc\": \"Returns the address of the current owner of the NFT with the given tokenId\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"address\", \"desc\": \"The current owner of the NFT.\"},\n    },\n    ownerOfHandler,\n)\n\n\ndef revealHandler(args):\n    receiptBox = ScratchVar(TealType.bytes)\n    sender = ScratchVar(TealType.bytes)\n    tokenId = ScratchVar(TealType.bytes)\n    collectionIndex = ScratchVar(TealType.bytes)\n\n    return Seq(\n        assert_is_launch(),\n        # load the receipt\n        receiptBox.store(Concat(Bytes(\"r\"), args[\"tempTokenId\"].load())),\n        length := App.box_length(receiptBox.load()),\n        Assert(length.hasValue()),\n        sender.store(App.box_extract(receiptBox.load(), Int(0), LENGTH_ADDRESS)),\n        tokenId.store(\n            App.box_extract(receiptBox.load(), LENGTH_ADDRESS, LENGTH_UINT256)\n        ),\n        # verify against the receipt\n        Assert(args[\"tokenId\"].load() == tokenId.load()),\n        # delete the receipt box\n        Assert(App.box_delete(receiptBox.load())),\n        Assert(App.box_delete(Concat(Bytes(\"t\"), args[\"tempTokenId\"].load()))),\n        # create the NFT\n        nft := NFT(args[\"tokenId\"].load()),\n        nft.create(sender.load()),\n        nft.set(\"metadata_uri\", args[\"tokenURI\"].load()),\n        # create the index lookup box\n        collectionIndex.store(\n            Itou256(U256toi(args[\"tokenId\"].load()) - Int(1)),\n        ),\n        length := App.box_length(Concat(Bytes(\"i\"), collectionIndex.load())),\n        Assert(Not(length.hasValue())),\n        App.box_put(Concat(Bytes(\"i\"), collectionIndex.load()), args[\"tokenId\"].load()),\n        # emit event and return\n        abi_event(\n            EVENT_REVEAL, Concat(args[\"tokenId\"].load(), args[\"tokenURI\"].load())\n        ),\n        abi_return(),\n    )\n\n\nreveal = ABI_Method(\n    {\n        \"name\": \"highforge_reveal\",\n        \"desc\": \"Reveals the NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tempTokenId\",\n                \"desc\": \"The temporary token ID\",\n            },\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tokenId\",\n                \"desc\": \"The actual token ID\",\n            },\n            {\n                \"type\": \"byte[256]\",\n                \"name\": \"tokenURI\",\n                \"desc\": \"The metadata URI for the token\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    revealHandler,\n)\n\n\ndef setApprovalForAllHandler(args):\n    return Seq(\n        If(\n            args[\"approved\"].load() == BOOL_TRUE,\n            Assert(\n                App.box_create(Concat(Txn.sender(), args[\"operator\"].load()), Int(1))\n            ),\n            If(\n                args[\"approved\"].load() == BOOL_FALSE,\n                Assert(App.box_delete(Concat(Txn.sender(), args[\"operator\"].load()))),\n                Reject(),\n            ),\n        ),\n        abi_event(\n            EVENT_APPROVAL_FOR_ALL,\n            Concat(\n                Txn.sender(),\n                args[\"operator\"].load(),\n                args[\"approved\"].load(),\n            ),\n        ),\n        abi_return(),\n    )\n\n\nsetApprovalForAll = ABI_Method(\n    {\n        \"name\": \"arc72_setApprovalForAll\",\n        \"desc\": \"Approve an operator for all NFTs for a user\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"address\",\n                \"name\": \"operator\",\n                \"desc\": \"Approved operator address\",\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"approved\",\n                \"desc\": \"true to give approval, false to revoke\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    setApprovalForAllHandler,\n)\n\n\ndef setupBalanceHandler(args):\n    return Seq(\n        Assert(\n            is_algo_txn(\n                Txn.group_index() - Int(1),\n                MIN_BALANCE_BALANCE_BOX,\n                Global.current_application_address(),\n            )\n        ),\n        length := App.box_length(Concat(Bytes(\"b\"), Txn.sender())),\n        If(\n            length.hasValue(),\n            send_algo_cover_fee(\n                MIN_BALANCE_BALANCE_BOX,\n                Gtxn[Txn.group_index() - Int(1)].sender(),\n            ),\n            Assert(\n                App.box_create(Concat(Bytes(\"b\"), Txn.sender()), LENGTH_BALANCE_BOX)\n            ),\n        ),\n        abi_return(),\n    )\n\n\nsetupBalance = ABI_Method(\n    {\n        \"name\": \"highforge_setupBalance\",\n        \"desc\": \"Makes sure that the balance box for the sender is set up\",\n        \"readonly\": False,\n        \"args\": [],\n        \"returns\": {\"type\": \"void\"},\n    },\n    setupBalanceHandler,\n)\n\n\ndef supportsInterfaceHandler(args):\n    return Seq(\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_SUPPORTS_INTERFACE,\n            abi_return(BOOL_TRUE),\n        ),\n        If(args[\"interfaceID\"].load() == INTERFACE_MASK, abi_return(BOOL_FALSE)),\n        If(args[\"interfaceID\"].load() == INTERFACE_ARC72_CORE, abi_return(BOOL_TRUE)),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_ENUMERATION,\n            abi_return(BOOL_TRUE),\n        ),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_MANAGEMENT,\n            abi_return(BOOL_TRUE),\n        ),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_METADATA,\n            abi_return(BOOL_TRUE),\n        ),\n        abi_return(BOOL_FALSE),\n    )\n\n\nsupportsInterface = ABI_Method(\n    {\n        \"name\": \"supportsInterface\",\n        \"desc\": \"Detects support for an interface specified by selector.\",\n        \"readonly\": True,\n        \"args\": [\n            {\n                \"type\": \"byte[4]\",\n                \"name\": \"interfaceID\",\n                \"desc\": \"The selector of the interface to detect.\",\n            },\n        ],\n        \"returns\": {\n            \"type\": \"bool\",\n            \"desc\": \"Whether the contract supports the interface.\",\n        },\n    },\n    supportsInterfaceHandler,\n)\n\n\ndef tokenByIndexHandler(args):\n    return Seq(\n        Assert(U256toi(args[\"index\"].load()) < App.globalGet(Bytes(\"totalMinted\"))),\n        contents := App.box_get(Concat(Bytes(\"i\"), args[\"index\"].load())),\n        Assert(contents.hasValue()),\n        abi_return(contents.value()),\n    )\n\n\ntokenByIndex = ABI_Method(\n    {\n        \"name\": \"arc72_tokenByIndex\",\n        \"desc\": \"Returns the token ID of the token with the given index among all NFTs defined by the contract\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"index\"},\n        ],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    tokenByIndexHandler,\n)\n\n\ndef tokenURIHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        abi_return(nft.get(\"metadata_uri\")),\n    )\n\n\ntokenURI = ABI_Method(\n    {\n        \"name\": \"arc72_tokenURI\",\n        \"desc\": \"Returns a URI pointing to the NFT metadata\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"byte[256]\", \"desc\": \"URI to token metadata.\"},\n    },\n    tokenURIHandler,\n)\n\n\ndef totalSupplyHandler(_):\n    return abi_return(Itou256(App.globalGet(Bytes(\"totalMinted\"))))\n\n\ntotalSupply = ABI_Method(\n    {\n        \"name\": \"arc72_totalSupply\",\n        \"desc\": \"Returns the number of NFTs currently defined by this contract\",\n        \"readonly\": True,\n        \"args\": [],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    totalSupplyHandler,\n)\n\n\ndef transferFromHandler(args):\n    owner = ScratchVar(TealType.bytes)\n\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        owner.store(nft.get(\"owner\")),\n        isOperator := App.box_length(Concat(owner.load(), Txn.sender())),\n        Assert(args[\"from\"].load() == owner.load()),\n        Assert(\n            Or(\n                Txn.sender() == nft.get(\"operator\"),\n                Txn.sender() == owner.load(),\n                isOperator.hasValue(),\n            )\n        ),\n        # we allow an optional txn before this one that covers the min balance\n        # cost for the balance box. if it already exists, we will refund it\n        If(\n            Txn.group_index() > Int(0),\n            If(\n                is_algo_txn(\n                    Txn.group_index() - Int(1),\n                    MIN_BALANCE_BALANCE_BOX,\n                    Global.current_application_address(),\n                ),\n                Seq(\n                    length := App.box_length(Concat(Bytes(\"b\"), args[\"to\"].load())),\n                    If(\n                        length.hasValue(),\n                        send_algo_cover_fee(\n                            MIN_BALANCE_BALANCE_BOX,\n                            Gtxn[Txn.group_index() - Int(1)].sender(),\n                        ),\n                    ),\n                ),\n            ),\n        ),\n        nft.transfer(owner.load(), args[\"to\"].load()),\n        abi_return(),\n    )\n\n\ntransferFrom = ABI_Method(\n    {\n        \"name\": \"arc72_transferFrom\",\n        \"desc\": \"Transfers ownership of an NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"from\"},\n            {\"type\": \"address\", \"name\": \"to\"},\n            {\"type\": \"uint256\", \"name\": \"tokenId\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    transferFromHandler,\n)\n\n\ndef updateTokenURIHandler(args):\n    return Seq(\n        assert_is_creator(),\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(nft.is_revealed()),\n        nft.set(\"metadata_uri\", args[\"tokenURI\"].load()),\n        abi_event(\n            EVENT_UPDATE_URI,\n            Concat(\n                args[\"tokenId\"].load(),\n                args[\"tokenURI\"].load(),\n            ),\n        ),\n        abi_return(),\n    )\n\n\nupdateTokenURI = ABI_Method(\n    {\n        \"name\": \"highforge_updateTokenURI\",\n        \"desc\": \"Allows the creator to update the token URI for a token\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n            {\n                \"type\": \"byte[256]\",\n                \"name\": \"tokenURI\",\n                \"desc\": \"The metadata URI for the token\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    updateTokenURIHandler,\n)\n\n\n################################################################################\n# OnComplete Branches\n################################################################################\n\n\ndef on_creation():\n    return Seq(\n        App.globalPut(Bytes(\"price\"), Int(0)),\n        # launch will be available when time >= launchStart\n        # it will go until maxSupply is reached OR time > launchEnd\n        App.globalPut(Bytes(\"maxSupply\"), Int(0)),\n        # (wl)launchStart and launchEnd are given in seconds since epoch\n        App.globalPut(Bytes(\"launchStart\"), Int(0)),\n        App.globalPut(Bytes(\"launchEnd\"), Int(0)),\n        App.globalPut(Bytes(\"launchPaused\"), Int(0)),\n        # whitelist will start when time > wlLaunchStart\n        # whitelist will end when time >= launchStart\n        App.globalPut(Bytes(\"wlLaunchStart\"), Int(0)),\n        App.globalPut(Bytes(\"wlTokenID\"), Int(0)),\n        App.globalPut(Bytes(\"wlPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltID\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlMax\"), Int(0)),\n        App.globalPut(Bytes(\"wlMinted\"), Int(0)),\n        # launchpad fee is in basis points (defaults to 2.5%)\n        App.globalPut(Bytes(\"launchpadFee\"), Int(250)),\n        App.globalPut(Bytes(\"nextMintID\"), Int(1)),\n        App.globalPut(Bytes(\"totalMinted\"), Int(0)),\n        App.globalPut(Bytes(\"charityAddress\"), Global.current_application_address()),\n        App.globalPut(Bytes(\"charityPoints\"), Int(0)),\n        Approve(),\n    )\n\n\ndef on_closeout():\n    return Reject()\n\n\ndef on_delete():\n    return Seq(\n        assert_is_creator(),\n        Assert(App.globalGet(Bytes(\"totalMinted\")) == Int(0)),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            closeout_asset_to_creator(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        closeout_algo(Global.creator_address()),\n        Approve(),\n    )\n\n\ndef on_noop():\n    return Cond(\n        [Txn.application_args[0] == Bytes(\"claimAlgo\"), on_claim_algo()],\n        [Txn.application_args[0] == Bytes(\"claimWLAlt\"), on_claim_wl_alt()],\n        [Txn.application_args[0] == Bytes(\"claimWLToken\"), on_claim_wl_token()],\n        [Txn.application_args[0] == Bytes(\"disableWL\"), on_disable_whitelist()],\n        [Txn.application_args[0] == Bytes(\"enableWL\"), on_enable_whitelist()],\n        [Txn.application_args[0] == Bytes(\"setCharity\"), on_set_charity()],\n        [Txn.application_args[0] == Bytes(\"setLaunchDates\"), on_set_launch_dates()],\n        [Txn.application_args[0] == Bytes(\"setLaunchDetails\"), on_set_launch_details()],\n        [Txn.application_args[0] == Bytes(\"setLaunchPaused\"), on_set_launch_paused()],\n        [Txn.application_args[0] == Bytes(\"setLaunchpadFee\"), on_set_launchpad_fee()],\n        [Txn.application_args[0] == approve.selector, approve.handler()],\n        [Txn.application_args[0] == balanceOf.selector, balanceOf.handler()],\n        [Txn.application_args[0] == burn.selector, burn.handler()],\n        [Txn.application_args[0] == getApproved.selector, getApproved.handler()],\n        [\n            Txn.application_args[0] == isApprovedForAll.selector,\n            isApprovedForAll.handler(),\n        ],\n        [Txn.application_args[0] == mint.selector, mint.handler()],\n        [Txn.application_args[0] == ownerOf.selector, ownerOf.handler()],\n        [Txn.application_args[0] == reveal.selector, reveal.handler()],\n        [\n            Txn.application_args[0] == setApprovalForAll.selector,\n            setApprovalForAll.handler(),\n        ],\n        [Txn.application_args[0] == setupBalance.selector, setupBalance.handler()],\n        [\n            Txn.application_args[0] == supportsInterface.selector,\n            supportsInterface.handler(),\n        ],\n        [Txn.application_args[0] == tokenByIndex.selector, tokenByIndex.handler()],\n        [Txn.application_args[0] == tokenURI.selector, tokenURI.handler()],\n        [Txn.application_args[0] == totalSupply.selector, totalSupply.handler()],\n        [Txn.application_args[0] == transferFrom.selector, transferFrom.handler()],\n    )\n\n\ndef on_optin():\n    return Reject()\n\n\ndef on_update():\n    return Seq(assert_is_launch(), Approve())\n\n\n################################################################################\n# Program Construction\n################################################################################\n\n\ndef approval_program():\n    program = Seq(\n        Assert(Txn.rekey_to() == Global.zero_address()),\n        Cond(\n            [Txn.application_id() == Int(0), on_creation()],\n            [Txn.on_completion() == OnComplete.CloseOut, on_closeout()],\n            [Txn.on_completion() == OnComplete.DeleteApplication, on_delete()],\n            [Txn.on_completion() == OnComplete.NoOp, on_noop()],\n            [Txn.on_completion() == OnComplete.OptIn, on_optin()],\n            [Txn.on_completion() == OnComplete.UpdateApplication, on_update()],\n        ),\n    )\n\n    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)\n\n\ndef clear_program():\n    program = on_closeout()\n    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)\n\n\np = Path(__file__).parent.absolute()\n(p / f\"arc72/{version}\").mkdir(exist_ok=True)\n\n\nwith open(f\"arc72/{version}/approval.teal\", \"w\") as f:\n    f.write(approval_program())\n\nwith open(f\"arc72/{version}/clear.teal\", \"w\") as f:\n    f.write(clear_program())\n\n\nimport base64, hashlib, subprocess\n\nsubprocess.run(\n    [\n        \"goal\",\n        \"clerk\",\n        \"compile\",\n        f\"arc72/{version}/approval.teal\",\n        \"-o\",\n        f\"arc72/{version}/approval.bin\",\n    ]\n)\nsubprocess.run(\n    [\n        \"goal\",\n        \"clerk\",\n        \"compile\",\n        f\"arc72/{version}/clear.teal\",\n        \"-o\",\n        f\"arc72/{version}/clear.bin\",\n    ]\n)\n\nwith open(f\"arc72/{version}/approval.bin\", \"rb\") as f:\n    contents = f.read()\n    print(\"approvalHash\", base64.b64encode(hashlib.sha256(contents).digest()).decode())\n    with open(f\"arc72/{version}/approval.b64\", \"w\") as f:\n        f.write(base64.b64encode(contents).decode())\n\nwith open(f\"arc72/{version}/clear.bin\", \"rb\") as f:\n    contents = f.read()\n    print(\"clearHash\", base64.b64encode(hashlib.sha256(contents).digest()).decode())\n    with open(f\"arc72/{version}/clear.b64\", \"w\") as f:\n        f.write(base64.b64encode(contents).decode())\n\nprint(\"\")\nprint(\"Copy approval.b64 and clear.b64 to algoseas-libs!!!\")"}
{"file_path": "https://github.com/manicdon7/algorand/blob/c12ccc8b6be34ae27fe836d267cdf66e25740079/.venv/Lib/site-packages/algokit_utils/_transfer.py", "code": "https://github.com/cloud-travelx/workshop-labitconf-22/blob/4d4ddddeaafd6d59947202b7199f6684714d54a9/assets/nfticket/NFTicketManager.py"}
{"file_path": "https://github.com/Ganainmtech/Algorand_Bytes/blob/6d78e8afabc809164c366607e1a9892af80c6750/localnet_examples/Intermediate/00_atomicTransfer.py", "code": "from typing import Final\n\nimport beaker as bkr\nfrom pyteal import *\n\n\nclass NFTicketManager(bkr.Application):\n    protocol: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.bytes,\n        static=True,\n        descr=\"Protocol fee account\",\n    )\n\n    protocol_fee: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.uint64,\n        default=Int(10),  # 1%\n        descr=\"Protocol Fee Percentage\",\n    )\n\n    supplier: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.bytes,\n        descr=\"Supplier account\",\n        static=True\n    )\n\n    supplier_share: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.uint64,\n        default=Int(1),\n        descr=\"Share of supplier on resale\"\n    )\n\n    @bkr.create\n    def create(self, protocol: abi.Account, supplier: abi.Account):\n        return Seq(\n            self.initialize_application_state(),\n            self.protocol.set(Txn.accounts[1]),\n            self.supplier.set(Txn.accounts[2])\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(protocol))\n    def set_up_asset(self, asset: abi.Asset):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset.asset_id(),\n                TxnField.asset_receiver: self.address,\n                TxnField.asset_amount: Int(0),\n                TxnField.fee: Int(0)\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(protocol))\n    def set_up_fee(self, supplier_share: abi.Uint64, protocol: abi.Uint64):\n        return Seq(\n            self.supplier_share.set(supplier_share.get()),\n            self.protocol_fee.set(protocol.get())\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def mint(self, name: abi.String, meta_url: abi.String, meta_hash: abi.String, *, output: abi.Uint64):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(0),\n                TxnField.config_asset_name: Concat(Bytes(\"NFTicket\"), name.get()),\n                TxnField.config_asset_unit_name: Bytes(\"NFTicket\"),\n                TxnField.config_asset_url: meta_url.get(),\n                TxnField.config_asset_metadata_hash: meta_hash.get(),\n                TxnField.config_asset_default_frozen: Int(1),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.fee: Int(0),\n            }),\n            InnerTxnBuilder.Submit(),\n\n            output.set(Gitxn[0].created_asset_id())\n        )\n\n    @bkr.internal(TealType.none)\n    def move_asset(self, asset, owner, to):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset,\n                TxnField.asset_sender: owner,\n                TxnField.asset_receiver: to,\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0),\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.internal(TealType.none)\n    def pay_share(self, asset, to, amount):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset,\n                TxnField.asset_receiver: to,\n                TxnField.asset_amount: amount,\n                TxnField.fee: Int(0)\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def redeem(self, asset: abi.Asset):\n        return self.move_asset(asset.asset_id(), self.address, Txn.sender())\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def withdraw(self, asset: abi.Asset, amount: abi.Uint64, to: abi.Account):\n        return self.pay_share(asset.asset_id(), to.address(), amount.get())\n\n    @bkr.external\n    def sell(self,\n             price: abi.Uint64,\n             nfticket: abi.Asset,\n             buyer: abi.Account,\n             protocol: abi.Account,\n             pay_asset: abi.Asset,\n             payment: abi.AssetTransferTransaction):\n        payment = payment.get()\n        return Seq(\n            # Payment to contract\n            #  (implicit) Payment asset\n            Assert(payment.asset_receiver() == self.address),\n            Assert(payment.xfer_asset() == pay_asset.asset_id()),\n\n            # Payment amount is sell price\n            Assert(payment.asset_amount() >= price.get()),\n\n            # Protocol Fee\n            Assert(self.protocol.get() == protocol.address()),\n            # (protocol_fee := ScratchVar(TealType.uint64)).store(price.get() * (self.protocol_fee.get() / Int(1000))),\n            (protocol_fee := abi.Uint64()).set(price.get() * self.protocol_fee.get() / Int(1000)),\n            # Pay to Protocol\n            self.pay_share(payment.xfer_asset(), protocol.address(), protocol_fee.get()),\n\n            # Seller profit\n            (sell_worth := abi.Uint64()).set(price.get() - protocol_fee.get()),\n            (supplier_share := abi.Uint64()).set(sell_worth.get() * self.supplier_share.get() / Int(1000)),\n            # Pay to seller\n            self.pay_share(payment.xfer_asset(), Txn.sender(), price.get() - supplier_share.get()),\n\n            # Move asset\n            #  (implicit check) Seller is owner\n            self.move_asset(nfticket.asset_id(), Txn.sender(), buyer.address())\n        )\n\n\nif __name__ == '__main__':\n    import sys\n    import json\n    import collections\n    from os import path\n\n    app = NFTicketManager()\n\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"--artifacts\":\n            app.dump(f\"{path.dirname(__file__)}/artifacts\")\n            exit(0)\n        if sys.argv[1] == \"--spec\":\n            spec = app.application_spec()\n\n\n            def cost(declared) -> collections.Counter:\n                return collections.Counter(map(lambda e: e[\"type\"], declared.values()))\n\n\n            print(cost(spec[\"schema\"][\"local\"][\"declared\"]))\n            print(cost(spec[\"schema\"][\"global\"][\"declared\"]))\n\n            sys.exit(0)\n        if sys.argv[1] == \"--abi\":\n            with open(__file__.replace(\".py\", \".abi.json\"), \"w\") as abi_fp:\n                json.dump(app.contract.dictify(), abi_fp, indent=2)\n\n    print(app.approval_program)"}
{"file_path": "https://github.com/atsoc1993/Hot-Potato-Contract-AVM/blob/e2e4979b491c97f4d333eeaf1332fecd566e505d/AlgoPotatoClient.py", "code": "https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/dao.py"}
{"file_path": "https://github.com/Vradss/BUILDH3R_WORKSHOPS/blob/7f9c2a5abec474893022c115e1ace1c9367b10e3/June/Algorand/main.py", "code": "from pathlib import Path\n\nfrom typing import Literal\n\n\n\nfrom beaker import *\n\nfrom beaker.lib.storage import BoxMapping\n\nfrom pyteal import *\n\n\n\n\n\nclass NFTProposal(abi.NamedTuple):\n\n    url: abi.Field[abi.String]\n\n    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]\n\n    name: abi.Field[abi.String]\n\n    unit_name: abi.Field[abi.String]\n\n    reserve: abi.Field[abi.Address]\n\n\n\n###############\n\n# DAO Contract\n\n###############\n\n\n\nclass DAOState:\n\n    # Global Storage\n\n    winning_proposal_votes = GlobalStateValue(\n\n        stack_type=TealType.uint64, default=Int(0)\n\n    )\n\n\n\n    winning_proposal = GlobalStateValue(stack_type=TealType.bytes, default=Bytes(\"\"))\n\n\n\n    # Box Storage\n\n    has_voted = BoxMapping(key_type=abi.Address, value_type=abi.Bool)\n\n    \n\n    proposals = BoxMapping(\n\n        key_type=abi.Tuple2[abi.Address, abi.Uint64],\n\n        value_type=NFTProposal,\n\n        prefix=Bytes(\"p-\"),\n\n    )\n\n\n\n    votes = BoxMapping(\n\n        key_type=abi.Tuple2[abi.Address, abi.Uint64],\n\n        value_type=abi.Uint64,\n\n        prefix=Bytes(\"v-\"),\n\n    )\n\n\n\ndao = Application(\"DAO\", state=DAOState)\n\n\n\n\n\n@dao.create(bare=True)\n\ndef create() -> Expr:\n\n    return dao.initialize_global_state()\n\n\n\n\n\n@dao.external\n\ndef add_proposal(\n\n    proposal: NFTProposal, proposal_id: abi.Uint64, mbr_payment: abi.PaymentTransaction\n\n) -> Expr:\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n    addr = abi.Address()\n\n\n\n    return Seq(\n\n        # Assert MBR payment is going to the contract\n\n        Assert(mbr_payment.get().receiver() == Global.current_application_address()),\n\n        # Get current MBR before adding proposal\n\n        pre_mbr := AccountParam.minBalance(Global.current_application_address()),\n\n        # Set proposal key\n\n        addr.set(Txn.sender()),\n\n        proposal_key.set(addr, proposal_id),\n\n        # Check if the proposal already exists\n\n        Assert(dao.state.proposals[proposal_key].exists() == Int(0)),\n\n        # Not using .get() here because desc is already a abi.String\n\n        dao.state.proposals[proposal_key].set(proposal),\n\n        # Verify payment covers MBR difference\n\n        current_mbr := AccountParam.minBalance(Global.current_application_address()),\n\n        Assert(mbr_payment.get().amount() >= current_mbr.value() - pre_mbr.value()),\n\n    )\n\n\n\n\n\n@dao.external\n\ndef vote(proposer: abi.Address, proposal_id: abi.Uint64) -> Expr:\n\n    total_votes = abi.Uint64()\n\n    current_votes = abi.Uint64()\n\n    true_value = abi.Bool()\n\n    zero_val = abi.Uint64()\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n\n\n    return Seq(\n\n        zero_val.set(Int(0)),\n\n        proposal_key.set(proposer, proposal_id),\n\n        # Make sure we haven't voted yet\n\n        Assert(dao.state.has_voted[Txn.sender()].exists() == Int(0)),\n\n        # Get current vote count\n\n        If(dao.state.votes[proposal_key].exists() == Int(0)).Then(\n\n            dao.state.votes[proposal_key].set(zero_val)\n\n        ),\n\n        dao.state.votes[proposal_key].store_into(current_votes),\n\n        # Increment and save total vote count\n\n        total_votes.set(current_votes.get() + Int(1)),\n\n        dao.state.votes[proposal_key].set(total_votes),\n\n        # Check if this proposal is now winning\n\n        If(total_votes.get() > dao.state.winning_proposal_votes.get()).Then(\n\n            dao.state.winning_proposal_votes.set(total_votes.get()),\n\n            dao.state.winning_proposal.set(proposal_key.encode()),\n\n        ),\n\n        # Set has_voted to true\n\n        true_value.set(value=True),\n\n        dao.state.has_voted[Txn.sender()].set(true_value),\n\n    )\n\n\n\n\n\n@dao.external\n\ndef mint(minter_app: abi.Application, *, output: abi.Uint64) -> Expr:\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n    proposal = NFTProposal()\n\n\n\n    return Seq(\n\n        # Get the winning proposal key\n\n        proposal_key.decode(dao.state.winning_proposal.get()),\n\n        # Get the winning proposal\n\n        dao.state.proposals[proposal_key].store_into(proposal),\n\n        # Call NFT minter\n\n        InnerTxnBuilder.ExecuteMethodCall(\n\n            app_id=Tmpl.Int(\"TMPL_MINTER_APP\"),\n\n            method_signature=f\"mint_nft({NFTProposal().type_spec()})uint64\",\n\n            args=[proposal],\n\n        ),\n\n        # Return created asset\n\n        output.set(Btoi(Suffix(InnerTxn.last_log(), Int(4)))),\n\n    )\n\n\n\n\n\n#####################\n\n# NFT Minter Contract\n\n#####################\n\n\n\nminter = Application(\"Minter\")\n\n\n\n\n\n@minter.external\n\ndef mint_nft(proposal: NFTProposal, *, output: abi.Uint64) -> Expr:\n\n    name = abi.String()\n\n    unit_name = abi.String()\n\n    reserve = abi.Address()\n\n    url = abi.String()\n\n    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])\n\n    abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n\n\n    return Seq(\n\n        # Get properties from proposal and mint NFT\n\n        proposal.name.store_into(name),\n\n        proposal.unit_name.store_into(unit_name),\n\n        proposal.reserve.store_into(reserve),\n\n        proposal.url.store_into(url),\n\n        proposal.metadata_hash.store_into(metadata_hash),\n\n        InnerTxnBuilder.Execute(\n\n            {\n\n                TxnField.type_enum: TxnType.AssetConfig,\n\n                TxnField.config_asset_name: name.get(),\n\n                TxnField.config_asset_unit_name: unit_name.get(),\n\n                TxnField.config_asset_reserve: reserve.get(),\n\n                TxnField.config_asset_url: url.get(),\n\n                TxnField.config_asset_metadata_hash: metadata_hash.encode(),\n\n                TxnField.config_asset_total: Int(1),\n\n                TxnField.fee: Int(0),\n\n            }\n\n        ),\n\n        # Return created asset\n\n        output.set(InnerTxn.created_asset_id()),\n\n    )\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    dao.build().export(Path(__file__).resolve().parent / f\"./artifacts/{dao.name}\")\n\n    minter.build().export(\n\n        Path(__file__).resolve().parent / f\"./artifacts/{minter.name}\"\n\n    )"}
{"file_path": "https://github.com/algorand/pyteal/blob/9a610281df4f306f2a0f94483f4a009320a5c63c/pyteal/ast/txn.py", "code": "https://github.com/Sam2much96/algorand_python_Scripts/blob/8c9356be983ffb4b3d0f3221d33eaf4a7d118b6a/contracts/escrow/Box_storage_escrow_3.py"}
{"file_path": "https://github.com/damees/algorand-oracle/blob/f7f078f9d153341d1ba546ff66e8afbf2685f114/algorand-oracle-smart-contracts/src/algorand_oracle.py", "code": "#!/usr/bin/env python3\n# *************************************************\n# godot3-Dystopia-game by INhumanity_arts\n# Released under MIT License\n# *************************************************\n# Box Storage Escrow Smart Contract\n#\n# An ARC 4 Abi Smart Contract\n# THe Entire SmartContract Logic in one File.\n# \n# Features:\n# (1) Box Storage\n# (2) Withdrawals\n# (3) Deposit\n# (4) NFT minting\n\n# To Do:\n# (1) Onchain Method Call \n# (2) Box Storage isn't yet supported in Algonaut Rust Crate, rewrite to use Global Storage\n\nfrom pyteal import *\nfrom beaker import *\n\nimport base64\nimport hashlib\nfrom base64 import b64encode, b64decode\n\nfrom typing import Final\n\n#from beaker.lib.storage import Mapping\n\n\n#beaker documentation : https://algorand-devrel.github.io/beaker/html/application_client.html\n\n\nfrom algosdk.v2client import algod\nfrom algosdk import mnemonic\nfrom beaker.client.application_client import ApplicationClient\nfrom beaker.client.logic_error import LogicException\nfrom beaker.consts import Algos\n\nfrom beaker.lib.storage import Mapping\n\nimport json\nfrom simple_smart_contract import create_app, compile_program, call_app, delete_app, pay, call_app_method, pay_construct, get_application_address, update_app\n\nfrom algosdk.future import transaction\nfrom algosdk.abi import Contract\n\nfrom algosdk.encoding import decode_address , encode_address\n\n# For running Teal inspector\nimport subprocess\n\n# Arc 4 Smart Contract\n\nclass BoxEscrow(Application):\n\n    #uses nonce https://www.investopedia.com/terms/n/nonce.asp\n    hashed_secret: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes,\n        descr=\"A scratch for saving secret nonce to application state\",\n    )\n    \n    #store transaction details to  boxes\n    \n \n    \n    #Bare app calls https://pyteal.readthedocs.io/en/stable/abi.html?highlight=registrable%20methods#registering-bare-app-calls\n    @Subroutine(TealType.none)  \n    def assert_sender_is_creator() -> Expr:\n        return Seq(\n            If(Txn.sender() == Global.creator_address())\n            .Then (\n\n                # If box Storage Exists, delete them\n                Pop(App.box_delete(Bytes(\"BoxA\"))),\n                Pop(App.box_delete(Bytes(\"BoxB\"))),\n                Pop(App.box_delete(Bytes(\"BoxC\")))    \n\n\n                )\n\n            )\n\n\n\n    # move any balance that the user has into the \"lost\" amount when they close out or clear state\n    transfer_balance_to_lost = App.globalPut(\n        Bytes(\"lost\"),\n        App.globalGet(Bytes(\"lost\")) + App.localGet(Txn.sender(), Bytes(\"balance\")),\n    )\n\n\n    \n                \n                \n                \n    \"\"\"\n    Docs:\n        https://pyteal.readthedocs.io/en/stable/abi.html?highlight=call_config#registering-methods\n \n    \"\"\"\n    \n    my_router = Router(\n    name=\"AlgoBank\",\n    bare_calls=BareCallActions(\n        # approve a creation no-op call \n        #no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),\n        no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),\n        # approve opt-in calls during normal usage, and during creation as a convenience for the creator\n        opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL),\n        # move any balance that the user has into the \"lost\" amount when they close out or clear state\n        close_out=OnCompleteAction(\n            action=transfer_balance_to_lost, call_config=CallConfig.CALL\n        ),\n        clear_state=OnCompleteAction(\n            action=transfer_balance_to_lost, call_config=CallConfig.CALL\n        ),\n        # only the creator can update or delete the app\n        update_application=OnCompleteAction(\n            action=assert_sender_is_creator, call_config=CallConfig.CALL\n        ),\n        delete_application=OnCompleteAction(\n            action=assert_sender_is_creator, call_config=CallConfig.CALL\n            ),\n        ),\n    )\n\n    @my_router.method(no_op=CallConfig.CALL, opt_in=CallConfig.CALL)\n    def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:\n        \"\"\"This method receives a payment from an account opted into this app and records it as a deposit.\n\n        The caller may opt into this app during this call.\n\n        Args:\n            payment: A payment transaction containing the amount of Algos the user wishes to deposit.\n                The receiver of this transaction must be this app's escrow account.\n            sender: An account that is opted into this app (or will opt in during this method call).\n                The deposited funds will be recorded in this account's local state. This account must\n                be the same as the sender of the `payment` transaction.\n        \"\"\"\n        return Seq(\n            Assert(payment.get().sender() == sender.address()),\n            Assert(payment.get().receiver() == Global.current_application_address()),\n\n\n        #Global Storage\n        App.globalPut(Bytes(\"Depositors\"), sender.address()),\n                \n\n        # Disabling Box Storage Until it's implemented in Algonaut\n\n        # write to box `A` with new value\n        # Deposit Address\n        #Pop(App.box_create(Bytes(\"BoxA\"), Int(10))),\n        #App.box_put(Bytes(\"BoxA\"), sender.address())\n\n        )\n\n\n    @my_router.method\n    def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:\n        \"\"\"Lookup the balance of a user held by this app.\n\n        Args:\n            user: The user whose balance you wish to look up. This user must be opted into this app.\n\n        Returns:\n            The balance corresponding to the given user, in microAlgos.\n        \"\"\"\n\n\n        return output.set(App.localGet(user.address(), Bytes(\"balance\")))\n\n\n    @my_router.method\n    def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:\n        \"\"\"Withdraw an amount of Algos held by this app.\n\n        The sender of this method call will be the source of the Algos, and the destination will be\n        the `recipient` argument.\n\n        The Algos will be transferred to the recipient using an inner transaction whose fee is set\n        to 0, meaning the caller's transaction must include a surplus fee to cover the inner\n        transaction.\n\n        Args:\n            amount: The amount of Algos requested to be withdraw, in microAlgos. This method will fail\n                if this amount exceeds the amount of Algos held by this app for the method call sender.\n            recipient: An account who will receive the withdrawn Algos. This may or may not be the same\n                as the method call sender.\n        \"\"\"\n        return Seq(\n\n            If(Txn.sender() != Global.creator_address()) \n\n            .Then( \n\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields(\n                    {\n                        TxnField.type_enum: TxnType.Payment,\n                        TxnField.receiver: recipient.address(),\n                        TxnField.amount: amount.get(),\n                        TxnField.fee: Int(0),\n                    }\n                ),\n                InnerTxnBuilder.Submit(),\n\n                #Global Storage\n                App.globalPut(Bytes(\"Withdrwl\"), amount.get()),\n                \n                App.globalPut(Bytes(\"Receipient\"), recipient.address()),\n                \n                \n                # Disabling Box Storages until it'simplemented in Algonaut\n\n                # write to box `B` with new value \"Withdrawal Amount\"\n                # converted from an Integer to a Byte\n                # App.box_put(Bytes(\"BoxB\"), Itob(amount.get())),\n                \n                # write to box `C` with new value \"Withdrawal To Address\"\n                #App.box_put(Bytes(\"BoxC\"), recipient.address())\n                )\n            .ElseIf( Txn.sender() == Global.creator_address())\n            .Then(Approve())\n        )\n\n\n    \n    #    \"\"\"\n    #    Triggers an Abi method call via smartcontracts\n\n\n    #    Args:\n    #        Abi Arguments to this method via BareApp calls\n\n    #    Docs: https://pyteal.readthedocs.io/en/stable/api.html?highlight=MethodCall#pyteal.InnerTxnBuilder.MethodCall\n\n    #    \"\"\"\n\n\n\n\n    @my_router.method\n    def mint(recipient : abi.Account, payment: abi.PaymentTransaction) -> Expr:\n        \"\"\"Mints an Asset Token To a Recipient Wallet Address\n            the caller's transaction must include a surplus fee to cover the inner\n            transaction\n\n        Args:\n            recipient: An account who will receive the withdrawn Algos. This may or may not be the same \n            as the method call sender.\n\n        Docs: https://pyteal.readthedocs.io/en/stable/api.html#pyteal.TxnExpr\n\n        \"\"\"\n\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(1),\n                TxnField.config_asset_unit_name: Bytes(\"PUNK 001\"),\n                TxnField.config_asset_name: Bytes(\"CryptoPunk\"),\n                TxnField.config_asset_url: Bytes(\"ipfs://QmXYApu5uDsfQHMx149LWJy3x5XRssUeiPzvqPJyLV2ABx\"), #CryptoPunk Asset CID\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n            }),\n            InnerTxnBuilder.Submit(),\n\n            #Bug for Testing debug state\n\n            #InnerTxnBuilder.Begin(),\n            #InnerTxnBuilder.SetFields({\n            #    TxnField.type_enum: TxnType.AssetTransfer,\n            #   TxnField.asset_receiver: recipient.address(),\n            #    TxnField.asset_amount: Int(1),\n            #    TxnField.xfer_asset: Txn.assets[0], # Must be in the assets array sent as part of the application call\n            #}),\n            #InnerTxnBuilder.Submit(),\n\n        )\n\n\n\n    approval_program, clear_state_program, contract = my_router.compile_program(\n        version=8, optimize=OptimizeOptions(scratch_slots=True)\n    )\n\n\n\n\n\n    \"\"\"\n    Write Out the Approval and Clear Programs. \n    Dump the Contract's method to a .json file.\n\n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"w\") as f:\n        f.write(approval_program)\n\n    with open(\"algobank_clear_state.teal\", \"w\") as f:\n        f.write(clear_state_program)\n        \n    with open(\"algobank.json\", \"w\") as f:\n        f.write(json.dumps(contract.dictify(), indent=4))\n\n\n\n\n\n\n\n\n\n    \n\n# Sha 265 Hashes a String\ndef sha256b64(s: str) -> str:\n    return base64.b64encode(hashlib.sha256(str(s).encode(\"utf-8\")).digest()).decode(\"utf-8\")\n\n#Configured to Testnet\n#\n#\ndef create_algorand_node_and_acct(command: str):\n    \n    # test-net\n    algod_address = \"https://node.testnet.algoexplorerapi.io\"\n    algod_token = \"\"\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n\n\n    _params = algod_client.suggested_params()\n\n    __mnemonic : str = \"tank game arrive train bring taxi tackle popular bacon gasp tell pigeon error step leaf zone suit chest next swim luggage oblige opinion about execute\"\n\n    __mnemonic_2 : str = \"degree feature waste gospel screen near subject boost wreck proof caution hen adapt fiber fault level blind entry also embark oval board bunker absorb garage\"\n\n    __mnemonic_3 : str = \"scrub garment fashion column property obscure agree mobile maple stage pass boat snow diary canyon lesson under curtain impact earn calm maximum song ability together\"\n\n\n    #For Sandbox\n    #client = sandbox.get_algod_client()\n\n    #accts = sandbox.get_accounts()\n\n    accts = {}\n    accts[1] = {}\n    accts[1]['pk'] = mnemonic.to_public_key(__mnemonic) #saves the new account's address\n    accts[1]['sk'] = mnemonic.to_private_key(__mnemonic) #saves the new account's mnemonic\n    \n    mnemonic_obj_a1 = mnemonic.to_private_key(__mnemonic)\n    mnemonic_obj_a2 = mnemonic.to_public_key(__mnemonic)\n    \n    #acct = accts.pop()\n\n    print('Algod Client Status: ',algod_client.status())\n\n    print (accts[1])\n\n    #other accounts\n    accts[2] = {}\n    accts[2]['pk'] = mnemonic.to_public_key(__mnemonic_2)\n    accts[2]['sk'] = mnemonic.to_private_key(__mnemonic_2)\n\n    accts[3] = {}\n    accts[3]['pk'] = mnemonic.to_public_key(__mnemonic_3)\n    accts[3]['sk'] = mnemonic.to_private_key(__mnemonic_3)\n\n\n\n    mnemonic_obj_b1 = mnemonic.to_private_key(__mnemonic_2)\n    mnemonic_obj_b2 = mnemonic.to_public_key(__mnemonic_2)\n    \n\n\n    # Create an Application client containing both an algod client and my app\n    \n    app_client = algod.AlgodClient(algod_token, algod_address,headers={'User-Agent': 'DoYouLoveMe?'})\n\n    \n\n    _app_id : int = 157718578  \n\n    escrow_address =get_application_address(_app_id)\n\n    pc :int = 79\n\n    print('Algod Client Status: ',algod_client.status())\n\n    command = input(\"Enter command  [deploy,pay,withdraw,deposit,mint,fetch, fetch2, balance, delete, update ,debug ]  \")\n    \n    \"*****************Perform Transactions Operations**********************\"\n\n    match command:\n        case \"deploy\":\n\n            \n\n\n\n            \"Deploy Smart Contract\"\n            deploy(_params, accts[1]['sk'],algod_client, 2500)\n        case \"delete\":\n    \n            \"Delete Smart Contract\"\n            delete_app(algod_client, accts[1]['sk'], _app_id)\n        case \"pay\" :\n        \n            \n\n            \"Pay to Account\"\n            pay(algod_client, accts[1]['sk'], escrow_address, 1101101)\n\n        case \"withdraw\":\n    \n            \n            call_app_method(app_client,accts[3]['sk'],_app_id, 2500,get_method(\"withdraw\"), 10_000,accts[3]['pk'] )\n\n        case \"deposit\":\n\n        \n\n            print (\"depositing 101100 MicroAlgos to Escrow Address \", escrow_address)\n\n            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)\n\n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"deposit\"), txn ,accts[2]['pk'] )\n        case \"update\":\n\n\n            update_(app_client, _app_id, _params,accts[1]['sk'])\n\n\n        case \"mint\":\n\n            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)            \n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"mint\"), accts[2]['pk'] ,txn )\n            \n\n        case \"fetch\" :\n            \n            #Prints Withdrawal & Deposit Information from box storage as Raw Bytes\n            \n\n            print(\"Withdrawal Amounts: \",app_client.application_box_by_name(_app_id,bytes(\"BoxB\".encode('utf-8', 'strict'))))\n\n            print(\"Withdrawal recipients: \",app_client.application_box_by_name(_app_id,bytes(\"BoxC\".encode('utf-8', 'strict'))))\n  \n            print(\"Depositors Address: \", app_client.application_box_by_name(_app_id,bytes(\"BoxA\".encode('utf-8', 'strict'))))\n\n        case \"fetch2\" :\n            #Prints Withdrawal & Deposit Information from box storage Decoded to Int and String\n            #Documentation: https://developer.algorand.org/docs/get-details/encoding/\n            \n            result2 = app_client.application_box_by_name(_app_id,bytes(\"BoxC\".encode('utf-8', 'strict')))\n            q =encode_address(base64.b64decode(result2[\"value\"]))\n            print (\"Withdrawal recipients: \",q)\n\n\n            result3 = app_client.application_box_by_name(_app_id,bytes(\"BoxA\".encode('utf-8', 'strict')))\n            g =encode_address(base64.b64decode(result3[\"value\"]))\n            print (\"Depositors Addresses: \",g)\n\n\n\n            result =app_client.application_box_by_name(_app_id,bytes(\"BoxB\".encode('utf-8', 'strict')))\n            \n            p = int.from_bytes(base64.b64decode(result[\"value\"]), byteorder=\"big\")\n            print(\"Withdrawal Amount: \",p)\n\n            \n\n        case \"balance\":\n\n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"balance\"),accts[2]['pk'] )\n\n        case \"debug\":\n            pc =input (\"enter program counter\")\n            # Using system() method  and Teal Inspector to\n            # execute shell commands\n            subprocess.Popen('tealinspector --network testnet --application_id {} --program_counter {}'.format(_app_id, pc), shell=True)\n\n        case other:\n            print (\"No Match Found, Please Pass a Valid command to this Method in ln 309\")\n\n\n# Utility function to get the Method object for a given method name\ndef get_method(name: str) :\n    with open(\"algobank.json\") as f:\n        js = f.read()\n    c = Contract.from_json(js)\n    for m in c.methods:\n        if m.name == name:\n            print (\"M: \",m.name)\n            return m\n    raise Exception(\"No method with the name {}\".format(name))\n\n\ndef update_(algod_client, app_id, params, private_key):\n\n    #Docs: https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/transaction.html?highlight=ApplicationUpdateTxn#algosdk.transaction.ApplicationUpdateTxn\n\n\n    # Read the compiled approvl & clear programs Teal files \n    \n    \"\"\"\n   \n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"r\") as f:\n        approval_program = f.read()\n\n    with open(\"algobank_clear_state.teal\", \"r\") as f:\n        clear_state_program= f.read()\n   \n\n    # compile program to binary\n    approval_program_compiled = compile_program(algod_client, approval_program)\n\n    # compile program to binary\n    clear_state_program_compiled = compile_program(algod_client, clear_state_program)\n\n    update_app(algod_client, app_id, params ,private_key, approval_program_compiled,clear_state_program_compiled)\n\n\n\ndef deploy(_params, mnemonic_ ,algod_client, fee):\n\n    _params.flat_fee = True\n    _params.fee = fee\n\n\n    # declare application state storage (immutable)\n    local_ints = 0\n    local_bytes = 0\n    global_ints = 1\n    global_bytes = 1\n    global_schema = transaction.StateSchema(global_ints, global_bytes)\n    local_schema = transaction.StateSchema(local_ints, local_bytes)\n\n\n    # Read the compiled approvl & clear programs Teal files \n    \n    \"\"\"\n   \n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"r\") as f:\n        approval_program = f.read()\n\n    with open(\"algobank_clear_state.teal\", \"r\") as f:\n        clear_state_program= f.read()\n   \n\n\n    \n\n\n\n    response = algod_client.compile(approval_program)\n    print (\"Raw Response =\",response )\n    print(\"Response Result = \",response['result'])\n    print(\"Response Hash = \",response['hash'])\n\n\n    # compile program to binary\n    approval_program_compiled = compile_program(algod_client, approval_program)\n\n    # compile program to binary\n    clear_state_program_compiled = compile_program(algod_client, clear_state_program)\n\n\n    app_id = create_app(algod_client,_params ,mnemonic_, approval_program_compiled, clear_state_program_compiled, global_schema, local_schema)\n\n    # Create the applicatiion on chain, set the app id for the app client & store app secret\n    print(f\"Created App with id: {app_id} \")\n\n\n\"\"\"\nTHE MAIN METHOD\n\"\"\"\n\nif __name__ == \"__main__\":\n    \n    #Builds the progam and deploys\n    ca = BoxEscrow()\n    \n\n    # Application State Machine\n    create_algorand_node_and_acct(\"\")"}
{"file_path": "https://github.com/0xLiquidGlass/unnamed/blob/b0d80257651279c7a3b02073f5e2f0d313fe7455/unnamedwallet/src/AtomicTxUtils.py", "code": "https://github.com/Sotatek-NguyenNguyen/gs-sc-algo/blob/04452faf44e9472fd718b9a50c13a5c4b83a564a/contract/nftContracts.py"}
{"file_path": "https://github.com/hodgerpodger/staketaxcsv/blob/98e02ecf0d00e0152d03359fb2f383352ee4702e/src/staketaxcsv/algo/api/indexer.py", "code": "from pyteal import *\n\n\ndef approval_program():\n    # Global\n    asset_name = Bytes(\"asset_name\")\n\n    # @Subroutine(TealType.uint64)\n    # def executeAssetCreationTxn(txn_index: TealType.uint64) -> TxnExpr:\n    #     \"\"\"\n    #     returns the ID of the generated asset or fails\n    #     \"\"\"\n    #     call_parameters = Gtxn[txn_index].application_args\n    #     asset_total = Btoi(call_parameters[3])\n    #     decimals = Btoi(call_parameters[4])\n    #     return Seq([\n    #         InnerTxnBuilder.Begin(),\n    #         InnerTxnBuilder.SetFields({\n    #             TxnField.type_enum: TxnType.AssetConfig,\n    #             # TxnField.config_asset_name: call_parameters[1],\n    #             # TxnField.config_asset_unit_name: call_parameters[2],\n    #             # TxnField.config_asset_total: asset_total,\n    #             # TxnField.config_asset_decimals: decimals,\n    #             # TxnField.config_asset_url: call_parameters[5],\n\n    #             # TxnField.config_asset_default_frozen: Int(1),\n    #             # TxnField.config_asset_metadata_hash: call_parameters[0],\n\n    #             TxnField.config_asset_manager: Global.current_application_address(),\n    #             TxnField.config_asset_reserve: Global.current_application_address(),\n    #             TxnField.config_asset_freeze: Global.current_application_address(),\n    #             TxnField.config_asset_clawback: Global.current_application_address(),\n    #         }),\n    #         InnerTxnBuilder.Submit(),\n    #         Log(Itob(InnerTxn.created_asset_id())),\n    #         # InnerTxn.created_asset_id()\n    #     ])\n\n    @Subroutine(TealType.none)\n    def executeAssetCreationTxn() -> TxnExpr:\n        return Seq([\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_name: App.globalGet(asset_name),\n                TxnField.config_asset_unit_name: Txn.application_args[1],\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(0),\n                TxnField.config_asset_url: Txn.application_args[2],\n\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n            }),\n            InnerTxnBuilder.Submit(),\n            Log(Itob(InnerTxn.created_asset_id())),\n        ])\n\n    @Subroutine(TealType.none)\n    def executeAssetTransferTxn() -> TxnExpr:\n        return Seq([\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: Txn.assets[0],\n                    TxnField.asset_receiver: Txn.accounts[1],\n                    # TxnField.asset_close_to:Txn.accounts[1],\n                    TxnField.asset_amount: Int(1),\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        ])\n\n    @Subroutine(TealType.none)\n    def executeAssetDestroyTxn() -> TxnExpr:\n        return Seq([\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.type_enum: TxnType.AssetConfig,\n                    # TxnField.xfer_asset: Txn.assets[0],\n                    TxnField.config_asset: Txn.assets[0]\n\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        ])\n\n    on_create = Seq(\n        App.globalPut(asset_name, Txn.application_args[0]),\n        Approve(),\n    )\n    on_mint = Seq(\n        executeAssetCreationTxn(),\n        Approve(),\n    )\n    on_withdraw = Seq(\n        executeAssetTransferTxn(),\n        Approve(),\n    )\n    on_deposit = Seq(\n        executeAssetDestroyTxn(),\n        Approve(),\n    )\n\n    on_call_method = Txn.application_args[0]\n    on_call = Cond(\n        [on_call_method == Bytes(\"mint\"), on_mint],\n        [on_call_method == Bytes(\"withdraw\"), on_withdraw],\n        [on_call_method == Bytes(\"deposit\"), on_deposit],\n\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, on_call],\n        [\n            Or(\n                Txn.on_completion() == OnComplete.OptIn,\n                Txn.on_completion() == OnComplete.CloseOut,\n                Txn.on_completion() == OnComplete.UpdateApplication,\n            ),\n            Reject(),\n        ],\n    )\n\n    return program\n\n\ndef clear_state_program():\n    return Approve()\n\n\nwith open(\"teal/nft/auction_approval.teal\", \"w\") as f:\n    compiled = compileTeal(\n        approval_program(), mode=Mode.Application, version=5)\n    f.write(compiled)\n\nwith open(\"teal/nft/auction_clear_state.teal\", \"w\") as f:\n    compiled = compileTeal(clear_state_program(),\n                           mode=Mode.Application, version=5)\n    f.write(compiled)"}
{"file_path": "https://github.com/johnnyknoxville1337/voting-contract/blob/fae150f93a98bc0b048a103971785ce891c96eed/src/Beaker/voting.py", "code": "https://github.com/CupStakes/cupstakes-smart-contracts/blob/2155155985eb525f111458e0c237b0aaed642c39/draw/sc.py"}
{"file_path": "https://github.com/scale-it/algo-builder/blob/c07b978651def4891768c618f0bc9cd7fab69bca/examples/permissioned-voting/assets/permissioned-voting-approval.py", "code": "from pyteal import *\nfrom assets import ticket_price, burn_ticket_price, storage_app_id, oracle_app_id, rewards_pool_address, super_admin_address\n\n# Of the above:\n# - immutable:\n#   - rewards_pool_address: hardcoded\n#   - storage_app_id: hardcoded\n# - mutable / just initial values, stored in global storage:\n#   - ticket_price\n#   - burn_ticket_price\n#   - oracle_app_id\n\nstorage_app_id_int = Int(storage_app_id)\n\nmax_randomness_range = 1000\n\n# Define Byte sequences used\n# Numbers and special symbols\nbytes_empty = Bytes('')\nbytes_151f7c75 = Bytes('base16', '151f7c75') # successful return from ABI call header\n\n# global storage lookup keys\n# kill switch: leave only \"collect\" action available\nkill_switch_key = Bytes('kill')\n# free draw NFT ID + implicit availability \nfree_draw_nft_id_key = Bytes('free_draw_nft')\n# ticket price in mAlgo\nticket_key = Bytes('ticket')\nburn_ticket_key = Bytes('burn_ticket')\n# oracle app id\noracle_app_id_key = Bytes('oracle_app_id')\n# sum or all odds of team NFTs. MUST BE POWER OF TWO\nmax_odds_key = Bytes('max_odds')\n# randomness oracle maximum range\nmax_randomness_range_key = Bytes('max_randomness_range')\n\n# local (user) storage lookup keys\n# NFT slots, available to collect\nslot1_key = Bytes(\"slot1\")\nslot2_key = Bytes(\"slot2\")\nslot3_key = Bytes(\"slot3\")\n# queued draw action. valid after round\ndraw_round_key = Bytes(\"draw_round\")\n# queued draw action. amount to draw\ndraw_amount_key = Bytes(\"draw_amount\")\ndraw_amount_paid_key = Bytes(\"draw_amount_paid\")\n\n# Log and misc\nbytes_rand = Bytes('rand')\nbytes_ret = Bytes('ret')\nbytes_default = Bytes('default')\nbytes_rand_mapped = Bytes(\"Rand mapped\")\n\n# extra_fields{} for zero fees\nzero_fee_extra_fields={}\nzero_fee_extra_fields[TxnField.fee]=Int(0)\n\n# error strings end up in algod error messages <3\nerr_contract_killed = \"CONTRACT KILLED\"\nerr_validation = \"VALIDATION FAIL\"\nerr_payment_incorrect = \"PAYMENT FAIL\"\nerr_payment_amount_invalid = \"PAYMENT AMT FAIL\"\nerr_wait_for_randomness = \"WAIT FOR RANDOMNESS\"\nerr_oracle_invalid = \"ORACLE INVALID\"\nerr_randomness_fail = \"RANDOMNESS FAIL\"\nerr_drawing_failed = \"DRAWING FAILED\"\nerr_drawing_disabled = \"DRAWING DISABLED\"\nerr_slot_not_empty = \"MUST COLLECT\"\nerr_no_free_slot = \"NO FREE SLOT\"\nerr_no_slots_full = \"NO NFTs IN SLOTS\"\nerr_unauthorized = \"UNAUTH\"\nerr_draw_queued = \"ERR DRAW QUEUED ALREADY\"\nerr_no_draw_queued = \"ERR NO DRAW QUEUED\"\nerr_randomness_expired = \"ERR RANDOMNESS EXPIRED\"\nerr_randomness_not_expired = \"ERR RANDOMNESS NOT EXPIRED\"\nerr_no_burn_available = \"ERR BURN NOT AVAILABLE\"\nerr_invalid_slot = \"ERR INVALID SLOT\"\nerr_no_burn_hacking = \"ERR NO BURN HACKING\"\n\nopup = OpUp(OpUpMode.Explicit, storage_app_id_int)\n\n# my greatest invention\n# assert that fails with an error string attached\n# Example error message: logic eval error: assert failed pc=2330. Details: pc=2330, opcodes=pushbytes 0x45525220445241572051554555454420414c5245414459 // \"ERR DRAW QUEUED ALREADY\"\ndef custom_assert(cond, str):\n    return If(Not(cond)).Then(Assert(Bytes('') == Bytes(str)))\n\n# same as above, but inversed - skips a Not()\n# not sure if it saves opcode costs\ndef fail_if(cond, str):\n    return If(cond).Then(Assert(Bytes('') == Bytes(str)))\n\n# as above but without condition\ndef fail(str):\n    return Assert(bytes_empty == Bytes(str))\n\n# helper function to get the draw amount of a user\n# called with 0 for txn sender (draw/freedraw) or 1 (first Txn.accounts entry) for executing the draw \ndef user_draw_amount(acctIdx):\n    return App.localGet(acctIdx, draw_amount_key)\n\n# return whether draw_round randomness has expired for user $acct\n# called with 1 (first Txn.accounts entry) for executing the draw or refund\ndef randomness_expired(addrIdx):\n    return Global.round() > App.globalGet(max_randomness_range_key) + App.localGet(addrIdx, draw_round_key)\n\n# reset user draw state to initial (no draw)\n# called with 0 when opting in or 1 (first Txn.accounts entry) for executing the draw \ndef reset_user_draw_state(addrIdx):\n    return Seq(\n        App.localPut(addrIdx, draw_amount_key, Int(0)),\n        App.localPut(addrIdx, draw_amount_paid_key, Int(0)),\n        App.localPut(addrIdx, draw_round_key, Int(0))\n    )\n\n# Set up default values upon creation; convenience operation, all of these are updatable\nhandle_creation = Seq(\n    App.globalPut(kill_switch_key, Int(0)), # kill-switch when 1 - only allow collecting and emptying NFTs\n    App.globalPut(free_draw_nft_id_key, Int(0)), # free draw NFT ID\n    App.globalPut(ticket_key, Int(ticket_price)), # ticket price in mAlgo\n    App.globalPut(burn_ticket_key, Int(burn_ticket_price)), # burn ticket price in mAlgo\n    App.globalPut(max_odds_key, Int(1048576)), # max odds for modulo op. MUST BE POWER OF TWO\n    App.globalPut(oracle_app_id_key, Int(oracle_app_id)), # randomness oracle app id - mutable in case of permanent beacon failure\n    App.globalPut(max_randomness_range_key, Int(max_randomness_range)), # range after which to refund ticket price\n    Approve()\n)\n\n# User opting in: Set up 3 local storage slots representing drawn NFT ID load slots,\n# and the \"draw queue\" entries: amount of draws and round to draw at\nhandle_optin = Seq(\n    App.localPut(Int(0), slot1_key, Int(0)),\n    App.localPut(Int(0), slot2_key, Int(0)),\n    App.localPut(Int(0), slot3_key, Int(0)),\n    reset_user_draw_state(Int(0)),\n)\n\n# Collect available NFTs\n# Assumes we have \"infinite\" NFTs available - will mint 10M per for CupStakes\n@Subroutine(TealType.none)\ndef sub_collect():\n    return Seq(\n        # check that at least some NFT slots are full\n        custom_assert(Or(\n            App.localGet(Int(0), slot1_key) != Int(0),\n            App.localGet(Int(0), slot2_key) != Int(0),\n            App.localGet(Int(0), slot3_key) != Int(0)\n        ), err_no_slots_full),\n        If(App.localGet(Int(0), slot1_key) != Int(0)).Then(Seq(\n            # send slot 1\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.localGet(Int(0), slot1_key),\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0)\n            }),\n            # clear slot 1\n            App.localPut(Int(0), slot1_key, Int(0))\n        )),\n        If(App.localGet(Int(0), slot2_key) != Int(0)).Then(Seq(\n            # send slot 2\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.localGet(Int(0), slot2_key),\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0)\n            }),\n            # clear slot 2\n            App.localPut(Int(0), slot2_key, Int(0))\n        )),\n        If(App.localGet(Int(0), slot3_key) != Int(0)).Then(Seq(\n            # send slot 3\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: App.localGet(Int(0), slot3_key),\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0)\n            }),\n            # clear slot 3\n            App.localPut(Int(0), slot3_key, Int(0))\n        )),\n    )\n\n# validate that the contract is not killswitched\n@Subroutine(TealType.none)\ndef not_killed():\n    return custom_assert(App.globalGet(kill_switch_key) == Int(0), err_contract_killed)\n\n# validate caller is the super_admin_address\n@Subroutine(TealType.none)\ndef super_admin_only():\n    return fail_if(Gtxn[0].sender() != Addr(super_admin_address), err_unauthorized)\n\n# validate called is admin/creator\n@Subroutine(TealType.none)\ndef admin_only():\n    return fail_if(Gtxn[0].sender() != Global.creator_address(), err_unauthorized)\n\n# Handles deleting the contract\n# Will send all ALGO And remaining NFTs to the rewards wallet\nhandle_delete_app = Seq(\n    admin_only(),\n    InnerTxnBuilder.Execute({\n        TxnField.type_enum: TxnType.Payment,\n        TxnField.close_remainder_to: Global.creator_address(),\n        TxnField.fee: Int(0),\n    })\n)\n\n# handle user's app close-out and clear-out\n# If we have NFTs available in slots and user requests close-out\n# we opt into them in the group txn if necessary\n# so here we send them\n# and then delete local state (likely not needed)\n# close-out may fail if not opted in, clear-out will not\nhandle_close_out = Seq(\n    If(Or(\n        App.localGet(Int(0), slot1_key) != Int(0),\n        App.localGet(Int(0), slot2_key) != Int(0),\n        App.localGet(Int(0), slot3_key) != Int(0)\n    )).Then(\n        sub_collect()\n    ),\n    App.localDel(Int(0), slot1_key),\n    App.localDel(Int(0), slot2_key),\n    App.localDel(Int(0), slot3_key),\n)\n\n# Main router class\nrouter = Router(\n    # Name of the contract\n    \"draw\",\n    # What to do for each on-complete type when no arguments are passed (bare call)\n    BareCallActions(\n        # On create only, just approve\n        no_op=OnCompleteAction.create_only(handle_creation),\n        # Always let creator update/delete but only by the creator of this contract\n        update_application=OnCompleteAction.call_only(super_admin_only), # super admin = 2/2 multisig:nullun+D13\n        delete_application=OnCompleteAction.call_only(handle_delete_app), # admin = D13\n        opt_in=OnCompleteAction.always(handle_optin), # user opt-in - set up user local state\n        close_out=OnCompleteAction.call_only(handle_close_out), # send stored NFTs before closing out state (will fail if user is not opted in)\n        clear_state=OnCompleteAction.call_only(handle_close_out) # attempt to send NFTs before clearing state (won't fail)\n    ),\n)\n\n# admin method to close out all held NFTs to creator address\n# intentionally allowed when contract is killed\n@router.method\ndef closeout_nft():\n    i = ScratchVar(TealType.uint64)\n    return Seq(\n        # creator is calling us or fail\n        admin_only(),\n        # iterate all foreign assets in Txn, close out\n        For(i.store(Int(0)), i.load() < Txn.assets.length(),  i.store(i.load() + Int(1))).Do(Seq(\n            # close out remaining NFT balances to creator address\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: Txn.assets[i.load()],\n                TxnField.asset_close_to: Global.creator_address(),\n            })\n        ))\n    )\n\n# admin method to opt contract in to NFTs\n# opts in to all txn's foreign assets\n@router.method\ndef optin():\n    i = ScratchVar(TealType.uint64)\n    return Seq(\n        # creator is calling us or fail\n        admin_only(),\n        # disabled when contract is killed\n        not_killed(),\n        # iterate all foreign assets in Txn, opt in\n        For(i.store(Int(0)), i.load() < Txn.assets.length(),  i.store(i.load() + Int(1))).Do(\n            # send opt-in to NFT txn\n            InnerTxnBuilder.Execute({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: Txn.assets[i.load()],\n                TxnField.asset_receiver: Global.current_application_address(),\n            })\n        )\n    )\n\n# admin method to change global state (8x)\n@router.method\ndef update_state_int(key1: abi.DynamicBytes, val1: abi.Uint64,\n                     key2: abi.DynamicBytes, val2: abi.Uint64,\n                     key3: abi.DynamicBytes, val3: abi.Uint64,\n                     key4: abi.DynamicBytes, val4: abi.Uint64,\n                     key5: abi.DynamicBytes, val5: abi.Uint64,\n                     key6: abi.DynamicBytes, val6: abi.Uint64,\n                     key7: abi.DynamicBytes, val7: abi.Uint64,\n                     key8: abi.DynamicBytes, val8: abi.Uint64):\n    return Seq(\n        # only admin/creator can call update global state\n        admin_only(),\n        # disabled when contract is killed\n        not_killed(),\n        If(key1.get() != bytes_empty).Then(App.globalPut(key1.get(), val1.get())),\n        If(key2.get() != bytes_empty).Then(App.globalPut(key2.get(), val2.get())),\n        If(key3.get() != bytes_empty).Then(App.globalPut(key3.get(), val3.get())),\n        If(key4.get() != bytes_empty).Then(App.globalPut(key4.get(), val4.get())),\n        If(key5.get() != bytes_empty).Then(App.globalPut(key5.get(), val5.get())),\n        If(key6.get() != bytes_empty).Then(App.globalPut(key6.get(), val6.get())),\n        If(key7.get() != bytes_empty).Then(App.globalPut(key7.get(), val7.get())),\n        If(key8.get() != bytes_empty).Then(App.globalPut(key8.get(), val8.get())),\n    )\n\n# mint \"free draw\" nft that is accepted in lieu of ticket by free_draw entry point\n# admin only; admin must pay the ticket price into the rewards pool\n@router.method\ndef get_free_draw_nft(num: abi.Uint64):\n    return Seq(\n        # only creator can make free_draw nfts\n        admin_only(),\n        # disabled when contract is killed\n        not_killed(),\n        # drawing enabled check. is this pointless?\n        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),\n        # first group txn type == algo payment\n        fail_if(Gtxn[0].type_enum() != TxnType.Payment, err_payment_incorrect),\n        # multisig rewards should receive the funds\n        fail_if(Gtxn[0].receiver() != Addr(rewards_pool_address), err_payment_incorrect),\n        # validate enough paid\n        fail_if(Gtxn[0].amount() != num.get() * App.globalGet(ticket_key), err_payment_amount_invalid),\n        # send NFT \n        InnerTxnBuilder.Execute({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: App.globalGet(free_draw_nft_id_key),\n            # hardcoded to creator address\n            TxnField.asset_receiver: Global.creator_address(),\n            TxnField.asset_amount: num.get(),\n            # user pays fees\n            TxnField.fee: Int(0)\n        })\n    )\n\n# function to validate ALGO payments for 1/3 draws or 1/2/3 burns\n# fails is drawing is disabled (ticket price == 0)\n# ticket_key will be 'ticket' or 'burn_ticket'\n@Subroutine(TealType.none)\ndef validate_payment(multiplier, ticket_key):\n    return Seq(\n        # multiplier is 1 or 3\n        # validate first payment: (algo) payment type\n        fail_if(Gtxn[0].type_enum() != TxnType.Payment, err_payment_incorrect),\n        # validate first payment: multiplier times ticket price\n        fail_if(Gtxn[0].amount() != multiplier * App.globalGet(ticket_key), err_payment_amount_invalid),\n        # receiver must be rewards pool address\n        fail_if(Gtxn[0].receiver() != Addr(rewards_pool_address), err_payment_incorrect),\n    )\n\n# function to validate Free Draw NFT payments for 1x Free Draw\n# fails is drawing is disabled (ticket price == 0)\n@Subroutine(TealType.none)\ndef validate_free_draw_payment(multiplier):\n    return Seq(\n        # drawing enabled check. redundant as we check in queue_draw but we deployed it like this, so :)\n        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),\n        # validate free draw payment with free draw nft\n        fail_if(Gtxn[0].type_enum() != TxnType.AssetTransfer, err_payment_incorrect),\n        # multiplier will be = 1\n        fail_if(Gtxn[0].asset_amount() != multiplier, err_payment_amount_invalid),\n        # free draw NFTs should be sent to the application address\n        fail_if(Gtxn[0].asset_receiver() != Global.current_application_address(), err_payment_incorrect),\n        # confirm NFT ID matches\n        fail_if(Gtxn[0].xfer_asset() != App.globalGet(free_draw_nft_id_key), err_payment_incorrect)\n    )\n\n# get random bytes from randomness oracle for $acct, round $rand_count - $cur\n# going before $rand_count is safe because rounds [$seed-7 -> $seed] are seeded by $seed round\n# returns random 32 byte / 256 bit sequence\n# account here is BYTES, not index like in other calls\n@Subroutine(TealType.bytes)\ndef get_random_bytes(acct, rand_round, cur):\n    res = abi.DynamicBytes()\n    return Seq(\n        # call the randomness contract\n        # passing round-$i (i in 0,1,2) and user address as user_bytes\n        # for multiple calls we prefer to call 3x for transparency w/ end users\n        InnerTxnBuilder.ExecuteMethodCall(\n            app_id=App.globalGet(oracle_app_id_key),\n            method_signature=\"get(uint64,byte[])byte[]\", # using get instead of must_get intentionally, handling zero byte return further down when randomness isn't ready (pretty error message)\n            args=[Itob(Minus(rand_round, cur)), acct],\n            extra_fields=zero_fee_extra_fields, # user pays fees\n        ),\n        # last_log is the encoded ABI return value\n        # It must begin with hex 151f7c75\n        fail_if(Len(InnerTxn.last_log()) < Int(6), err_oracle_invalid),\n        fail_if(Substring(InnerTxn.last_log(), Int(0), Int(4)) != bytes_151f7c75, err_randomness_fail),\n        # decode the ABI return value into res scratch slot\n        abi.DynamicBytes.decode(res, Substring(InnerTxn.last_log(), Int(4), Len(InnerTxn.last_log()))),\n        # check that it isn't zero (eg when randomness was not ready yet)\n        fail_if(res.get() == bytes_empty, err_randomness_fail),\n        Log(bytes_rand),\n        Log(res.get()),\n        Return(res.get())\n    )\n\n# helper to get int value from storage contract's global storage\n@Subroutine(TealType.uint64)\ndef get_ext_storage(keynum):\n    extvalue = App.globalGetEx(storage_app_id_int, Itob(keynum))\n    return Seq(\n        extvalue, # must include this or pyteal compilation fails\n        Return(extvalue.value())\n    )\n\n# pick next round as a draw target\n# if we are at round mod 8 == 0 it is safe to use current round\n# as the randomness seed is based on this current block's signature\n# so it can't be known yet\n# otherwise choose the next multiple of 8\n@Subroutine(TealType.uint64)\ndef get_next_rand_round():\n    return Return(Cond( # I don't know why this isn't an If() statement. Don't ask. Still, effectively the same.\n        [Mod(Global.round(), Int(8)) == Int(0), Global.round()],\n        [Int(1), Add(Global.round(), Minus(Int(8), Mod(Global.round(), Int(8))))],\n    ))\n\n# map a 256 bit random value into one of the NFTs according to their rarity\n# team NFT IDs and odds are stored like so:\n# 1: TEAM_1_NFT_ID\n# 2: TEAM_1_ODDS\n# 3: TEAM_2_NFT_ID\n# 4: TEAM_2_ODDS + TEAM_1_ODDS\n# ...\n# 63: TEAM_32_NFT_ID\n# 64: SUM(TEAM_ODDS) ~ aka max_odds **MUST BE POWER OF 2 for mapping from 256 bits to be uniform**\n# We get a 256 bit random value and do modulo SUM(TEAM_ODDS) (stored in global storage max_odds_key)\n# this goes into rand_val and is in [0, max_odds)\n# then iterate for(i=2; i<=64; i+=2)\n# first nft odds value which is larger than $rand_val is the NFT to return\n# the ID is one index before the currently iterated idx\n@Subroutine(TealType.uint64)\ndef get_random_nft_id(acct, rnd, iter):\n    i = ScratchVar(TealType.uint64)\n    rand_val = ScratchVar(TealType.uint64)\n    return Seq(\n        # random(256bit) modulo (max_odds) -> to_integer() -> $rand_val\n        rand_val.store(Btoi(\n            BytesMod( # BytesMod is expensive - could have sliced a few bytes off the rnd tail, Btoi and do int mod so save op costs\n                get_random_bytes(acct, rnd, iter), # 256 bit\n                Itob(App.globalGet(max_odds_key)) # Must be power of 2\n            )\n        )),\n        Log(bytes_rand_mapped), # debug/log label & mapped rand value\n        Log(Itob(rand_val.load())),\n        # for all possible NFT values\n        For(i.store(Int(2)),\n            Le(i.load(), Int(64)),\n            i.store(Add(i.load(), Int(2)))\n        ).Do(Seq(\n            # described in function header doc\n            If (get_ext_storage(i.load()) > rand_val.load()).Then(Seq(\n                # switch to using i as results storage\n                # ID to return is one before the odds that just won\n                i.store(get_ext_storage(Minus(i.load(), Int(1)))),\n                # assert that the value is not zero\n                fail_if(i.load() == Int(0), err_drawing_failed), # Needed?\n                Return(i.load())\n            ))\n        )),\n        # failsafe\n        fail_if(Int(1), err_drawing_failed),\n        # never reached, but pyteal like this\n        Return(Int(1))\n    )\n\n# translate int(1,2,3) -> slot1_key slot2_key slot3_key or fail the program  \n# used by burn entry points to map slot idx to slot name\n@Subroutine(TealType.bytes)\ndef slot_int_to_key(slot_int):\n    return Cond(\n        [slot_int == Int(1), slot1_key],\n        [slot_int == Int(2), slot2_key],\n        [slot_int == Int(3), slot3_key],\n        [Int(1), Seq(fail(err_invalid_slot), bytes_empty)] # The seq, bytes dance is to satisfy pyteal\n    )\n\n# utility to get the first available free NFT slot in user storage\n# empty bytes is all slots filled\n@Subroutine(TealType.bytes)\ndef get_free_slot_for(addrIdx):\n    return Cond(\n        [App.localGet(addrIdx, slot1_key) == Int(0), slot1_key],\n        [App.localGet(addrIdx, slot2_key) == Int(0), slot2_key],\n        [App.localGet(addrIdx, slot3_key) == Int(0), slot3_key],\n        [Int(1), bytes_empty]\n    )\n\n# validate (num) 1 or 3 free slots are available in user storage\n# used before a draw is queued\n@Subroutine(TealType.none)\ndef validate_free_slots(num, acctIdx):\n    return Cond(\n        # validating 1 slot available: is there is any free slot we're good\n        [num == Int(1), fail_if(get_free_slot_for(acctIdx) == bytes_empty, err_no_free_slot)], # NO FREE SLOT\n        # validating all slots are available\n        [Int(1), custom_assert(And(\n            App.localGet(acctIdx, slot1_key) == Int(0),\n            App.localGet(acctIdx, slot2_key) == Int(0),\n            App.localGet(acctIdx, slot3_key) == Int(0)\n        ), err_slot_not_empty)] # \"MUST_COLLECT\"\n    )\n\n# internal method to queue a draw action into user local storage\n@Subroutine(TealType.uint64)\ndef queue_draw(num, paid_num, ticket_key):\n    return Seq(\n        # drawing is enabled\n        fail_if(App.globalGet(ticket_key) == Int(0), err_drawing_disabled),\n        # already a draw in queue? fail\n        fail_if(user_draw_amount(Int(0)) != Int(0), err_draw_queued),\n        # save amount of draws in key\n        App.localPut(Int(0), draw_amount_key, num),\n        # save amount paid for refund in case of randomness expiry\n        App.localPut(Int(0), draw_amount_paid_key, App.globalGet(ticket_key) * paid_num),\n        # get next safe randomness round and save it in key\n        App.localPut(Int(0), draw_round_key, get_next_rand_round()),\n        # return the round so the user knows how long to wait (+2 in practice for the VRF oracle to be seeded by off-chain service)\n        Return(App.localGet(Gtxn[0].sender(), draw_round_key))\n    );\n\n\n# DRAW/BURN_DRAW/FREE_DRAW methods\n# these all return the randomness round commitment\n\n# entry point to queue a 1x draw paying with a free draw NFT\n@router.method\ndef free_draw(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 1x Free Draw NFTs sent or fail\n        validate_free_draw_payment(Int(1)),\n        # validate there are 1x free NFT slots in user storage or fail\n        validate_free_slots(Int(1), Int(0)),\n        # add a 1x draw \"queue\" to user storage and return the round\n        # paid == 0 - no refunds for free drawers, sorry\n        output.set(queue_draw(Int(1), Int(0), ticket_key))\n    )\n\n# entry point to queue a 1x draw paying with ALGO\n@router.method\ndef draw(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 1x ALGO payments are sent or fail\n        validate_payment(Int(1), ticket_key),\n        # validate there is 1x free slot available to draw into, or fail\n        validate_free_slots(Int(1), Int(0)),\n        # add a 1x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(1), Int(1), ticket_key))\n    )\n\n# entry point to queue a 3x draw paying with ALGO\n@router.method\ndef draw3(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 3x ALGO ticket price is sent or fail\n        validate_payment(Int(3), ticket_key),\n        # validate there are 3x free NFT slots in user storage or fail\n        validate_free_slots(Int(3), Gtxn[0].sender()),\n        # add a 3x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(3), Int(3), ticket_key))\n    )\n\n@router.method\ndef burn_draw(slot: abi.Uint64, *, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate passed slot is burnable\n        fail_if(App.localGet(Int(0), slot_int_to_key(slot.get())) == Int(0), err_no_burn_available),\n        # \"burn\" NFT - zero out slot$n\n        App.localPut(Int(0), slot_int_to_key(slot.get()), Int(0)),\n        # validate burn payment sent\n        validate_payment(Int(1), burn_ticket_key),\n        # skip validate free slot, we just created one\n        # add a 1x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(1), Int(1), burn_ticket_key))\n    )\n\n@router.method\ndef burn_draw2(slot1: abi.Uint64, slot2: abi.Uint64, *, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate passed slots are burnable\n        fail_if(slot1.get() == slot2.get(), err_no_burn_hacking), # if sneaky user tries to burn the same slot twice, amuse them with an error message\n        fail_if(App.localGet(Int(0), slot_int_to_key(slot1.get())) == Int(0), err_no_burn_available),\n        fail_if(App.localGet(Int(0), slot_int_to_key(slot2.get())) == Int(0), err_no_burn_available),\n        # \"burn\" NFTs - zero out slots\n        App.localPut(Int(0), slot_int_to_key(slot1.get()), Int(0)),\n        App.localPut(Int(0), slot_int_to_key(slot2.get()), Int(0)),\n        # validate burn payment sent\n        validate_payment(Int(2), burn_ticket_key),\n        # skip validate free slot, we just created two\n        # add a 1x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(2), Int(2), burn_ticket_key))\n    )\n\n@router.method\ndef burn_draw3(*, output: abi.Uint64):\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # validate 3 NFTs are in user storage to burn\n        custom_assert(get_free_slot_for(Int(0)) == bytes_empty, err_no_burn_available),\n        # validate 3x ALGO ticket price is sent or fail\n        validate_payment(Int(3), burn_ticket_key),\n        App.localPut(Int(0), slot_int_to_key(Int(1)), Int(0)),\n        App.localPut(Int(0), slot_int_to_key(Int(2)), Int(0)),\n        App.localPut(Int(0), slot_int_to_key(Int(3)), Int(0)),\n        # add a 3x draw \"queue\" to user storage and return the round\n        output.set(queue_draw(Int(3), Int(3), burn_ticket_key))\n    )\n\n# does the actual drawing\n# meant to be called by (our) backend to make the UX nicer but isn't restricted as such\n# we have exposed a fallback to end users in the frontend if our redundant backends fail\n# note we are using \"1\" as the account index - meaning first foreign account\n@router.method\ndef exec_draw():\n    i = ScratchVar(TealType.uint64) # draw number iterator\n    return Seq(\n        # disabled when contract is killed\n        not_killed(),\n        # Otherwise do store(txn.accounts.last())\n        # if no draw queued, fail\n        fail_if(Eq(user_draw_amount(Int(1)), Int(0)), err_no_draw_queued),\n        # if round is not past yet, fail\n        fail_if(Lt(Global.round(), App.localGet(Int(1), draw_round_key)), err_wait_for_randomness),\n        fail_if(randomness_expired(Int(1)), err_randomness_expired),\n        # auto-inner TXN to storage app to increase budget - triggers when 3x draw\n        opup.ensure_budget(Int(450) * user_draw_amount(Int(1))),\n        # for i=0; i<user.draw_amount; i++\n        For(i.store(Int(0)), Lt(i.load(), user_draw_amount(Int(1))), i.store(Add(i.load(), Int(1)))).Do(Seq(\n            App.localPut(\n                Int(1),\n                # get free NFT slot for user\n                get_free_slot_for(Int(1)),\n                # save a random NFT ID\n                get_random_nft_id(\n                    Txn.accounts[Int(1)],\n                    App.localGet(Int(1), draw_round_key), # agreed upon round\n                    i.load() # draw number in [0, 1, 2]\n                 )\n            )\n        )),\n        # reset queued draw user storage keys\n        reset_user_draw_state(Int(1))\n    )\n\n# collect all available NFTs from user storage slots\n# intentionally left enabled when contract is killed\n@router.method\ndef collect():\n    return sub_collect()\n\n# refund in case randomness has expired\n# this should never happen, but has to be factored in anyhow\n# free draw users are SOL\n# paying users get their money back & a digital apology\n# intentionally left available when contract is killed\n@router.method\ndef refund(*, output: abi.Uint64):\n    amount = ScratchVar(TealType.uint64) # draw amount to refund\n    addr = ScratchVar(TealType.bytes) # address to refund\n    return Seq(\n        # Otherwise do store(txn.accounts.last())\n        # if no draw queued, fail\n        addr.store(Txn.accounts[Int(1)]),\n        fail_if(user_draw_amount(Int(1)) == Int(0), err_no_draw_queued),\n        # if round is not past yet, fail\n        custom_assert(randomness_expired(Int(1)), err_randomness_not_expired),\n        amount.store(App.localGet(Int(1), draw_amount_paid_key)),\n        # for i=0; i<user.draw_amount; i++\n        # reset queued draw user storage keys\n        reset_user_draw_state(Int(1)),\n        InnerTxnBuilder.Execute({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.sender(),\n            TxnField.amount: amount.load(),\n            TxnField.fee: Int(0),\n        }),\n        output.set(amount.load()),\n    )\n\ndef get_contracts():\n    return router.compile_program(version=6)"}
{"file_path": "https://github.com/Algofiorg/smart-contracts/blob/64b8995a81e7ccbb080ee4401b1dbe7a9ac181ef/contracts/governance/voting_escrow.py", "code": "https://github.com/summitbajaj/AlDonate/blob/1a0fd9ad0b0a036508c40a10d2432f0213f17f61/donate.py"}
{"file_path": "https://github.com/GoraNetwork/algokit_default_template/blob/38a15bdfe2fff9820b1abb9b01c8a4a278c32d9d/template_content/protocol/assets/helpers/voting_base.py", "code": "import base64\nfrom typing import Tuple\nfrom algosdk import mnemonic, transaction, account\nfrom algosdk.v2client import algod\nfrom pyteal import *\n\nprint(\"\u2588\u2591\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2588\u2003 \u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2580\u2580\")\nprint(\"\u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2584\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2588\u2584\")\n\ntxn_history = {}\n\n\ndef donation_escrow(benefactor):\n\n    # Getting AppID\n    # AppID = AppParamObject\n    # Getting Minimum Allowed Fee\n    Fee = Global.min_txn_fee()\n\n    program = And(\n        Global.group_size() == Int(1),\n        Txn.rekey_to() == Global.zero_address(),\n        Txn.fee() <= Fee,\n        Or(\n            And(\n                Txn.type_enum() == TxnType.Payment,\n                Txn.receiver() == Addr(benefactor),\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetConfig,\n                Txn.config_asset_total() == Int(1),\n                Txn.config_asset_unit_name() == Bytes(\"AlD\")\n                # ensure nft is the logo of the charity\n                # Txn.config_asset_url()\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetTransfer,\n\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetFreeze,\n            )\n        )\n    )\n\n    return compileTeal(program, Mode.Signature, version=5)\n\n\n# user declared account mnemonics\nbenefactor_mnemonic = \"mom lottery uniform olive visa occur garlic artefact minimum reward custom legend suit stock install leg doctor favorite retreat cart all exact camp able cute\"\nsender_mnemonic = \"shoe onion turkey shallow belt drop owner merit eager reflect radio gravity stone eyebrow busy dolphin verb bonus load unit engage young decrease ability fame\"\n\n\n# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config\nalgod_address = \"http://localhost:4001\"\nalgod_token = \"a\" * 64\n\n# helper function to compile program source\n\n\ndef compile_smart_signature(\n    client: algod.AlgodClient, source_code: str\n) -> Tuple[str, str]:\n    compile_response = client.compile(source_code)\n    return compile_response[\"result\"], compile_response[\"hash\"]\n\n\ndef payment_transaction(\n    creator_mnemonic: str, amt: int, rcv: str, algod_client: algod.AlgodClient\n) -> dict:\n    creator_pk = mnemonic.to_private_key(creator_mnemonic)\n    creator_address = account.address_from_private_key(creator_pk)\n\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(creator_address, params, rcv, amt)\n    signed = unsigned_txn.sign(creator_pk)\n\n    txid = algod_client.send_transaction(signed)\n    pmtx = transaction.wait_for_confirmation(algod_client, txid, 5)\n    return txid, pmtx[\"txn\"][\"txn\"]\n\n\n# for minting nft\ndef mint_nft(encoded_program: str, algod_client: algod.AlgodClient):\n    sp = algod_client.suggested_params()\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # define NFT asset parameters\n    txn = transaction.AssetConfigTxn(\n        sender=lsig.address(),\n        sp=sp,\n        default_frozen=False,\n        unit_name=\"AlD\",\n        asset_name=\"AlDonate NFT\",\n        manager=lsig.address(),\n        reserve=lsig.address(),\n        freeze=lsig.address(),\n        clawback=lsig.address(),\n        url=\"https://tinyurl.com/mt3yzhz4\",\n        total=1,\n        decimals=0,\n    )\n\n    # sign the transaction using the logic signature\n    stxn = transaction.LogicSigTransaction(txn, lsig)\n\n    # send the transaction to the network\n    tx_id = algod_client.send_transaction(stxn)\n    print(\"\")\n    print(f\"Minting Transaction ID: {tx_id}\")\n    print(\"\")\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 5)\n\n    return pmtx\n\n# perform opt in transaction for minted NFT\n\n\ndef opt_in_nft(\n    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str\n):\n    sp = algod_client.suggested_params()\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n    optin_txn = transaction.AssetOptInTxn(\n        sender=receiver_address, sp=sp, index=asset_id\n    )\n    signed_optin_txn = optin_txn.sign(receiver_pk)\n    txid = algod_client.send_transaction(signed_optin_txn)\n    print(\"\")\n    print(f\"Opting in your wallet to receive NFT: {txid}\")\n\n    # Wait for the transaction to be confirmed\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n    print(\"\")\n\n\ndef transfer_nft_to_donor(\n        encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str, id, txn):\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n    opt_in_nft(encoded_program, asset_id, algod_client, receiver_mnemonic)\n\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n    note = f\"Transaction: {id}, Amount: {txn['amt']}, Fee: {txn['fee']}\".encode(\n    )\n    # Transfer the newly created NFT from escrow to donor\n    txn = transaction.AssetTransferTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        receiver=receiver_address,\n        amt=1,\n        index=asset_id,\n        note=note\n    )\n    stxn = transaction.LogicSigTransaction(txn, lsig)\n    txid = algod_client.send_transaction(stxn)\n\n    print(f\"Sent asset transfer transaction with txid: {txid}\")\n    # Wait for the transaction to be confirmed\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n\n\ndef freeze_donor_nft(\n    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str\n):\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # Create freeze transaction to freeze the asset in acct2 balance\n    freeze_txn = transaction.AssetFreezeTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        target=receiver_address,\n        index=asset_id,\n        new_freeze_state=True,\n    )\n\n    stxn = transaction.LogicSigTransaction(freeze_txn, lsig)\n    txid = algod_client.send_transaction(stxn)\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(\"\")\n    print(f\"Sent freeze transaction with txid: {txid}\")\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n    print(\"\")\n    print(\"Congrats! NFT has been transferred to you! Note: You will not be able to transfer this asset\")\n\n\ndef lsig_payment_txn(\n    encoded_program: str, amt: int, rcv: str, algod_client: algod.AlgodClient\n):\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # Create transaction with the lsig address as the sender\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(lsig.address(), params, rcv, amt)\n\n    # sign the transaction using the logic\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\ndef main():\n    # initialize an algodClient\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n    # define private keys\n    private_key = mnemonic.to_private_key(benefactor_mnemonic)\n    # receiver_public_key = account.address_from_private_key(private_key)\n\n    print(\"\")\n    print(\"\")\n    print(\"\")\n    print(\"Thank you for your donation! Which charity will you like to send the donation to? Key in the number:\")\n    print(\"\")\n    print(\"\")\n\n    choice = 0\n\n    while (choice != 3):\n\n        print(\"1: NKF  || Onboarded suppliers: - Penny Appeal(Turkey Food Donation), - Ikea Foundation(Turkey Shelters)\")\n        print(\"2: WWF  || Onboarded suppliers: - Ghana Stores(Ghana Food Donation)\")\n        print(\"3: To exit this application\")\n        print(\"4: View your Donations\")\n        choice = int(input())\n        charity = \"\"\n\n        if choice == 1:\n            print(\"sending donation to NKF\")\n            charity = \"NKF\"\n            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'\n\n        elif choice == 2:\n            print(\"sending donation to WWF\")\n            charity = \"WWF\"\n            receiver_public_key = 'XHT4KIAFOP4626AFLA6GMOMST4QO3AO2XADMIJJOACMFEGT5GLA6LOCLWQ'\n\n        elif choice == 3:\n            break\n\n        elif choice == 4:\n            for charity, transactions_list in txn_history.items():\n                print(f\"Transactions for {charity}:\")\n                for txn in transactions_list:\n                    print(f\"\\tTransaction ID: {txn['txn_id']}\")\n                    print(f\"\\tAmount Donated: {txn['amount_donated']}\")\n                    print(f\"\\tCertificate ID: {txn['certificate_id']}\\n\")\n\n            continue\n\n        else:\n            print(\"Sending donation to NKF\")\n            charity = \"NKF\"\n            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'\n\n        print(\"\")\n        print(\"Compiling Donation Smart Signature......\")\n        print(\"\")\n        stateless_program_teal = donation_escrow(receiver_public_key)\n        escrow_result, escrow_address = compile_smart_signature(\n            algod_client, stateless_program_teal\n        )\n\n        print(\"Program:\", escrow_result)\n        print(\"LSig Address: \", escrow_address)\n        print(\"\")\n        print(\"Activating Donation Smart Signature......\")\n\n        # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator\n        amt = 100000\n        id, txn = payment_transaction(\n            sender_mnemonic, amt, escrow_address, algod_client)\n\n        if charity not in txn_history.keys():\n            txn_history[charity] = []\n\n        # Mint NFT using the escrow address\n        print(\"Thank you for your donation, Minting NFT......\")\n        pmtx = mint_nft(escrow_result, algod_client)\n        created_asset = pmtx[\"asset-index\"]\n\n        txn_history[charity].append(\n            {\"txn_id\": id, \"amount_donated\": amt, \"certificate_id\": created_asset})\n\n        print(\"\")\n        print(\"Withdrawing from Donation Smart Signature......\")\n        print(f\"NFT Address: {created_asset}\")\n\n        # Withdraws 1 ALGO from smart signature using logic signature.\n        withdrawal_amt = 10000\n        lsig_payment_txn(escrow_result, withdrawal_amt,\n                         receiver_public_key, algod_client)\n\n        transfer_nft_to_donor(escrow_result, created_asset,\n                              algod_client, sender_mnemonic, id, txn)\n        freeze_donor_nft(escrow_result, created_asset,\n                         algod_client, sender_mnemonic)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"file_path": "https://github.com/bytesdruid/Voting/blob/805017f6b4cd126daa77c4bc9b9f894faf333f87/voting_contract.py", "code": "https://github.com/0xnayan/algoNFT/blob/13d5a1c34ec03891e2ceaeac30c19a44da01e624/mint_nfts.py"}
{"file_path": "https://github.com/0xBitzz/Algo-Smart-DAO-Encode-Project/blob/4db7b98e9f2f1e60b86ed92849da38c9521f24c9/voting-contract/src/Beaker/voting.py", "code": "from pathlib import Path\nfrom typing import Literal\nfrom beaker import *\nfrom pyteal import *\n\n\nclass NFTs(abi.NamedTuple):\n    url: abi.Field[abi.String]\n    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]\n    name: abi.Field[abi.String]\n    unitName: abi.Field[abi.String]\n    reserve: abi.Field[abi.Address]\n\n    asa = LocalStateValue(stack_type=TealType.uint64, default=Int(0))\n    burn_address = LocalStateValue(stack_type= TealType.bytes, default=Bytes(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ\"))\n    burntId = LocalStateValue(stack_type= TealType.uint64, default=Int(0))\n\n\napp = Application(\"MintNFTs\", state=NFTs)\n\n@app.create(bare=True)\ndef create() -> Expr:\n    return app.initialize_global_state()\n\n\n@app.external(authorize= Authorize.only(Global.creator_address()))\ndef mintNFTs(requestMint: NFTs, *, output: abi.Uint64) -> Expr:\n    name = abi.String()\n    unitName = abi.String()\n    reserve = abi.Address()\n    url = abi.String()\n    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])\n\n    return Seq(\n        requestMint.name.store_into(name),\n        requestMint.unitName.store_into(unitName),\n        requestMint.reserve.store_into(reserve),\n        requestMint.url.store_into(url),\n        requestMint.metadata_hash.store_into(metadata_hash),\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_name: name.get(),\n                TxnField.config_asset_unit_name: unitName.get(),\n                TxnField.config_asset_reserve: reserve.get(),\n                TxnField.config_asset_url: url.get(),\n                TxnField.config_asset_metadata_hash: metadata_hash.encode(),\n                TxnField.config_asset_total: Int(1),\n                TxnField.fee: Int(0),\n            }\n        ),\n        output.set(InnerTxn.created_asset_id()),\n        app.state.asa.set(InnerTxn.created_asset_id())\n    )\n\n\n@app.external(authorize= Authorize.only(Global.creator_address()))\ndef transferNFTs(assetId: abi.Uint64, receiver: abi.Address) -> Expr:\n    assetId= app.state.asa.get()\n    receiver= abi.Address()\n    return Seq(\n\n        Assert(app.state.asa == assetId),\n        Assert(app.state.burntId != assetId),\n\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: receiver.get(),\n                TxnField.xfer_asset: assetId,\n                TxnField.asset_amount: Int(1),\n            }\n    )\n)\n\n@app.external(authorize= Authorize.only(Global.creator_address()))\ndef burn(Id: abi.Uint64) -> Expr:\n    burntAddress= app.state.burn_address.get()\n    Id= abi.Uint64()\n    return Seq(\n        Assert(app.state.asa == Id.get()),\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: burntAddress,\n                TxnField.xfer_asset: Id.get(),\n                TxnField.asset_amount: Int(1),\n            }\n        ),\n        app.state.burntId.set(Id.get())\n)\n\n\nif __name__ == \"__main__\":\n    app.build().export(\n        Path(__file__).resolve().parent / f\"./artifacts/{app.name}\"\n    )"}
{"file_path": "https://github.com/GoraNetwork/price_oracle_beacon/blob/3cb959bc046d77166aba3965eb663fc0c9859218/utils/gora_pyteal_utils.py", "code": "https://github.com/sagaranand015/algorand-smart-asa/blob/68eb9b7f07b93c5fd52ddcd29a73633f82e2f520/contracts/emission_control.py"}
{"file_path": "https://github.com/gconnect/voting-dapp-pyteal-react/blob/829a74626f934ebb9778b431ce9d7662e6897f85/venv/bin/pip", "code": "from typing import Final\n\nfrom pyteal import *\nfrom beaker import *\n\n\nclass EmissionRuleResult(abi.NamedTuple):\n    emission: abi.Field[abi.String]\n    max: abi.Field[abi.Uint64]\n    min: abi.Field[abi.Uint64]\n\n\nCOMPLIANCE_ASA_APP_BINDING = \"https://compliance.app/\"\n\nUNDERLYING_COMPLIANCE_NFT_DECIMALS = Int(0)\nUNDERLYING_COMPLIANCE_NFT_DEFAULT_FROZEN = Int(0)\nUNDERLYING_COMPLIANCE_NFT_UNIT_NAME = Bytes(\"COM-ASA\")\nUNDERLYING_COMPLIANCE_NFT_NAME = Bytes(\"COMPLIANCE-ASA\")\nUNDERLYING_COMPLIANCE_NFT_URL = Bytes(COMPLIANCE_ASA_APP_BINDING)\nUNDERLYING_COMPLIANCE_NFT_METADATA_HASH = Bytes(\"Comliance NFT Metadata\")\nUNDERLYING_COMPLIANCE_NFT_MANAGER_ADDR = Global.current_application_address()\nUNDERLYING_COMPLIANCE_NFT_RESERVE_ADDR = Global.current_application_address()\nUNDERLYING_COMPLIANCE_NFT_FREEZE_ADDR = Global.current_application_address()\nUNDERLYING_COMPLIANCE_NFT_CLAWBACK_ADDR = Global.current_application_address()\n\n\nclass EmissionControl(Application):\n    \"\"\"\n    Emission Control(aka Smart Contract App) for storing business' compliance analysis on chain\n    and creating/minting NFTs for businesses based on the rules defined by the regulators.\n    \"\"\"\n\n    regulator: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.bytes,\n        descr=\"Regulator acting as the owner of the Emission Control\",\n    )\n    emission_parameter: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.bytes, descr=\"Emission Parameter to keep track of\"\n    )\n    emission_max: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.uint64, descr=\"Max value of the emission control parameter\"\n    )\n    emission_min: Final[ApplicationStateValue] = ApplicationStateValue(\n        TealType.uint64, descr=\"Min value of the emission control parameter\"\n    )\n\n    @external\n    def get_emission_rule(self, *, output: EmissionRuleResult):\n        \"\"\"\n        Returns the rules defined by the regulator for the given emission SC\n        \"\"\"\n        return Seq(\n            (max := abi.Uint64()).set(self.emission_max.get()),\n            (min := abi.Uint64()).set(self.emission_min.get()),\n            (parameter := abi.String()).set(self.emission_parameter.get()),\n            output.set(parameter, max, min),\n        )\n\n    @external\n    def set_emission_rule(\n        self,\n        emission_parameter: abi.String,\n        emission_max: abi.Uint64,\n        emission_min: abi.Uint64,\n        *,\n        output: abi.Bool,\n    ):\n        \"\"\"\n        Sets the rules defined by the regulator for the given emission\n        \"\"\"\n        return Seq(\n            self.emission_parameter.set(emission_parameter.get()),\n            self.emission_max.set(emission_max.get()),\n            self.emission_min.set(emission_min.get()),\n            output.set(True),\n        )\n\n    @external\n    def is_business_compliant(\n        self,\n        emission_parameter: abi.String,\n        emission_value: abi.Uint64,\n        *,\n        output: abi.Bool,\n    ):\n        \"\"\"\n        Returns true/false based on whether the business is compliant to the emissions value or not\n        \"\"\"\n        return Seq(\n            Assert(\n                self.emission_parameter == emission_parameter.get(),\n                comment=\"Emission Parameter given is not correct for the app being used!\",\n            ),\n            Assert(\n                emission_value.get() >= self.emission_min,\n                comment=\"Emission value is lesser than min configured\",\n            ),\n            If(emission_value.get() <= self.emission_max)\n            .Then(output.set(True))\n            .Else(output.set(False)),\n        )\n\n    @internal(TealType.uint64)\n    def create_compliance_nft_internal(self):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetConfig,\n                    TxnField.config_asset_total: Int(1),\n                    TxnField.config_asset_decimals: UNDERLYING_COMPLIANCE_NFT_DECIMALS,\n                    TxnField.config_asset_unit_name: UNDERLYING_COMPLIANCE_NFT_UNIT_NAME,\n                    TxnField.config_asset_name: UNDERLYING_COMPLIANCE_NFT_NAME,\n                    TxnField.config_asset_url: UNDERLYING_COMPLIANCE_NFT_URL,\n                    TxnField.config_asset_manager: UNDERLYING_COMPLIANCE_NFT_MANAGER_ADDR,\n                    TxnField.config_asset_reserve: UNDERLYING_COMPLIANCE_NFT_RESERVE_ADDR,\n                    TxnField.config_asset_freeze: UNDERLYING_COMPLIANCE_NFT_FREEZE_ADDR,\n                    TxnField.config_asset_clawback: UNDERLYING_COMPLIANCE_NFT_CLAWBACK_ADDR,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n            Return(InnerTxn.created_asset_id()),\n        )\n\n    @internal(TealType.none)\n    def app_opt_into_asset(self, asset_id: Expr):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: asset_id,\n                    TxnField.asset_amount: Int(0),\n                    TxnField.sender: Global.current_application_address(),\n                    # TxnField.asset_sender: Global.current_application_address(),\n                    TxnField.asset_receiver: Global.current_application_address(),\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @internal(TealType.none)\n    def opt_into_asset_for_business(\n        self, business_address: Expr, asset_id: Expr\n    ):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: asset_id,\n                    TxnField.asset_amount: Int(0),\n                    TxnField.sender: business_address,\n                    # TxnField.asset_sender: Global.current_application_address(),\n                    TxnField.asset_receiver: business_address,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @internal(TealType.none)\n    def transfer_compliance_nft_to_business(\n        self, business_address: Expr, asset_id: Expr\n    ):\n        # TODO: Add the check for business' emission control before actually transferring the token!\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields(\n                {\n                    TxnField.fee: Int(0),\n                    TxnField.type_enum: TxnType.AssetTransfer,\n                    TxnField.xfer_asset: asset_id,\n                    TxnField.asset_amount: Int(1),\n                    TxnField.sender: Global.current_application_address(),\n                    # TxnField.asset_sender: Global.current_application_address(),\n                    TxnField.asset_receiver: business_address,\n                }\n            ),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @external\n    def create_compliance_nft(self, *, output: abi.Uint64):\n        \"\"\"\n        Creates the compliance NFT for the business via the Algorand SC\n        \"\"\"\n        return Seq(\n            (asset_id := abi.Uint64()).set(\n                self.create_compliance_nft_internal()\n            ),\n            self.app_opt_into_asset(asset_id.get()),\n            output.set(asset_id),\n        )\n\n    @external\n    def allocate_compliance_nft_to_business(\n        self,\n        business_address: abi.Address,\n        asset_id: abi.Uint64,\n        *,\n        output: abi.Uint64,\n    ):\n        \"\"\"\n        Creates the compliance NFT for the business via the Algorand SC\n        \"\"\"\n        return Seq(\n            self.transfer_compliance_nft_to_business(\n                business_address.get(), asset_id.get()\n            ),\n            output.set(asset_id),\n        )\n\n    @external\n    def business_opt_into_asset(\n        self,\n        business_address: abi.Address,\n        asset_id: abi.Uint64,\n        *,\n        output: abi.Uint64,\n    ):\n        \"\"\"\n        Business Account opting into the Compliance NFT\n        \"\"\"\n        return Seq(\n            self.opt_into_asset_for_business(\n                business_address.get(), asset_id.get()\n            ),\n            output.set(asset_id),\n        )\n\n    @create\n    def create(self):\n        return self.initialize_application_state()\n\n    @update(authorize=Authorize.only(Global.creator_address()))\n    def update(self):\n        return Approve()\n\n    @opt_in\n    def opt_in(self):\n        return Approve()\n\n\nif __name__ == \"__main__\":\n    EmissionControl().dump(\"./artifacts\")"}
{"file_path": "https://github.com/algorandfoundation/ExtendableDAO/blob/0e8c974683130d681e2cd88c671fede52154e031/contracts.py", "code": "https://github.com/bytesdruid/Pure-NFT/blob/03143e8f897f930c481ec640d142087d8ed30a4c/asset_contract/asset.py"}
{"file_path": "https://github.com/0EFB6/blockchain-voting-system/blob/5d3bab077ab260c2e99bb3561a48d7c2b234712d/voting_area_initialisation/voting_area_initialisation.py", "code": "from pyteal import *\n\ndef approval():\n    on_creation = Seq(\n        [\n            # g byteslice - asset name is Bloom Token\n            App.globalPut(Bytes(\"AssetName\"), Bytes(\"Pure NFT\")),\n            # g byteslice - unit name is BLT\n            App.globalPut(Bytes(\"UnitName\"), Bytes(\"NFP1023\")),\n            # g int - decimals\n            App.globalPut(Bytes(\"Decimals\"), Int(0)),\n            # g Int - total supply \n            App.globalPut(Bytes(\"Total\"), Int(1)),\n            # g Int - reserve is total amount not sitting in local balance\n            App.globalPut(Bytes(\"GlobalReserve\"), Int(1)),\n            # approve sequence\n            Return(Int(1)),\n        ]\n    )\n\n    opt_in = Seq([\n        # l int - local balance\n        App.localPut(Int(0), Bytes(\"LocalBalance\"), Int(0)),\n        Return(Int(1))\n    ])\n\n    init_admin = Seq([\n        # make sure account opting in is the contract creator address\n        Assert(Txn.sender() == Global.creator_address()),\n        # set the txn sender address to manager\n        App.localPut(Int(0), Bytes(\"Admin\"), Int(1)),\n        Return(Int(1))\n    ])\n\n    is_admin = App.localGet(Int(0), Bytes(\"Admin\"))\n\n    set_admin = Seq(\n        [\n            Assert(And(is_admin, Txn.application_args.length() == Int(1))),\n            App.localPut(Int(1), Bytes(\"Admin\"), Int(1)),\n            Return(Int(1)),\n        ]\n    )\n\n    on_closeout = Seq(\n        [\n            App.globalPut(\n                Bytes(\"GlobalReserve\"),\n                App.globalGet(Bytes(\"GlobalReserve\"))\n                + App.localGet(Int(0), Bytes(\"LocalBalance\")),\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    mint = Seq(\n        [\n            Assert(Txn.application_args.length() == Int(2)),\n            Assert(Btoi(Txn.application_args[1]) <= App.globalGet(Bytes(\"GlobalReserve\"))),\n            App.globalPut(\n                Bytes(\"GlobalReserve\"), App.globalGet(Bytes(\"GlobalReserve\")) - Btoi(Txn.application_args[1]),\n            ),\n            App.localPut(\n                Int(0),\n                Bytes(\"LocalBalance\"),\n                App.localGet(Int(0), Bytes(\"LocalBalance\")) + Btoi(Txn.application_args[1]),\n            ),\n            Return(is_admin),\n        ]\n    )\n\n    transfer_amount = Btoi(Txn.application_args[1])    \n    transfer = Seq(\n        [\n            Assert(Txn.application_args.length() == Int(2)),\n            Assert(transfer_amount <= App.localGet(Int(0), Bytes(\"LocalBalance\"))),\n            App.localPut(\n                Int(0),\n                Bytes(\"LocalBalance\"),\n                App.localGet(Int(0), Bytes(\"LocalBalance\")) - transfer_amount,\n            ),\n            App.localPut(\n                Int(1),                 \n                Bytes(\"LocalBalance\"),\n                App.localGet(Int(1), Bytes(\"LocalBalance\")) + transfer_amount,\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, opt_in],\n        [Txn.application_args[0] == Bytes(\"Init_Admin\"), init_admin],\n        [Txn.application_args[0] == Bytes(\"Set_Admin\"), set_admin],\n        [Txn.application_args[0] == Bytes(\"Mint\"), mint],\n        [Txn.application_args[0] == Bytes(\"Transfer\"), transfer],\n    )\n\n    return program\n\ndef clear():\n    program = Seq(\n        [\n            App.globalPut(\n                Bytes(\"GlobalReserve\"),\n                App.globalGet(Bytes(\"GlobalReserve\"))\n                + App.localGet(Int(0), Bytes(\"LocalBalance\")),\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    return program\n\n\nif __name__ == \"__main__\":\n    with open(\"approval.teal\", \"w\") as f:\n        compiled = compileTeal(approval(), mode=Mode.Application, version=6)\n        f.write(compiled)\n\n    with open(\"clear.teal\", \"w\") as f:\n        compiled = compileTeal(clear(), mode=Mode.Application, version=6)\n        f.write(compiled)"}
