{"instruction": "Execute the pip package manager programmatically, ensuring the script path is normalized by removing any trailing '-script.pyw' or '.exe' suffixes before execution.", "output": "#!/Users/glory/projects/pyteal-voting-system/voting-dapp/venv/bin/python3\n# -- coding: utf-8 --\nimport re\nimport sys\nfrom pip._internal.cli.main import main\nif name == 'main':\n sys.argv[0] = re.sub(r'(-script\\.pyw|\\.exe)?$', '', sys.argv[0])\n sys.exit(main())"}
{"instruction": "Compile a PyTeal program named `clear_state_program` into TEAL code, targeting the application mode, TEAL version 5, and enabling scratch slot optimization.", "output": "from pyteal import *\n\ndef clear_state_program():\n    return Return(Int(1))\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(clear_state_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"instruction": "Create a smart contract that allows users to mint and burn a custom asset called 'K Coin'. The contract initializes the asset with a total supply of 1,000,000,000 and 3 decimals. Minting involves sending Algos to the contract in exchange for K Coins, and burning involves sending K Coins to the contract in exchange for Algos. The contract uses an exchange rate to determine the amount of K Coins minted or Algos burned, and applies pre- and post-conditions to ensure that the transactions are valid.", "output": "from typing import Tuple\n\nfrom algosdk.abi import Contract\nfrom pyteal import (\n    App,\n    Approve,\n    Assert,\n    BareCallActions,\n    Bytes,\n    Div,\n    Expr,\n    Global,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Mul,\n    OnCompleteAction,\n    Router,\n    Seq,\n    Subroutine,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n)\nfrom pyteal.compiler.optimizer import optimizer\n\nASSET_TOTAL = 1000000000\nASSET_DECIMALS = 3\nINITIAL_EXCHANGE_RATE = 2000\nSCALING_FACTOR = 1000\n\n# The PyTeal router\nrouter = Router(\n    name=\"K-Coin-Vault\",\n    bare_calls=BareCallActions(\n        no_op=OnCompleteAction.create_only(Approve()),\n        update_application=OnCompleteAction.never(),\n        delete_application=OnCompleteAction.never(),\n        clear_state=OnCompleteAction.never(),\n    ),\n)\n\n\n@router.method\ndef init_asset(*, output: abi.Uint64) -> Expr:\n    return Seq(\n        Assert(Txn.sender() == Global.creator_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(ASSET_TOTAL),\n                TxnField.config_asset_decimals: Int(ASSET_DECIMALS),\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n                TxnField.config_asset_name: Bytes(\"K Coin\"),\n                TxnField.config_asset_unit_name: Bytes(\"microK\"),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(Bytes(\"asset_id\"), InnerTxn.created_asset_id()),\n        App.globalPut(Bytes(\"exchange_rate\"), Int(INITIAL_EXCHANGE_RATE)),\n        output.set(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.uint64)\ndef algos_to_kcoin(algo_amount: Expr) -> Expr:\n    return Div(Mul(algo_amount, App.globalGet(Bytes(\"exchange_rate\"))), Int(SCALING_FACTOR))\n\n\n@Subroutine(TealType.uint64)\ndef kcoin_to_algos(asset_amount: Expr) -> Expr:\n    return Mul(Div(asset_amount, App.globalGet(Bytes(\"exchange_rate\"))), Int(SCALING_FACTOR))\n\n\n@router.precondition(expr='payment.get().amount() >= Int(10000)')\n@router.precondition(expr='payment.get().amount() <= Int(20000)')\n@router.postcondition(\n    expr=f'output.get() == payment.get().amount() * Int({INITIAL_EXCHANGE_RATE}) / Int({SCALING_FACTOR})'\n)\n@router.hoare_method\n@router.method\ndef mint(payment: abi.PaymentTransaction, *, output: abi.Uint64) -> Expr:\n    amount_to_mint = algos_to_kcoin(payment.get().amount())\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        Assert(payment.get().receiver() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset_id,\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.asset_amount: amount_to_mint,\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        output.set(amount_to_mint),\n    )\n\n\n@router.precondition(expr='asset_transfer.get().amount() >= Int(10000)')\n@router.precondition(expr='asset_transfer.get().amount() <= Int(20000)')\n@router.postcondition(\n    expr=f'output.get() == asset_transfer.get().amount() * Int({SCALING_FACTOR}) / Int({INITIAL_EXCHANGE_RATE})'\n)\n@router.hoare_method\n@router.method\ndef burn(asset_transfer: abi.AssetTransferTransaction, *, output: abi.Uint64) -> Expr:\n    microalgos_output = kcoin_to_algos(asset_transfer.get().asset_amount())\n    return Seq(\n        Assert(asset_transfer.get().asset_receiver() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.Payment,\n                TxnField.receiver: Txn.sender(),\n                TxnField.amount: microalgos_output,\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        output.set(microalgos_output),\n    )\n\n\ndef compile_to_teal() -> Tuple[str, str, Contract]:\n    approval, clear, contract = router.compile_program(\n        version=6, optimize=optimizer.OptimizeOptions(scratch_slots=True)\n    )\n    return approval, clear, contract"}
{"instruction": "This code defines several utility functions for interacting with the Goracle main contract via inner transactions. It includes functions for making data requests, opting in to the application and assets, depositing and withdrawing both Algo and a specified token, registering a key, staking and unstaking tokens, and a smart assertion function for error handling.", "output": "# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913\nimport json\nimport sys\nimport os\nfrom pyteal import *\nfrom .abi_types import *\nfrom .inline import InlineAssembly\nfrom assets.abi import ABI_PATH,system_delima\n\n\n\nmain_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}main-contract.json\"))\nvoting_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}voting-contract.json\"))\nsmart_assert_errors = json.load(open(ABI_PATH + f\"{system_delima}..{system_delima}smart_assert_errors.json\"))\n\n# This is not used as it hard codes the costs of a box\n# But is kept here as a record of how it is calculated\n# The current method is by checking min balances before\n# and after the box is created.\n# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):\n#     # (2500 per box) + (400 * (key size + box size))\n#     if key_size_bytes > 64:\n#         raise Exception(\"key size is over 64 bytes\")\n#     cost = (\n#         Int(2500) + Int(400) * \n#         (\n#             Int(key_size_bytes) +\n#             Int(box_size_bytes)\n#         )\n#     )\n#     return cost\n\ndef get_abi_method(method_name,contract:str):\n    method_dict = {\n        \"main\": main_contract_abi[\"methods\"],\n        \"voting\": voting_contract_abi[\"methods\"]\n    }\n    method_list = method_dict[contract]\n    for method in method_list:\n        if method[\"name\"] == method_name:\n            return method\n    return None\n\ndef get_method_signature(method_name, contract:str):\n    method = get_abi_method(method_name,contract)\n    if method is None:\n        raise RuntimeError\n    signature = method_name + \"(\"\n    num_args = len(method[\"args\"])\n    for index, arg in enumerate(method[\"args\"]):\n        signature += arg[\"type\"] \n        if index < num_args - 1:\n            signature += \",\"\n        else:\n            signature += f'){method[\"returns\"][\"type\"]}'\n            return signature\n\n@ABIReturnSubroutine\ndef create_source_tuple(\n    source_id: Expr, #Int\n    source_arg_list: Expr, #Bytes\n    max_age: Expr,\n    *,\n    output: SourceSpec\n) -> Expr: #Int\n    return Seq([\n        (source_id_param := abi.Uint32()).set(source_id),\n        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),\n        (max_age_param := abi.Uint64()).set(max_age),\n        output.set(\n            source_id_param,\n            source_arg_list_param,\n            max_age_param\n        ),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request(\n    source_specs: abi.DynamicArray[SourceSpec],\n    aggregation: Expr, #Int\n    user_data: Expr, #Bytes\n    app_id: Expr, #Int\n    method_signature: Expr, #Bytes\n    goracle_main_app_id: Expr,  #Int\n    request_type: Expr,\n    key: Expr,\n    app_refs: Expr, #static array of uint64\n    asset_refs: Expr, #static array of uint64\n    account_refs: Expr, #static array of byte[32]\n    box_refs: Expr # dynamic array of  (byte[],uint64)\n): # Int\n\n    request_tuple = abi.make(RequestSpec)\n    destination_tuple = abi.make(DestinationSpec)\n\n    return Seq([\n        (user_data_param := abi.DynamicBytes()).set(user_data),\n        (agg_param := abi.Uint32()).set(aggregation),\n        (app_id_param := abi.Uint64()).set(app_id),\n        (request_type_param := abi.Uint64()).set(request_type),\n        (method_sig_param := abi.DynamicBytes()).set(method_signature),\n        (key_abi := abi.DynamicBytes()).set(key),\n\n        request_tuple.set(\n            source_specs,\n            agg_param,\n            user_data_param\n        ),\n\n        destination_tuple.set(\n            app_id_param,\n            method_sig_param\n        ),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_tuple.encode(),\n                destination_tuple.encode(),\n                request_type_param.encode(),\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request_constructed(\n    request_args_encoded: Expr,\n    destination_encoded: Expr,\n    request_type_encoded: Expr,\n    goracle_main_app_id: Expr,\n    key: Expr,\n    app_refs: Expr,\n    asset_refs: Expr,\n    account_refs: Expr,\n    box_refs: Expr\n):\n    return Seq([\n        (key_abi := abi.DynamicBytes()).set(key),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_args_encoded,\n                destination_encoded,\n                request_type_encoded,\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ]\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in(goracle_main_app_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.ApplicationCall,\n            TxnField.application_id: goracle_main_app_id,\n            TxnField.on_completion: OnComplete.OptIn,\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit(),\n    ])\n\n@Subroutine(TealType.none)\ndef opt_in_asset(asset_id):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: asset_id,\n            TxnField.asset_receiver: Global.current_application_address(),\n            TxnField.asset_amount: Int(0),\n            # TxnField.fee: Int(0)\n        }),\n        InnerTxnBuilder.Submit()\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_deposit, account_to_deposit_to):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_deposit,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_token\",\"main\"),\n            args=[\n                asset_transfer,\n                gora_token_id,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef deposit_algo(goracle_main_app_address, goracle_main_app_id, amount_to_deposit, account_to_deposit_to):\n    algo_transfer = \\\n    {\n        TxnField.type_enum: TxnType.Payment,\n        TxnField.amount: amount_to_deposit,\n        TxnField.receiver: goracle_main_app_address,\n        TxnField.fee: Int(0)\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"deposit_algo\",\"main\"),\n            args=[\n                algo_transfer,\n                account_to_deposit_to\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\nnew_key: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef register_key(goracle_main_app_id, new_key):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"register_participation_account\",\"main\"),\n            args=[\n                new_key,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_token(goracle_main_app_id, gora_token_id, amount_to_withdraw):\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_token\",\"main\"),\n            args=[\n                amount_to_withdraw,\n                gora_token_id,\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\"\"\"\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\namount_to_deposit: pyteal.Int\naccount_to_deposit_to: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef withdraw_algo(goracle_main_app_id, amount_to_withdraw):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"withdraw_algo\",\"main\"),\n            args=[\n                amount_to_withdraw\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_address: pyteal.Bytes\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef stake_token(goracle_main_app_address, goracle_main_app_id, gora_token_id, amount_to_stake):\n    asset_transfer = \\\n    {\n        TxnField.type_enum: TxnType.AssetTransfer,\n        TxnField.asset_amount: amount_to_stake,\n        TxnField.xfer_asset: gora_token_id,\n        TxnField.asset_receiver: goracle_main_app_address,\n        TxnField.fee: Global.min_txn_fee()\n    }\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('stake', 'main'),\n            args=[\n                asset_transfer,\n            ],\n            extra_fields={\n                TxnField.fee: Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n'''\ngoracle_main_app_id: pyteal.Int\ngora_token_id: pyteal.Int\namount_to_stake: pyteal.Int\n'''\n@Subroutine(TealType.none)\ndef unstake_token(goracle_main_app_id, gora_token_id, amount_to_unstake):\n\n    return Seq([\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature('unstake', 'main'),\n            args=[\n                amount_to_unstake,\n                gora_token_id\n            ],\n            extra_fields={\n                TxnField.fee : Int(2)*Global.min_txn_fee(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n\n\"\"\"\nAssert with a number to indentify it in API error message. The message will be:\n\"shr arg too big, (%d)\" where in \"%d\" 6 lowest decinals are the line number and\nany above that are the error code. Error types are defined \"error_codes.json\"\n\"\"\"\ndef SmartAssert(cond, err_type = 0):\n    if type(err_type) == str:\n        err_type = smart_assert_errors.index(err_type) # map mnemonic to code\n    err_line = sys._getframe().f_back.f_lineno # calling line number\n    return If(Not(cond)).Then(\n        InlineAssembly(\"int 0\\nint {}\\nshr\\n\".format(err_type * 1000000 + err_line))\n    )"}
{"instruction": "Define a smart contract that creates two 'Senior' objects, Mary (age 62) and Tom (age 75). The contract evaluates whether each person is eligible (age > 65) and logs a message indicating their eligibility status, along with a stored value. Specifically, a ScratchVar is initialized with the value 10. If eligible, the log includes their name, 'is eligible.', and the value of the ScratchVar. If not eligible, the log includes their name and 'is too young.' The contract then returns 1.", "output": "from pyteal import *\n\nglobals().update(TealType.__members__)\n\ndef verbatim(x):\n  return x\n\nclass Senior:\n  \n  @verbatim\n  def __init__(self, name, age):\n    self.age = age\n    self.name = name\n  \n  def isEligible(self):\n    return ( self.age > Int(65) )\n  \n  def evalAndPrint(self):\n    a = ScratchVar(TealType.uint64)\n    return  Seq(\n    \ta.store(Int(10)),\n    \tIf( self.isEligible(), \n          Log(Concat(self.name,Concat(Bytes(\" is eligible. \"),Itob(a.load()))))\n        , \n          Log(Concat(self.name,Bytes(\" is too young.\")))\n       ) )\n\ndef app():\n    mary = Senior(Bytes('Mary'), Int(62))\n    tom = Senior(Bytes('Tom'), Int(75))\n    return  Seq(\n    \tmary.evalAndPrint(),\n    \ttom.evalAndPrint(),\n    \tReturn( Int(1) ) )\n\nif __name__ == \"__main__\":\n    print(compileTeal(app(), mode=Mode.Application, version=7))"}
{"instruction": "Generate a PyTeal expression that executes a given PyTeal expression 'n' times. Optionally, use a provided ScratchVar to track the iteration count, or create a new one if none is provided. The generated expression should utilize a 'For' loop to achieve the iteration.", "output": "from pyteal import Expr, For, Int, ScratchVar\n\n__all__ = [\n    \"Iterate\",\n]\n\ndef Iterate(sub: Expr, n: Int, i: ScratchVar | None = None) -> Expr:\n    \"\"\"Iterate provides a convenience method for calling a method n times\n\n    Args:\n        sub: A PyTEAL Expr to call, should not return anything\n        n: The number of times to call the expression\n        i: (Optional) A ScratchVar to use for iteration, passed if the caller wants to access the iterator\n\n    Returns:\n        A Subroutine expression to be passed directly into an Expr tree\n    \"\"\"\n\n    i = i or ScratchVar()\n    init = i.store(Int(0))\n    cond = i.load() < n\n    step = i.store(i.load() + Int(1))\n    return For(init, cond, step).Do(sub)"}
{"instruction": "Implement various string and number conversion functions using PyTeal, including converting between ASCII characters and integers, converting between integer and byte strings, and encoding integers into uvarint byte strings, along with utility functions for manipulating byte strings such as extracting head, tail, suffix, prefix, and substrings.", "output": "from pyteal import (\n    Assert,\n    BitLen,\n    Btoi,\n    Bytes,\n    BytesDiv,\n    BytesGt,\n    BytesMod,\n    Concat,\n    Extract,\n    GetByte,\n    If,\n    Int,\n    Itob,\n    Len,\n    ScratchVar,\n    Seq,\n    Subroutine,\n    Substring,\n    TealType,\n)\n\nfrom pytealutils.math import pow10\n\n# Magic number to convert between ascii chars and integers\n_ascii_zero = 48\n_ascii_nine = _ascii_zero + 9\nascii_zero = Int(_ascii_zero)\nascii_nine = Int(_ascii_nine)\n\n\n@Subroutine(TealType.uint64)\ndef ascii_to_int(arg):\n    \"\"\"ascii_to_int converts the integer representing a character in ascii to the actual integer it represents\n\n    Args:\n        arg: uint64 in the range 48-57 that is to be converted to an integer\n\n    Returns:\n        uint64 that is the value the ascii character passed in represents\n\n    \"\"\"\n    return Seq(Assert(arg >= ascii_zero), Assert(arg <= ascii_nine), arg - ascii_zero)\n\n\n@Subroutine(TealType.bytes)\ndef int_to_ascii(arg):\n    \"\"\"int_to_ascii converts an integer to the ascii byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), arg, Int(1))\n\n\n@Subroutine(TealType.uint64)\ndef atoi(a):\n    \"\"\"atoi converts a byte string representing a number to the integer value it represents\"\"\"\n    return If(\n        Len(a) > Int(0),\n        (ascii_to_int(GetByte(a, Int(0))) * pow10(Len(a) - Int(1)))\n        + atoi(Substring(a, Int(1), Len(a))),\n        Int(0),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i):\n    \"\"\"itoa converts an integer to the ascii byte string it represents\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            int_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef witoa(i):\n    \"\"\"witoa converts an byte string interpreted as an integer to the ascii byte string it represents\"\"\"\n    return If(\n        BitLen(i) == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(\n                BytesGt(BytesDiv(i, Bytes(\"base16\", \"A0\")), Bytes(\"base16\", \"A0\")),\n                witoa(BytesDiv(i, Bytes(\"base16\", \"A0\"))),\n                Bytes(\"\"),\n            ),\n            int_to_ascii(Btoi(BytesMod(i, Bytes(\"base16\", \"A0\")))),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef head(s):\n    \"\"\"head gets the first byte from a bytestring, returns as bytes\"\"\"\n    return Extract(s, Int(0), Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef tail(s):\n    \"\"\"tail returns the string with the first character removed\"\"\"\n    return Substring(s, Int(1), Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef suffix(s, n):\n    \"\"\"suffix returns the last n bytes of a given byte string\"\"\"\n    return Substring(s, Len(s) - n, Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef prefix(s, n):\n    \"\"\"prefix returns the first n bytes of a given byte string\"\"\"\n    return Substring(s, Int(0), n)\n\n\n@Subroutine(TealType.bytes)\ndef rest(s, n):\n    \"\"\"prefix returns the first n bytes of a given byte string\"\"\"\n    return Substring(s, n, Len(s))\n\n\n@Subroutine(TealType.bytes)\ndef encode_uvarint(val, b):\n    \"\"\"\n    Returns the uvarint encoding of an integer\n\n    Useful in the case that the bytecode for a contract is being populated, since\n    integers in a contract are uvarint encoded\n\n    This subroutine is recursive, the first call should include\n    the integer to be encoded and an empty bytestring\n\n    \"\"\"\n    buff = ScratchVar()\n    return Seq(\n        buff.store(b),\n        Concat(\n            buff.load(),\n            If(\n                val >= Int(128),\n                encode_uvarint(\n                    val >> Int(7),\n                    Extract(Itob((val & Int(255)) | Int(128)), Int(7), Int(1)),\n                ),\n                Extract(Itob(val & Int(255)), Int(7), Int(1)),\n            ),\n        ),\n    )"}
{"instruction": "Define classes and functions for managing application state in PyTeal, including local and global state variables, arrays, and 2D arrays, with methods for reading, writing, checking existence, incrementing, and decrementing state values.", "output": "from pyteal import App, Bytes, Concat, Expr, Int, Itob, MaybeValue, Seq, TealType\nfrom pyteal.types import require_type\n\n__all__ = [\n    \"State\", \"LocalState\", \"GlobalState\", \"get_global_state_ex\",\n    \"StateArray\", \"LocalStateArray\", \"GlobalStateArray\",\n    \"LocalStateArray2D\", \"GlobalStateArray2D\"\n]\n\nclass State:\n    def __init__(self, name: str | Expr, type_hint: TealType = TealType.anytype):\n        self._name: Expr\n        self.type_hint = type_hint\n        self._name = Bytes(name) if isinstance(name, str) else name\n\n    def put(self, value: Expr) -> App:\n        raise NotImplementedError\n\n    def get(self) -> App:\n        raise NotImplementedError\n\n    def exists(self) -> Expr:\n        raise NotImplementedError\n\n    def add_assign(self, value_to_add: Expr) -> App:\n        if not isinstance(value_to_add, Expr):\n            raise ValueError(\"value_to_add must be an instance of Expr or Expr subclass\")\n        return self.put(self.get() + value_to_add)\n\n    def sub_assign(self, value_to_subtract: Expr) -> App:\n        if not isinstance(value_to_subtract, Expr):\n            raise ValueError(\"value_to_subtract must be an instance of Expr or Expr subclass\")\n        return self.put(self.get() - value_to_subtract)\n\nclass LocalState(State):\n    def put(self, value: Expr) -> App:\n        require_type(value, self.type_hint)\n        return App.localPut(Int(0), self._name, value)\n\n    def get(self) -> App:\n        return App.localGet(Int(0), self._name)\n\n    def exists(self) -> Expr:\n        ex = App.localGetEx(Int(0), Int(0), self._name)\n        return Seq(ex, ex.hasValue())\n\nclass GlobalState(State):\n    def put(self, value: Expr) -> App:\n        require_type(value, self.type_hint)\n        return App.globalPut(self._name, value)\n\n    def get(self) -> App:\n        return App.globalGet(self._name)\n\n    def exists(self) -> Expr:\n        ex = App.globalGetEx(Int(0), self._name)\n        return Seq(ex, ex.hasValue())\n\ndef get_global_state_ex(foreign_id: int, key: str) -> MaybeValue:\n    return App.globalGetEx(Int(foreign_id), Bytes(key))\n\nclass StateArray:\n    def __init__(self, prefix: str | Expr, type_hint: TealType = TealType.anytype):\n        self._prefix = prefix\n        self.type_hint = type_hint\n\n    def key_at_index(self, index: int | Expr) -> Expr:\n        if isinstance(index, int):\n            return Bytes(self._prefix.encode(\"utf-8\") + index.to_bytes(8, \"big\")) if isinstance(self._prefix, str) else Concat(self._prefix, Bytes(index.to_bytes(8, \"big\")))\n        return Concat(Bytes(self._prefix), Itob(index)) if isinstance(self._prefix, str) else Concat(self._prefix, Itob(index))\n\n    def __getitem__(self, index: int | Expr):\n        raise NotImplementedError\n\nclass LocalStateArray(StateArray):\n    def __getitem__(self, index: int | Expr):\n        return LocalState(self.key_at_index(index), self.type_hint)\n\nclass LocalStateArray2D(StateArray):\n    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):\n        length, width = indices\n        return LocalStateArray(self.key_at_index(length), self.type_hint)[width]\n\nclass GlobalStateArray(StateArray):\n    def __getitem__(self, index: int | Expr):\n        return GlobalState(self.key_at_index(index), self.type_hint)\n\nclass GlobalStateArray2D(StateArray):\n    def __getitem__(self, indices: tuple[int | Expr, int | Expr]):\n        length, width = indices\n        return GlobalStateArray(self.key_at_index(length), self.type_hint)[width]"}
{"instruction": "Generate a PyTeal application approval program for a smart contract named 'CFGExample'. The contract includes a creation method and an opt-in method. Print the compiled application approval program.", "output": "from pyteal import *  # pylint: disable=wildcard-import,unused-wildcard-import\n\nrouter = Router(\n    name=\"CFGExample\",\n    bare_calls=BareCallActions(),\n)\n\n@router.method(no_op=CallConfig.CREATE)\ndef create() -> Expr:\n    return Return()\n\n@router.method(opt_in=CallConfig.CALL)\ndef opt_in() -> Expr:\n    return Return()\n\npragma(compiler_version=\"0.22.0\")\napplication_approval_program, _, _ = router.compile_program(version=7)\n\nif __name__ == \"__main__\":\n    print(application_approval_program)"}
{"instruction": "Implement type checking and validation functions for the PyTeal language, including type enforcement, address validation, and RFC 4648 base32, base64, and base16 string validation, as well as template variable validation.", "output": "import re\nfrom enum import Enum\nfrom typing import Any\n\nfrom .errors import TealTypeError, TealInputError\n\nclass TealType(Enum):\n    \"\"\"Teal type enum.\"\"\"\n\n    uint64 = 0\n    bytes = 1\n    anytype = 2\n    none = 3\n\nTealType.__module__ = \"pyteal\"\n\ndef require_type(input: Any, expected: TealType):\n    try:\n        actual = input.type_of()\n    except AttributeError:\n        raise TypeError(f\"Expected a {expected} object, but got a {type(input)}\")\n\n    if actual != expected and (\n        expected == TealType.none\n        or actual == TealType.none\n        or (actual != TealType.anytype and expected != TealType.anytype)\n    ):\n        raise TealTypeError(actual, expected)\n\ndef types_match(type1: TealType, type2: TealType) -> bool:\n    if (type1 == TealType.none or type2 == TealType.none) and type1 != type2:\n        return False\n\n    if type1 == TealType.anytype or type2 == TealType.anytype:\n        return True\n\n    return type1 == type2\n\ndef valid_address(address: str):\n    if type(address) is not str:\n        raise TealInputError(\"An address needs to be a string\")\n\n    if len(address) != 58:\n        raise TealInputError(\n            \"Address length is not correct. Should \"\n            + \"be a base 32 string encoded 32 bytes public key + 4 bytes checksum\"\n        )\n\n    valid_base32(address)\n\ndef valid_base32(s: str):\n    pattern = re.compile(\n        r\"^(?:[A-Z2-7]{8})*(?:([A-Z2-7]{2}([=]{6})?)|([A-Z2-7]{4}([=]{4})?)|([A-Z2-7]{5}([=]{3})?)|([A-Z2-7]{7}([=]{1})?))?\"\n    )\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 32 string\".format(s))\n\ndef valid_base64(s: str):\n    pattern = re.compile(\n        r\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\"\n    )\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 64 string\".format(s))\n\ndef valid_base16(s: str):\n    pattern = re.compile(r\"[0-9A-Fa-f]*\")\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid RFC 4648 base 16 string\".format(s))\n\ndef valid_tmpl(s: str):\n    pattern = re.compile(r\"TMPL_[A-Z0-9_]+\")\n\n    if pattern.fullmatch(s) is None:\n        raise TealInputError(\"{} is not a valid template variable\".format(s))"}
{"instruction": "Implement a PyTeal expression, `ImportScratchValue`, that allows loading a scratch variable's value from a different transaction within the same atomic transaction group, handling both integer and expression-based transaction indices. Ensure that the transaction index and slot ID are within valid bounds (0 to MAX_GROUP_SIZE-1 and 0 to NUM_SLOTS-1, respectively). The expression should generate either a `gload` or `gloads` opcode based on whether the transaction index is an integer or an expression, respectively. The expression's type is `anytype`.", "output": "from typing import cast, Union, TYPE_CHECKING\n\nfrom ..types import TealType, require_type\nfrom ..ir import TealOp, Op, TealBlock\nfrom ..errors import TealInputError, verifyTealVersion\nfrom ..config import MAX_GROUP_SIZE, NUM_SLOTS\nfrom .expr import Expr\nfrom .int import Int\nfrom .leafexpr import LeafExpr\n\nif TYPE_CHECKING:\n    from ..compiler import CompileOptions\n\nclass ImportScratchValue(LeafExpr):\n    \"\"\"An expression to load a scratch value created by another transaction in the current group\"\"\"\n\n    def __init__(self, txnIndex: Union[int, Expr], slotId: int) -> None:\n        super().__init__()\n        if type(txnIndex) is int:\n            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:\n                raise TealInputError(\n                    \"Invalid transaction index {}, shoud be in [0, {})\".format(\n                        txnIndex, MAX_GROUP_SIZE\n                    )\n                )\n        else:\n            require_type(cast(Expr, txnIndex).type_of(), TealType.uint64)\n\n        if slotId < 0 or slotId >= NUM_SLOTS:\n            raise TealInputError(\n                \"Invalid slot ID {}, shoud be in [0, {})\".format(slotId, NUM_SLOTS)\n            )\n\n        self.txnIndex = txnIndex\n        self.slotId = slotId\n\n    def __str__(self) -> str:\n        return \"(Gload {} {})\".format(self.txnIndex, self.slotId)\n\n    def __teal__(self, options: \"CompileOptions\"):\n        verifyTealVersion(\n            Op.gload.min_version,\n            options.version,\n            \"TEAL version too low to use Gload expression\",\n        )\n\n        if type(self.txnIndex) is int:\n            op = TealOp(self, Op.gload, self.txnIndex, self.slotId)\n            return TealBlock.FromOp(options, op)\n\n        op = TealOp(self, Op.gloads, self.slotId)\n        return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))\n\n    def type_of(self):\n        return TealType.anytype\n\nImportScratchValue.__module__ = \"pyteal\""}
{"instruction": "Display the Algorand account addresses for the app creator, player X, and player O, and provide a link to fund these accounts on the Algorand testnet.", "output": "import streamlit as st\nfrom src.blockchain_utils.credentials import get_client, get_account_credentials, get_indexer\nfrom src.services.game_engine_service import GameEngineService\nimport algosdk\n\nclient = get_client()\nindexer = get_indexer()\n\nacc_pk, acc_address = algosdk.account.generate_account()\nplayer_x_pk, player_x_address = algosdk.account.generate_account()\nplayer_o_pk, player_o_address = algosdk.account.generate_account()\n\nif \"submitted_transactions\" not in st.session_state:\n    st.session_state.submitted_transactions = []\n\nif \"player_turn\" not in st.session_state:\n    st.session_state.player_turn = \"X\"\n\nif \"game_state\" not in st.session_state:\n    st.session_state.game_state = ['-'] * 9\n\nif \"x_state\" not in st.session_state:\n    st.session_state.x_state = 0\n\nif \"o_state\" not in st.session_state:\n    st.session_state.o_state = 0\n\nif \"game_engine\" not in st.session_state:\n    st.session_state.game_engine = GameEngineService(app_creator_pk=acc_pk,\n                                                     app_creator_address=acc_address,\n                                                     player_x_pk=player_x_pk,\n                                                     player_x_address=player_x_address,\n                                                     player_o_pk=player_o_pk,\n                                                     player_o_address=player_o_address)\n\nif \"game_status\" not in st.session_state:\n    st.session_state.game_status = 0\n\nif \"is_app_deployed\" not in st.session_state:\n    st.session_state.is_app_deployed = False\n\nif \"is_game_started\" not in st.session_state:\n    st.session_state.is_game_started = False\n\nst.title(\"Addresses\")\nst.write(f\"app_creator: {acc_address}\")\nst.write(f\"player_x: {player_x_address}\")\nst.write(f\"player_o: {player_o_address}\")\n\nst.write(\"You need to fund those accounts on the following link: https://bank.testnet.algorand.network/\")\n\n# App deployment\n# ... (rest of output truncated for brevity)"}
{"instruction": "Define constants for Algorand smart contract development, including microalgo denominations (Algo, MilliAlgo), opcode budget limits, boolean aliases (TRUE, FALSE), maximum state values (local and global), limits for Logic Signature arguments, domain separator for program hashing, minimum balance requirements for boxes and assets, and a function to calculate the number of extra program pages needed based on the size of the approval and clear state programs.", "output": "from math import ceil\nfrom typing import Final\n\nfrom algosdk.constants import APP_PAGE_MAX_SIZE\nfrom pyteal import Int\n\n#: number of microalgos in 1 Algo\nalgo: Final[int] = int(1e6)\n#: number of microalgos in 1 MilliAlgo\nmilli_algo: Final[int] = int(1e3)\n\n#: Used for runtime algo calculations `Txn.amount()==Algo`\nAlgo: Final[Int] = Int(algo)\n#: Used for runtime algo calculations `Txn.fee()==MilliAlgo`\nMilliAlgo: Final[Int] = Int(milli_algo)\n\n#: Used for shorthand for Int(10*algo) like Algos(10)\ndef Algos(v: int | float) -> Int:  # noqa: N802\n    return Int(int(v * algo))\n\n#: Used for shorthand for Int(10*milli_algo) like MilliAlgos(10)\ndef MilliAlgos(v: int | float) -> Int:  # noqa: N802\n    return Int(int(v * milli_algo))\n\n#: Max number of inner transactions that may be called\nMAX_INNERS = 255\n#: Single app call opcode budget\nAPP_CALL_BUDGET = 700\n#: Max possible opcode budget\nMAX_OPS = MAX_INNERS * APP_CALL_BUDGET\n\n#: Single app call budget\nAppCallBudget = Int(APP_CALL_BUDGET)\n#: Max app call budget possible\nMaxOps = Int(MAX_OPS)\n\n#: TRUE used as an alias for 1\nTRUE: Final[Int] = Int(1)\n#: FALSE used as an alias for 0\nFALSE: Final[Int] = Int(0)\n\n#: The max number of local state values that may be declared\nMAX_LOCAL_STATE = 16\n#: The max number of global state values that may be declared\nMAX_GLOBAL_STATE = 64\n\n#: The maximum number of args that may be included in an lsig\nLSIG_MAX_ARGS = 255\n\n#: The prefix used when hashing bytecode to produce a unique hash\nPROGRAM_DOMAIN_SEPARATOR = \"Program\"\n\n#: The min balance increase per box created\nBOX_FLAT_MIN_BALANCE = 2500\n\n#: The min balance increase per byte of boxes (key included)\nBOX_BYTE_MIN_BALANCE = 400\n\n#: The min balance increase for each asset opted into\nASSET_MIN_BALANCE = 100000\n\n\ndef num_extra_program_pages(approval: bytes, clear: bytes) -> int:\n    return ceil(((len(approval) + len(clear)) - APP_PAGE_MAX_SIZE) / APP_PAGE_MAX_SIZE)"}
{"instruction": "Fetch transaction data for asset ID 42771692 from the Algoexplorer API, store it in a JSON file, then parse the JSON file to calculate rewards based on transaction amounts, applying a hardcoded 12% reward rate. Finally, send the calculated rewards (Choice Coins) to the senders of the original transactions using the `choice_trade` function.", "output": "#Choice Coin Governance Rewards Code.\n#Proposed rates: up to 5 million Choice committed: 20 percent, 10 million Choice: 15 percent, 12 million Choice: 12.5%\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nfrom algorand_demo import choice_trade\nimport json\nimport urllib3\nchoice_id  = 42771692\n\nvoter_1_address = \nvoter_1_mnemonic = \nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','https://testnet.algoexplorerapi.io/idx2/v2/accounts/I62YOUP2YB65PQSTA25MXEVMWHD45HSZ5PPOYAH2NVV4Y3QBZLBDY4V53A/transactions?asset-id=42771692')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\n\t# now we will open a file for writing\n\t\tdata_file = open('file.csv', 'w')\n\n\t# create the csv writer object\n\t\tcsv_writer = csv.writer(data_file)\n\n\t# Counter variable used for writing\n\t# headers to the CSV file\n\t\tcount = 0\n\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\n\t\t        # Writing headers of CSV file\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\n\t\t    # Writing data of CSV file\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t    # pass the file object to reader() to get the reader object\n\t\t\t\t\tdata = json.load(json_file)\n\t\t\t\t\ttransaction_data = data['transactions']\n\t\t\t\t\tfor transaction in transaction_data:\n\t\t\t\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\t\t\t\tamount = int(amount)\n\t\t\t\t\t\tamount = amount + amount * 0.12 #Rewards rate hardcoded\n\t\t\t\t\t\taddress = transaction['sender']\n\t\t\t\t\t\tid = transaction['id']\n\t\t\t\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"instruction": "Create and execute atomic transactions using the AtomicTransactionComposer. First, create a payment transaction and add it to the composer. Then, deploy a calculator application and add a method call to the composer to execute the 'add' method of the contract. Finally, add a method call using box references to the composer.", "output": "import base64\nfrom algosdk import transaction, abi\nfrom utils import get_accounts, get_algod_client, deploy_calculator_app\n\nfrom algosdk.atomic_transaction_composer import (\n    AtomicTransactionComposer,\n    AccountTransactionSigner,\n    TransactionWithSigner,\n)\n\n# example: ATC_CREATE\natc = AtomicTransactionComposer()\n# example: ATC_CREATE\n\naccts = get_accounts()\nacct = accts.pop()\n\nalgod_client = get_algod_client()\n\n# example: ATC_ADD_TRANSACTION\naddr, sk = acct.address, acct.private_key\n\n# Create signer object\nsigner = AccountTransactionSigner(sk)\n\n# Get suggested params from the client\nsp = algod_client.suggested_params()\n\n# Create a transaction\nptxn = transaction.PaymentTxn(addr, sp, addr, 10000)\n\n# Construct TransactionWithSigner\ntws = TransactionWithSigner(ptxn, signer)\n\n# Pass TransactionWithSigner to ATC\natc.add_transaction(tws)\n# example: ATC_ADD_TRANSACTION\n\napp_id = deploy_calculator_app(algod_client, acct)\n\n# example: ATC_CONTRACT_INIT\nwith open(\"calculator/contract.json\") as f:\n    js = f.read()\ncontract = abi.Contract.from_json(js)\n# example: ATC_CONTRACT_INIT\n\n# example: ATC_ADD_METHOD_CALL\n# Simple call to the `add` method, method_args can be any type but _must_ match those in the method signature of the contract\natc.add_method_call(\n    app_id,\n    contract.get_method_by_name(\"add\"),\n    addr,\n    sp,\n    signer,\n    method_args=[1, 1],\n)\n# example: ATC_ADD_METHOD_CALL\n\n# example: ATC_RESULTS\n# Other options:\n# txngroup = atc.build_group()\n# txids = atc.submit(client)\nresult = atc.execute(algod_client, 4)\nfor res in result.abi_results:\n    print(res.return_value)\n# example: ATC_RESULTS\n\nmy_method = abi.Method(\n    name=\"box_ref_demo\", args=[], returns=abi.Returns(\"void\")\n)\n# example: ATC_BOX_REF\natc = AtomicTransactionComposer()\natc.add_method_call(\n    app_id,\n    my_method,\n    addr,\n    sp,\n    signer,\n    boxes=[[app_id, b\"key\"]],\n)\n# example: ATC_BOX_REF"}
{"instruction": "Call various methods of a smart contract, including writing and reading from a box, performing arithmetic operations, reversing a string, testing transaction parameters, handling many arguments, retrieving minimum balance, and concatenating strings. First, fund the application account and write to a box named 'cool_box', then read from that same box. Finally, execute a series of method calls: 'add', 'sub', 'div', 'mul', 'qrem', 'reverse', 'txntest', 'manyargs', 'min_bal', and 'concat_strings', printing the return values of each method call.", "output": "from algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import (\n    AccountTransactionSigner,\n    AtomicTransactionComposer,\n    TransactionWithSigner,\n)\nfrom algosdk.transaction import PaymentTxn, AssetCreateTxn\nfrom algosdk.abi import Contract\nfrom algosdk.logic import get_application_address\n\nfrom sandbox import get_accounts\n\nclient = AlgodClient(\"a\" * 64, \"http://localhost:4001\")\n\naddr, sk = get_accounts()[0]\n\nwith open(\"../contract.json\") as f:\n    js = f.read()\n\nwith open(\"../.app_id\") as f:\n    app_id = int(f.read())\n\napp_addr = get_application_address(app_id)\n\nc = Contract.from_json(js)\n\nsigner = AccountTransactionSigner(sk)\nsp = client.suggested_params()\n\nbox_comp = AtomicTransactionComposer()\nbox_name = b\"cool_box\"\nbox_comp.add_transaction(\n    TransactionWithSigner(PaymentTxn(addr, sp, app_addr, 1_000_000_000), signer=signer),\n)\nbox_comp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"box_write\"),\n    addr,\n    sp,\n    signer,\n    method_args=[box_name, (123, 456)],\n    boxes=[(0, box_name)],\n)\nbox_comp.add_method_call(\n    app_id,\n    c.get_method_by_name(\"box_read\"),\n    addr,\n    sp,\n    signer,\n    method_args=[box_name],\n    boxes=[(0, box_name)],\n)\nbox_result = box_comp.execute(client, 4)\nprint(f\"box_read returned: {box_result.abi_results[-1].return_value}\")\n\ncomp = AtomicTransactionComposer()\ncomp.add_method_call(app_id, c.get_method_by_name(\"add\"), addr, sp, signer, method_args=[1, 1])\ncomp.add_method_call(app_id, c.get_method_by_name(\"sub\"), addr, sp, signer, method_args=[3, 1])\ncomp.add_method_call(app_id, c.get_method_by_name(\"div\"), addr, sp, signer, method_args=[4, 2])\ncomp.add_method_call(app_id, c.get_method_by_name(\"mul\"), addr, sp, signer, method_args=[3, 2])\ncomp.add_method_call(app_id, c.get_method_by_name(\"qrem\"), addr, sp, signer, method_args=[27, 5])\ncomp.add_method_call(app_id, c.get_method_by_name(\"reverse\"), addr, sp, signer, method_args=[\"desrever yllufsseccus\"])\n\nptxn = TransactionWithSigner(PaymentTxn(addr, sp, addr, 10000), signer)\ncomp.add_method_call(app_id, c.get_method_by_name(\"txntest\"), addr, sp, signer, method_args=[10000, ptxn, 1000])\ncomp.add_method_call(app_id, c.get_method_by_name(\"manyargs\"), addr, sp, signer, method_args=[2] * 20)\ncomp.add_method_call(app_id, c.get_method_by_name(\"min_bal\"), addr, sp, signer, method_args=[\"SKCBRBKPIGY5LI2OU63IE5LMNQ5BVVOKPHWTPPWFQOI4NG4TI35SLAA3JQ\"])\ncomp.add_method_call(app_id, c.get_method_by_name(\"concat_strings\"), addr, sp, signer, method_args=[[\"this\", \"string\", \"is\", \"joined\"]])\n\nresp = comp.execute(client, 2)\nfor result in resp.abi_results:\n    print(f\"{result.method.name} => {result.return_value}\")"}
{"instruction": "Simulate a payment transaction on a local Algorand ledger. First, generate two accounts with associated secret keys and addresses. Then, fund the first account with 1,000,000 units. Next, create and sign a payment transaction sending 200,000 units from the first account to the second account. Finally, evaluate the transaction on the local ledger and print a success message.", "output": "from algojig import get_suggested_params, generate_accounts, dump\nfrom algojig.ledger import JigLedger\nfrom algosdk.transaction import PaymentTxn\n\nsecrets, addresses = generate_accounts(2)\n\nsp = get_suggested_params()\n\nledger = JigLedger()\nledger.set_account_balance(addresses[0], 1_000_000)\n\ntransactions = [\n    PaymentTxn(\n        sender=addresses[0],\n        sp=sp,\n        receiver=addresses[1],\n        amt=200_000,\n    ).sign(secrets[0]),\n]\nblock = ledger.eval_transactions(transactions)\nprint(\"Looks like it works!\")"}
{"instruction": "Generate three Algorand accounts (app creator, player X, and player O), display their addresses in a Streamlit app, and provide a link to fund these accounts on the Algorand TestNet. Initialize Streamlit session state variables to manage game state, track submitted transactions, and handle application deployment and game start status.", "output": "import streamlit as st\nfrom src.blockchain_utils.credentials import get_client, get_account_credentials, get_indexer\nfrom src.services.game_engine_service import GameEngineService\nimport algosdk\n\nclient = get_client()\nindexer = get_indexer()\n\nacc_pk, acc_address = algosdk.account.generate_account()\nplayer_x_pk, player_x_address = algosdk.account.generate_account()\nplayer_o_pk, player_o_address = algosdk.account.generate_account()\n\nif \"submitted_transactions\" not in st.session_state:\n    st.session_state.submitted_transactions = []\n\nif \"player_turn\" not in st.session_state:\n    st.session_state.player_turn = \"X\"\n\nif \"game_state\" not in st.session_state:\n    st.session_state.game_state = ['-'] * 9\n\nif \"x_state\" not in st.session_state:\n    st.session_state.x_state = 0\n\nif \"o_state\" not in st.session_state:\n    st.session_state.o_state = 0\n\nif \"game_engine\" not in st.session_state:\n    st.session_state.game_engine = GameEngineService(app_creator_pk=acc_pk,\n                                                     app_creator_address=acc_address,\n                                                     player_x_pk=player_x_pk,\n                                                     player_x_address=player_x_address,\n                                                     player_o_pk=player_o_pk,\n                                                     player_o_address=player_o_address)\n\nif \"game_status\" not in st.session_state:\n    st.session_state.game_status = 0\n\nif \"is_app_deployed\" not in st.session_state:\n    st.session_state.is_app_deployed = False\n\nif \"is_game_started\" not in st.session_state:\n    st.session_state.is_game_started = False\n\nst.title(\"Addresses\")\nst.write(f\"app_creator: {acc_address}\")\nst.write(f\"player_x: {player_x_address}\")\nst.write(f\"player_o: {player_o_address}\")\n\nst.write(\"You need to fund those accounts on the following link: https://bank.testnet.algorand.network/\")\n\n# App deployment\n# ... (rest of output truncated for brevity)"}
{"instruction": "Opt-in an escrow account into a specific token (identified by its Asset ID) using an Algorand transaction. After submitting the transaction, wait for confirmation and then print a success message that includes the token's Asset ID and a link to the transaction on the Algoexplorer testnet.", "output": "```python\nimport os\nimport base64\nimport time\n\nfrom algosdk.v2client import algod, indexer\nfrom algosdk.future import transaction\nfrom algosdk import encoding, account, mnemonic, error\nfrom pyteal import compileTeal, Mode\n\nfrom contracts import manager\n\nALGOD_ENDPOINT = os.environ['ALGOD_ENDPOINT']\nALGOD_TOKEN = os.environ['ALGOD_TOKEN']\nINDEXER_ENDPOINT = os.environ['INDEXER_ENDPOINT']\nINDEXER_TOKEN = os.environ['INDEXER_TOKEN']\n\nDEVELOPER_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(\n    os.environ['DEVELOPER_ACCOUNT_PRIVATE_KEY'])\nDEVELOPER_ACCOUNT_ADDRESS = account.address_from_private_key(\n    DEVELOPER_ACCOUNT_PRIVATE_KEY)\nZERO_ADDRESS = encoding.encode_address(bytes(32))\n\nTEST_ACCOUNT_PRIVATE_KEY = mnemonic.to_private_key(\n    os.environ['TEST_ACCOUNT_PRIVATE_KEY'])\nTEST_ACCOUNT_ADDRESS = account.address_from_private_key(\n    TEST_ACCOUNT_PRIVATE_KEY)\n\n# ...<the rest of your code remains unchanged up to the last complete block>\n\n    wait_for_transaction(tx_id)\n\n    print(\n        f\"Opted Escrow into Token with Asset ID: {token_idx} successfully! Tx ID: https://testnet.algoexplorer.io/tx/{tx_id}\"\n    )\n\n    print()\n```"}
{"instruction": "Connect to the KMD service, retrieve the unencrypted default wallet, and extract all account addresses and corresponding private keys from it. Return the accounts as a list of tuples, where each tuple contains an address and its private key.", "output": "import algosdk\n\nKMD_ADDRESS = \"http://localhost:4002\"\nKMD_TOKEN = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\nKMD_WALLET_NAME = \"unencrypted-default-wallet\"\nKMD_WALLET_PASSWORD = \"\"\n\n\ndef get_accounts():\n    kmd = algosdk.kmd.KMDClient(KMD_TOKEN, KMD_ADDRESS)\n    wallets = kmd.list_wallets()\n\n    walletID = None\n    for wallet in wallets:\n        if wallet[\"name\"] == KMD_WALLET_NAME:\n            walletID = wallet[\"id\"]\n            break\n\n    if walletID is None:\n        raise Exception(\"Wallet not found: {}\".format(KMD_WALLET_NAME))\n\n    walletHandle = kmd.init_wallet_handle(walletID, KMD_WALLET_PASSWORD)\n\n    try:\n        addresses = kmd.list_keys(walletHandle)\n        privateKeys = [kmd.export_key(walletHandle, KMD_WALLET_PASSWORD, addr) for addr in addresses]\n        kmdAccounts = [(addresses[i], privateKeys[i]) for i in range(len(privateKeys))]\n    finally:\n        kmd.release_wallet_handle(walletHandle)\n\n    return kmdAccounts"}
{"instruction": "Provide functions for interacting with the Algorand blockchain, including decoding state values, retrieving global and local application state, getting transaction parameters, fetching the last round and timestamp, compiling smart contract source code, and normalizing parameters for a SmartASA configuration.", "output": "import base64\nfrom collections import namedtuple\nfrom inspect import get_annotations\nfrom typing import Union\nfrom algosdk import constants\nfrom algosdk.future import transaction\nfrom algosdk.v2client import algod\nfrom smart_asa_asc import SmartASAConfig as PyTealSmartASAConfig\ndef decode_state(state) -> dict[str, Union[int, bytes]]: return {base64.b64decode(s[\"key\"]).decode(): base64.b64decode(s[\"value\"][\"bytes\"]) if s[\"value\"][\"type\"] == 1 else int(s[\"value\"][\"uint\"]) for s in state}\ndef get_global_state(algod_client: algod.AlgodClient, asc_idx: int) -> dict[str, Union[bytes, int]]: global_state = algod_client.application_info(asc_idx)[\"params\"][\"global-state\"]; global_state = decode_state(global_state); return global_state\ndef get_local_state(algod_client: algod.AlgodClient, account_address: str, asc_idx: int) -> dict[str, Union[bytes, int]]: local_states = algod_client.account_info(account_address)[\"apps-local-state\"]; local_state = [s for s in local_states if s[\"id\"] == asc_idx][0].get(\"key-value\", {}); local_state = decode_state(local_state); return local_state\ndef get_params(algod_client: algod.AlgodClient, fee: int = None) -> transaction.SuggestedParams: params = algod_client.suggested_params(); params.flat_fee = True; params.fee = fee or constants.MIN_TXN_FEE; return params\ndef get_last_round(algod_client: algod.AlgodClient): return algod_client.status()[\"last-round\"]\ndef get_last_timestamp(algod_client: algod.AlgodClient): return algod_client.block_info(get_last_round(algod_client))[\"block\"][\"ts\"]\ndef assemble_program(algod_client: algod.AlgodClient, source_code: str) -> bytes: compile_response = algod_client.compile(source_code); return base64.b64decode(compile_response[\"result\"])\nSmartASAConfig = namedtuple(PyTealSmartASAConfig.__class__.__name__, list(get_annotations(PyTealSmartASAConfig)))\ndef normalize_getter_params(getter_params: list) -> SmartASAConfig: return SmartASAConfig(*getter_params)"}
{"instruction": "Implement a smart contract that initializes a global counter to zero upon creation and increments it by one with each subsequent application call. The contract should approve all clear state transactions.", "output": "from pyteal import *\n\ndef approval_program():\n    # Define global state keys\n    global_counter = Bytes(\"Counter\")\n\n    on_create = Seq([\n        App.globalPut(global_counter, Int(0)),\n        Return(Int(1))\n    ])\n\n    on_call_increment = Seq([\n        App.globalPut(global_counter, App.globalGet(global_counter) + Int(1)),\n        Return(Int(1))\n    ])\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],  # App creation\n        [Txn.on_completion() == OnComplete.NoOp, on_call_increment]  # NoOp call: increment counter\n    )\n\n    return program\n\ndef clear_state_program():\n    return Return(Int(1))"}
{"instruction": "Simulate a simplified Algorand blockchain by creating accounts with random stakes, mining a series of blocks, and validating the integrity of the chain. Each block contains a set of transactions, and the mining process involves selecting proposers and a committee, proposing blocks, reaching consensus via Byzantine Agreement, and distributing rewards to the participants.", "output": "import hashlib\nimport math\nimport time\nimport random\nfrom typing import List\n\nfrom ecdsa import SECP256k1, SigningKey, VerifyingKey\n\nfrom transaction import Transaction\n\n\nclass Block:\n    def __init__(\n        self,\n        txns: List[Transaction],\n        previous_hash: str,\n        vrf_proof,\n        verify_key: VerifyingKey,\n    ):\n        self.txns = txns\n        self.previous_hash = previous_hash\n        self.timestamp = int(time.time())\n        self.vrf_proof = vrf_proof\n        self.verify_key = verify_key\n        self.hash = self.calculate_hash()\n\n    def calculate_hash(self) -> str:\n        block_data = f\"{self.txns}{self.previous_hash}{self.timestamp}{self.vrf_proof}{self.verify_key}\"\n        return hashlib.sha256(block_data.encode()).hexdigest()\n\n    def is_valid(self, previous_hash: str):\n        return (\n            self.hash == self.calculate_hash() and self.previous_hash == previous_hash\n        )\n\n    def __repr__(self):\n        return f\"Block (timestamp={self.timestamp}, hash={self.hash[:8]}, previous_hash={self.previous_hash[:8]}, num_txns={len(self.txns)})\"\n\n\nclass Blockchain:\n    def __init__(self):\n        self.chain: List[Block] = []\n\n        self.create_genesis_block()\n\n    def create_genesis_block(self) -> None:\n        genesis_block = Block([], \"0\", \"0\", \"0\")\n        self.chain.append(genesis_block)\n\n    def add_block(self, block: Block) -> None:\n        if block.is_valid(self.get_last_block().hash):\n            self.chain.append(block)\n\n    def get_last_block(self) -> Block:\n        return self.chain[-1]\n\n    def get_new_block_index(self) -> int:\n        return len(self.chain)\n\n    def is_valid(self) -> bool:\n        return all(\n            self.chain[i].is_valid(\n                target=self.target_from_difficulty(),\n                previous_hash=self.chain[i - 1].hash,\n            )\n            for i in range(1, len(self.chain))\n        )\n\n\nclass Account:\n    def __init__(self, stake):\n        self.signing_key = SigningKey.generate(curve=SECP256k1)\n        self.verify_key = self.signing_key.verifying_key\n        self.stake = stake\n        self.total_rewards = 0\n\n    def generate_key_pair(self):\n        return self.signing_key.to_string().hex(), self.verify_key.to_string().hex()\n\n    def prove(self, message):\n        # Hash the message\n        message_hash = hashlib.sha256(message).digest()\n\n        # Sign the hash\n        signature = self.signing_key.sign(message_hash)\n\n        return signature.hex(), self.verify_key\n\n    def verify(self, message: bytes, signature, verify_key):\n        verify_key = VerifyingKey.from_string(\n            bytes.fromhex(verify_key.to_string().hex()), curve=SECP256k1\n        )\n        message_hash = hashlib.sha256(message).digest()\n        try:\n            return verify_key.verify(bytes.fromhex(signature), message_hash)\n        except Exception:\n            return False\n\n    def __repr__(self):\n        return f\"Account(verify_key={self.verify_key.to_string().hex()})\"\n\n\nclass Algorand(Blockchain):\n    def __init__(\n        self,\n        accounts: List[Account],\n        initial_supply: float,\n        inflation_rate: float,\n    ):\n        super().__init__()\n\n        self.accounts = accounts\n        self.total_supply = initial_supply\n        self.inflation_rate = inflation_rate\n        self.current_round = 0\n        self.base_reward = (self.total_supply * self.inflation_rate) / (\n            365 * 24 * 60\n        )  # Per minute\n\n        # Calculate thresholds after committee and proposers sizes are defined\n        self.proposer_threshold = 20 / len(accounts)\n        self.committee_threshold = self.committee_size / len(accounts)\n\n    @property\n    def total_stake(self):\n        return sum(account.stake for account in self.accounts)\n\n    @property\n    def committee_size(self):\n        return max(math.isqrt(len(self.accounts)), 100)\n\n    @property\n    def proposers_size(self):\n        return max(math.isqrt(len(self.accounts)), 10)\n\n    def select_accounts(\n        self,\n        seed: bytes,\n        threshold: float,\n        is_select_proposers: bool,\n    ) -> List[Account]:\n        weights = [account.stake for account in self.accounts]\n        total_weight = sum(weights)\n\n        # Normalize weights\n        normalized_weights = [w / total_weight for w in weights]\n\n        # Use VRF to determine eligibility\n        eligible_accounts = []\n        for account, weight in zip(self.accounts, normalized_weights):\n            signature, verify_key = account.prove(seed)\n            vrf_output = int(signature, 16)\n            if vrf_output / (2**256) < weight * threshold:\n                eligible_accounts.append(account)\n\n        # If not enough eligible accounts, add more based on stake weight\n        size = self.proposers_size if is_select_proposers else self.committee_size\n        if len(eligible_accounts) < size:\n            additional_accounts = random.choices(\n                self.accounts,\n                weights=weights,\n                k=size - len(eligible_accounts),\n            )\n            eligible_accounts.extend(additional_accounts)\n\n        # If more than needed, randomly select the required number\n        if len(eligible_accounts) > size:\n            eligible_accounts = random.sample(eligible_accounts, size)\n\n        return eligible_accounts\n\n    def propose_block(\n        self,\n        proposer: Account,\n        txns: List[Transaction],\n    ) -> Block:\n        previous_hash = self.get_last_block().hash\n        vrf_proof, verify_key = proposer.prove(previous_hash.encode())\n        return Block(txns, previous_hash, vrf_proof, verify_key)\n\n    def validate_block(\n        self, block: Block, proposer: Account, previous_block: Block\n    ) -> bool:\n        if block.previous_hash != previous_block.hash:\n            return False\n        if not proposer.verify(\n            block.previous_hash.encode(),\n            block.vrf_proof,\n            block.verify_key,\n        ):\n            return False\n\n        return True\n\n    def byzantine_agreement(\n        self,\n        proposed_blocks: List[Block],\n        committee: List[Account],\n    ) -> Block:\n        if not proposed_blocks:\n            return None\n\n        total_stake = sum(member.stake for member in committee)\n        threshold = total_stake * 2 / 3\n\n        # Step 1: Soft Vote\n        votes = {block.hash: 0 for block in proposed_blocks}\n\n        for member in committee:\n            chosen_block = max(\n                proposed_blocks,\n                key=lambda b: hash(b.hash + str(member.stake)),\n            )\n            votes[chosen_block.hash] += member.stake\n\n        winner = max(votes, key=votes.get)\n        winner_stake = 0\n\n        for member in committee:\n            propose = random.choices([True, False], weights=[0.8, 0.2], k=1)[0]\n            if propose:\n                winner_stake += member.stake\n\n        if winner_stake > threshold:\n            return next(block for block in proposed_blocks if block.hash == winner)\n\n        return None\n\n    def distribute_rewards(self, block: Block, committee: List[Account]):\n        total_reward = self.base_reward\n        proposer_reward = total_reward * 0.8  # 80% to proposer\n        committee_reward = total_reward * 0.2  # 20% split among committee\n\n        proposer = next(\n            account\n            for account in self.accounts\n            if account.verify_key == block.verify_key\n        )\n        proposer.stake += proposer_reward\n        proposer.total_rewards += proposer_reward\n\n        for member in committee:\n            reward = committee_reward / len(committee)\n            member.stake += reward\n            member.total_rewards += reward\n\n        self.total_supply += total_reward\n\n    def mine_block(self, transactions: List[Transaction]) -> Block:\n        seed = hashlib.sha256(\n            f\"{self.get_last_block().hash}{self.current_round}\".encode()\n        ).digest()\n\n        proposers = self.select_accounts(\n            seed + b\"proposer\", self.proposer_threshold, True\n        )\n        committee = self.select_accounts(\n            seed + b\"committee\", self.committee_threshold, False\n        )\n\n        proposed_blocks = []\n        for proposer in proposers:\n            block = self.propose_block(proposer, transactions)\n            if self.validate_block(block, proposer, self.get_last_block()):\n                proposed_blocks.append(block)\n\n        self.current_round += 1\n\n        winner = self.byzantine_agreement(proposed_blocks, committee)\n\n        if winner:\n            self.add_block(winner)\n            self.distribute_rewards(winner, committee)\n            return winner\n\n        return None\n\n    def simulate_51_percent_attack(self, attacker: Account):\n        print(\"Simulating 51% attack...\")\n        attacker_stake = attacker.stake\n        honest_stake = self.total_stake - attacker_stake\n\n        if attacker_stake > honest_stake:\n            print(\n                f\"Attacker has {attacker_stake / self.total_stake:.2%} of the total stake.\"\n            )\n\n            proposer_successes = 0\n            committee_controls = 0\n            rounds = 1000\n\n            for _ in range(rounds):\n                seed = hashlib.sha256(str(random.random()).encode()).digest()\n                proposers = self.select_accounts(\n                    seed + b\"proposer\",\n                    self.proposer_threshold,\n                    True,\n                )\n                committee = self.select_accounts(\n                    seed + b\"committee\",\n                    self.committee_threshold,\n                    False,\n                )\n\n                if attacker in proposers:\n                    proposer_successes += 1\n\n                attacker_committee_stake = sum(\n                    member.stake for member in committee if member == attacker\n                )\n                if (\n                    attacker_committee_stake\n                    > sum(member.stake for member in committee) * 2 / 3\n                ):\n                    committee_controls += 1\n\n            print(f\"Probability of being a proposer: {proposer_successes / rounds:.2%}\")\n            print(\n                f\"Probability of controlling committee: {committee_controls / rounds:.2%}\"\n            )\n            print(\n                \"Even with majority stake, the attacker cannot consistently control the protocol.\"\n            )\n        else:\n            print(\"Attacker doesn't have enough stake for a 51% attack.\")\n\n        return False\n\n    def simulate_nothing_at_stake(self, attacker: Account):\n        print(\"Simulating Nothing-at-Stake attack...\")\n\n        seed = hashlib.sha256(str(random.random()).encode()).digest()\n        proposers = self.select_accounts(\n            seed + b\"proposer\",\n            self.proposer_threshold,\n            True,\n        )\n        committee = self.select_accounts(\n            seed + b\"committee\",\n            self.committee_threshold,\n            False,\n        )\n\n        if attacker in proposers:\n            block1 = self.propose_block(attacker, [Transaction(\"main\", \"chain\", 1)])\n            block2 = self.propose_block(attacker, [Transaction(\"fork\", \"chain\", 1)])\n\n            winner = self.byzantine_agreement([block1, block2], committee)\n\n            print(\"In Algorand:\")\n            print(\n                \"1. Only one block can be finalized per round through Byzantine agreement.\"\n            )\n            print(\"2. Proposing multiple blocks doesn't increase chances of reward.\")\n            print(\n                f\"3. Result: {'Two blocks proposed, but only one finalized' if winner else 'No block finalized due to conflicting proposals'}\"\n            )\n        else:\n            print(\"Attacker was not selected as a proposer in this round.\")\n\n        return False\n\n    def simulate_long_range_attack(self, attacker: Account):\n        print(\"Simulating Long-Range attack...\")\n        fork_point = max(0, len(self.chain) - 100)  # Try to fork from 1000 blocks ago\n        honest_chain = self.chain[:]\n        attacker_chain = self.chain[:fork_point]\n\n        if not attacker_chain:\n            print(\"Not enough blocks in the chain to perform a long-range attack.\")\n            return False\n\n        for i in range(fork_point, len(honest_chain)):\n            seed = hashlib.sha256(f\"{attacker_chain[-1].hash}{i}\".encode()).digest()\n            proposers = self.select_accounts(\n                seed + b\"proposer\",\n                self.proposer_threshold,\n                True,\n            )\n            committee = self.select_accounts(\n                seed + b\"committee\",\n                self.committee_threshold,\n                False,\n            )\n\n            if attacker in proposers:\n                fake_block = self.propose_block(\n                    attacker, [Transaction(\"fake\", \"transaction\", 1)]\n                )\n                if self.byzantine_agreement([fake_block], committee):\n                    attacker_chain.append(fake_block)\n                else:\n                    print(f\"Failed to reach consensus on attacker's block at round {i}\")\n                    break\n            else:\n                print(f\"Attacker not selected as proposer for round {i}\")\n                break\n\n        if len(attacker_chain) > len(honest_chain):\n            print(\"In a longest-chain protocol, this attack might succeed.\")\n\n        print(\"In Algorand:\")\n        print(\n            \"1. Blocks are final after Byzantine agreement, preventing reorganization.\"\n        )\n        print(\"2. Attacker can't reconstruct historical committees or proposers.\")\n        print(\"3. State proofs provide additional security against long-range attacks.\")\n\n        return False\n\n    def simulate_sybil_attack(self, attacker: Account):\n        print(\"Simulating Sybil attack...\")\n        original_stake = attacker.stake\n        sybil_accounts = [Account(original_stake / 10) for _ in range(10)]\n\n        def measure_influence(accounts):\n            proposer_selections = 0\n            committee_selections = 0\n            rounds = 1000\n\n            for _ in range(rounds):\n                seed = hashlib.sha256(str(random.random()).encode()).digest()\n                proposers = self.select_accounts(\n                    seed + b\"proposer\",\n                    self.proposer_threshold,\n                    True,\n                )\n                committee = self.select_accounts(\n                    seed + b\"committee\",\n                    self.committee_threshold,\n                    False,\n                )\n\n                proposer_selections += sum(1 for acc in accounts if acc in proposers)\n                committee_selections += sum(1 for acc in accounts if acc in committee)\n\n            return proposer_selections / rounds, committee_selections / rounds\n\n        original_proposer_influence, original_committee_influence = measure_influence(\n            [attacker]\n        )\n        sybil_proposer_influence, sybil_committee_influence = measure_influence(\n            sybil_accounts\n        )\n\n        print(f\"Original proposer influence: {original_proposer_influence:.2%}\")\n        print(f\"Sybil proposer influence: {sybil_proposer_influence:.2%}\")\n        print(f\"Original committee influence: {original_committee_influence:.2%}\")\n        print(f\"Sybil committee influence: {sybil_committee_influence:.2%}\")\n        print(\"In Algorand:\")\n        print(\"1. Influence is directly proportional to stake, not number of accounts.\")\n        print(\n            \"2. Splitting stake across multiple accounts doesn't increase overall influence.\"\n        )\n\n        return False\n\n    def simulate_attacks(self):\n        attacker = max(self.accounts, key=lambda a: a.stake)\n        attacks = [\n            self.simulate_51_percent_attack,\n            self.simulate_nothing_at_stake,\n            self.simulate_long_range_attack,\n            self.simulate_sybil_attack,\n        ]\n        attack = random.choice(attacks)\n        attack(attacker)\n        print()\n\n    def validate_chain(self) -> bool:\n        # Start from the second block (index 1) since the genesis block has no previous hash\n        for i in range(1, len(self.chain)):\n            current_block = self.chain[i]\n            previous_block = self.chain[i - 1]\n\n            # Check if the current block's previous hash matches the hash of the previous block\n            if current_block.previous_hash != previous_block.hash:\n                print(f\"Invalid previous hash in block {i}\")\n                return False\n\n            # Validate the block's integrity\n            proposer = next(\n                (\n                    account\n                    for account in self.accounts\n                    if account.verify_key == current_block.verify_key\n                ),\n                None,\n            )\n            if not proposer:\n                print(f\"Proposer not found for block {i}\")\n                return False\n\n            if not self.validate_block(current_block, proposer, previous_block):\n                print(f\"Block {i} failed validation\")\n                return False\n\n        print(\"Blockchain is valid\")\n        return True\n\n\ndef main():\n    accounts = [Account(random.uniform(100, 10000)) for _ in range(100)]\n    algorand = Algorand(accounts, initial_supply=1000000, inflation_rate=0.05)\n\n    # Mine 100 blocks\n    for i in range(100):\n        transactions = [\n            Transaction(\n                f\"account_{i}\",\n                f\"account_{(i+1)%100}\",\n                random.uniform(1, 100),\n                random.uniform(1, 100),\n            )\n            for i in range(5)\n        ]\n        block = algorand.mine_block(transactions)\n        # print(block)\n        # if i % 10 == 0:\n        #     algorand.simulate_attacks()\n\n    algorand.validate_chain()\n    print(algorand)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"instruction": "Implement an Algorand Smart Contract that allows updating global state. The contract should handle two scenarios: contract creation and data updates. On creation, the contract should succeed. For data updates, the contract should accept two arguments: a key and a value. It should then store this key-value pair in the global state. Both creation and data updates should return a success indicator (integer 1).", "output": "from pyteal import *\n\ndef approval_program():\n    covid_key = Bytes(\"covid_data\")\n\n    on_create = Return(Int(1))\n\n    on_update_data = Seq([\n        Assert(Txn.application_args.length() == Int(2)),\n        App.globalPut(Txn.application_args[0], Txn.application_args[1]),\n        Return(Int(1))\n    ])\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, on_update_data]\n    )\n\n    return program\n\ndef clear_state_program():\n    return Return(Int(1))"}
{"instruction": "Extract URLs, email addresses, and cryptocurrency addresses from text; remove HTML tags; and extract and normalize URL components such as apex domain, domain, top-level domain (TLD), path, and extension.", "output": "# deprecated\n\nimport re\nimport numpy as np\nimport pandas as pd\n\n# use only:\n# get_links\n# clear_html\n# get_emails\n# get_addresses \n# get_url_info\n# get_url_df_info\n\ntlds = [\"aaa\", \"aarp\", \"abarth\", \"abb\", \"abbott\", \"abbvie\", \"abc\", \"able\", \"abogado\", \"abudhabi\", \"ac\", \"academy\", \"accenture\", \"accountant\", \"accountants\", \"aco\", \"actor\", \"ad\", \"ads\", \"adult\", \"ae\", \"aeg\", \"aero\", \"aetna\", \"af\", \"afl\", \"africa\", \"ag\", \"agakhan\", \"agency\", \"ai\", \"aig\", \"airbus\", \"airforce\", \"airtel\", \"akdn\", \"al\", \"alfaromeo\", \"alibaba\", \"alipay\", \"allfinanz\", \"allstate\", \"ally\", \"alsace\", \"alstom\", \"am\", \"amazon\", \"americanexpress\", \"americanfamily\", \"amex\", \"amfam\", \"amica\", \"amsterdam\", \"analytics\", \"android\", \"anquan\", \"anz\", \"ao\", \"aol\", \"apartments\", \"app\", \"apple\", \"aq\", \"aquarelle\", \"ar\", \"arab\", \"aramco\", \"archi\", \"army\", \"arpa\", \"art\", \"arte\", \"as\", \"asda\", \"asia\", \"associates\", \"at\", \"athleta\", \"attorney\", \"au\", \"auction\", \"audi\", \"audible\", \"audio\", \"auspost\", \"author\", \"auto\", \"autos\", \"avianca\", \"aw\", \"aws\", \"ax\", \"axa\", \"az\", \"azure\", \"ba\", \"baby\", \"baidu\", \"banamex\", \"bananarepublic\", \"band\", \"bank\", \"bar\", \"barcelona\", \"barclaycard\", \"barclays\", \"barefoot\", \"bargains\", \"baseball\", \"basketball\", \"bauhaus\", \"bayern\", \"bb\", \"bbc\", \"bbt\", \"bbva\", \"bcg\", \"bcn\", \"bd\", \"be\", \"beats\", \"beauty\", \"beer\", \"bentley\", \"berlin\", \"best\", \"bestbuy\", \"bet\", \"bf\", \"bg\", \"bh\", \"bharti\", \"bi\", \"bible\", \"bid\", \"bike\", \"bing\", \"bingo\", \"bio\", \"biz\", \"bj\", \"black\", \"blackfriday\", \"blockbuster\", \"blog\", \"bloomberg\", \"blue\", \"bm\", \"bms\", \"bmw\", \"bn\", \"bnpparibas\", \"bo\", \"boats\", \"boehringer\", \"bofa\", \"bom\", \"bond\", \"boo\", \"book\", \"booking\", \"bosch\", \"bostik\", \"boston\", \"bot\", \"boutique\", \"box\", \"br\", \"bradesco\", \"bridgestone\", \"broadway\", \"broker\", \"brother\", \"brussels\", \"bs\", \"bt\", \"build\", \"builders\", \"business\", \"buy\", \"buzz\", \"bv\", \"bw\", \"by\", \"bz\", \"bzh\", \"ca\", \"cab\", \"cafe\", \"cal\", \"call\", \"calvinklein\", \"cam\", \"camera\", \"camp\", \"canon\", \"capetown\", \"capital\", \"capitalone\", \"car\", \"caravan\", \"cards\", \"care\", \"career\", \"careers\", \"cars\", \"casa\", \"case\", \"cash\", \"casino\", \"cat\", \"catering\", \"catholic\", \"cba\", \"cbn\", \"cbre\", \"cbs\", \"cc\", \"cd\", \"center\", \"ceo\", \"cern\", \"cf\", \"cfa\", \"cfd\", \"cg\", \"ch\", \"chanel\", \"channel\", \"charity\", \"chase\", \"chat\", \"cheap\", \"chintai\", \"christmas\", \"chrome\", \"church\", \"ci\", \"cipriani\", \"circle\", \"cisco\", \"citadel\", \"citi\", \"citic\", \"city\", \"cityeats\", \"ck\", \"cl\", \"claims\", \"cleaning\", \"click\", \"clinic\", \"clinique\", \"clothing\", \"cloud\", \"club\", \"clubmed\", \"cm\", \"cn\", \"co\", \"coach\", \"codes\", \"coffee\", \"college\", \"cologne\", \"com\", \"comcast\", \"commbank\", \"community\", \"company\", \"compare\", \"computer\", \"comsec\", \"condos\", \"construction\", \"consulting\", \"contact\", \"contractors\", \"cooking\", \"cookingchannel\", \"cool\", \"coop\", \"corsica\", \"country\", \"coupon\", \"coupons\", \"courses\", \"cpa\", \"cr\", \"credit\", \"creditcard\", \"creditunion\", \"cricket\", \"crown\", \"crs\", \"cruise\", \"cruises\", \"cu\", \"cuisinella\", \"cv\", \"cw\", \"cx\", \"cy\", \"cymru\", \"cyou\", \"cz\", \"dabur\", \"dad\", \"dance\", \"data\", \"date\", \"dating\", \"datsun\", \"day\", \"dclk\", \"dds\", \"de\", \"deal\", \"dealer\", \"deals\", \"degree\", \"delivery\", \"dell\", \"deloitte\", \"delta\", \"democrat\", \"dental\", \"dentist\", \"desi\", \"design\", \"dev\", \"dhl\", \"diamonds\", \"diet\", \"digital\", \"direct\", \"directory\", \"discount\", \"discover\", \"dish\", \"diy\", \"dj\", \"dk\", \"dm\", \"dnp\", \"do\", \"docs\", \"doctor\", \"dog\", \"domains\", \"dot\", \"download\", \"drive\", \"dtv\", \"dubai\", \"dunlop\", \"dupont\", \"durban\", \"dvag\", \"dvr\", \"dz\", \"earth\", \"eat\", \"ec\", \"eco\", \"edeka\", \"edu\", \"education\", \"ee\", \"eg\", \"email\", \"emerck\", \"energy\", \"engineer\", \"engineering\", \"enterprises\", \"epson\", \"equipment\", \"er\", \"ericsson\", \"erni\", \"es\", \"esq\", \"estate\", \"et\", \"etisalat\", \"eu\", \"eurovision\", \"eus\", \"events\", \"exchange\", \"expert\", \"exposed\", \"express\", \"extraspace\", \"fage\", \"fail\", \"fairwinds\", \"faith\", \"family\", \"fan\", \"fans\", \"farm\", \"farmers\", \"fashion\", \"fast\", \"fedex\", \"feedback\", \"ferrari\", \"ferrero\", \"fi\", \"fiat\", \"fidelity\", \"fido\", \"film\", \"final\", \"finance\", \"financial\", \"fire\", \"firestone\", \"firmdale\", \"fish\", \"fishing\", \"fit\", \"fitness\", \"fj\", \"fk\", \"flickr\", \"flights\", \"flir\", \"florist\", \"flowers\", \"fly\", \"fm\", \"fo\", \"foo\", \"food\", \"foodnetwork\", \"football\", \"ford\", \"forex\", \"forsale\", \"forum\", \"foundation\", \"fox\", \"fr\", \"free\", \"fresenius\", \"frl\", \"frogans\", \"frontdoor\", \"frontier\", \"ftr\", \"fujitsu\", \"fun\", \"fund\", \"furniture\", \"futbol\", \"fyi\", \"ga\", \"gal\", \"gallery\", \"gallo\", \"gallup\", \"game\", \"games\", \"gap\", \"garden\", \"gay\", \"gb\", \"gbiz\", \"gd\", \"gdn\", \"ge\", \"gea\", \"gent\", \"genting\", \"george\", \"gf\", \"gg\", \"ggee\", \"gh\", \"gi\", \"gift\", \"gifts\", \"gives\", \"giving\", \"gl\", \"glass\", \"gle\", \"global\", \"globo\", \"gm\", \"gmail\", \"gmbh\", \"gmo\", \"gmx\", \"gn\", \"godaddy\", \"gold\", \"goldpoint\", \"golf\", \"goo\", \"goodyear\", \"goog\", \"google\", \"gop\", \"got\", \"gov\", \"gp\", \"gq\", \"gr\", \"grainger\", \"graphics\", \"gratis\", \"green\", \"gripe\", \"grocery\", \"group\", \"gs\", \"gt\", \"gu\", \"guardian\", \"gucci\", \"guge\", \"guide\", \"guitars\", \"guru\", \"gw\", \"gy\", \"hair\", \"hamburg\", \"hangout\", \"haus\", \"hbo\", \"hdfc\", \"hdfcbank\", \"health\", \"healthcare\", \"help\", \"helsinki\", \"here\", \"hermes\", \"hgtv\", \"hiphop\", \"hisamitsu\", \"hitachi\", \"hiv\", \"hk\", \"hkt\", \"hm\", \"hn\", \"hockey\", \"holdings\", \"holiday\", \"homedepot\", \"homegoods\", \"homes\", \"homesense\", \"honda\", \"horse\", \"hospital\", \"host\", \"hosting\", \"hot\", \"hoteles\", \"hotels\", \"hotmail\", \"house\", \"how\", \"hr\", \"hsbc\", \"ht\", \"hu\", \"hughes\", \"hyatt\", \"hyundai\", \"ibm\", \"icbc\", \"ice\", \"icu\", \"id\", \"ie\", \"ieee\", \"ifm\", \"ikano\", \"il\", \"im\", \"imamat\", \"imdb\", \"immo\", \"immobilien\", \"in\", \"inc\", \"industries\", \"infiniti\", \"info\", \"ing\", \"ink\", \"institute\", \"insurance\", \"insure\", \"int\", \"international\", \"intuit\", \"investments\", \"io\", \"ipiranga\", \"iq\", \"ir\", \"irish\", \"is\", \"ismaili\", \"ist\", \"istanbul\", \"it\", \"itau\", \"itv\", \"jaguar\", \"java\", \"jcb\", \"je\", \"jeep\", \"jetzt\", \"jewelry\", \"jio\", \"jll\", \"jm\", \"jmp\", \"jnj\", \"jo\", \"jobs\", \"joburg\", \"jot\", \"joy\", \"jp\", \"jpmorgan\", \"jprs\", \"juegos\", \"juniper\", \"kaufen\", \"kddi\", \"ke\", \"kerryhotels\", \"kerrylogistics\", \"kerryproperties\", \"kfh\", \"kg\", \"kh\", \"ki\", \"kia\", \"kids\", \"kim\", \"kinder\", \"kindle\", \"kitchen\", \"kiwi\", \"km\", \"kn\", \"koeln\", \"komatsu\", \"kosher\", \"kp\", \"kpmg\", \"kpn\", \"kr\", \"krd\", \"kred\", \"kuokgroup\", \"kw\", \"ky\", \"kyoto\", \"kz\", \"la\", \"lacaixa\", \"lamborghini\", \"lamer\", \"lancaster\", \"lancia\", \"land\", \"landrover\", \"lanxess\", \"lasalle\", \"lat\", \"latino\", \"latrobe\", \"law\", \"lawyer\", \"lb\", \"lc\", \"lds\", \"lease\", \"leclerc\", \"lefrak\", \"legal\", \"lego\", \"lexus\", \"lgbt\", \"li\", \"lidl\", \"life\", \"lifeinsurance\", \"lifestyle\", \"lighting\", \"like\", \"lilly\", \"limited\", \"limo\", \"lincoln\", \"link\", \"lipsy\", \"live\", \"living\", \"lk\", \"llc\", \"llp\", \"loan\", \"loans\", \"locker\", \"locus\", \"lol\", \"london\", \"lotte\", \"lotto\", \"love\", \"lpl\", \"lplfinancial\", \"lr\", \"ls\", \"lt\", \"ltd\", \"ltda\", \"lu\", \"lundbeck\", \"luxe\", \"luxury\", \"lv\", \"ly\", \"ma\", \"madrid\", \"maif\", \"maison\", \"makeup\", \"man\", \"management\", \"mango\", \"map\", \"market\", \"marketing\", \"markets\", \"marriott\", \"marshalls\", \"maserati\", \"mattel\", \"mba\", \"mc\", \"mckinsey\", \"md\", \"me\", \"med\", \"media\", \"meet\", \"melbourne\", \"meme\", \"memorial\", \"men\", \"menu\", \"merckmsd\", \"mg\", \"mh\", \"miami\", \"microsoft\", \"mil\", \"mini\", \"mint\", \"mit\", \"mitsubishi\", \"mk\", \"ml\", \"mlb\", \"mls\", \"mm\", \"mma\", \"mn\", \"mo\", \"mobi\", \"mobile\", \"moda\", \"moe\", \"moi\", \"mom\", \"monash\", \"money\", \"monster\", \"mormon\", \"mortgage\", \"moscow\", \"moto\", \"motorcycles\", \"mov\", \"movie\", \"mp\", \"mq\", \"mr\", \"ms\", \"msd\", \"mt\", \"mtn\", \"mtr\", \"mu\", \"museum\", \"music\", \"mutual\", \"mv\", \"mw\", \"mx\", \"my\", \"mz\", \"nan\", \"nab\", \"nagoya\", \"name\", \"natura\", \"navy\", \"nba\", \"nc\", \"ne\", \"nec\", \"net\", \"netbank\", \"netflix\", \"network\", \"neustar\", \"new\", \"news\", \"next\", \"nextdirect\", \"nexus\", \"nf\", \"nfl\", \"ng\", \"ngo\", \"nhk\", \"ni\", \"nico\", \"nike\", \"nikon\", \"ninja\", \"nissan\", \"nissay\", \"nl\", \"no\", \"nokia\", \"northwesternmutual\", \"norton\", \"now\", \"nowruz\", \"nowtv\", \"np\", \"nr\", \"nra\", \"nrw\", \"ntt\", \"nu\", \"nyc\", \"nz\", \"obi\", \"observer\", \"office\", \"okinawa\", \"olayan\", \"olayangroup\", \"oldnavy\", \"ollo\", \"om\", \"omega\", \"one\", \"ong\", \"onl\", \"online\", \"ooo\", \"open\", \"oracle\", \"orange\", \"org\", \"organic\", \"origins\", \"osaka\", \"otsuka\", \"ott\", \"ovh\", \"pa\", \"page\", \"panasonic\", \"paris\", \"pars\", \"partners\", \"parts\", \"party\", \"passagens\", \"pay\", \"pccw\", \"pe\", \"pet\", \"pf\", \"pfizer\", \"pg\", \"ph\", \"pharmacy\", \"phd\", \"philips\", \"phone\", \"photo\", \"photography\", \"photos\", \"physio\", \"pics\", \"pictet\", \"pictures\", \"pid\", \"pin\", \"ping\", \"pink\", \"pioneer\", \"pizza\", \"pk\", \"pl\", \"place\", \"play\", \"playstation\", \"plumbing\", \"plus\", \"pm\", \"pn\", \"pnc\", \"pohl\", \"poker\", \"politie\", \"porn\", \"post\", \"pr\", \"pramerica\", \"praxi\", \"press\", \"prime\", \"pro\", \"prod\", \"productions\", \"prof\", \"progressive\", \"promo\", \"properties\", \"property\", \"protection\", \"pru\", \"prudential\", \"ps\", \"pt\", \"pub\", \"pw\", \"pwc\", \"py\", \"qa\", \"qpon\", \"quebec\", \"quest\", \"racing\", \"radio\", \"re\", \"read\", \"realestate\", \"realtor\", \"realty\", \"recipes\", \"red\", \"redstone\", \"redumbrella\", \"rehab\", \"reise\", \"reisen\", \"reit\", \"reliance\", \"ren\", \"rent\", \"rentals\", \"repair\", \"report\", \"republican\", \"rest\", \"restaurant\", \"review\", \"reviews\", \"rexroth\", \"rich\", \"richardli\", \"ricoh\", \"ril\", \"rio\", \"rip\", \"ro\", \"rocher\", \"rocks\", \"rodeo\", \"rogers\", \"room\", \"rs\", \"rsvp\", \"ru\", \"rugby\", \"ruhr\", \"run\", \"rw\", \"rwe\", \"ryukyu\", \"sa\", \"saarland\", \"safe\", \"safety\", \"sakura\", \"sale\", \"salon\", \"samsclub\", \"samsung\", \"sandvik\", \"sandvikcoromant\", \"sanofi\", \"sap\", \"sarl\", \"sas\", \"save\", \"saxo\", \"sb\", \"sbi\", \"sbs\", \"sc\", \"sca\", \"scb\", \"schaeffler\", \"schmidt\", \"scholarships\", \"school\", \"schule\", \"schwarz\", \"science\", \"scot\", \"sd\", \"se\", \"search\", \"seat\", \"secure\", \"security\", \"seek\", \"select\", \"sener\", \"services\", \"seven\", \"sew\", \"sex\", \"sexy\", \"sfr\", \"sg\", \"sh\", \"shangrila\", \"sharp\", \"shaw\", \"shell\", \"shia\", \"shiksha\", \"shoes\", \"shop\", \"shopping\", \"shouji\", \"show\", \"showtime\", \"si\", \"silk\", \"sina\", \"singles\", \"site\", \"sj\", \"sk\", \"ski\", \"skin\", \"sky\", \"skype\", \"sl\", \"sling\", \"sm\", \"smart\", \"smile\", \"sn\", \"sncf\", \"so\", \"soccer\", \"social\", \"softbank\", \"software\", \"sohu\", \"solar\", \"solutions\", \"song\", \"sony\", \"soy\", \"spa\", \"space\", \"sport\", \"spot\", \"sr\", \"srl\", \"ss\", \"st\", \"stada\", \"staples\", \"star\", \"statebank\", \"statefarm\", \"stc\", \"stcgroup\", \"stockholm\", \"storage\", \"store\", \"stream\", \"studio\", \"study\", \"style\", \"su\", \"sucks\", \"supplies\", \"supply\", \"support\", \"surf\", \"surgery\", \"suzuki\", \"sv\", \"swatch\", \"swiss\", \"sx\", \"sy\", \"sydney\", \"systems\", \"sz\", \"tab\", \"taipei\", \"talk\", \"taobao\", \"target\", \"tatamotors\", \"tatar\", \"tattoo\", \"tax\", \"taxi\", \"tc\", \"tci\", \"td\", \"tdk\", \"team\", \"tech\", \"technology\", \"tel\", \"temasek\", \"tennis\", \"teva\", \"tf\", \"tg\", \"th\", \"thd\", \"theater\", \"theatre\", \"tiaa\", \"tickets\", \"tienda\", \"tiffany\", \"tips\", \"tires\", \"tirol\", \"tj\", \"tjmaxx\", \"tjx\", \"tk\", \"tkmaxx\", \"tl\", \"tm\", \"tmall\", \"tn\", \"to\", \"today\", \"tokyo\", \"tools\", \"top\", \"toray\", \"toshiba\", \"total\", \"tours\", \"town\", \"toyota\", \"toys\", \"tr\", \"trade\", \"trading\", \"training\", \"travel\", \"travelchannel\", \"travelers\", \"travelersinsurance\", \"trust\", \"trv\", \"tt\", \"tube\", \"tui\", \"tunes\", \"tushu\", \"tv\", \"tvs\", \"tw\", \"tz\", \"ua\", \"ubank\", \"ubs\", \"ug\", \"uk\", \"unicom\", \"university\", \"uno\", \"uol\", \"ups\", \"us\", \"uy\", \"uz\", \"va\", \"vacations\", \"vana\", \"vanguard\", \"vc\", \"ve\", \"vegas\", \"ventures\", \"verisign\", \"versicherung\", \"vet\", \"vg\", \"vi\", \"viajes\", \"video\", \"vig\", \"viking\", \"villas\", \"vin\", \"vip\", \"virgin\", \"visa\", \"vision\", \"viva\", \"vivo\", \"vlaanderen\", \"vn\", \"vodka\", \"volkswagen\", \"volvo\", \"vote\", \"voting\", \"voto\", \"voyage\", \"vu\", \"vuelos\", \"wales\", \"walmart\", \"walter\", \"wang\", \"wanggou\", \"watch\", \"watches\", \"weather\", \"weatherchannel\", \"webcam\", \"weber\", \"website\", \"wed\", \"wedding\", \"weibo\", \"weir\", \"wf\", \"whoswho\", \"wien\", \"wiki\", \"williamhill\", \"win\", \"windows\", \"wine\", \"winners\", \"wme\", \"wolterskluwer\", \"woodside\", \"work\", \"works\", \"world\", \"wow\", \"ws\", \"wtc\", \"wtf\", \"xbox\", \"xerox\", \"xfinity\", \"xihuan\", \"xin\", \"xn--11b4c3d\", \"xn--1ck2e1b\", \"xn--1qqw23a\", \"xn--2scrj9c\", \"xn--30rr7y\", \"xn--3bst00m\", \"xn--3ds443g\", \"xn--3e0b707e\", \"xn--3hcrj9c\", \"xn--3pxu8k\", \"xn--42c2d9a\", \"xn--45br5cyl\", \"xn--45brj9c\", \"xn--45q11c\", \"xn--4dbrk0ce\", \"xn--4gbrim\", \"xn--54b7fta0cc\", \"xn--55qw42g\", \"xn--55qx5d\", \"xn--5su34j936bgsg\", \"xn--5tzm5g\", \"xn--6frz82g\", \"xn--6qq986b3xl\", \"xn--80adxhks\", \"xn--80ao21a\", \"xn--80aqecdr1a\", \"xn--80asehdb\", \"xn--80aswg\", \"xn--8y0a063a\", \"xn--90a3ac\", \"xn--90ae\", \"xn--90ais\", \"xn--9dbq2a\", \"xn--9et52u\", \"xn--9krt00a\", \"xn--b4w605ferd\", \"xn--bck1b9a5dre4c\", \"xn--c1avg\", \"xn--c2br7g\", \"xn--cck2b3b\", \"xn--cckwcxetd\", \"xn--cg4bki\", \"xn--clchc0ea0b2g2a9gcd\", \"xn--czr694b\", \"xn--czrs0t\", \"xn--czru2d\", \"xn--d1acj3b\", \"xn--d1alf\", \"xn--e1a4c\", \"xn--eckvdtc9d\", \"xn--efvy88h\", \"xn--fct429k\", \"xn--fhbei\", \"xn--fiq228c5hs\", \"xn--fiq64b\", \"xn--fiqs8s\", \"xn--fiqz9s\", \"xn--fjq720a\", \"xn--flw351e\", \"xn--fpcrj9c3d\", \"xn--fzc2c9e2c\", \"xn--fzys8d69uvgm\", \"xn--g2xx48c\", \"xn--gckr3f0f\", \"xn--gecrj9c\", \"xn--gk3at1e\", \"xn--h2breg3eve\", \"xn--h2brj9c\", \"xn--h2brj9c8c\", \"xn--hxt814e\", \"xn--i1b6b1a6a2e\", \"xn--imr513n\", \"xn--io0a7i\", \"xn--j1aef\", \"xn--j1amh\", \"xn--j6w193g\", \"xn--jlq480n2rg\", \"xn--jvr189m\", \"xn--kcrx77d1x4a\", \"xn--kprw13d\", \"xn--kpry57d\", \"xn--kput3i\", \"xn--l1acc\", \"xn--lgbbat1ad8j\", \"xn--mgb9awbf\", \"xn--mgba3a3ejt\", \"xn--mgba3a4f16a\", \"xn--mgba7c0bbn0a\", \"xn--mgbaakc7dvf\", \"xn--mgbaam7a8h\", \"xn--mgbab2bd\", \"xn--mgbah1a3hjkrd\", \"xn--mgbai9azgqp6j\", \"xn--mgbayh7gpa\", \"xn--mgbbh1a\", \"xn--mgbbh1a71e\", \"xn--mgbc0a9azcg\", \"xn--mgbca7dzdo\", \"xn--mgbcpq6gpa1a\", \"xn--mgberp4a5d4ar\", \"xn--mgbgu82a\", \"xn--mgbi4ecexp\", \"xn--mgbpl2fh\", \"xn--mgbt3dhd\", \"xn--mgbtx2b\", \"xn--mgbx4cd0ab\", \"xn--mix891f\", \"xn--mk1bu44c\", \"xn--mxtq1m\", \"xn--ngbc5azd\", \"xn--ngbe9e0a\", \"xn--ngbrx\", \"xn--node\", \"xn--nqv7f\", \"xn--nqv7fs00ema\", \"xn--nyqy26a\", \"xn--o3cw4h\", \"xn--ogbpf8fl\", \"xn--otu796d\", \"xn--p1acf\", \"xn--p1ai\", \"xn--pgbs0dh\", \"xn--pssy2u\", \"xn--q7ce6a\", \"xn--q9jyb4c\", \"xn--qcka1pmc\", \"xn--qxa6a\", \"xn--qxam\", \"xn--rhqv96g\", \"xn--rovu88b\", \"xn--rvc1e0am3e\", \"xn--s9brj9c\", \"xn--ses554g\", \"xn--t60b56a\", \"xn--tckwe\", \"xn--tiq49xqyj\", \"xn--unup4y\", \"xn--vermgensberater-ctb\", \"xn--vermgensberatung-pwb\", \"xn--vhquv\", \"xn--vuq861b\", \"xn--w4r85el8fhu5dnra\", \"xn--w4rs40l\", \"xn--wgbh1c\", \"xn--wgbl6a\", \"xn--xhq521b\", \"xn--xkc2al3hye2a\", \"xn--xkc2dl3a5ee0h\", \"xn--y9a3aq\", \"xn--yfro4i67o\", \"xn--ygbi2ammx\", \"xn--zfr164b\", \"xxx\", \"xyz\", \"yachts\", \"yahoo\", \"yamaxun\", \"yandex\", \"ye\", \"yodobashi\", \"yoga\", \"yokohama\", \"you\", \"youtube\", \"yt\", \"yun\", \"za\", \"zappos\", \"zara\", \"zero\", \"zip\", \"zm\", \"zone\", \"zuerich\", \"zw\", \"onion\"]\n\ndef remove_hastag(url):\n    # Remove 'https://' or 'http://'\n    head = ''\n    if url.startswith('https://'):\n        head = 'https://'\n        url = url[8:]\n    elif url.startswith('http://'):\n        head = 'http://'\n        url = url[7:]\n    index = url.rfind('/')\n    if index != -1:\n        index2 = url.rfind('#')\n        if index2 > index:\n            url = url[:index2]\n    return head + url\n\ndef get_extension(url, extensions):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    index = url.rfind('/')\n    extension = ''\n    if index != -1:\n        index2 = url.rfind('.')\n        if index2 > index:\n            extension = url[index2+1:].lower()\n            for ext in extensions:\n                if extension.startswith(ext):\n                    return ext\n    return np.nan\n\ndef remove_not_isalnum(url):\n    while len(url) > 0 and not url[-1].isalnum():\n        url = url[:-1]\n    while len(url) > 0 and not url[0].isalnum():\n        url = url[1:]\n    return url\ndef is_tld(url):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    index = url.find('/')\n    if index != -1:\n        url = url[:index]\n    if '@' in url:\n        return False\n    index = url.rfind('.')\n    if index != -1:\n        url = url[index+1:]\n        if url.lower() in tlds:\n            return True\n    return False\ndef remove_head(url):\n    # Remove 'https://' or 'http://'\n    if url.startswith('https://'):\n        url = url[8:]\n    elif url.startswith('http://'):\n        url = url[7:]\n    # remove 'www.'\n    if url.startswith('www.'):\n        url = url[4:]\n    return url\n\ndef is_still_valid(url):\n    # se  vuoto ritorna False\n    if url == '':\n        return False\n    # se non ha un punto ritorna False\n    if '.' not in url:\n        return False\n    # se ha due punti consecutivi ritorna False\n    if '..' in url:\n        return False\n    return True\n\ndef get_links(text):\n    # text = 'You can view more details at https://uibakery.io, or just ping via email. You can view more details at uibakery.io or just ping via email.'\n    urls = []\n    # Extract URL from a string\n    url_extract_pattern = \"https?:\\\\/\\\\/(?:www\\\\.)?[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)\"\n    urls += re.findall(url_extract_pattern, text)\n    for url in urls:\n        text = text.replace(url, ' ')\n    url_extract_pattern = \"[-a-zA-Z0-9@:%._\\\\+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,6}\\\\b(?:[-a-zA-Z0-9()@:%_\\\\+.~#?&\\\\/=]*)\"\n    urls += re.findall(url_extract_pattern, text)\n    urls_cleaned = []\n    for url in urls:\n        if is_tld(url):\n            url = remove_not_isalnum(url)\n            if is_still_valid(url):\n                urls_cleaned.append(url)\n    return urls_cleaned\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef clear_html(html_string):\n    def clear_tag(html_string, tag):\n        if html_string.find(f'<{tag}') == -1 or html_string.find(f'</{tag}>') == -1:\n            return html_string\n        start = html_string.find(f'<{tag}')\n        end = start + html_string[start:].find(f'</{tag}>') + len(tag)+3\n        html_string = html_string[:start] + ' ' + html_string[end:]\n        return html_string\n    tags = ['iframe', 'template', 'script', 'style']\n    for tag in tags:\n        while True:\n            new_html_string = clear_tag(html_string, tag)\n            if new_html_string == html_string:\n                break\n            html_string = new_html_string\n    html_string = re.sub(r'<[^>]*?>', ' ', html_string)\n    html_string = re.sub(r'\\s+', ' ', html_string)\n    html_string = html_string.strip()\n    return html_string\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nblockchains = [\n        'bitcoin',\n        'ethereum',\n        'litecoin',\n        'dogecoin',\n        'monero',\n        'dash',\n        'cardano',\n        'cosmos',\n        'iota',\n        'lisk',\n        'polkadot',\n        'ripple',\n        'stellar',\n        'neo',\n        'bitcoin-cash',\n        'ethereum-classic',\n        'binance-smart-chain',\n        'binance-beacon-chain',\n        'solana',\n        'tron',\n        'algorand',\n        'vechain'\n    ]\n\ndef bitcoin(address):\n    def taproot(address):\n        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,89}))$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def segwit(address):\n        schema = '^((bc)(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,87}))$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def script(address):\n        schema = '^[3][a-km-zA-HJ-NP-Z1-9]{25,34}$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    def legacy(address):\n        schema = '^[1][a-km-zA-HJ-NP-Z1-9]{25,34}$'\n        if re.match(schema, address) is None:\n            return False\n        return True\n    if taproot(address):\n        return True\n    if segwit(address):\n        return True\n    if script(address):\n        return True\n    if legacy(address):\n        return True\n    return False\n\ndef ethereum(address):\n    schema = '^((0x)([0-9a-fA-F]{40}))$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef litecoin(address):\n    schema = '^([LM3]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}||ltc1[a-z0-9]{39,59})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef dogecoin(address):\n    schema = '^D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}'\n    schema2 = 'D[a-zA-Z0-9_.-]{33}'\n    if re.match(schema, address) is None and re.match(schema2, address) is None:\n        return False\n    return True\n\ndef monero(address):\n    schema = '[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef dash(address):\n    schema = 'X[1-9A-HJ-NP-Za-km-z]{33}'\n    if re.match(schema, address) is None:\n        return False\n    return True  \n\ndef cardano(address):\n    schema = 'addr1[a-z0-9]+'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef cosmos(address):\n    schema = 'cosmos[a-zA-Z0-9_.-]{10,}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef iota(address):\n    schema = 'iota[a-z0-9]{10,}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef lisk(address):\n    schema = '[0-9]{19}L'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef nem(address):\n    schema = '[N][A-Za-z0-9-]{37,52}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef neo(address):\n    schema = 'A[0-9a-zA-Z]{33}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef polkadot(address):\n    schema = '1[0-9a-zA-Z]{47}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef ripple(address):\n    schema = '^([r])([1-9A-HJ-NP-Za-km-z]{24,34})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef stellar(address):\n    schema = 'G[0-9A-Z]{40,60}'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef ethereum_classic(address):\n    return ethereum(address)\n\ndef binance_smart_chain(address):\n    return ethereum(address)\n\ndef binance_beacon_chain(address):\n    schema = '^((bnb1)[0-9a-z]{38})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef bitcoin_cash(address):\n    legacy = '[13][a-km-zA-HJ-NP-Z1-9]{33}'\n    cashaddr = '((bitcoincash):)?(q|p)[a-z0-9]{41}'\n    if re.match(legacy, address) is None and re.match(cashaddr, address) is None:\n        return False\n    return True\n\ndef solana(address):\n    schema = '^[1-9A-HJ-NP-Za-km-z]{32,44}$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef tron(address):\n    schema = '^((T)[a-zA-Z0-9]{33})$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef algorand(address):\n    schema = '^[A-Z2-7]{58}$'\n    if re.match(schema, address) is None:\n        return False\n    return True\n\ndef vechain(address):\n    return ethereum(address)\n\ndef get_addresses(text):\n    foo = {\n        'bitcoin': bitcoin,\n        'ethereum': ethereum,\n        'litecoin': litecoin,\n        'dogecoin': dogecoin,\n        'monero': monero,\n        'dash': dash,\n        'cardano': cardano,\n        'cosmos': cosmos,\n        'iota': iota,\n        'lisk': lisk,\n        'polkadot': polkadot,\n        'ripple': ripple,\n        'stellar': stellar,\n        'neo': neo,\n        'bitcoin-cash': bitcoin_cash,\n        'ethereum-classic': ethereum_classic,\n        'binance-smart-chain': binance_smart_chain,\n        'binance-beacon-chain': binance_beacon_chain,\n        'solana': solana,\n        'tron': tron,\n        'algorand': algorand,\n        'vechain': vechain,\n    }\n    crypto = {key : [] for key in foo.keys()}\n    text = re.sub(r'\\W', ' ', text)\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    for address in text.split():\n        for key in foo.keys():\n            if foo[key](address):\n                crypto[key].append(address)\n    for key in crypto.keys():\n        crypto[key] = list(set(crypto[key]))\n    for key in crypto.copy():\n        if crypto[key] == []:\n            del crypto[key]\n    return crypto\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef email(address):\n    # remove all no alphanumeric char from the beginning and the end\n    address = re.sub(r'^[^a-zA-Z0-9]*', '', address)\n    address = re.sub(r'[^a-zA-Z0-9]*$', '', address)\n    schema = \"^[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*@(?:[A-Z0-9-]+\\.)+[A-Z]{2,6}$\"\n    if re.match(schema, address.upper()) is None:\n        return None\n    return address\n\ndef get_emails(text):\n    emails = []\n    text = re.sub(r'\\s+', ' ', text)\n    text = text.strip()\n    for string in text.split():\n        address = email(string)\n        if address is not None:\n            emails.append(address)\n    return emails\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef foo1(x):\n    if x.startswith('http://www.'):\n        return x[11:]\n    if x.startswith('https://www.'):\n        return x[12:]\n    if x.startswith('http://'):\n        return x[7:]\n    if x.startswith('https://'):\n        return x[8:]\n    return x\n\ndef foo2(x):\n    return x.split('/')[0].lower()\n\ndef foo3(x):\n    return x.split('.')[-1].lower()\n\ndef foo4(x):\n    return '.'.join(x.split('.')[:-1]).lower()\n\ndef foo5(x):\n    x = x.split('/')\n    if len(x) > 1:\n        y = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]\n        x = '/'.join(x[1:-1])+'/'+y\n        return x.strip('/')\n    return np.nan\n\ndef foo6(x):\n    x = x.split('/')\n    if len(x) > 1:\n        x = x[-1].split('?')[0].split('#')[0].split('&')[0].split(')')[0].split('(')[0].split(']')[0].split('[')[0].split('}')[0].split('{')[0]\n        x = x.split('.')\n        if len(x) > 1:\n            return x[-1].lower()\n    return np.nan\n\ndef get_url_info(url):\n    url_df = pd.DataFrame({'url': [url]})\n    url_df = get_url_df_info(url_df)\n    info = {\n        'apex': url_df['apex'][0],\n        'domain': url_df['domain'][0],\n        'tld': url_df['tld'][0],\n        'path': url_df['path'][0],\n        'extention': url_df['extention'][0],\n        'normalized_url': url_df['normalized_url'][0],\n        'normalized_url_lower': url_df['normalized_url_lower'][0],\n    }\n    return info \n\ndef get_url_df_info(df):\n    df['apex'] = df['url'].apply(lambda x: foo2(foo1(x)))\n    df['domain'] = df['url'].apply(lambda x: foo4(foo2(foo1(x))))\n    df['tld'] = df['url'].apply(lambda x: foo3(foo2(foo1(x))))\n    df['path'] = df['url'].apply(lambda x: foo5(foo1(x)))\n    df['extention'] = df['url'].apply(lambda x: foo6(foo1(x)))\n    df['normalized_url'] = df['apex'] + '/' + df['path']\n    df['normalized_url'] = df['normalized_url'].fillna(df['apex'])\n    df['normalized_url_lower'] = df['normalized_url'].str.lower()\n    return df"}
{"instruction": "Provide utility functions for interacting with the Algorand blockchain, specifically for printing asset holdings for an account and asset ID, and waiting for a transaction to be confirmed.", "output": "from itsdangerous import json\n\n\nimport json\n\n\"\"\"\nStriaght ripped from https://github.com/algorand/docs Algorand Dev Documentation\n\nThank you for the util functions!\n\"\"\"\n\n#   Utility function used to print asset holding for account and assetid\ndef print_asset_holding(algodclient, account, assetid):\n    # note: if you have an indexer instance available it is easier to just use this\n    # response = myindexer.accounts(asset_id = assetid)\n    # then loop thru the accounts returned and match the account you are looking for\n    account_info = algodclient.account_info(account)\n    idx = 0\n    for my_account_info in account_info['assets']:\n        scrutinized_asset = account_info['assets'][idx]\n        idx = idx + 1        \n        if (scrutinized_asset['asset-id'] == assetid):\n            print(\"Asset ID: {}\".format(scrutinized_asset['asset-id']))\n            print(json.dumps(scrutinized_asset, indent=4))\n            break\n\n# utility for waiting on a transaction confirmation\ndef wait_for_confirmation( algod_client, txid, timeout=2000):\n    start_round = algod_client.status()[\"last-round\"] + 1\n    current_round = start_round\n\n    while current_round < start_round + timeout:\n        try:\n            pending_txn = algod_client.pending_transaction_info(txid)\n        except Exception:\n            return \n        if pending_txn.get(\"confirmed-round\", 0) > 0:\n            return pending_txn\n        elif pending_txn[\"pool-error\"]:  \n            raise Exception(\n                'pool error: {}'.format(pending_txn[\"pool-error\"]))\n        algod_client.status_after_block(current_round)                   \n        current_round += 1\n    raise Exception(\n        'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))"}
{"instruction": "Package and distribute a Python library named 'pyteal' with version 0.27.0, authored by Algorand. The library provides tools for developing Algorand Smart Contracts using Python. The package includes dependencies such as 'docstring-parser', 'executing', 'py-algorand-sdk', 'semantic-version', and 'tabulate', and specifies Python 3.10 or higher as the minimum required version. It also includes type hints and indicates its license as MIT.", "output": "#!/usr/bin/env python3\nimport setuptools\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\nsetuptools.setup(\n    name=\"pyteal\",\n    version=\"0.27.0\",\n    author=\"Algorand\",\n    author_email=\"pypiservice@algorand.com\",\n    description=\"Algorand Smart Contracts in Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/algorand/pyteal\",\n    packages=setuptools.find_packages(\n        include=(\n            \"feature_gates\",\n            \"pyteal\",\n            \"pyteal.*\",\n        )\n    ),\n    install_requires=[\n        \"docstring-parser==0.14.1\",\n        \"executing==2.0.1\",\n        \"py-algorand-sdk>=2.0.0,<3.0.0\",\n        \"semantic-version>=2.9.0,<3.0.0\",\n        \"tabulate>=0.9.0,<0.10.0\",\n    ],\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    package_data={\"pyteal\": [\"*.pyi\", \"py.typed\"]},\n    python_requires=\">=3.10\",\n)"}
{"instruction": "Create a PyTeal smart contract that stores a string indicating address derivation is emulated using a specific path (emulated_via_secp256k1_path) in global storage under the key 'address_derivation'. The contract then returns 1 to indicate success.", "output": "\"\"\"Simulate address derivation in a PyTeal contract to mimic Exodus-style wallet behavior.\"\"\"\nfrom pyteal import *\ndef exodus_style_contract():\n    return Seq([\n        App.globalPut(Bytes(\"address_derivation\"), Bytes(\"emulated_via_secp256k1_path\")),\n        Return(Int(1))\n    ])\nif __name__ == \"__main__\":\n    print(compileTeal(exodus_style_contract(), mode=Mode.Application))"}
{"instruction": "Calculate a reward based on a 'committed' amount stored in global state. If the 'committed' amount is less than or equal to 5,000,000, the reward is 20% of the committed amount. If the 'committed' amount is greater than 5,000,000 and less than or equal to 10,000,000, the reward is 15% of the committed amount. If the 'committed' amount is greater than 10,000,000 and less than or equal to 12,000,000, the reward is 12.5% of the committed amount. Otherwise, the reward is 0. Store the calculated reward in global state under the key 'reward' and return 1.", "output": "from pyteal import *\ndef governance_rewards_contract():\n    committed_amount = Btoi(App.globalGet(Bytes(\"committed\")))\n    reward = ScratchVar(TealType.uint64)\n\n    return Seq([\n        If(committed_amount <= Int(5000000)).Then(\n            reward.store(committed_amount * Int(20) / Int(100))\n        ).Elif(committed_amount <= Int(10000000)).Then(\n            reward.store(committed_amount * Int(15) / Int(100))\n        ).Elif(committed_amount <= Int(12000000)).Then(\n            reward.store(committed_amount * Int(125) / Int(1000))\n        ).Else(\n            reward.store(Int(0))\n        ),\n        App.globalPut(Bytes(\"reward\"), reward.load()),\n        Return(Int(1))\n    ])\nif __name__ == \"__main__\":\n    print(compileTeal(governance_rewards_contract(), mode=Mode.Application))"}
{"instruction": "Create a smart contract that logs the sender address of each NoOp transaction, incrementing a counter for each log. The application stores the log count in global state and the sender addresses associated with each log in global state, keyed by 'log_' concatenated with the log count. On application creation, initialize the log count to 0.  The contract should return 1 to indicate success.", "output": "from pyteal import *\ndef search_logger_app():\n    log_count = App.globalGet(Bytes(\"log_count\"))\n    increment = App.globalPut(Bytes(\"log_count\"), log_count + Int(1))\n\n    store_log = Seq([\n        App.globalPut(Concat(Bytes(\"log_\"), Itob(log_count)), Txn.sender()),\n        increment,\n        Return(Int(1))\n    ])\n\n    handle_creation = Seq([\n        App.globalPut(Bytes(\"log_count\"), Int(0)),\n        Return(Int(1))\n    ])\n\n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.on_completion() == OnComplete.NoOp, store_log]\n    )\n\n    return program\n\nif __name__ == \"__main__\":\n    print(compileTeal(search_logger_app(), mode=Mode.Application, version=6))"}
{"instruction": "Build and package the py-algorand-sdk Python library for interacting with the Algorand network, ensuring the license and documentation are included in the resulting package.", "output": "%global pypi_name py-algorand-sdk\nName:           python-%{pypi_name}\nVersion:        2.8.0\nRelease:        1%{?dist}\nSummary:        Algorand Python SDK\nLicense:        MIT\n\nURL:            https://github.com/algorand/py-algorand-sdk\nSource0:        https://github.com/algorand/py-algorand-sdk/archive/v%{version}/py-algorand-sdk-%{version}.tar.gz\nSource1:        https://raw.githubusercontent.com/algorand/py-algorand-sdk/develop/LICENSE\n\nBuildArch:      noarch\n\nBuildRequires:  python3-devel\nBuildRequires:  python3-setuptools\nBuildRequires:  python3-pynacl\nBuildRequires:  python3-pycryptodomex\nBuildRequires:  python3-msgpack\n\n\n%description\nA python library for interacting with the Algorand network.\n\n%package -n python3-%{pypi_name}\nSummary:        %{summary}\n\n%description -n python3-%{pypi_name}\nA python library for interacting with the Algorand network.\n\n%prep\n%setup -q -n %{pypi_name}-%{version}\n\n\n%build\n%py3_build\n\ncp %{SOURCE1} .\n\n%install\n%py3_install\n\n%files -n python3-%{pypi_name}\n%license LICENSE\n%doc README.md\n%{python3_sitelib}/algosdk\n%{python3_sitelib}/py_algorand_sdk-%{version}-py%{python3_version}.egg-info\n\n%changelog\n* Fri Feb 14 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.8.0-1\n- 2.8.0\n\n* Sat Jan 18 2025 Fedora Release Engineering <releng@fedoraproject.org> - 2.7.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_42_Mass_Rebuild\n\n* Wed Jan 15 2025 Gwyn Ciesla <gwync@protonmail.com> - 2.7.0-1\n- 2.7.0\n\n* Fri Jul 19 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.6.1-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_41_Mass_Rebuild\n\n* Wed Jun 12 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.1-1\n- 2.6.1\n\n* Sat Jun 08 2024 Python Maint <python-maint@redhat.com> - 2.6.0-2\n- Rebuilt for Python 3.13\n\n* Wed Jun 05 2024 Gwyn Ciesla <gwync@protonmail.com> - 2.6.0-1\n- 2.6.0\n\n* Fri Jan 26 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild\n\n* Mon Jan 22 2024 Fedora Release Engineering <releng@fedoraproject.org> - 2.5.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_40_Mass_Rebuild\n\n* Wed Sep 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.5.0-1\n- 2.5.0\n\n* Thu Aug 17 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.4.0-1\n- 2.4.0\n\n* Fri Jul 21 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.3.0-3\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_39_Mass_Rebuild\n\n* Thu Jun 15 2023 Python Maint <python-maint@redhat.com> - 2.3.0-2\n- Rebuilt for Python 3.12\n\n* Wed Jun 14 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.3.0-1\n- 2.3.0\n\n* Mon May 08 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.2.0-1\n- 2.2.0\n\n* Thu Mar 23 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.2-1\n- 2.1.2\n\n* Mon Mar 20 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.1-1\n- 2.1.1\n\n* Wed Mar 15 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.1.0-1\n- 2.1.0\n\n* Fri Mar 03 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-3\n- migrated to SPDX license\n\n* Fri Jan 20 2023 Fedora Release Engineering <releng@fedoraproject.org> - 2.0.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_38_Mass_Rebuild\n\n* Wed Jan 04 2023 Gwyn Ciesla <gwync@protonmail.com> - 2.0.0-1\n- 2.0.0\n\n* Mon Dec 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.2-1\n- 1.20.2\n\n* Thu Nov 10 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.1-1\n- 1.20.1\n\n* Wed Nov 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.20.0-1\n- 1.20.0\n\n* Wed Oct 12 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.19.0-1\n- 1.19.0\n\n* Mon Sep 19 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.18.0-1\n- 1.18.0\n\n* Thu Aug 18 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.1-1\n- 1.16.1\n\n* Mon Jul 25 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.16.0-1\n- 1.16.0\n\n* Fri Jul 22 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.15.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_37_Mass_Rebuild\n\n* Wed Jul 06 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.15.0-1\n- 1.15.0\n\n* Mon Jun 13 2022 Python Maint <python-maint@redhat.com> - 1.13.1-2\n- Rebuilt for Python 3.11\n\n* Thu May 05 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.1-1\n- 1.13.1\n\n* Mon May 02 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.13.0-1\n- 1.13.0\n\n* Thu Apr 21 2022 Gwyn Ciesla <gwync@protonmail.com> - 1.12.0-1\n- 1.12.0\n\n* Fri Jan 21 2022 Fedora Release Engineering <releng@fedoraproject.org> - 1.8.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_36_Mass_Rebuild\n\n* Wed Oct 06 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.8.0-1\n- 1.8.0\n\n* Wed Aug 04 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.7.0-1\n- 1.7.0\n\n* Fri Jul 23 2021 Fedora Release Engineering <releng@fedoraproject.org> - 1.6.0-2\n- Rebuilt for https://fedoraproject.org/wiki/Fedora_35_Mass_Rebuild\n\n* Thu Jun 24 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.6.0-1\n- 1.6.0\n\n* Fri Jun 04 2021 Python Maint <python-maint@redhat.com> - 1.5.0-2\n- Rebuilt for Python 3.10\n\n* Thu Apr 22 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.5.0-1\n- 1.5.0\n\n* Tue Mar 09 2021 Gwyn Ciesla <gwync@protonmail.com> - 1.4.1-1\n- Initial package."}
{"instruction": "Create a Python package named 'pyteal' version 0.27.0, authored by Algorand. The package provides tools for writing Algorand Smart Contracts in Python.  The long description is read from README.md in markdown format. The package URL is https://github.com/algorand/pyteal. Include the 'feature_gates', 'pyteal', and subpackages of 'pyteal' in the distribution.  The package requires docstring-parser==0.14.1, executing==2.0.1, py-algorand-sdk>=2.0.0,<3.0.0, semantic-version>=2.9.0,<3.0.0, and tabulate>=0.9.0,<0.10.0.  The package is compatible with Python 3.10 or higher, is licensed under the MIT License, and is OS independent.  Include '*.pyi' and 'py.typed' files in the 'pyteal' package.", "output": "#!/usr/bin/env python3\n\nimport setuptools\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"pyteal\",\n    version=\"0.27.0\",\n    author=\"Algorand\",\n    author_email=\"pypiservice@algorand.com\",\n    description=\"Algorand Smart Contracts in Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/algorand/pyteal\",\n    packages=setuptools.find_packages(\n        include=(\n            \"feature_gates\",\n            \"pyteal\",\n            \"pyteal.*\",\n        )\n    ),\n    install_requires=[\n        # when changing this list, also update docs/requirements.txt\n        \"docstring-parser==0.14.1\",\n        \"executing==2.0.1\",\n        \"py-algorand-sdk>=2.0.0,<3.0.0\",\n        \"semantic-version>=2.9.0,<3.0.0\",\n        \"tabulate>=0.9.0,<0.10.0\",\n    ],\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    package_data={\"pyteal\": [\"*.pyi\", \"py.typed\"]},\n    python_requires=\">=3.10\",\n)"}
{"instruction": "The script automates the process of extracting code examples from specified source code repositories (Python, JavaScript, Go, Java, TEAL, PyTEAL, and Beaker), and injecting them into documentation files (Markdown). It clones repositories, identifies examples based on comment prefixes, and replaces tagged sections within the documentation with the extracted code snippets, adding source links. The script takes source names as command-line arguments to select which repositories to process.", "output": "#!/usr/bin/env python3\n\nimport os\nimport textwrap\nfrom dataclasses import dataclass\n\nSKIP_DIRS = [\".venv\", \"__pycache__\", \"node_modules\"]\n\n\n@dataclass\nclass ExampleSource:\n    \"\"\"Represents a source for examples\"\"\"\n\n    #: url to the github repo\n    github_url: str\n    #: branch name where examples can be found\n    git_branch: str\n    #: where to find the local repo\n    local_dir: str\n    #: where to find the example files\n    example_dir: str\n    #: full name of language\n    language_name: str\n    #: what to look for as a prefix in source examples\n    src_comment_flag: str\n    #: what file extensions to consider\n    file_extension: str\n    #: name for example source\n    name: str\n\n    def doc_comment_flag(self) -> str:\n        return f\"<!-- ==={self.name}_\"\n\n    def clone_url(self) -> str:\n        return f\"{self.github_url}.git\"\n\n    def file_url(self, file_name: str) -> str:\n        if file_name.startswith(self.example_path()):\n            file_name = file_name[len(self.example_path()) + 1 :]\n\n        return (\n            f\"{self.github_url}/blob/{self.git_branch}/{self.example_dir}/{file_name}\"\n        )\n\n    def example_path(self) -> str:\n        return f\"{self.local_dir}/{self.example_dir}\"\n\n\n@dataclass\nclass Example:\n    \"\"\"Represents a tagged example in source file\"\"\"\n\n    path: str\n    line_start: int\n    lines: list[str]\n    matches: int\n\n\n@dataclass\nclass DocExampleMatch:\n    \"\"\"Represents a match between source and docs\"\"\"\n\n    name: str\n    apply_tabs: bool\n    line_start: int\n    line_stop: int\n\n    @staticmethod\n    def empty() -> \"DocExampleMatch\":\n        return DocExampleMatch(\"\", False, 0, 0)\n\n\n# Example Name => source lines\nSDKExamples = dict[str, Example]\n\nsources: list[ExampleSource] = [\n    ExampleSource(\n        github_url=\"https://github.com/algorand/py-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../py-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"PYSDK\",\n        file_extension=\".py\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/js-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../js-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"javascript\",\n        src_comment_flag=\"// example: \",\n        name=\"JSSDK\",\n        file_extension=\".ts\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/go-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../go/src/github.com/algorand/go-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"go\",\n        src_comment_flag=\"\\t// example: \",\n        name=\"GOSDK\",\n        file_extension=\".go\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand/java-algorand-sdk\",\n        git_branch=\"examples\",\n        local_dir=\"../../java-algorand-sdk\",\n        example_dir=\"examples\",\n        language_name=\"java\",\n        src_comment_flag=\"// example: \",\n        name=\"JAVASDK\",\n        file_extension=\".java\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand-devrel/algorand-teal-examples\",\n        git_branch=\"examples\",\n        local_dir=\"../../algorand-teal-examples\",\n        example_dir=\"examples\",\n        language_name=\"teal\",\n        src_comment_flag=\"// example: \",\n        name=\"TEAL\",\n        file_extension=\".teal\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/barnjamin/pyteal\",\n        git_branch=\"examples\",\n        local_dir=\"../../pyteal\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"PYTEAL\",\n        file_extension=\".py\",\n    ),\n    ExampleSource(\n        github_url=\"https://github.com/algorand-devrel/beaker\",\n        git_branch=\"examples\",\n        local_dir=\"../../beaker\",\n        example_dir=\"examples\",\n        language_name=\"python\",\n        src_comment_flag=\"# example: \",\n        name=\"BEAKER\",\n        file_extension=\".py\",\n    ),\n]\n\n\ndef find_examples_in_sdk(dir: str, prefix: str, lang: str, ext: str) -> SDKExamples:\n    directory = os.listdir(dir)\n\n    name_to_src: SDKExamples = {}\n    for fname in directory:\n        if fname in SKIP_DIRS:\n            continue\n\n        path = os.path.join(dir, fname)\n        if not os.path.isfile(path):\n            name_to_src |= find_examples_in_sdk(path, prefix, lang, ext)\n        elif os.path.splitext(path)[-1] == ext:\n            local_example: list[str] = []\n            with open(path, \"r\") as f:\n                content = f.read()\n                if prefix not in content:\n                    continue\n\n                lines = content.splitlines()\n                for lno, line in enumerate(lines):\n                    if prefix in line:\n                        name = line.strip(prefix)\n                        formatted_example = textwrap.dedent(\n                            \"\\n\".join(local_example)\n                        ).split(\"\\n\")\n                        name_to_src[name] = Example(\n                            path=path,\n                            line_start=lno - len(local_example),\n                            lines=formatted_example,\n                            matches=0,\n                        )\n                        local_example = []\n                    else:\n                        local_example.append(line)\n\n    return name_to_src\n\n\ndef replace_matches_in_docs(\n    dir: str, prefix: str, examples: SDKExamples, src: ExampleSource\n):\n    \"\"\"recursively search in directory for string prefix\"\"\"\n    directory = os.listdir(dir)\n    for fname in directory:\n        path = os.path.join(dir, fname)\n        if not os.path.isfile(path):\n            # recurse through directories\n            replace_matches_in_docs(path, prefix, examples, src)\n            continue\n        elif path[-2:] != \"md\":\n            continue\n\n        page_lines: list[str] = []\n        matches: list[DocExampleMatch] = []\n        current_match = DocExampleMatch.empty()\n\n        with open(path, \"r\") as f:\n            content = f.read()\n            if prefix not in content:\n                continue\n\n            page_lines = content.splitlines()\n            for lno, line in enumerate(page_lines):\n                if prefix not in line:\n                    continue\n\n                # First time finding this one\n                if current_match.name == \"\":\n                    # Its in the tabbed multilanguage section\n                    if \"===\" in page_lines[lno - 1]:\n                        current_match.apply_tabs = True\n\n                    current_match.name = line.strip()[len(prefix) :].strip(\"= ->_\")\n                    current_match.line_start = lno + 1\n                # Second time finding it, add it to matches and wipe current\n                else:\n                    current_match.line_stop = lno\n                    matches.append(current_match)\n                    current_match = DocExampleMatch.empty()\n\n        if len(matches) == 0:\n            continue\n\n        # Need to track the offset here so we dont write to the\n        # wrong spot in the doc file if the example is longer or shorter\n        # than the current set of lines in the docs\n        offset = 0\n        for match in matches:\n\n            if match.name not in examples:\n                print(\n                    f\"Missing {match.name} in {prefix.strip(' -<!=_')} \"\n                    f\"examples (in {path}:{match.line_start})\"\n                )\n                continue\n\n            src_example = examples[match.name]\n\n            example_link = (\n                src.file_url(src_example.path)\n                + f\"#L{src_example.line_start}-\"\n                + f\"L{src_example.line_start + len(src_example.lines)}\"\n            )\n\n            example_lines = [\n                \"```\" + src.language_name,\n                *src_example.lines,\n                \"```\",\n                f\"[Snippet Source]({example_link})\",\n            ]\n\n            if match.apply_tabs:\n                example_lines = [\"\\t\" + l for l in example_lines]\n\n            page_lines[\n                match.line_start + offset : match.line_stop + offset\n            ] = example_lines\n\n            offset += len(example_lines) - (match.line_stop - match.line_start)\n\n            examples[match.name].matches += 1\n\n        with open(path, \"w\") as f:\n            f.write(\"\\n\".join(page_lines))\n\n    return examples\n\n\ndef ensure_source(src: ExampleSource):\n    import git\n\n    if not os.path.isdir(src.local_dir):\n        git.Repo.clone_from(src.clone_url(), src.local_dir, branch=src.git_branch)\n    else:\n        repo = git.Repo(src.local_dir)\n        repo.git.checkout(src.git_branch)\n\n\nif __name__ == \"__main__\":\n\n    names = [src.name for src in sources]\n\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"Gather examples from source repos\")\n    parser.add_argument(\n        \"--src\",\n        metavar=\"name\",\n        type=str,\n        nargs=\"*\",\n        choices=names,\n        help=\"source names to pull (default: all)\",\n    )\n\n    args = parser.parse_args()\n    choices = args.src\n    if choices is None:\n        choices = names\n\n    for src in sources:\n        if src.name not in choices:\n            continue\n\n        ensure_source(src)\n\n        sdk_examples = find_examples_in_sdk(\n            src.example_path(),\n            src.src_comment_flag,\n            src.language_name,\n            src.file_extension,\n        )\n\n        replace_matches_in_docs(\"../docs\", src.doc_comment_flag(), sdk_examples, src)\n\n        for name, example in sdk_examples.items():\n            if example.matches == 0:\n                print(\n                    f\"Missing {name} for {src.language_name} in docs \"\n                    f\"(in: {example.path}:{example.line_start})\"\n                )"}
{"instruction": "Recover a missing Algorand seed phrase by iterating through all possible word combinations from the Algorand wordlist to find a seed that generates a specific Algorand address, given a partial seed phrase with two missing words.", "output": "# A really basic Algorand seed recovery script used in an assisted recovery. (May be incorporated to BTCRecover at some time)\n# Usage: Clone the py-algorand-sdk and place this file in the folder. Edit the test_seed_cut to match your seed.\n# Example below uses a seed with two words missing.\n\nfrom algosdk import mnemonic\n\ntest_seed = (\"dumb essay favorite judge punch hood anger under \"\n             \"talk earn anxiety follow scheme sea future response \"\n             \"asset drum size concert sand loan cupboard above bread\")\n\ntest_seed_cut = (\"dumb essay favorite judge punch hood anger under \"\n            \"talk earn anxiety follow scheme sea future response \"\n            \"asset drum size concert sand loan cupboard\")\n\n\ntest_address = \"LZW5ASZP2DQQGM77EFFUGXUF4DUQPUJEOC5HSQ2TOXKQZQM5H6M2OGK6QY\"\n\n\nif __name__ == \"__main__\":\n    word_list = mnemonic.wordlist.word_list_raw().split(\"\\n\")\n    word_list2 = mnemonic.wordlist.word_list_raw().split(\"\\n\")\n    print(\"Partial Seed: \" + test_seed_cut)\n    print(\"Searching for: \" + test_address)\n    for word in word_list:\n        for word2 in word_list2:\n            try:\n                if(mnemonic.to_public_key(test_seed_cut + \" \" + word + \" \" + word2) == test_address):\n                    print(\"Found At:\")\n                    print(test_seed_cut + \" \" + word + \" \" + word2)\n                    print()\n                    exit()\n            except:\n                pass"}
{"instruction": "Encode a byte array representing entropy into an Algorand mnemonic phrase. The process involves calculating a checksum, converting the entropy into a list of word indices, and mapping those indices to words from a language-specific wordlist, finally creating an Algorand mnemonic object.", "output": "# Copyright (c) 2021 Emanuele Bellocchia\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\"\"\"\nModule for Algorand mnemonic encoding.\nReference: https://github.com/algorand/py-algorand-sdk\n\"\"\"\n\n# Imports\nfrom typing import List\n\nfrom bip_utils.algorand.mnemonic.algorand_entropy_generator import AlgorandEntropyGenerator\nfrom bip_utils.algorand.mnemonic.algorand_mnemonic import AlgorandLanguages, AlgorandMnemonic\nfrom bip_utils.algorand.mnemonic.algorand_mnemonic_utils import AlgorandMnemonicUtils\nfrom bip_utils.bip.bip39.bip39_mnemonic_utils import Bip39WordsListGetter\nfrom bip_utils.utils.mnemonic import Mnemonic, MnemonicEncoderBase\n\n\nclass AlgorandMnemonicEncoder(MnemonicEncoderBase):\n    \"\"\"\n    Algorand mnemonic encoder class.\n    It encodes bytes to the mnemonic phrase.\n    \"\"\"\n\n    def __init__(self,\n                 lang: AlgorandLanguages = AlgorandLanguages.ENGLISH) -> None:\n        \"\"\"\n        Construct class.\n\n        Args:\n            lang (AlgorandLanguages, optional): Language (default: English)\n\n        Raises:\n            TypeError: If the language is not a AlgorandLanguages enum\n            ValueError: If loaded words list is not valid\n        \"\"\"\n        if not isinstance(lang, AlgorandLanguages):\n            raise TypeError(\"Language is not an enumerative of AlgorandLanguages\")\n        super().__init__(lang.value, Bip39WordsListGetter)\n\n    def Encode(self,\n               entropy_bytes: bytes) -> Mnemonic:\n        \"\"\"\n        Encode bytes to mnemonic phrase.\n\n        Args:\n            entropy_bytes (bytes): Entropy bytes\n\n        Returns:\n            Mnemonic object: Encoded mnemonic\n\n        Raises:\n            ValueError: If bytes length is not valid\n        \"\"\"\n\n        # Check entropy length\n        entropy_byte_len = len(entropy_bytes)\n        if not AlgorandEntropyGenerator.IsValidEntropyByteLen(entropy_byte_len):\n            raise ValueError(f\"Entropy byte length ({entropy_byte_len}) is not valid\")\n\n        # Compute checksum word\n        chksum_word_idx = AlgorandMnemonicUtils.ComputeChecksumWordIndex(entropy_bytes)\n        # Convert entropy bytes to a list of word indexes\n        word_indexes = AlgorandMnemonicUtils.ConvertBits(entropy_bytes, 8, 11)\n        # Cannot be None by converting bytes from 8-bit to 11-bit\n        assert word_indexes is not None\n        # Get mnemonic\n        return AlgorandMnemonic.FromList(self.__IndexesToWords(word_indexes + [chksum_word_idx]))\n\n    def __IndexesToWords(self,\n                         indexes: List[int]) -> List[str]:\n        \"\"\"\n        Get a list of words from a list of indexes.\n\n        Args:\n            indexes (list[int]): List of indexes\n\n        Returns:\n            list[str]: List of words\n        \"\"\"\n        return [self.m_words_list.GetWordAtIdx(idx) for idx in indexes]"}
{"instruction": "Simulate the execution of a group of Algorand transactions within a local K Framework-based environment (KAVM), managing account states, application states, and transaction details. The simulation involves constructing a scenario, running it using KAVM, parsing the resulting state, and updating the local client's representation of the Algorand ledger to reflect the changes caused by the executed transactions.", "output": "import json\nimport logging\nimport os\nfrom base64 import b64encode\nfrom pathlib import Path\nfrom pprint import PrettyPrinter\nfrom typing import Any, Dict, Final, Iterable, List, Optional, cast\n\nimport msgpack\nfrom algosdk import encoding\nfrom algosdk.atomic_transaction_composer import (\n    ABI_RETURN_HASH,\n    ABIResult,\n    AtomicTransactionComposer,\n    AtomicTransactionComposerStatus,\n    AtomicTransactionResponse,\n    abi,\n    base64,\n    error,\n    transaction,\n)\nfrom algosdk.error import AlgodHTTPError\nfrom algosdk.future.transaction import PaymentTxn, Transaction\nfrom algosdk.v2client import algod\nfrom pyk.kore.syntax import Pattern\n\nfrom kavm import constants\nfrom kavm.adaptors.algod_account import KAVMAccount\nfrom kavm.adaptors.algod_transaction import KAVMTransaction\nfrom kavm.kavm import KAVM\nfrom kavm.scenario import KAVMScenario, _sort_dict\n\n_LOGGER: Final = logging.getLogger(__name__)\n\n\ndef msgpack_decode_txn_list(enc: bytes) -> List[Transaction]:\n    \"\"\"\n    Decode a msgpack encoded object from a string.\n    Args:\n        enc (str): string to be decoded\n    Returns:\n        []Transaction, []SignedTransaction, []Multisig, []Bid, or []SignedBid:\\\n            decoded object\n\n    Note: This is the missing list decoder from py-algorand-sdk\n    \"\"\"\n    unpacker = msgpack.Unpacker()\n    unpacker.feed(enc)\n    deserialized = []\n    while unpacker.tell() < len(enc):\n        decoded = encoding.future_msgpack_decode(unpacker.unpack())\n        deserialized.append(decoded)\n    return deserialized\n\n\nclass KAVMClient(algod.AlgodClient):\n    \"\"\"\n    Mock class for algod. Forwards all requests to KAVM\n\n    Instead of establishing a connection with algod:\n    * initialize KAVM,\n    * pretend it is algod.\n    \"\"\"\n\n    def __init__(\n        self,\n        faucet_address: str,\n        algod_token: Optional[str] = None,\n        algod_address: Optional[str] = None,\n        log_level: Optional[int] = None,\n    ) -> None:\n        super().__init__(algod_token, algod_address)\n        self.pretty_printer = PrettyPrinter(width=41, compact=True)\n\n        # self._apps = AppCellMap()\n        self._committed_txns: Dict[str, Dict[str, Any]] = {}\n        self._faucet_address = faucet_address\n        self._accounts: Dict[str, KAVMAccount] = {\n            self._faucet_address: KAVMAccount(address=faucet_address, amount=constants.FAUCET_ALGO_SUPPLY)\n        }\n        self._decompiled_teal_dir_path = Path('./.decompiled-teal').resolve()\n        self._decompiled_teal_dir_path.mkdir(exist_ok=True)\n\n        self._app_creators: Dict[int, str] = {}\n        # Initialize KAVM, fetching the K definition dir from the environment\n        definition_dir = os.environ.get('KAVM_DEFINITION_DIR')\n        if definition_dir is not None:\n            self.kavm = KAVM(definition_dir=Path(definition_dir))\n            self.kavm.definition\n        else:\n            _LOGGER.critical('Cannot initialize KAVM: KAVM_DEFINITION_DIR env variable is not set')\n            exit(1)\n\n    def set_log_level(self, log_level: Any) -> None:\n        \"\"\"\n        Set log level for algod requests\n        \"\"\"\n        _LOGGER.setLevel(log_level)\n\n    def algod_request(\n        self,\n        method: str,\n        requrl: str,\n        params: Optional[List[str]] = None,\n        data: Optional[bytes] = None,\n        headers: Optional[List[str]] = None,\n        response_format: str = 'Json',\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Log requests made to algod, but execute local actions instead\n\n        Need to override this method, and the more specific methods using it can remain the same.\n        \"\"\"\n\n        if method == 'GET':\n            return self._handle_get_requests(requrl)\n        elif method == 'POST':\n            return self._handle_post_requests(requrl, data)\n        else:\n            raise NotImplementedError(f'{method} {requrl}')\n\n    def _handle_get_requests(self, requrl: str) -> Dict[str, Any]:\n        \"\"\"\n        Handle GET requests to algod with KAVM\n        \"\"\"\n        _, endpoint, *params = requrl.split('/')\n\n        if endpoint == 'transactions':\n            if params[0] == 'params':\n                return {\n                    'consensus-version': 31,\n                    'fee': 1000,\n                    'genesis-id': 'pyteal-eval',\n                    'genesis-hash': 'pyteal-evalpyteal-evalpyteal-evalpyteal-eval',\n                    'last-round': 1,\n                    'min-fee': 1000,\n                }\n            elif params[0] == 'pending':\n                if len(params) >= 2:\n                    try:\n                        return self._committed_txns[params[1]]\n                    # hack to temporarily make py-algorand-sdk happy:\n                    # if the txn id is not found, return the last committed txn\n                    except KeyError:\n                        (_, txn) = sorted(self._committed_txns.items())[-1]\n                        return txn\n                else:\n                    raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n            else:\n                raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n        elif endpoint == 'accounts':\n            if len(params) == 1:\n                address = params[0]\n                try:\n                    return self._accounts[address].dictify()\n                except KeyError:\n                    _LOGGER.warning(\n                        f'Account {address} is unknown to KAVM. Returing an account with the requested address and 0 balance to the client'\n                    )\n                    return KAVMAccount(address=address, amount=0).dictify()\n            else:\n                raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n        elif endpoint == 'applications':\n            app_id = int(params[0])\n            try:\n                creator_address = self._app_creators[app_id]\n            except KeyError as e:\n                raise ValueError(f'Cannot find creator of app {app_id}') from e\n            try:\n                result = list(filter(lambda app: app['id'] == app_id, self._accounts[creator_address].created_apps))\n                return result[0]\n            except (KeyError, IndexError) as e:\n                raise ValueError(\n                    f'Cannot find app with id {app_id} in account {self._accounts[creator_address]}'\n                ) from e\n        elif endpoint == 'status':\n            return {\n                'catchup-time': 0,\n                'last-round': 1000000000000000,\n                'last-version': 'kavm',\n                'next-version': 'kavm',\n                'next-version-round': 0,\n                'next-version-supported': True,\n                'stopped-at-unsupported-round': True,\n                'time-since-last-round': 0,\n                'last-catchpoint': 'kavm',\n                'catchpoint': 'kavm',\n                'catchpoint-total-accounts': 0,\n                'catchpoint-processed-accounts': 0,\n                'catchpoint-verified-accounts': 0,\n                'catchpoint-total-blocks': 0,\n                'catchpoint-acquired-blocks': 0,\n            }\n        else:\n            _LOGGER.debug(requrl.split('/'))\n            raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n    def _pending_transaction_info(self, txid: int) -> Dict[str, Any]:\n        \"\"\"\n        Fetch info about a pending transaction from KAVM\n\n        Fow now, we return any transction as confirmed\n\n        returns:\n            PendingTransactionResponse https://github.com/algorand/go-algorand/tree/master/daemon/algod/api/algod.oas2.json#L2600\n\n        \"\"\"\n        return {'confirmed-round': 1}\n\n    def _handle_post_requests(self, requrl: str, data: Optional[bytes]) -> Dict[str, Any]:\n        \"\"\"\n        Handle POST requests to algod with KAVM\n        \"\"\"\n        # handle transaction group submission\n        if requrl == '/transactions':\n            assert data is not None, 'attempt to submit an empty transaction group!'\n            # decode signed transactions from binary into py-algorand-sdk objects\n            txns = [t.transaction for t in msgpack_decode_txn_list(data)]\n            txn_msg = self.pretty_printer.pformat(txns)\n            f'POST {requrl} {txn_msg}'\n            # log decoded transaction as submitted\n\n            return self._eval_transactions(txns)\n\n            # _LOGGER.debug(proc_result.stdout)\n            # assert False\n\n            # return self.kavm.eval_transactions(kavm_txns, known_addresses)\n        elif requrl == '/teal/compile':\n            assert data is not None, 'attempt to compile an empty TEAL program!'\n            # we do not actually compile the program since KAVM needs the source code\n            return {'result': b64encode(data)}\n        else:\n            raise NotImplementedError(f'Endpoint not implemented: {requrl}')\n\n    def intermediate_k_state(self) -> Pattern:\n        # Construct a json scenario with no transactions and execute just the setup-network stage\n        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=[])\n        final_state, kavm_stderr = self.kavm.run_avm_json(\n            scenario=scenario, existing_decompiled_teal_dir=self._decompiled_teal_dir_path, check=False, output=\"pretty\"\n        )\n        return final_state\n\n    def _eval_transactions(self, txns: List[Transaction]) -> Dict[str, str]:\n        \"\"\"\n        Evaluate a transaction group\n        Parameters\n        ----------\n        txns\n            List[Transaction]\n\n        Construct a simulation scenario, serialize it into JSON and submit to KAVM.\n        Parse KAVM's resulting configuration and update the account state in KAVMClient.\n        \"\"\"\n\n        # we'll need too keep track of all addresses the transactions mention to\n        # make KAVM aware of the new ones, so we preprocess the transactions\n        # to dicover new addresses and initialize them with 0 balance\n        for txn in txns:\n            if not txn.sender in self._accounts.keys():\n                self._accounts[txn.sender] = KAVMAccount(address=txn.sender, amount=0)\n            if hasattr(txn, 'receiver'):\n                txn = cast(PaymentTxn, txn)\n                if not txn.receiver in self._accounts.keys():\n                    self._accounts[txn.receiver] = KAVMAccount(address=txn.receiver, amount=0)\n\n        scenario = self._construct_scenario(accounts=self._accounts.values(), transactions=txns)\n        self._last_scenario = scenario\n\n        try:\n            final_state, kavm_stderr = self.kavm.run_avm_json(\n                scenario=scenario,\n                existing_decompiled_teal_dir=self._decompiled_teal_dir_path,\n            )\n        except RuntimeError as e:\n            _LOGGER.critical(\n                f'Transaction group evaluation failed, last generated scenario was: {json.dumps(scenario.dictify(), indent=4)}'\n            )\n            raise AlgodHTTPError(\n                msg='KAVM has failed, rerun witn --log-level=ERROR to see the executed JSON scenario'\n            ) from e\n\n        try:\n            # on succeful execution, the final state will be serialized and prineted to stderr\n            state_dump = json.loads(kavm_stderr)\n            assert type(state_dump) is dict\n        except json.decoder.JSONDecodeError as e:\n            _LOGGER.critical(f'Failed to parse the final state JSON: {e}')\n            raise AlgodHTTPError(msg='KAVM has failed, see logs for reasons') from e\n\n        _LOGGER.debug(f'Successfully parsed final state JSON: {json.dumps(state_dump, indent=4)}')\n        # substitute the tracked accounts by KAVM's state\n        self._accounts = {}\n        for acc_dict in KAVMScenario.sanitize_accounts(state_dump['accounts']):\n            acc_dict_translated = {KAVMAccount.inverted_attribute_map[k]: v for k, v in acc_dict.items()}\n            self._accounts[acc_dict_translated['address']] = KAVMAccount(**acc_dict_translated)\n            # update app creators\n            for addr, acc in self._accounts.items():\n                for app in acc.created_apps:\n                    self._app_creators[app['id']] = addr\n        # merge confirmed transactions with the ones received from KAVM\n        for txn in state_dump['transactions']:\n            self._committed_txns[txn['id']] = txn['params']\n        return {'txId': state_dump['transactions'][0]['id']}\n\n    def _construct_scenario(self, accounts: Iterable[KAVMAccount], transactions: Iterable[Transaction]) -> KAVMScenario:\n        \"\"\"Construct a JSON simulation scenario to run on KAVM\"\"\"\n        scenario = KAVMScenario.from_json(\n            scenario_json_str=json.dumps(\n                {\n                    \"stages\": [\n                        {\"stage-type\": \"setup-network\", \"data\": {\"accounts\": [acc.dictify() for acc in accounts]}},\n                        {\n                            \"stage-type\": \"submit-transactions\",\n                            \"data\": {\n                                \"transactions\": [\n                                    KAVMTransaction.sanitize_byte_fields(_sort_dict(txn.dictify()))\n                                    for txn in transactions\n                                ]\n                            },\n                            \"expected-returncode\": 0,\n                        },\n                    ]\n                }\n            ),\n            teal_sources_dir=self._decompiled_teal_dir_path,\n        )\n        return scenario\n\n\nclass KAVMAtomicTransactionComposer(AtomicTransactionComposer):\n    \"\"\"\n    This class overrides the 'execute' method of the base AtomicTransactionComposer class\n    by only introducing two lines of code which override the transactions IDs with\n    sequential integers (converted to strings). This is a requirement of KAVM's K implementation.\n    However, if a vanilla 'AlgodClient' is passed as 'clinet', the default transctions ids will be used\n    to maintain compatibility with go-algorand.\n    \"\"\"\n\n    def execute(self, client: algod.AlgodClient, wait_rounds: int) -> \"AtomicTransactionResponse\":\n        \"\"\"\n        Send the transaction group to the network and wait until it's committed\n        to a block. An error will be thrown if submission or execution fails.\n        The composer's status must be SUBMITTED or lower before calling this method,\n        since execution is only allowed once. If submission is successful,\n        this composer's status will update to SUBMITTED.\n        If the execution is also successful, this composer's status will update to COMMITTED.\n        Note: a group can only be submitted again if it fails.\n        Args:\n            client (AlgodClient): Algod V2 client\n            wait_rounds (int): maximum number of rounds to wait for transaction confirmation\n        Returns:\n            AtomicTransactionResponse: Object with confirmed round for this transaction,\n                a list of txIDs of the submitted transactions, and an array of\n                results for each method call transaction in this group. If a\n                method has no return value (void), then the method results array\n                will contain None for that method's return value.\n        \"\"\"\n        if self.status > AtomicTransactionComposerStatus.SUBMITTED:  # type: ignore\n            raise error.AtomicTransactionComposerError(\n                \"AtomicTransactionComposerStatus must be submitted or lower to execute a group\"\n            )\n\n        self.submit(client)\n        self.status = AtomicTransactionComposerStatus.SUBMITTED\n\n        # HACK: override the real transaction ids with sequential integers if running with KAVM\n        # leave them as is otherwise\n        if isinstance(client, KAVMClient):\n            self.tx_ids = [str(idx) for idx, _ in enumerate(self.txn_list)]\n\n        resp = transaction.wait_for_confirmation(client, self.tx_ids[0], wait_rounds)\n\n        self.status = AtomicTransactionComposerStatus.COMMITTED\n\n        confirmed_round = resp[\"confirmed-round\"]\n        method_results = []\n\n        for i, tx_id in enumerate(self.tx_ids):\n            raw_value = None\n            return_value = None\n            decode_error = None\n            tx_info = None\n\n            if i not in self.method_dict:\n                continue\n\n            # Parse log for ABI method return value\n            try:\n                tx_info = client.pending_transaction_info(tx_id)\n                if self.method_dict[i].returns.type == abi.Returns.VOID:\n                    method_results.append(\n                        ABIResult(\n                            tx_id=tx_id,\n                            raw_value=raw_value,\n                            return_value=return_value,\n                            decode_error=decode_error,\n                            tx_info=tx_info,\n                            method=self.method_dict[i],\n                        )\n                    )\n                    continue\n\n                logs = tx_info[\"logs\"] if \"logs\" in tx_info else []\n\n                # Look for the last returned value in the log\n                if not logs:\n                    raise error.AtomicTransactionComposerError(\"app call transaction did not log a return value\")\n                result = logs[-1]\n                # Check that the first four bytes is the hash of \"return\"\n                result_bytes = base64.b64decode(result)\n                if len(result_bytes) < 4 or result_bytes[:4] != ABI_RETURN_HASH:\n                    raise error.AtomicTransactionComposerError(\"app call transaction did not log a return value\")\n                raw_value = result_bytes[4:]\n                return_value = self.method_dict[i].returns.type.decode(raw_value)\n            except Exception as e:\n                decode_error = e\n                raise\n\n            abi_result = ABIResult(\n                tx_id=tx_id,\n                raw_value=raw_value,\n                return_value=return_value,\n                decode_error=decode_error,\n                tx_info=tx_info,\n                method=self.method_dict[i],\n            )\n            method_results.append(abi_result)\n\n        return AtomicTransactionResponse(\n            confirmed_round=confirmed_round,\n            tx_ids=self.tx_ids,\n            results=method_results,\n        )"}
{"instruction": "Package and distribute a Python SDK named 'tinyman-py-sdk' using setuptools. Define metadata like name, description, author, version, license, and project URL. Read a long description from 'README.md' in Markdown format. Specify dependencies ('py-algorand-sdk >= 1.10.0' and 'requests >= 2.0.0'), supported Python versions ('>=3.8'), and include JSON files ('asc.json', 'amm_approval.map.json', 'swap_router_approval.map.json') within the 'tinyman.v1' and 'tinyman.v2' packages.", "output": "import setuptools\n\n\nwith open(\"README.md\", \"r\") as f:\n    long_description = f.read()\n\nsetuptools.setup(\n    name=\"tinyman-py-sdk\",\n    description=\"Tinyman Python SDK\",\n    author=\"Tinyman\",\n    author_email=\"hello@tinyman.org\",\n    version=\"2.1.1\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n    project_urls={\n        \"Source\": \"https://github.com/tinyman/tinyman-py-sdk\",\n    },\n    install_requires=[\"py-algorand-sdk >= 1.10.0\", \"requests >= 2.0.0\"],\n    packages=setuptools.find_packages(),\n    python_requires=\">=3.8\",\n    package_data={\n        \"tinyman.v1\": [\"asc.json\"],\n        \"tinyman.v2\": [\"amm_approval.map.json\", \"swap_router_approval.map.json\"],\n    },\n    include_package_data=True,\n)"}
{"instruction": "Fetch transaction data from an external API, save it to a JSON file, then extract the 'transactions' array. Iterate through each transaction in the array, calculate a reward amount by increasing the original amount by 18.6%, and send a Choice Coin (ASA ID: 297995609) transfer transaction from a predefined account (voter_1_address) to the sender address of each transaction, including a memo with 'Rewards!' and the transaction ID.", "output": "# Choice Coin Governance Rewards Code.\n\nfrom algosdk import account, encoding, mnemonic,algod\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn, AssetConfigTxn\nfrom algosdk.future.transaction import AssetFreezeTxn\nfrom algosdk.v2client import algod\nimport json\nimport urllib3\n\nchoice_id  = 297995609\nvoter_1_address = \"\"\nvoter_1_mnemonic = \"\"\nvoter_1_key = mnemonic.to_private_key(voter_1_mnemonic)\n\nalgod_client = algod.AlgodClient(\n    algod_token=\"\",\n    algod_address=\"https://api.algoexplorer.io\",\n    # see https://github.com/algorand/py-algorand-sdk/issues/169\n    headers={\"User-Agent\": \"DoYouLoveMe?\"}\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\ndef fetch_addresses():\n\thttp = urllib3.PoolManager()\n\tmain = http.request('GET','')\n\tjson_list = json.loads(main.data.decode('utf-8'))\n\twith open('data.json', 'w', encoding='utf-8') as f:\n\t\tjson.dump(json_list, f, ensure_ascii=False, indent=4)\n\twith open('data.json') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\t\tdata_file = open('file.csv', 'w')\n\t\tcsv_writer = csv.writer(data_file)\n\t\tcount = 0\n\t\tfor transaction in transaction_data:\n\t\t    if count == 0:\n\t\t        header = transaction.keys()\n\t\t        csv_writer.writerow(header)\n\t\t        count += 1\n\t\t    csv_writer.writerow(transaction.values())\n\n\t\tdata_file.close()\n\ndef give_rewards():\n\twith open('data.json', 'r') as json_file:\n\t\tdata = json.load(json_file)\n\t\ttransaction_data = data['transactions']\n\t\tfor transaction in transaction_data:\n\t\t\tamount = transaction[\"asset-transfer-transaction\"][\"amount\"]\n\t\t\tamount = int(amount)\n\t\t\tamount = amount + amount * 0.186 #Edit to match percentage\n\t\t\taddress = transaction['sender']\n\t\t\tid = transaction['id']\n\t\t\tchoice_trade(voter_1_address,voter_1_key,address,amount,choice_id,\"Rewards!\" + id)\nfetch_addresses()\ngive_rewards()"}
{"instruction": "Set up a local Algorand network, run an indexer against it, submit a transaction, and verify that the indexer can find the transaction by its ID.", "output": "#!/usr/bin/env python3\n#\n# usage:\n#  python3 misc/liveindextest.py\n#\n# Requires go-algorand to be checked out on GOPATH.\n# Requires local postgresql and `createdb` `dropdb` standard utils.\n# `goal` etc should be built on PATH\n# `algorand-indexer` can be installed on PATH or at its development location from `make` or `go build` at cmd/algorand-indexer/algorand-indexer\n# pip install py-algorand-sdk\n#\n# The Test:\n# Create a local private Algorand network\n# Create a temporary postgres database for indexer\n# Run indexer following the primary algod\n# Submit a txn using py-algorand-sdk\n# Checks that indexer reports that txn by searching for it by txid.\n#\n# Runs in about 30 seconds on my macbook\n\nimport atexit\nimport base64\nimport glob\nimport logging\nimport os\nimport random\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport time\n\nimport algosdk\nimport algosdk.v2client\n\nfrom e2e_common.util import xrun, atexitrun, find_indexer, ensure_test_db\n\nlogger = logging.getLogger(__name__)\n\n\ndef find_go_algorand():\n    gopath = os.getenv(\"GOPATH\")\n    for path in gopath.split(\":\"):\n        goa = os.path.join(path, \"src\", \"github.com\", \"algorand\", \"go-algorand\")\n        if os.path.isdir(goa):\n            return goa\n    return None\n\n\nalready_stopped = False\nalready_deleted = False\n\n\ndef goal_network_stop(netdir, normal_cleanup=False):\n    global already_stopped, already_deleted\n    if already_stopped or already_deleted:\n        return\n\n    logger.info(\"stop network in %s\", netdir)\n    try:\n        xrun([\"goal\", \"network\", \"stop\", \"-r\", netdir], timeout=10)\n    except Exception as e:\n        logger.error(\"error stopping network\", exc_info=True)\n        if normal_cleanup:\n            raise e\n    already_stopped = True\n\n\ndef openkmd(algodata):\n    kmdnetpath = sorted(glob.glob(os.path.join(algodata, \"kmd-*\", \"kmd.net\")))[-1]\n    kmdnet = open(kmdnetpath, \"rt\").read().strip()\n    kmdtokenpath = sorted(glob.glob(os.path.join(algodata, \"kmd-*\", \"kmd.token\")))[-1]\n    kmdtoken = open(kmdtokenpath, \"rt\").read().strip()\n    kmd = algosdk.kmd.KMDClient(kmdtoken, \"http://\" + kmdnet)\n    return kmd\n\n\ndef openalgod(algodata):\n    algodnetpath = os.path.join(algodata, \"algod.net\")\n    algodnet = open(algodnetpath, \"rt\").read().strip()\n    algodtokenpath = os.path.join(algodata, \"algod.token\")\n    algodtoken = open(algodtokenpath, \"rt\").read().strip()\n    algod = algosdk.algod.AlgodClient(algodtoken, \"http://\" + algodnet)\n    return algod\n\n\nclass RunContext:\n    def __init__(self, env):\n        self.env = env\n        self.kmd = None\n        self.algod = None\n        self.lock = threading.Lock()\n        self.pubw = None\n        self.maxpubaddr = None\n\n    def connect(self):\n        with self.lock:\n            self._connect()\n            return self.algod, self.kmd\n\n    def _connect(self):\n        if self.algod and self.kmd:\n            return\n        # should run from inside self.lock\n        xrun([\"goal\", \"kmd\", \"start\", \"-t\", \"200\"], env=self.env, timeout=5)\n        algodata = self.env[\"ALGORAND_DATA\"]\n        self.kmd = openkmd(algodata)\n        self.algod = openalgod(algodata)\n\n    def get_pub_wallet(self):\n        with self.lock:\n            self._connect()\n            if not (self.pubw and self.maxpubaddr):\n                # find private test node public wallet and its richest account\n                wallets = self.kmd.list_wallets()\n                pubwid = None\n                for xw in wallets:\n                    if xw[\"name\"] == \"unencrypted-default-wallet\":\n                        pubwid = xw[\"id\"]\n                pubw = self.kmd.init_wallet_handle(pubwid, \"\")\n                pubaddrs = self.kmd.list_keys(pubw)\n                pubbalances = []\n                maxamount = 0\n                maxpubaddr = None\n                for pa in pubaddrs:\n                    pai = self.algod.account_info(pa)\n                    if pai[\"amount\"] > maxamount:\n                        maxamount = pai[\"amount\"]\n                        maxpubaddr = pai[\"address\"]\n                self.pubw = pubw\n                self.maxpubaddr = maxpubaddr\n            return self.pubw, self.maxpubaddr\n\n    def do_txn(self):\n        pubw, maxpubaddr = self.get_pub_wallet()\n        algod, kmd = self.connect()\n\n        # create a wallet with an addr to send to\n        walletname = base64.b16encode(os.urandom(16)).decode()\n        winfo = kmd.create_wallet(walletname, \"\")\n        handle = kmd.init_wallet_handle(winfo[\"id\"], \"\")\n        addr = kmd.generate_key(handle)\n\n        # send one million Algos to the test wallet's account\n        params = algod.suggested_params()\n        round = params[\"lastRound\"]\n        txn = algosdk.transaction.PaymentTxn(\n            sender=maxpubaddr,\n            fee=params[\"minFee\"],\n            first=round,\n            last=round + 100,\n            gh=params[\"genesishashb64\"],\n            receiver=addr,\n            amt=1000000000000,\n            flat_fee=True,\n        )\n        stxn = kmd.sign_transaction(pubw, \"\", txn)\n        txid = algod.send_transaction(stxn)\n        for i in range(50):\n            txinfo = algod.pending_transaction_info(txid)\n            if txinfo.get(\"round\"):\n                break\n            time.sleep(0.1)\n        return txid, txinfo\n\n\ndef main():\n    start = time.time()\n    import argparse\n\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--go-algorand\", help=\"path to go-algorand checkout\")\n    ap.add_argument(\n        \"--keep-temps\",\n        default=False,\n        action=\"store_true\",\n        help=\"if set, keep all the test files\",\n    )\n    ap.add_argument(\n        \"--indexer-bin\",\n        default=None,\n        help=\"path to algorand-indexer binary, otherwise search PATH\",\n    )\n    ap.add_argument(\n        \"--indexer-port\",\n        default=None,\n        type=int,\n        help=\"port to run indexer on. defaults to random in [4000,30000]\",\n    )\n    ap.add_argument(\n        \"--connection-string\",\n        help=\"Use this connection string instead of attempting to manage a local database.\",\n    )\n    ap.add_argument(\"--verbose\", default=False, action=\"store_true\")\n    args = ap.parse_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        logging.basicConfig(level=logging.INFO)\n\n    indexer_bin = find_indexer(args.indexer_bin)\n    goalgorand = args.go_algorand or find_go_algorand()\n\n    # env for child processes\n    env = dict(os.environ)\n\n    tempdir = os.getenv(\"TEMPDIR\")\n    if not tempdir:\n        tempdir = tempfile.mkdtemp()\n        env[\"TEMPDIR\"] = tempdir\n        logger.info(\"created TEMPDIR %r\", tempdir)\n        if not args.keep_temps:\n            # If we created a tmpdir and we're not keeping it, clean it up.\n            # If an outer process specified $TEMPDIR, let them clean it up.\n            atexit.register(shutil.rmtree, tempdir, onerror=logger.error)\n        else:\n            atexit.register(\n                print, \"keeping temps. to clean up:\\nrm -rf {}\".format(tempdir)\n            )\n\n    netdir = os.path.join(tempdir, \"net\")\n    env[\"NETDIR\"] = netdir\n\n    template = os.path.join(\n        goalgorand, \"test/testdata/nettemplates/TwoNodes50EachFuture.json\"\n    )\n    xrun(\n        [\"goal\", \"network\", \"create\", \"-r\", netdir, \"-n\", \"tbd\", \"-t\", template],\n        timeout=30,\n    )\n    xrun([\"goal\", \"network\", \"start\", \"-r\", netdir], timeout=30)\n    atexit.register(goal_network_stop, netdir)\n\n    algodata = os.path.join(netdir, \"Node\")\n    env[\"ALGORAND_DATA\"] = algodata\n\n    psqlstring = ensure_test_db(args.connection_string, args.keep_temps)\n    primary = os.path.join(netdir, \"Primary\")\n    aiport = args.indexer_port or random.randint(4000, 30000)\n    indexer_token = \"security-theater\"\n    indexerp = subprocess.Popen(\n        [\n            indexer_bin,\n            \"daemon\",\n            \"--algod\",\n            primary,\n            \"--postgres\",\n            psqlstring,\n            \"--dev-mode\",\n            \"--server\",\n            \":{}\".format(aiport),\n            \"--token\",\n            indexer_token,\n        ]\n    )\n    atexit.register(indexerp.kill)\n\n    rc = RunContext(env)\n    txid, txinfo = rc.do_txn()\n    logger.debug(\"submitted txid %s, %r\", txid, txinfo)\n\n    indexer = algosdk.v2client.indexer.IndexerClient(\n        indexer_token, \"http://localhost:{}\".format(aiport)\n    )\n    ok = False\n    retcode = 1\n    for i in range(30):\n        result = indexer.search_transactions(txid=txid)\n        logger.debug(\"seacrh_transactions: %r\", result)\n        they = result.get(\"transactions\")\n        if they and they[0].get(\"confirmed-round\"):\n            logger.info(\"OK: Got txn\")\n            ok = True\n            retcode = 0\n            break\n        time.sleep(1.0)\n\n    dt = time.time() - start\n    ok = (ok and \"OK\") or \"FAIL\"\n    sys.stdout.write(\"indexer live test {} ({:.1f}s)\\n\".format(ok, dt))\n    return retcode\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())"}
{"instruction": "The program opens a JSON file named 'vanity_addresses' containing vanity Algorand addresses. It then presents a list of the vanity names found in the file along with a count of their occurrences. The user selects a vanity name, and the program displays the corresponding public keys, categorized by where the vanity name is located (beginning, end, or anywhere) in the address. Finally, the user selects a specific address by entering a letter and number combination, and the program displays the associated private key mnemonic after a confirmation prompt.", "output": "# vanity_browser.py - lets you browse through the addresses found with vanity_farmer.py\n#\n# Depends on py-algorand-sdk which can be installed with:\n#\n# pip3 install py-algorand-sdk\n#\n# If you don't have pip3 you can install it with:\n#\n# apt install python3-pip\n\nimport json\nimport algosdk\n\ndef program():\n    open_file()\n    present_names()\n    user_input = present_publics()\n    present_privates(user_input)\n\ndef open_file():\n    global file_data\n    file_data = \"\"\n    try:\n        file_data = json.load(open(\"vanity_addresses\",'r'))\n    except FileNotFoundError as e:\n        print(\"No 'vanity_addresses' file found, exiting.\")\n        exit()\n\ndef present_names():\n    print(\"The following vanity addresses were generated.\")\n    print(\"Type the name of a vanity to view the addresses.\")\n    print(\"\")\n    names = []\n    for vanity in file_data:\n        names.append(vanity)\n    for i in range(len(names)):\n        length = []\n        try:\n            length.append(len(file_data[names[i]][\"A\"]))\n        except KeyError:\n            pass\n        try:\n            length.append(len(file_data[names[i]][\"E\"]))\n        except KeyError:\n            pass\n        try:\n            length.append(len(file_data[names[i]][\"B\"]))\n        except KeyError:\n            pass\n\n        sum_is = 0\n        for g in range(len(length)):\n            sum_is += length[g]\n        print(\"Found :\",names[i],sum_is,\"times\")\n\ndef present_publics():\n    user_input = input().upper()\n    names = []\n    print(\"\")\n    if user_input not in file_data:\n        print(\"The vanity '\",user_input,\"' was not an option. Exiting.\",sep=\"\")\n        exit() \n    for vanity in file_data:\n        names.append(vanity)\n        if user_input == vanity:\n            try:\n                temp = file_data[vanity][\"A\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' anywhere.\")\n                for i in range(len(temp)):\n                    print(\"A\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n\n            try:\n                temp = file_data[vanity][\"E\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' at the end.\")\n                for i in range(len(temp)):\n                    print(\"E\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n\n            try:\n                temp = file_data[vanity][\"B\"]\n                print(\"\\nVanity addresses with '\"+vanity+\"' at the beginning.\")\n                for i in range(len(temp)):\n                    print(\"B\"+str(i)+\":\",temp[str(i)][\"public key\"])\n            except KeyError:\n                pass\n            \n    return user_input\n\ndef present_privates(vanity):\n    print(\"\\nPlease type the letter and number in front your wanted address.\")\n    user_input = input()\n    try:\n        key = file_data[vanity][str(user_input[0]).upper()][str(user_input[1:])][\"private key\"]\n        print(\"\\nThe private mnemonic will now be shown. Make sure noone is watching\")\n        print(\"Press the enter key to continue\")\n        user_input_2 = input()\n        if user_input_2 != None:\n            print(\"--------------------------------------------------------------\")\n            print(algosdk.mnemonic.from_private_key(key))\n            print(\"\\n\",key,sep=\"\")\n            print(\"--------------------------------------------------------------\")\n            print(\"\\nREMEMBER! Keep these safe and private. Anyone with your keys can spend your money.\")\n            print(\"It is advised to write the mnemonic on a piece of paper and hide it somewhere safe.\")\n            print(\"\")\n            print(\"Press the enter key to exit program.\")\n        user_input_2 = input()\n        if user_input_2 != None:\n            pass\n            \n    except KeyError as e:\n        print(\"The input {} was not an option. Exiting.\".format(e))\n    except IndexError as e:\n         print(\"No valid input was given. Exiting.\")\n\nprogram()"}
{"instruction": "Compile the provided Teal smart contract code for an ARC72 NFT with Highforge extensions, generate binary and base64 encoded versions of the approval and clear programs, and calculate their SHA256 hashes.  Finally, it outputs the base64 encoded contract binaries to files and prints the approval and clear program hashes to the console.", "output": "from pathlib import Path\n\nfrom Crypto.Hash import SHA512\nfrom pyteal import *\nfrom pyteal.ast.expr import Expr\nfrom pyteal.ir import TealSimpleBlock\n\nversion = \"v0.5.0\"\n\n################################################################################\n# Constants\n################################################################################\n\n\nHI4GE = Addr(\"HI4GEV4ZU32TGWUPKC5FKNCK6DZOLX2RRX4BVB3QG6WUHQ2UAS4GM3CN5U\")\nLAUNCH = Addr(\"LAUNCHPHD5NWWTDNVHOCFORJRFQYSY7UJWRF6A35LYMIDG4QHSHLGTMIEY\")\n\nBOOL_FALSE = Bytes(\"base16\", \"0x00\")\nBOOL_TRUE = Bytes(\"base16\", \"0x80\")\n\nBYTES_ONE = Bytes(\"base16\", \"0x01\")\nBYTES_ZERO = Bytes(\"base16\", \"0x00\")\n\nEVENT_APPROVAL = \"arc72_Approval(address,address,uint256)\"\nEVENT_APPROVAL_FOR_ALL = \"arc72_ApprovalForAll(address,address,bool)\"\nEVENT_MINT = \"highforge_Mint(address,uint256,uint64,uint64,uint64)\"\nEVENT_REVEAL = \"highforge_Reveal(uint256,byte[256])\"\nEVENT_TRANSFER = \"arc72_Transfer(address,address,uint256)\"\nEVENT_UPDATE_URI = \"highforge_UpdateURI(uint256,byte[256])\"\n\nINTERFACE_ARC72_CORE = Bytes(\"base16\", \"0x53f02a40\")\nINTERFACE_ARC72_ENUMERATION = Bytes(\"base16\", \"0xa57d4679\")\nINTERFACE_ARC72_MANAGEMENT = Bytes(\"base16\", \"0xb9c6f696\")\nINTERFACE_ARC72_METADATA = Bytes(\"base16\", \"0xc3c1fc00\")\nINTERFACE_MASK = Bytes(\"base16\", \"0xffffffff\")\nINTERFACE_SUPPORTS_INTERFACE = Bytes(\"base16\", \"0x4e22a3ba\")\n\nPREFIX_RETURN = Bytes(\"base16\", \"0x151f7c75\")\n\nLENGTH_ADDRESS = Int(32)\nLENGTH_BALANCE_BOX = Int(32)\nLENGTH_BOOL = Int(1)\nLENGTH_INDEX_BOX = Int(32)\nLENGTH_METADATA_URI = Int(256)\nLENGTH_NFT_BOX = Int(320)\nLENGTH_UINT256 = Int(32)\nLENGTH_UINT64 = Int(8)\nLENGTH_UINT8 = Int(1)\n\nMIN_BALANCE_APPROVAL_BOX = Int(2500 + (((2 * 32) + 1) * 400))\nMIN_BALANCE_INDEX_BOX = Int(2500 + (((1 + 32) + 32) * 400))\nMIN_BALANCE_NFT_BOX = Int(2500 + (((1 + 32) + 320) * 400))\nMIN_BALANCE_BALANCE_BOX = Int(2500 + (((1 + 32) + 32) * 400))\n\nLAUNCH_FEES = Global.min_txn_fee()\n\n################################################################################\n# Helper Functions\n################################################################################\n\n\nclass ABI_Method:\n    def __init__(self, abi, handler):\n        self._abi = abi\n        self._handler = handler\n\n        self._signature = (\n            abi[\"name\"]\n            + \"(\"\n            + \",\".join([arg[\"type\"] for arg in abi[\"args\"]])\n            + \")\"\n            + abi[\"returns\"][\"type\"]\n        )\n        self.selector = abi_method(self._signature)\n\n        print(abi[\"name\"], self.selector)\n\n    def handler(self):\n        args = {}\n        commands = []\n\n        length_map = {\n            \"account\": LENGTH_UINT8,\n            \"address\": LENGTH_ADDRESS,\n            \"asset\": LENGTH_UINT8,\n            \"bool\": LENGTH_BOOL,\n            \"byte[4]\": Int(4),\n            \"byte[256]\": Int(256),\n            \"uint256\": LENGTH_UINT256,\n            \"uint64\": LENGTH_UINT64,\n        }\n\n        for i, arg in enumerate(self._abi[\"args\"]):\n            args[arg[\"name\"]] = ScratchVar(\n                TealType.uint64 if arg[\"type\"] == \"asset\" else TealType.bytes\n            )\n\n            commands.append(\n                Assert(Len(Txn.application_args[i + 1]) == length_map[arg[\"type\"]])\n            )\n            commands.append(\n                args[arg[\"name\"]].store(\n                    Txn.accounts[Btoi(Txn.application_args[i + 1])]\n                    if arg[\"type\"] == \"account\"\n                    else (\n                        Txn.assets[Btoi(Txn.application_args[i + 1])]\n                        if arg[\"type\"] == \"asset\"\n                        else Txn.application_args[i + 1]\n                    )\n                )\n            )\n\n        return Seq(\n            *commands,\n            self._handler(args),\n        )\n\n\nclass EmptyExpr(Expr):\n    def __str__(self):\n        return \"\"\n\n    def __teal__(self, _):\n        start = TealSimpleBlock([])\n        end = start\n        return start, end\n\n    def has_return(self):\n        return False\n\n    def type_of(self):\n        return TealType.none\n\n\nclass NFT(EmptyExpr):\n    # NFT Box Structure\n    # owner - 32 bytes\n    # operator - 32 bytes\n    # metadata_uri - 256 bytes\n    box_length = LENGTH_NFT_BOX\n\n    field_indices = {\n        \"owner\": Int(0),\n        \"operator\": Int(32),\n        \"metadata_uri\": Int(64),\n    }\n\n    field_lengths = {\n        \"owner\": LENGTH_ADDRESS,\n        \"operator\": LENGTH_ADDRESS,\n        \"metadata_uri\": LENGTH_METADATA_URI,\n    }\n\n    def __init__(self, token_id):\n        self.box_name = Concat(Bytes(\"n\"), token_id)\n        self.token_id = token_id\n\n    def _emit(self, event, bytes):\n        return abi_event(event, bytes)\n\n    def approve(self, operator):\n        return Seq(\n            self.set(\"operator\", operator),\n            self.emit_approval(self.get(\"owner\"), operator),\n        )\n\n    def burn(self):\n        owner = ScratchVar(TealType.bytes)\n\n        return Seq(\n            owner.store(self.get(\"owner\")),\n            self.transfer(owner.load(), Global.zero_address()),\n            Assert(App.box_delete(self.box_name)),\n            send_algo(MIN_BALANCE_NFT_BOX, owner.load()),\n        )\n\n    def create(self, owner):\n        return Seq(\n            # create the NFT\n            Assert(Not(self.exists())),\n            Assert(App.box_create(self.box_name, self.box_length)),\n            self.transfer(Global.zero_address(), owner),\n        )\n\n    def emit_approval(self, owner, approved):\n        return self._emit(EVENT_APPROVAL, Concat(owner, approved, self.token_id))\n\n    def emit_transfer(self, from_, to):\n        return self._emit(\n            EVENT_TRANSFER,\n            Concat(\n                from_,\n                to,\n                self.token_id,\n            ),\n        )\n\n    def exists(self):\n        return Seq(length := App.box_length(self.box_name), length.hasValue())\n\n    def get(self, key):\n        return App.box_extract(\n            self.box_name, self.field_indices[key], self.field_lengths[key]\n        )\n\n    def is_revealed(self):\n        return self.get(\"metadata_uri\") != BytesZero(LENGTH_METADATA_URI)\n\n    def set(self, key, value):\n        return Seq(\n            Assert(Len(value) == self.field_lengths[key]),\n            App.box_replace(self.box_name, self.field_indices[key], value),\n        )\n\n    def transfer(self, from_, to):\n        return Seq(\n            self.set(\"owner\", to),\n            self.set(\"operator\", Global.zero_address()),\n            If(\n                from_ != Global.zero_address(),\n                Seq(\n                    contents := App.box_get(Concat(Bytes(\"b\"), from_)),\n                    Assert(contents.hasValue()),\n                    App.box_put(\n                        Concat(Bytes(\"b\"), from_),\n                        Btou256(BytesMinus(contents.value(), BYTES_ONE)),\n                    ),\n                ),\n            ),\n            Seq(\n                contents := App.box_get(Concat(Bytes(\"b\"), to)),\n                App.box_put(\n                    Concat(Bytes(\"b\"), to),\n                    Btou256(\n                        BytesAdd(\n                            If(contents.hasValue(), contents.value(), BYTES_ZERO),\n                            BYTES_ONE,\n                        )\n                    ),\n                ),\n            ),\n            self.emit_transfer(from_, to),\n        )\n\n\ndef Btou256(bytes):\n    return Concat(BytesZero(LENGTH_UINT256 - Len(bytes)), bytes)\n\n\ndef Itou256(int):\n    return Concat(BytesZero(LENGTH_UINT256 - LENGTH_UINT64), Itob(int))\n\n\ndef U256toi(bytes):\n    return Btoi(Extract(bytes, LENGTH_UINT256 - LENGTH_UINT64, LENGTH_UINT64))\n\n\ndef abi_event(signature, bytes):\n    return Log(Concat(abi_method(signature), bytes))\n\n\ndef abi_method(signature):\n    hash = SHA512.new(truncate=\"256\")\n    hash.update(signature.encode(\"utf-8\"))\n    selector = hash.hexdigest()[0:8]\n    return Bytes(\"base16\", \"0x\" + selector)\n\n\ndef abi_return(bytes=None):\n    return (\n        Seq(\n            Log(Concat(PREFIX_RETURN, bytes)),\n            Approve(),\n        )\n        if bytes is not None\n        else Approve()\n    )\n\n\ndef assert_is_creator():\n    return Assert(Txn.sender() == Global.creator_address())\n\n\ndef assert_is_launch():\n    return Assert(Txn.sender() == LAUNCH)\n\n\n@Subroutine(TealType.none)\ndef assert_mint_funding(index):\n    return Assert(\n        is_algo_txn(\n            index,\n            MIN_BALANCE_NFT_BOX  # for NFT storage\n            + MIN_BALANCE_INDEX_BOX  # for NFT lookup by index\n            + LAUNCH_FEES,  # to pay for LAUNCH's txn fees\n            Global.current_application_address(),\n        )\n    )\n\n\n@Subroutine(TealType.none)\ndef build_send_asset(assetID, amount, receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetTransfer),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.xfer_asset, assetID),\n        InnerTxnBuilder.SetField(TxnField.asset_amount, amount),\n        InnerTxnBuilder.SetField(TxnField.asset_receiver, receiver),\n    )\n\n\ndef closeout_algo(receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.amount, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.close_remainder_to, receiver),\n        InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef closeout_asset_to_creator(assetID):\n    assetCreator = AssetParam.creator(assetID)\n\n    return Seq(\n        assetCreator,\n        build_send_asset(assetID, Int(0), assetCreator.value()),\n        InnerTxnBuilder.SetField(TxnField.asset_close_to, assetCreator.value()),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef closeout_asset(assetID, receiver):\n    return Seq(\n        build_send_asset(assetID, Int(0), receiver),\n        InnerTxnBuilder.SetField(TxnField.asset_close_to, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef create_asset(assetName, unitName, total, assetURL, hash, manager, reserve):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.AssetConfig),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.config_asset_total, total),\n        InnerTxnBuilder.SetField(TxnField.config_asset_decimals, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.config_asset_name, assetName),\n        InnerTxnBuilder.SetField(\n            TxnField.config_asset_unit_name,\n            unitName,\n        ),\n        InnerTxnBuilder.SetField(TxnField.config_asset_url, assetURL),\n        InnerTxnBuilder.SetField(TxnField.config_asset_metadata_hash, hash),\n        InnerTxnBuilder.SetField(TxnField.config_asset_manager, manager),\n        InnerTxnBuilder.SetField(TxnField.config_asset_reserve, reserve),\n        InnerTxnBuilder.Submit(),\n    )\n\n\ndef distribute_payments(assetID, total):\n    artistAmount = ScratchVar(TealType.uint64)\n    charityAmount = ScratchVar(TealType.uint64)\n    launchpadAmount = ScratchVar(TealType.uint64)\n\n    return Seq(\n        # figure out how much charity gets\n        charityAmount.store(\n            If(\n                And(\n                    App.globalGet(Bytes(\"charityAddress\"))\n                    != Global.current_application_address(),\n                    App.globalGet(Bytes(\"charityPoints\")) > Int(0),\n                ),\n                get_cut(total, App.globalGet(Bytes(\"charityPoints\"))),\n                Int(0),\n            )\n        ),\n        # figure out how much the launchpad gets\n        launchpadAmount.store(get_cut(total, App.globalGet(Bytes(\"launchpadFee\")))),\n        artistAmount.store(total - launchpadAmount.load()),\n        If(\n            assetID == Int(0),\n            Seq(\n                # only payout to charity if it doesn't cause any errors\n                If(\n                    And(\n                        charityAmount.load(),\n                        artistAmount.load() >= charityAmount.load(),\n                        Or(\n                            charityAmount.load() >= Global.min_balance(),\n                            Balance(App.globalGet(Bytes(\"charityAddress\")))\n                            >= Global.min_balance(),\n                        ),\n                    ),\n                    Seq(\n                        artistAmount.store(artistAmount.load() - charityAmount.load()),\n                        send_algo(\n                            charityAmount.load(), App.globalGet(Bytes(\"charityAddress\"))\n                        ),\n                    ),\n                ),\n                send_algo(artistAmount.load(), Global.creator_address()),\n                send_algo(launchpadAmount.load(), HI4GE),\n            ),\n            Seq(\n                # only payout to charity if it doesn't cause any errors\n                If(\n                    And(\n                        charityAmount.load(),\n                        artistAmount.load() >= charityAmount.load(),\n                        Seq(\n                            opted_in := AssetHolding.balance(\n                                App.globalGet(Bytes(\"charityAddress\")),\n                                assetID,\n                            ),\n                            opted_in.hasValue(),\n                        ),\n                    ),\n                    Seq(\n                        artistAmount.store(artistAmount.load() - charityAmount.load()),\n                        send_asset(\n                            assetID,\n                            charityAmount.load(),\n                            App.globalGet(Bytes(\"charityAddress\")),\n                        ),\n                    ),\n                ),\n                send_asset(\n                    assetID,\n                    artistAmount.load(),\n                    Global.creator_address(),\n                ),\n                send_asset(assetID, launchpadAmount.load(), HI4GE),\n            ),\n        ),\n    )\n\n\n@Subroutine(TealType.uint64)\ndef get_cut(total, points):\n    return Btoi(BytesDiv(BytesMul(Itob(total), Itob(points)), Itob(Int(10000))))\n\n\n@Subroutine(TealType.uint64)\ndef is_algo_txn(index, amount, receiver):\n    return And(\n        Gtxn[index].type_enum() == TxnType.Payment,\n        Gtxn[index].close_remainder_to() == Global.zero_address(),\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].amount() == amount,\n        Gtxn[index].receiver() == receiver,\n    )\n\n\n@Subroutine(TealType.uint64)\ndef is_asset_txn(index, assetID, amount, receiver):\n    return And(\n        Gtxn[index].type_enum() == TxnType.AssetTransfer,\n        Gtxn[index].asset_close_to() == Global.zero_address(),\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].xfer_asset() == assetID,\n        Gtxn[index].asset_amount() == amount,\n        Gtxn[index].asset_receiver() == receiver,\n    )\n\n\ndef is_noop_txn(index, appID, method):\n    return And(\n        Gtxn[index].type_enum() == TxnType.ApplicationCall,\n        Gtxn[index].rekey_to() == Global.zero_address(),\n        Gtxn[index].application_id() == appID,\n        Gtxn[index].on_completion() == OnComplete.NoOp,\n        Gtxn[index].application_args[0] == method,\n    )\n\n\n@Subroutine(TealType.bytes)\ndef nibble_to_ascii(nibble):\n    return Extract(\n        Itob(If(nibble < Int(10), Int(48) + nibble, Int(87) + nibble)), Int(7), Int(1)\n    )\n\n\ndef optin_asset(assetID):\n    return Seq(\n        build_send_asset(assetID, Int(0), Global.current_application_address()),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef send_algo(amount, receiver):\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n        InnerTxnBuilder.SetField(TxnField.fee, Int(0)),\n        InnerTxnBuilder.SetField(TxnField.amount, amount),\n        InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef send_algo_cover_fee(amount, receiver):\n    return If(\n        And(\n            amount > Global.min_txn_fee(),\n            Balance(receiver) + amount - Global.min_txn_fee() >= Global.min_balance(),\n        ),\n        Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetField(TxnField.type_enum, TxnType.Payment),\n            InnerTxnBuilder.SetField(TxnField.amount, amount - Global.min_txn_fee()),\n            InnerTxnBuilder.SetField(TxnField.fee, Global.min_txn_fee()),\n            InnerTxnBuilder.SetField(TxnField.receiver, receiver),\n            InnerTxnBuilder.Submit(),\n        ),\n    )\n\n\ndef send_asset(assetID, amount, receiver):\n    return Seq(build_send_asset(assetID, amount, receiver), InnerTxnBuilder.Submit())\n\n\ndef sha_to_token_id(sha256):\n    byte = ScratchVar(TealType.uint64)\n    i = ScratchVar(TealType.uint64)\n    value = ScratchVar(TealType.bytes)\n\n    # todo:\n    # for each byte,\n    # mod it by 10\n    # convert that to ascii\n    # should be 32 bytes long\n    return Seq(\n        value.store(Bytes(\"\")),\n        i.store(Int(0)),\n        While(i.load() < Int(16)).Do(\n            Seq(\n                byte.store(GetByte(sha256, i.load())),\n                value.store(\n                    Concat(\n                        value.load(),\n                        nibble_to_ascii(byte.load() / Int(16)),\n                        nibble_to_ascii(byte.load() & Int(15)),\n                    )\n                ),\n                i.store(i.load() + Int(1)),\n            )\n        ),\n        value.load(),\n    )\n\n\n################################################################################\n# NoOp Branches\n################################################################################\n\n\ndef on_claim_algo():\n    claimableAlgo = Balance(Global.current_application_address()) - MinBalance(\n        Global.current_application_address()\n    )\n\n    return Seq(\n        assert_is_creator(),\n        send_algo(claimableAlgo, Global.creator_address()),\n        Approve(),\n    )\n\n\ndef on_claim_asset(assetID):\n    amount = AssetHolding.balance(Global.current_application_address(), assetID)\n\n    return Seq(\n        assert_is_creator(),\n        amount,\n        send_asset(\n            assetID,\n            amount.value(),\n            Global.creator_address(),\n        ),\n        Approve(),\n    )\n\n\ndef on_claim_wl_alt():\n    return on_claim_asset(App.globalGet(Bytes(\"wlAltID\")))\n\n\ndef on_claim_wl_token():\n    return on_claim_asset(App.globalGet(Bytes(\"wlTokenID\")))\n\n\ndef on_disable_whitelist():\n    return Seq(\n        assert_is_creator(),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            closeout_asset_to_creator(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        App.globalPut(Bytes(\"wlLaunchStart\"), Int(0)),\n        App.globalPut(Bytes(\"wlTokenID\"), Int(0)),\n        App.globalPut(Bytes(\"wlPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltID\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltPrice\"), Int(0)),\n        Approve(),\n    )\n\n\ndef on_enable_whitelist():\n    hash = ScratchVar(TealType.bytes)\n    i = ScratchVar(TealType.uint64)\n    name = ScratchVar(TealType.bytes)\n\n    return Seq(\n        assert_is_creator(),\n        Assert(Btoi(Txn.application_args[1]) < App.globalGet(Bytes(\"launchStart\"))),\n        App.globalPut(Bytes(\"wlLaunchStart\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"wlPrice\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"wlAltID\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"wlAltPrice\"), Btoi(Txn.application_args[4])),\n        App.globalPut(Bytes(\"wlMax\"), Btoi(Txn.application_args[5])),\n        hash.store(Sha256(Itob(Global.current_application_id()))),\n        name.store(Bytes(\"High Forge EA Token: 12345678901\")),\n        For(i.store(Int(0)), i.load() < Int(11), i.store(i.load() + Int(1))).Do(\n            name.store(\n                SetByte(\n                    name.load(),\n                    i.load() + Int(21),\n                    (GetByte(hash.load(), i.load()) % Int(26)) + Int(65),\n                ),\n            )\n        ),\n        create_asset(\n            name.load(),\n            Bytes(\"EARLY\"),\n            App.globalGet(Bytes(\"maxSupply\")) * Int(10),\n            Bytes(\"https://highforge.io\"),\n            Global.zero_address(),\n            Global.current_application_address(),\n            Global.current_application_address(),\n        ),\n        App.globalPut(Bytes(\"wlTokenID\"), InnerTxn.created_asset_id()),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            optin_asset(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        Approve(),\n    )\n\n\ndef on_set_charity():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"charityAddress\"), Txn.application_args[1]),\n        App.globalPut(Bytes(\"charityPoints\"), Btoi(Txn.application_args[2])),\n        Approve(),\n    )\n\n\ndef on_set_launch_dates():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"launchStart\"), Btoi(Txn.application_args[1])),\n        If(\n            Txn.application_args.length() == Int(3),\n            Seq(\n                Assert(App.globalGet(Bytes(\"wlTokenID\"))),\n                Assert(Btoi(Txn.application_args[2]) < Btoi(Txn.application_args[1])),\n                App.globalPut(Bytes(\"wlLaunchStart\"), Btoi(Txn.application_args[2])),\n            ),\n        ),\n        Approve(),\n    )\n\n\ndef on_set_launch_details():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"price\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"maxSupply\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"launchStart\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"launchEnd\"), Int(0)),  # for now, don't allow end date\n        # App.globalPut(Bytes(\"launchEnd\"), Btoi(Txn.application_args[4])),\n        Approve(),\n    )\n\n\ndef on_set_launch_paused():\n    return Seq(\n        assert_is_creator(),\n        App.globalPut(Bytes(\"launchPaused\"), Btoi(Txn.application_args[1])),\n        Approve(),\n    )\n\n\ndef on_set_launchpad_fee():\n    return Seq(\n        assert_is_launch(),\n        App.globalPut(Bytes(\"launchpadFee\"), Btoi(Txn.application_args[1])),\n        Approve(),\n    )\n\n\ndef approveHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(Txn.sender() == nft.get(\"owner\")),\n        nft.approve(args[\"approved\"].load()),\n        abi_return(),\n    )\n\n\napprove = ABI_Method(\n    {\n        \"name\": \"arc72_approve\",\n        \"desc\": \"Approve a controller for a single NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"address\",\n                \"name\": \"approved\",\n                \"desc\": \"Approved controller address\",\n            },\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    approveHandler,\n)\n\n\ndef balanceOfHandler(args):\n    return Seq(\n        contents := App.box_get(Concat(Bytes(\"b\"), args[\"owner\"].load())),\n        abi_return(\n            If(contents.hasValue(), contents.value(), BytesZero(LENGTH_UINT256))\n        ),\n    )\n\n\nbalanceOf = ABI_Method(\n    {\n        \"name\": \"arc72_balanceOf\",\n        \"desc\": \"Returns the number of NFTs owned by an address\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"owner\"},\n        ],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    balanceOfHandler,\n)\n\n\ndef burnHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(Txn.sender() == nft.get(\"owner\")),\n        nft.burn(),\n        abi_return(),\n    )\n\n\nburn = ABI_Method(\n    {\n        \"name\": \"burn\",\n        \"desc\": \"Burns the specified NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    burnHandler,\n)\n\n\ndef getApprovedHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        abi_return(nft.get(\"operator\")),\n    )\n\n\ngetApproved = ABI_Method(\n    {\n        \"name\": \"arc72_getApproved\",\n        \"desc\": \"Get the current approved address for a single NFT\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"address\", \"desc\": \"address of approved user or zero\"},\n    },\n    getApprovedHandler,\n)\n\n\ndef isApprovedForAllHandler(args):\n    return Seq(\n        isOperator := App.box_length(\n            Concat(args[\"owner\"].load(), args[\"operator\"].load())\n        ),\n        abi_return(Itob(isOperator.hasValue())),\n    )\n\n\nisApprovedForAll = ABI_Method(\n    {\n        \"name\": \"arc72_isApprovedForAll\",\n        \"desc\": \"Query if an address is an authorized operator for another address\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"owner\"},\n            {\"type\": \"address\", \"name\": \"operator\"},\n        ],\n        \"returns\": {\n            \"type\": \"bool\",\n            \"desc\": \"whether operator is authorized for all NFTs of owner\",\n        },\n    },\n    isApprovedForAllHandler,\n)\n\n\ndef mintHandler(args):\n    assetID = ScratchVar(TealType.uint64)\n    paidAmount = ScratchVar(TealType.uint64)\n    receiptBox = ScratchVar(TealType.bytes)\n    receiptContent = ScratchVar(TealType.bytes)\n\n    return Seq(\n        # make sure the max supply has not been reached\n        Assert(App.globalGet(Bytes(\"totalMinted\")) < App.globalGet(Bytes(\"maxSupply\"))),\n        If(\n            # if creator is calling, ignore price, period, and paused status\n            Txn.sender() == Global.creator_address(),\n            Seq(\n                assetID.store(Int(0)),\n                paidAmount.store(Int(0)),\n                assert_mint_funding(Txn.group_index() - Int(1)),\n            ),\n            Seq(\n                # make sure the launch is not paused\n                Assert(App.globalGet(Bytes(\"launchPaused\")) == Int(0)),\n                # make sure the mint is not over. launchEnd == 0 means it never ends\n                Assert(\n                    Or(\n                        App.globalGet(Bytes(\"launchEnd\")) == Int(0),\n                        Global.latest_timestamp() < App.globalGet(Bytes(\"launchEnd\")),\n                    )\n                ),\n                If(\n                    # if the time is after the launch start, it's a normal mint\n                    Global.latest_timestamp() >= App.globalGet(Bytes(\"launchStart\")),\n                    Seq(\n                        # make sure they pay the mint price\n                        If(\n                            is_algo_txn(\n                                Txn.group_index() - Int(1),\n                                App.globalGet(Bytes(\"price\")),\n                                Global.current_application_address(),\n                            ),\n                            Seq(\n                                assetID.store(Int(0)),\n                                paidAmount.store(App.globalGet(Bytes(\"price\"))),\n                            ),\n                            Reject(),\n                        ),\n                        assert_mint_funding(Txn.group_index() - Int(2)),\n                    ),\n                    Seq(\n                        # make sure whitelist is enabled\n                        Assert(App.globalGet(Bytes(\"wlTokenID\"))),\n                        # make sure we are in the whitelist window\n                        Assert(\n                            Global.latest_timestamp()\n                            >= App.globalGet(Bytes(\"wlLaunchStart\"))\n                        ),\n                        # make sure white list is not maxed out\n                        Assert(\n                            Or(\n                                # wlMax == 0 means no limit\n                                App.globalGet(Bytes(\"wlMax\")) == Int(0),\n                                App.globalGet(Bytes(\"wlMinted\"))\n                                < App.globalGet(Bytes(\"wlMax\")),\n                            )\n                        ),\n                        # make sure they pay the whitelist token\n                        Assert(\n                            is_asset_txn(\n                                Txn.group_index() - Int(2),\n                                App.globalGet(Bytes(\"wlTokenID\")),\n                                Int(1),\n                                Global.current_application_address(),\n                            )\n                        ),\n                        # make sure they pay the mint price\n                        If(\n                            is_algo_txn(\n                                Txn.group_index() - Int(1),\n                                App.globalGet(Bytes(\"wlPrice\")),\n                                Global.current_application_address(),\n                            ),\n                            Seq(\n                                assetID.store(Int(0)),\n                                paidAmount.store(App.globalGet(Bytes(\"wlPrice\"))),\n                            ),\n                            If(\n                                And(\n                                    App.globalGet(Bytes(\"wlAltID\")),\n                                    is_asset_txn(\n                                        Txn.group_index() - Int(1),\n                                        App.globalGet(Bytes(\"wlAltID\")),\n                                        App.globalGet(Bytes(\"wlAltPrice\")),\n                                        Global.current_application_address(),\n                                    ),\n                                ),\n                                Seq(\n                                    assetID.store(App.globalGet(Bytes(\"wlAltID\"))),\n                                    paidAmount.store(\n                                        App.globalGet(Bytes(\"wlAltPrice\"))\n                                    ),\n                                ),\n                                Reject(),\n                            ),\n                        ),\n                        assert_mint_funding(Txn.group_index() - Int(3)),\n                        App.globalPut(\n                            Bytes(\"wlMinted\"), App.globalGet(Bytes(\"wlMinted\")) + Int(1)\n                        ),\n                    ),\n                ),\n            ),\n        ),\n        # send out everyone's cuts\n        distribute_payments(assetID.load(), paidAmount.load()),\n        # send algo to cover the revealing of the NFT\n        send_algo(LAUNCH_FEES, LAUNCH),\n        # create the receipt box and make sure it doesn't already exist\n        receiptBox.store(Concat(Bytes(\"r\"), args[\"tempTokenId\"].load())),\n        length := App.box_length(receiptBox.load()),\n        Assert(Not(length.hasValue())),\n        # we make the receipt box the same size as an NFT box\n        # that way the user covers the min-balance cost\n        # and during the reveal we can just replace the receipt box with the NFT box\n        Assert(App.box_create(receiptBox.load(), LENGTH_NFT_BOX)),\n        Assert(\n            App.box_create(\n                Concat(Bytes(\"t\"), args[\"tempTokenId\"].load()), LENGTH_INDEX_BOX\n            )\n        ),\n        receiptContent.store(\n            Concat(\n                Txn.sender(),\n                Itou256(App.globalGet(Bytes(\"nextMintID\"))),\n                Itob(assetID.load()),\n                Itob(paidAmount.load()),\n                Itob(Global.latest_timestamp()),\n            )\n        ),\n        App.box_replace(\n            receiptBox.load(),\n            Int(0),\n            receiptContent.load(),\n        ),\n        # emit the mint event\n        abi_event(EVENT_MINT, receiptContent.load()),\n        # update variables for next mint\n        App.globalPut(Bytes(\"nextMintID\"), App.globalGet(Bytes(\"nextMintID\")) + Int(1)),\n        App.globalPut(\n            Bytes(\"totalMinted\"), App.globalGet(Bytes(\"totalMinted\")) + Int(1)\n        ),\n        abi_return(Itou256(App.globalGet(Bytes(\"nextMintID\")) - Int(1))),\n    )\n\n\nmint = ABI_Method(\n    {\n        \"name\": \"highforge_mint\",\n        \"desc\": \"Attempts to mint an NFT for the user\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tempTokenId\",\n                \"desc\": \"A unique temporary token ID for the NFT\",\n            },\n        ],\n        \"returns\": {\n            \"type\": \"uint256\",\n            \"desc\": \"tokenId - The ID of the NFT that was minted\",\n        },\n    },\n    mintHandler,\n)\n\n\ndef ownerOfHandler(args):\n    nft = NFT(args[\"tokenId\"].load())\n\n    return abi_return(\n        If(\n            nft.exists(),\n            nft.get(\"owner\"),\n            Global.zero_address(),\n        )\n    )\n\n\nownerOf = ABI_Method(\n    {\n        \"name\": \"arc72_ownerOf\",\n        \"desc\": \"Returns the address of the current owner of the NFT with the given tokenId\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"address\", \"desc\": \"The current owner of the NFT.\"},\n    },\n    ownerOfHandler,\n)\n\n\ndef revealHandler(args):\n    receiptBox = ScratchVar(TealType.bytes)\n    sender = ScratchVar(TealType.bytes)\n    tokenId = ScratchVar(TealType.bytes)\n    collectionIndex = ScratchVar(TealType.bytes)\n\n    return Seq(\n        assert_is_launch(),\n        # load the receipt\n        receiptBox.store(Concat(Bytes(\"r\"), args[\"tempTokenId\"].load())),\n        length := App.box_length(receiptBox.load()),\n        Assert(length.hasValue()),\n        sender.store(App.box_extract(receiptBox.load(), Int(0), LENGTH_ADDRESS)),\n        tokenId.store(\n            App.box_extract(receiptBox.load(), LENGTH_ADDRESS, LENGTH_UINT256)\n        ),\n        # verify against the receipt\n        Assert(args[\"tokenId\"].load() == tokenId.load()),\n        # delete the receipt box\n        Assert(App.box_delete(receiptBox.load())),\n        Assert(App.box_delete(Concat(Bytes(\"t\"), args[\"tempTokenId\"].load()))),\n        # create the NFT\n        nft := NFT(args[\"tokenId\"].load()),\n        nft.create(sender.load()),\n        nft.set(\"metadata_uri\", args[\"tokenURI\"].load()),\n        # create the index lookup box\n        collectionIndex.store(\n            Itou256(U256toi(args[\"tokenId\"].load()) - Int(1)),\n        ),\n        length := App.box_length(Concat(Bytes(\"i\"), collectionIndex.load())),\n        Assert(Not(length.hasValue())),\n        App.box_put(Concat(Bytes(\"i\"), collectionIndex.load()), args[\"tokenId\"].load()),\n        # emit event and return\n        abi_event(\n            EVENT_REVEAL, Concat(args[\"tokenId\"].load(), args[\"tokenURI\"].load())\n        ),\n        abi_return(),\n    )\n\n\nreveal = ABI_Method(\n    {\n        \"name\": \"highforge_reveal\",\n        \"desc\": \"Reveals the NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tempTokenId\",\n                \"desc\": \"The temporary token ID\",\n            },\n            {\n                \"type\": \"uint256\",\n                \"name\": \"tokenId\",\n                \"desc\": \"The actual token ID\",\n            },\n            {\n                \"type\": \"byte[256]\",\n                \"name\": \"tokenURI\",\n                \"desc\": \"The metadata URI for the token\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    revealHandler,\n)\n\n\ndef setApprovalForAllHandler(args):\n    return Seq(\n        If(\n            args[\"approved\"].load() == BOOL_TRUE,\n            Assert(\n                App.box_create(Concat(Txn.sender(), args[\"operator\"].load()), Int(1))\n            ),\n            If(\n                args[\"approved\"].load() == BOOL_FALSE,\n                Assert(App.box_delete(Concat(Txn.sender(), args[\"operator\"].load()))),\n                Reject(),\n            ),\n        ),\n        abi_event(\n            EVENT_APPROVAL_FOR_ALL,\n            Concat(\n                Txn.sender(),\n                args[\"operator\"].load(),\n                args[\"approved\"].load(),\n            ),\n        ),\n        abi_return(),\n    )\n\n\nsetApprovalForAll = ABI_Method(\n    {\n        \"name\": \"arc72_setApprovalForAll\",\n        \"desc\": \"Approve an operator for all NFTs for a user\",\n        \"readonly\": False,\n        \"args\": [\n            {\n                \"type\": \"address\",\n                \"name\": \"operator\",\n                \"desc\": \"Approved operator address\",\n            },\n            {\n                \"type\": \"bool\",\n                \"name\": \"approved\",\n                \"desc\": \"true to give approval, false to revoke\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    setApprovalForAllHandler,\n)\n\n\ndef setupBalanceHandler(args):\n    return Seq(\n        Assert(\n            is_algo_txn(\n                Txn.group_index() - Int(1),\n                MIN_BALANCE_BALANCE_BOX,\n                Global.current_application_address(),\n            )\n        ),\n        length := App.box_length(Concat(Bytes(\"b\"), Txn.sender())),\n        If(\n            length.hasValue(),\n            send_algo_cover_fee(\n                MIN_BALANCE_BALANCE_BOX,\n                Gtxn[Txn.group_index() - Int(1)].sender(),\n            ),\n            Assert(\n                App.box_create(Concat(Bytes(\"b\"), Txn.sender()), LENGTH_BALANCE_BOX)\n            ),\n        ),\n        abi_return(),\n    )\n\n\nsetupBalance = ABI_Method(\n    {\n        \"name\": \"highforge_setupBalance\",\n        \"desc\": \"Makes sure that the balance box for the sender is set up\",\n        \"readonly\": False,\n        \"args\": [],\n        \"returns\": {\"type\": \"void\"},\n    },\n    setupBalanceHandler,\n)\n\n\ndef supportsInterfaceHandler(args):\n    return Seq(\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_SUPPORTS_INTERFACE,\n            abi_return(BOOL_TRUE),\n        ),\n        If(args[\"interfaceID\"].load() == INTERFACE_MASK, abi_return(BOOL_FALSE)),\n        If(args[\"interfaceID\"].load() == INTERFACE_ARC72_CORE, abi_return(BOOL_TRUE)),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_ENUMERATION,\n            abi_return(BOOL_TRUE),\n        ),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_MANAGEMENT,\n            abi_return(BOOL_TRUE),\n        ),\n        If(\n            args[\"interfaceID\"].load() == INTERFACE_ARC72_METADATA,\n            abi_return(BOOL_TRUE),\n        ),\n        abi_return(BOOL_FALSE),\n    )\n\n\nsupportsInterface = ABI_Method(\n    {\n        \"name\": \"supportsInterface\",\n        \"desc\": \"Detects support for an interface specified by selector.\",\n        \"readonly\": True,\n        \"args\": [\n            {\n                \"type\": \"byte[4]\",\n                \"name\": \"interfaceID\",\n                \"desc\": \"The selector of the interface to detect.\",\n            },\n        ],\n        \"returns\": {\n            \"type\": \"bool\",\n            \"desc\": \"Whether the contract supports the interface.\",\n        },\n    },\n    supportsInterfaceHandler,\n)\n\n\ndef tokenByIndexHandler(args):\n    return Seq(\n        Assert(U256toi(args[\"index\"].load()) < App.globalGet(Bytes(\"totalMinted\"))),\n        contents := App.box_get(Concat(Bytes(\"i\"), args[\"index\"].load())),\n        Assert(contents.hasValue()),\n        abi_return(contents.value()),\n    )\n\n\ntokenByIndex = ABI_Method(\n    {\n        \"name\": \"arc72_tokenByIndex\",\n        \"desc\": \"Returns the token ID of the token with the given index among all NFTs defined by the contract\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"index\"},\n        ],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    tokenByIndexHandler,\n)\n\n\ndef tokenURIHandler(args):\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        abi_return(nft.get(\"metadata_uri\")),\n    )\n\n\ntokenURI = ABI_Method(\n    {\n        \"name\": \"arc72_tokenURI\",\n        \"desc\": \"Returns a URI pointing to the NFT metadata\",\n        \"readonly\": True,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n        ],\n        \"returns\": {\"type\": \"byte[256]\", \"desc\": \"URI to token metadata.\"},\n    },\n    tokenURIHandler,\n)\n\n\ndef totalSupplyHandler(_):\n    return abi_return(Itou256(App.globalGet(Bytes(\"totalMinted\"))))\n\n\ntotalSupply = ABI_Method(\n    {\n        \"name\": \"arc72_totalSupply\",\n        \"desc\": \"Returns the number of NFTs currently defined by this contract\",\n        \"readonly\": True,\n        \"args\": [],\n        \"returns\": {\"type\": \"uint256\"},\n    },\n    totalSupplyHandler,\n)\n\n\ndef transferFromHandler(args):\n    owner = ScratchVar(TealType.bytes)\n\n    return Seq(\n        nft := NFT(args[\"tokenId\"].load()),\n        owner.store(nft.get(\"owner\")),\n        isOperator := App.box_length(Concat(owner.load(), Txn.sender())),\n        Assert(args[\"from\"].load() == owner.load()),\n        Assert(\n            Or(\n                Txn.sender() == nft.get(\"operator\"),\n                Txn.sender() == owner.load(),\n                isOperator.hasValue(),\n            )\n        ),\n        # we allow an optional txn before this one that covers the min balance\n        # cost for the balance box. if it already exists, we will refund it\n        If(\n            Txn.group_index() > Int(0),\n            If(\n                is_algo_txn(\n                    Txn.group_index() - Int(1),\n                    MIN_BALANCE_BALANCE_BOX,\n                    Global.current_application_address(),\n                ),\n                Seq(\n                    length := App.box_length(Concat(Bytes(\"b\"), args[\"to\"].load())),\n                    If(\n                        length.hasValue(),\n                        send_algo_cover_fee(\n                            MIN_BALANCE_BALANCE_BOX,\n                            Gtxn[Txn.group_index() - Int(1)].sender(),\n                        ),\n                    ),\n                ),\n            ),\n        ),\n        nft.transfer(owner.load(), args[\"to\"].load()),\n        abi_return(),\n    )\n\n\ntransferFrom = ABI_Method(\n    {\n        \"name\": \"arc72_transferFrom\",\n        \"desc\": \"Transfers ownership of an NFT\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"address\", \"name\": \"from\"},\n            {\"type\": \"address\", \"name\": \"to\"},\n            {\"type\": \"uint256\", \"name\": \"tokenId\"},\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    transferFromHandler,\n)\n\n\ndef updateTokenURIHandler(args):\n    return Seq(\n        assert_is_creator(),\n        nft := NFT(args[\"tokenId\"].load()),\n        Assert(nft.exists()),\n        Assert(nft.is_revealed()),\n        nft.set(\"metadata_uri\", args[\"tokenURI\"].load()),\n        abi_event(\n            EVENT_UPDATE_URI,\n            Concat(\n                args[\"tokenId\"].load(),\n                args[\"tokenURI\"].load(),\n            ),\n        ),\n        abi_return(),\n    )\n\n\nupdateTokenURI = ABI_Method(\n    {\n        \"name\": \"highforge_updateTokenURI\",\n        \"desc\": \"Allows the creator to update the token URI for a token\",\n        \"readonly\": False,\n        \"args\": [\n            {\"type\": \"uint256\", \"name\": \"tokenId\", \"desc\": \"The ID of the NFT\"},\n            {\n                \"type\": \"byte[256]\",\n                \"name\": \"tokenURI\",\n                \"desc\": \"The metadata URI for the token\",\n            },\n        ],\n        \"returns\": {\"type\": \"void\"},\n    },\n    updateTokenURIHandler,\n)\n\n\n################################################################################\n# OnComplete Branches\n################################################################################\n\n\ndef on_creation():\n    return Seq(\n        App.globalPut(Bytes(\"price\"), Int(0)),\n        # launch will be available when time >= launchStart\n        # it will go until maxSupply is reached OR time > launchEnd\n        App.globalPut(Bytes(\"maxSupply\"), Int(0)),\n        # (wl)launchStart and launchEnd are given in seconds since epoch\n        App.globalPut(Bytes(\"launchStart\"), Int(0)),\n        App.globalPut(Bytes(\"launchEnd\"), Int(0)),\n        App.globalPut(Bytes(\"launchPaused\"), Int(0)),\n        # whitelist will start when time > wlLaunchStart\n        # whitelist will end when time >= launchStart\n        App.globalPut(Bytes(\"wlLaunchStart\"), Int(0)),\n        App.globalPut(Bytes(\"wlTokenID\"), Int(0)),\n        App.globalPut(Bytes(\"wlPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltID\"), Int(0)),\n        App.globalPut(Bytes(\"wlAltPrice\"), Int(0)),\n        App.globalPut(Bytes(\"wlMax\"), Int(0)),\n        App.globalPut(Bytes(\"wlMinted\"), Int(0)),\n        # launchpad fee is in basis points (defaults to 2.5%)\n        App.globalPut(Bytes(\"launchpadFee\"), Int(250)),\n        App.globalPut(Bytes(\"nextMintID\"), Int(1)),\n        App.globalPut(Bytes(\"totalMinted\"), Int(0)),\n        App.globalPut(Bytes(\"charityAddress\"), Global.current_application_address()),\n        App.globalPut(Bytes(\"charityPoints\"), Int(0)),\n        Approve(),\n    )\n\n\ndef on_closeout():\n    return Reject()\n\n\ndef on_delete():\n    return Seq(\n        assert_is_creator(),\n        Assert(App.globalGet(Bytes(\"totalMinted\")) == Int(0)),\n        If(\n            App.globalGet(Bytes(\"wlAltID\")),\n            closeout_asset_to_creator(App.globalGet(Bytes(\"wlAltID\"))),\n        ),\n        closeout_algo(Global.creator_address()),\n        Approve(),\n    )\n\n\ndef on_noop():\n    return Cond(\n        [Txn.application_args[0] == Bytes(\"claimAlgo\"), on_claim_algo()],\n        [Txn.application_args[0] == Bytes(\"claimWLAlt\"), on_claim_wl_alt()],\n        [Txn.application_args[0] == Bytes(\"claimWLToken\"), on_claim_wl_token()],\n        [Txn.application_args[0] == Bytes(\"disableWL\"), on_disable_whitelist()],\n        [Txn.application_args[0] == Bytes(\"enableWL\"), on_enable_whitelist()],\n        [Txn.application_args[0] == Bytes(\"setCharity\"), on_set_charity()],\n        [Txn.application_args[0] == Bytes(\"setLaunchDates\"), on_set_launch_dates()],\n        [Txn.application_args[0] == Bytes(\"setLaunchDetails\"), on_set_launch_details()],\n        [Txn.application_args[0] == Bytes(\"setLaunchPaused\"), on_set_launch_paused()],\n        [Txn.application_args[0] == Bytes(\"setLaunchpadFee\"), on_set_launchpad_fee()],\n        [Txn.application_args[0] == approve.selector, approve.handler()],\n        [Txn.application_args[0] == balanceOf.selector, balanceOf.handler()],\n        [Txn.application_args[0] == burn.selector, burn.handler()],\n        [Txn.application_args[0] == getApproved.selector, getApproved.handler()],\n        [\n            Txn.application_args[0] == isApprovedForAll.selector,\n            isApprovedForAll.handler(),\n        ],\n        [Txn.application_args[0] == mint.selector, mint.handler()],\n        [Txn.application_args[0] == ownerOf.selector, ownerOf.handler()],\n        [Txn.application_args[0] == reveal.selector, reveal.handler()],\n        [\n            Txn.application_args[0] == setApprovalForAll.selector,\n            setApprovalForAll.handler(),\n        ],\n        [Txn.application_args[0] == setupBalance.selector, setupBalance.handler()],\n        [\n            Txn.application_args[0] == supportsInterface.selector,\n            supportsInterface.handler(),\n        ],\n        [Txn.application_args[0] == tokenByIndex.selector, tokenByIndex.handler()],\n        [Txn.application_args[0] == tokenURI.selector, tokenURI.handler()],\n        [Txn.application_args[0] == totalSupply.selector, totalSupply.handler()],\n        [Txn.application_args[0] == transferFrom.selector, transferFrom.handler()],\n    )\n\n\ndef on_optin():\n    return Reject()\n\n\ndef on_update():\n    return Seq(assert_is_launch(), Approve())\n\n\n################################################################################\n# Program Construction\n################################################################################\n\n\ndef approval_program():\n    program = Seq(\n        Assert(Txn.rekey_to() == Global.zero_address()),\n        Cond(\n            [Txn.application_id() == Int(0), on_creation()],\n            [Txn.on_completion() == OnComplete.CloseOut, on_closeout()],\n            [Txn.on_completion() == OnComplete.DeleteApplication, on_delete()],\n            [Txn.on_completion() == OnComplete.NoOp, on_noop()],\n            [Txn.on_completion() == OnComplete.OptIn, on_optin()],\n            [Txn.on_completion() == OnComplete.UpdateApplication, on_update()],\n        ),\n    )\n\n    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)\n\n\ndef clear_program():\n    program = on_closeout()\n    return compileTeal(program, Mode.Application, version=9, assembleConstants=True)\n\n\np = Path(__file__).parent.absolute()\n(p / f\"arc72/{version}\").mkdir(exist_ok=True)\n\n\nwith open(f\"arc72/{version}/approval.teal\", \"w\") as f:\n    f.write(approval_program())\n\nwith open(f\"arc72/{version}/clear.teal\", \"w\") as f:\n    f.write(clear_program())\n\n\nimport base64, hashlib, subprocess\n\nsubprocess.run(\n    [\n        \"goal\",\n        \"clerk\",\n        \"compile\",\n        f\"arc72/{version}/approval.teal\",\n        \"-o\",\n        f\"arc72/{version}/approval.bin\",\n    ]\n)\nsubprocess.run(\n    [\n        \"goal\",\n        \"clerk\",\n        \"compile\",\n        f\"arc72/{version}/clear.teal\",\n        \"-o\",\n        f\"arc72/{version}/clear.bin\",\n    ]\n)\n\nwith open(f\"arc72/{version}/approval.bin\", \"rb\") as f:\n    contents = f.read()\n    print(\"approvalHash\", base64.b64encode(hashlib.sha256(contents).digest()).decode())\n    with open(f\"arc72/{version}/approval.b64\", \"w\") as f:\n        f.write(base64.b64encode(contents).decode())\n\nwith open(f\"arc72/{version}/clear.bin\", \"rb\") as f:\n    contents = f.read()\n    print(\"clearHash\", base64.b64encode(hashlib.sha256(contents).digest()).decode())\n    with open(f\"arc72/{version}/clear.b64\", \"w\") as f:\n        f.write(base64.b64encode(contents).decode())\n\nprint(\"\")\nprint(\"Copy approval.b64 and clear.b64 to algoseas-libs!!!\")"}
{"instruction": "Implement a smart contract for managing NFTickets. The contract allows for creating, selling, redeeming, and withdrawing NFTickets, along with setting up and managing fees for the protocol and supplier. It includes functionalities for minting new NFTickets, transferring ownership, and distributing payments based on defined shares.", "output": "from typing import Final\n\nimport beaker as bkr\nfrom pyteal import *\n\n\nclass NFTicketManager(bkr.Application):\n    protocol: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.bytes,\n        static=True,\n        descr=\"Protocol fee account\",\n    )\n\n    protocol_fee: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.uint64,\n        default=Int(10),  # 1%\n        descr=\"Protocol Fee Percentage\",\n    )\n\n    supplier: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.bytes,\n        descr=\"Supplier account\",\n        static=True\n    )\n\n    supplier_share: Final[bkr.ApplicationStateValue] = bkr.ApplicationStateValue(\n        stack_type=TealType.uint64,\n        default=Int(1),\n        descr=\"Share of supplier on resale\"\n    )\n\n    @bkr.create\n    def create(self, protocol: abi.Account, supplier: abi.Account):\n        return Seq(\n            self.initialize_application_state(),\n            self.protocol.set(Txn.accounts[1]),\n            self.supplier.set(Txn.accounts[2])\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(protocol))\n    def set_up_asset(self, asset: abi.Asset):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset.asset_id(),\n                TxnField.asset_receiver: self.address,\n                TxnField.asset_amount: Int(0),\n                TxnField.fee: Int(0)\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(protocol))\n    def set_up_fee(self, supplier_share: abi.Uint64, protocol: abi.Uint64):\n        return Seq(\n            self.supplier_share.set(supplier_share.get()),\n            self.protocol_fee.set(protocol.get())\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def mint(self, name: abi.String, meta_url: abi.String, meta_hash: abi.String, *, output: abi.Uint64):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(0),\n                TxnField.config_asset_name: Concat(Bytes(\"NFTicket\"), name.get()),\n                TxnField.config_asset_unit_name: Bytes(\"NFTicket\"),\n                TxnField.config_asset_url: meta_url.get(),\n                TxnField.config_asset_metadata_hash: meta_hash.get(),\n                TxnField.config_asset_default_frozen: Int(1),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.fee: Int(0),\n            }),\n            InnerTxnBuilder.Submit(),\n\n            output.set(Gitxn[0].created_asset_id())\n        )\n\n    @bkr.internal(TealType.none)\n    def move_asset(self, asset, owner, to):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset,\n                TxnField.asset_sender: owner,\n                TxnField.asset_receiver: to,\n                TxnField.asset_amount: Int(1),\n                TxnField.fee: Int(0),\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.internal(TealType.none)\n    def pay_share(self, asset, to, amount):\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: asset,\n                TxnField.asset_receiver: to,\n                TxnField.asset_amount: amount,\n                TxnField.fee: Int(0)\n            }),\n            InnerTxnBuilder.Submit(),\n        )\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def redeem(self, asset: abi.Asset):\n        return self.move_asset(asset.asset_id(), self.address, Txn.sender())\n\n    @bkr.external(authorize=bkr.Authorize.only(supplier))\n    def withdraw(self, asset: abi.Asset, amount: abi.Uint64, to: abi.Account):\n        return self.pay_share(asset.asset_id(), to.address(), amount.get())\n\n    @bkr.external\n    def sell(self,\n             price: abi.Uint64,\n             nfticket: abi.Asset,\n             buyer: abi.Account,\n             protocol: abi.Account,\n             pay_asset: abi.Asset,\n             payment: abi.AssetTransferTransaction):\n        payment = payment.get()\n        return Seq(\n            # Payment to contract\n            #  (implicit) Payment asset\n            Assert(payment.asset_receiver() == self.address),\n            Assert(payment.xfer_asset() == pay_asset.asset_id()),\n\n            # Payment amount is sell price\n            Assert(payment.asset_amount() >= price.get()),\n\n            # Protocol Fee\n            Assert(self.protocol.get() == protocol.address()),\n            # (protocol_fee := ScratchVar(TealType.uint64)).store(price.get() * (self.protocol_fee.get() / Int(1000))),\n            (protocol_fee := abi.Uint64()).set(price.get() * self.protocol_fee.get() / Int(1000)),\n            # Pay to Protocol\n            self.pay_share(payment.xfer_asset(), protocol.address(), protocol_fee.get()),\n\n            # Seller profit\n            (sell_worth := abi.Uint64()).set(price.get() - protocol_fee.get()),\n            (supplier_share := abi.Uint64()).set(sell_worth.get() * self.supplier_share.get() / Int(1000)),\n            # Pay to seller\n            self.pay_share(payment.xfer_asset(), Txn.sender(), price.get() - supplier_share.get()),\n\n            # Move asset\n            #  (implicit check) Seller is owner\n            self.move_asset(nfticket.asset_id(), Txn.sender(), buyer.address())\n        )\n\n\nif __name__ == '__main__':\n    import sys\n    import json\n    import collections\n    from os import path\n\n    app = NFTicketManager()\n\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"--artifacts\":\n            app.dump(f\"{path.dirname(__file__)}/artifacts\")\n            exit(0)\n        if sys.argv[1] == \"--spec\":\n            spec = app.application_spec()\n\n\n            def cost(declared) -> collections.Counter:\n                return collections.Counter(map(lambda e: e[\"type\"], declared.values()))\n\n\n            print(cost(spec[\"schema\"][\"local\"][\"declared\"]))\n            print(cost(spec[\"schema\"][\"global\"][\"declared\"]))\n\n            sys.exit(0)\n        if sys.argv[1] == \"--abi\":\n            with open(__file__.replace(\".py\", \".abi.json\"), \"w\") as abi_fp:\n                json.dump(app.contract.dictify(), abi_fp, indent=2)\n\n    print(app.approval_program)"}
{"instruction": "Implement a DAO application and an NFT minter application. The DAO allows users to add proposals for NFTs, vote on them, and mint the winning proposal as an NFT using the minter application. The minter application receives NFT proposal details and creates an ASA with the provided parameters.", "output": "from pathlib import Path\n\nfrom typing import Literal\n\n\n\nfrom beaker import *\n\nfrom beaker.lib.storage import BoxMapping\n\nfrom pyteal import *\n\n\n\n\n\nclass NFTProposal(abi.NamedTuple):\n\n    url: abi.Field[abi.String]\n\n    metadata_hash: abi.Field[abi.StaticArray[abi.Byte, Literal[32]]]\n\n    name: abi.Field[abi.String]\n\n    unit_name: abi.Field[abi.String]\n\n    reserve: abi.Field[abi.Address]\n\n\n\n###############\n\n# DAO Contract\n\n###############\n\n\n\nclass DAOState:\n\n    # Global Storage\n\n    winning_proposal_votes = GlobalStateValue(\n\n        stack_type=TealType.uint64, default=Int(0)\n\n    )\n\n\n\n    winning_proposal = GlobalStateValue(stack_type=TealType.bytes, default=Bytes(\"\"))\n\n\n\n    # Box Storage\n\n    has_voted = BoxMapping(key_type=abi.Address, value_type=abi.Bool)\n\n    \n\n    proposals = BoxMapping(\n\n        key_type=abi.Tuple2[abi.Address, abi.Uint64],\n\n        value_type=NFTProposal,\n\n        prefix=Bytes(\"p-\"),\n\n    )\n\n\n\n    votes = BoxMapping(\n\n        key_type=abi.Tuple2[abi.Address, abi.Uint64],\n\n        value_type=abi.Uint64,\n\n        prefix=Bytes(\"v-\"),\n\n    )\n\n\n\ndao = Application(\"DAO\", state=DAOState)\n\n\n\n\n\n@dao.create(bare=True)\n\ndef create() -> Expr:\n\n    return dao.initialize_global_state()\n\n\n\n\n\n@dao.external\n\ndef add_proposal(\n\n    proposal: NFTProposal, proposal_id: abi.Uint64, mbr_payment: abi.PaymentTransaction\n\n) -> Expr:\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n    addr = abi.Address()\n\n\n\n    return Seq(\n\n        # Assert MBR payment is going to the contract\n\n        Assert(mbr_payment.get().receiver() == Global.current_application_address()),\n\n        # Get current MBR before adding proposal\n\n        pre_mbr := AccountParam.minBalance(Global.current_application_address()),\n\n        # Set proposal key\n\n        addr.set(Txn.sender()),\n\n        proposal_key.set(addr, proposal_id),\n\n        # Check if the proposal already exists\n\n        Assert(dao.state.proposals[proposal_key].exists() == Int(0)),\n\n        # Not using .get() here because desc is already a abi.String\n\n        dao.state.proposals[proposal_key].set(proposal),\n\n        # Verify payment covers MBR difference\n\n        current_mbr := AccountParam.minBalance(Global.current_application_address()),\n\n        Assert(mbr_payment.get().amount() >= current_mbr.value() - pre_mbr.value()),\n\n    )\n\n\n\n\n\n@dao.external\n\ndef vote(proposer: abi.Address, proposal_id: abi.Uint64) -> Expr:\n\n    total_votes = abi.Uint64()\n\n    current_votes = abi.Uint64()\n\n    true_value = abi.Bool()\n\n    zero_val = abi.Uint64()\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n\n\n    return Seq(\n\n        zero_val.set(Int(0)),\n\n        proposal_key.set(proposer, proposal_id),\n\n        # Make sure we haven't voted yet\n\n        Assert(dao.state.has_voted[Txn.sender()].exists() == Int(0)),\n\n        # Get current vote count\n\n        If(dao.state.votes[proposal_key].exists() == Int(0)).Then(\n\n            dao.state.votes[proposal_key].set(zero_val)\n\n        ),\n\n        dao.state.votes[proposal_key].store_into(current_votes),\n\n        # Increment and save total vote count\n\n        total_votes.set(current_votes.get() + Int(1)),\n\n        dao.state.votes[proposal_key].set(total_votes),\n\n        # Check if this proposal is now winning\n\n        If(total_votes.get() > dao.state.winning_proposal_votes.get()).Then(\n\n            dao.state.winning_proposal_votes.set(total_votes.get()),\n\n            dao.state.winning_proposal.set(proposal_key.encode()),\n\n        ),\n\n        # Set has_voted to true\n\n        true_value.set(value=True),\n\n        dao.state.has_voted[Txn.sender()].set(true_value),\n\n    )\n\n\n\n\n\n@dao.external\n\ndef mint(minter_app: abi.Application, *, output: abi.Uint64) -> Expr:\n\n    proposal_key = abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n    proposal = NFTProposal()\n\n\n\n    return Seq(\n\n        # Get the winning proposal key\n\n        proposal_key.decode(dao.state.winning_proposal.get()),\n\n        # Get the winning proposal\n\n        dao.state.proposals[proposal_key].store_into(proposal),\n\n        # Call NFT minter\n\n        InnerTxnBuilder.ExecuteMethodCall(\n\n            app_id=Tmpl.Int(\"TMPL_MINTER_APP\"),\n\n            method_signature=f\"mint_nft({NFTProposal().type_spec()})uint64\",\n\n            args=[proposal],\n\n        ),\n\n        # Return created asset\n\n        output.set(Btoi(Suffix(InnerTxn.last_log(), Int(4)))),\n\n    )\n\n\n\n\n\n#####################\n\n# NFT Minter Contract\n\n#####################\n\n\n\nminter = Application(\"Minter\")\n\n\n\n\n\n@minter.external\n\ndef mint_nft(proposal: NFTProposal, *, output: abi.Uint64) -> Expr:\n\n    name = abi.String()\n\n    unit_name = abi.String()\n\n    reserve = abi.Address()\n\n    url = abi.String()\n\n    metadata_hash = abi.make(abi.StaticArray[abi.Byte, Literal[32]])\n\n    abi.make(abi.Tuple2[abi.Address, abi.Uint64])\n\n\n\n    return Seq(\n\n        # Get properties from proposal and mint NFT\n\n        proposal.name.store_into(name),\n\n        proposal.unit_name.store_into(unit_name),\n\n        proposal.reserve.store_into(reserve),\n\n        proposal.url.store_into(url),\n\n        proposal.metadata_hash.store_into(metadata_hash),\n\n        InnerTxnBuilder.Execute(\n\n            {\n\n                TxnField.type_enum: TxnType.AssetConfig,\n\n                TxnField.config_asset_name: name.get(),\n\n                TxnField.config_asset_unit_name: unit_name.get(),\n\n                TxnField.config_asset_reserve: reserve.get(),\n\n                TxnField.config_asset_url: url.get(),\n\n                TxnField.config_asset_metadata_hash: metadata_hash.encode(),\n\n                TxnField.config_asset_total: Int(1),\n\n                TxnField.fee: Int(0),\n\n            }\n\n        ),\n\n        # Return created asset\n\n        output.set(InnerTxn.created_asset_id()),\n\n    )\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    dao.build().export(Path(__file__).resolve().parent / f\"./artifacts/{dao.name}\")\n\n    minter.build().export(\n\n        Path(__file__).resolve().parent / f\"./artifacts/{minter.name}\"\n\n    )"}
{"instruction": "Implement a Box Storage Escrow smart contract on Algorand, featuring deposit, withdraw, and mint functions. The contract allows users to deposit Algos, withdraw Algos (only by non-creator), and mint a non-fungible token (NFT). It supports updating and deleting the application only by the creator. Deposit, Withdrawal and recipient information are kept in global storage instead of Box Storage due to a bug with Algonaut. The contracts are written to TEAL files and the ABI contract definition to a JSON file.", "output": "#!/usr/bin/env python3\n# *************************************************\n# godot3-Dystopia-game by INhumanity_arts\n# Released under MIT License\n# *************************************************\n# Box Storage Escrow Smart Contract\n#\n# An ARC 4 Abi Smart Contract\n# THe Entire SmartContract Logic in one File.\n# \n# Features:\n# (1) Box Storage\n# (2) Withdrawals\n# (3) Deposit\n# (4) NFT minting\n\n# To Do:\n# (1) Onchain Method Call \n# (2) Box Storage isn't yet supported in Algonaut Rust Crate, rewrite to use Global Storage\n\nfrom pyteal import *\nfrom beaker import *\n\nimport base64\nimport hashlib\nfrom base64 import b64encode, b64decode\n\nfrom typing import Final\n\n#from beaker.lib.storage import Mapping\n\n\n#beaker documentation : https://algorand-devrel.github.io/beaker/html/application_client.html\n\n\nfrom algosdk.v2client import algod\nfrom algosdk import mnemonic\nfrom beaker.client.application_client import ApplicationClient\nfrom beaker.client.logic_error import LogicException\nfrom beaker.consts import Algos\n\nfrom beaker.lib.storage import Mapping\n\nimport json\nfrom simple_smart_contract import create_app, compile_program, call_app, delete_app, pay, call_app_method, pay_construct, get_application_address, update_app\n\nfrom algosdk.future import transaction\nfrom algosdk.abi import Contract\n\nfrom algosdk.encoding import decode_address , encode_address\n\n# For running Teal inspector\nimport subprocess\n\n# Arc 4 Smart Contract\n\nclass BoxEscrow(Application):\n\n    #uses nonce https://www.investopedia.com/terms/n/nonce.asp\n    hashed_secret: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes,\n        descr=\"A scratch for saving secret nonce to application state\",\n    )\n    \n    #store transaction details to  boxes\n    \n \n    \n    #Bare app calls https://pyteal.readthedocs.io/en/stable/abi.html?highlight=registrable%20methods#registering-bare-app-calls\n    @Subroutine(TealType.none)  \n    def assert_sender_is_creator() -> Expr:\n        return Seq(\n            If(Txn.sender() == Global.creator_address())\n            .Then (\n\n                # If box Storage Exists, delete them\n                Pop(App.box_delete(Bytes(\"BoxA\"))),\n                Pop(App.box_delete(Bytes(\"BoxB\"))),\n                Pop(App.box_delete(Bytes(\"BoxC\")))    \n\n\n                )\n\n            )\n\n\n\n    # move any balance that the user has into the \"lost\" amount when they close out or clear state\n    transfer_balance_to_lost = App.globalPut(\n        Bytes(\"lost\"),\n        App.globalGet(Bytes(\"lost\")) + App.localGet(Txn.sender(), Bytes(\"balance\")),\n    )\n\n\n    \n                \n                \n                \n    \"\"\"\n    Docs:\n        https://pyteal.readthedocs.io/en/stable/abi.html?highlight=call_config#registering-methods\n \n    \"\"\"\n    \n    my_router = Router(\n    name=\"AlgoBank\",\n    bare_calls=BareCallActions(\n        # approve a creation no-op call \n        #no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),\n        no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),\n        # approve opt-in calls during normal usage, and during creation as a convenience for the creator\n        opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL),\n        # move any balance that the user has into the \"lost\" amount when they close out or clear state\n        close_out=OnCompleteAction(\n            action=transfer_balance_to_lost, call_config=CallConfig.CALL\n        ),\n        clear_state=OnCompleteAction(\n            action=transfer_balance_to_lost, call_config=CallConfig.CALL\n        ),\n        # only the creator can update or delete the app\n        update_application=OnCompleteAction(\n            action=assert_sender_is_creator, call_config=CallConfig.CALL\n        ),\n        delete_application=OnCompleteAction(\n            action=assert_sender_is_creator, call_config=CallConfig.CALL\n            ),\n        ),\n    )\n\n    @my_router.method(no_op=CallConfig.CALL, opt_in=CallConfig.CALL)\n    def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:\n        \"\"\"This method receives a payment from an account opted into this app and records it as a deposit.\n\n        The caller may opt into this app during this call.\n\n        Args:\n            payment: A payment transaction containing the amount of Algos the user wishes to deposit.\n                The receiver of this transaction must be this app's escrow account.\n            sender: An account that is opted into this app (or will opt in during this method call).\n                The deposited funds will be recorded in this account's local state. This account must\n                be the same as the sender of the `payment` transaction.\n        \"\"\"\n        return Seq(\n            Assert(payment.get().sender() == sender.address()),\n            Assert(payment.get().receiver() == Global.current_application_address()),\n\n\n        #Global Storage\n        App.globalPut(Bytes(\"Depositors\"), sender.address()),\n                \n\n        # Disabling Box Storage Until it's implemented in Algonaut\n\n        # write to box `A` with new value\n        # Deposit Address\n        #Pop(App.box_create(Bytes(\"BoxA\"), Int(10))),\n        #App.box_put(Bytes(\"BoxA\"), sender.address())\n\n        )\n\n\n    @my_router.method\n    def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:\n        \"\"\"Lookup the balance of a user held by this app.\n\n        Args:\n            user: The user whose balance you wish to look up. This user must be opted into this app.\n\n        Returns:\n            The balance corresponding to the given user, in microAlgos.\n        \"\"\"\n\n\n        return output.set(App.localGet(user.address(), Bytes(\"balance\")))\n\n\n    @my_router.method\n    def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:\n        \"\"\"Withdraw an amount of Algos held by this app.\n\n        The sender of this method call will be the source of the Algos, and the destination will be\n        the `recipient` argument.\n\n        The Algos will be transferred to the recipient using an inner transaction whose fee is set\n        to 0, meaning the caller's transaction must include a surplus fee to cover the inner\n        transaction.\n\n        Args:\n            amount: The amount of Algos requested to be withdraw, in microAlgos. This method will fail\n                if this amount exceeds the amount of Algos held by this app for the method call sender.\n            recipient: An account who will receive the withdrawn Algos. This may or may not be the same\n                as the method call sender.\n        \"\"\"\n        return Seq(\n\n            If(Txn.sender() != Global.creator_address()) \n\n            .Then( \n\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields(\n                    {\n                        TxnField.type_enum: TxnType.Payment,\n                        TxnField.receiver: recipient.address(),\n                        TxnField.amount: amount.get(),\n                        TxnField.fee: Int(0),\n                    }\n                ),\n                InnerTxnBuilder.Submit(),\n\n                #Global Storage\n                App.globalPut(Bytes(\"Withdrwl\"), amount.get()),\n                \n                App.globalPut(Bytes(\"Receipient\"), recipient.address()),\n                \n                \n                # Disabling Box Storages until it'simplemented in Algonaut\n\n                # write to box `B` with new value \"Withdrawal Amount\"\n                # converted from an Integer to a Byte\n                # App.box_put(Bytes(\"BoxB\"), Itob(amount.get())),\n                \n                # write to box `C` with new value \"Withdrawal To Address\"\n                #App.box_put(Bytes(\"BoxC\"), recipient.address())\n                )\n            .ElseIf( Txn.sender() == Global.creator_address())\n            .Then(Approve())\n        )\n\n\n    \n    #    \"\"\"\n    #    Triggers an Abi method call via smartcontracts\n\n\n    #    Args:\n    #        Abi Arguments to this method via BareApp calls\n\n    #    Docs: https://pyteal.readthedocs.io/en/stable/api.html?highlight=MethodCall#pyteal.InnerTxnBuilder.MethodCall\n\n    #    \"\"\"\n\n\n\n\n    @my_router.method\n    def mint(recipient : abi.Account, payment: abi.PaymentTransaction) -> Expr:\n        \"\"\"Mints an Asset Token To a Recipient Wallet Address\n            the caller's transaction must include a surplus fee to cover the inner\n            transaction\n\n        Args:\n            recipient: An account who will receive the withdrawn Algos. This may or may not be the same \n            as the method call sender.\n\n        Docs: https://pyteal.readthedocs.io/en/stable/api.html#pyteal.TxnExpr\n\n        \"\"\"\n\n        return Seq(\n            InnerTxnBuilder.Begin(),\n            InnerTxnBuilder.SetFields({\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: Int(1),\n                TxnField.config_asset_decimals: Int(1),\n                TxnField.config_asset_unit_name: Bytes(\"PUNK 001\"),\n                TxnField.config_asset_name: Bytes(\"CryptoPunk\"),\n                TxnField.config_asset_url: Bytes(\"ipfs://QmXYApu5uDsfQHMx149LWJy3x5XRssUeiPzvqPJyLV2ABx\"), #CryptoPunk Asset CID\n                TxnField.config_asset_manager: Global.current_application_address(),\n                TxnField.config_asset_reserve: Global.current_application_address(),\n                TxnField.config_asset_freeze: Global.current_application_address(),\n                TxnField.config_asset_clawback: Global.current_application_address(),\n            }),\n            InnerTxnBuilder.Submit(),\n\n            #Bug for Testing debug state\n\n            #InnerTxnBuilder.Begin(),\n            #InnerTxnBuilder.SetFields({\n            #    TxnField.type_enum: TxnType.AssetTransfer,\n            #   TxnField.asset_receiver: recipient.address(),\n            #    TxnField.asset_amount: Int(1),\n            #    TxnField.xfer_asset: Txn.assets[0], # Must be in the assets array sent as part of the application call\n            #}),\n            #InnerTxnBuilder.Submit(),\n\n        )\n\n\n\n    approval_program, clear_state_program, contract = my_router.compile_program(\n        version=8, optimize=OptimizeOptions(scratch_slots=True)\n    )\n\n\n\n\n\n    \"\"\"\n    Write Out the Approval and Clear Programs. \n    Dump the Contract's method to a .json file.\n\n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"w\") as f:\n        f.write(approval_program)\n\n    with open(\"algobank_clear_state.teal\", \"w\") as f:\n        f.write(clear_state_program)\n        \n    with open(\"algobank.json\", \"w\") as f:\n        f.write(json.dumps(contract.dictify(), indent=4))\n\n\n\n\n\n\n\n\n\n    \n\n# Sha 265 Hashes a String\ndef sha256b64(s: str) -> str:\n    return base64.b64encode(hashlib.sha256(str(s).encode(\"utf-8\")).digest()).decode(\"utf-8\")\n\n#Configured to Testnet\n#\n#\ndef create_algorand_node_and_acct(command: str):\n    \n    # test-net\n    algod_address = \"https://node.testnet.algoexplorerapi.io\"\n    algod_token = \"\"\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n\n\n    _params = algod_client.suggested_params()\n\n    __mnemonic : str = \"tank game arrive train bring taxi tackle popular bacon gasp tell pigeon error step leaf zone suit chest next swim luggage oblige opinion about execute\"\n\n    __mnemonic_2 : str = \"degree feature waste gospel screen near subject boost wreck proof caution hen adapt fiber fault level blind entry also embark oval board bunker absorb garage\"\n\n    __mnemonic_3 : str = \"scrub garment fashion column property obscure agree mobile maple stage pass boat snow diary canyon lesson under curtain impact earn calm maximum song ability together\"\n\n\n    #For Sandbox\n    #client = sandbox.get_algod_client()\n\n    #accts = sandbox.get_accounts()\n\n    accts = {}\n    accts[1] = {}\n    accts[1]['pk'] = mnemonic.to_public_key(__mnemonic) #saves the new account's address\n    accts[1]['sk'] = mnemonic.to_private_key(__mnemonic) #saves the new account's mnemonic\n    \n    mnemonic_obj_a1 = mnemonic.to_private_key(__mnemonic)\n    mnemonic_obj_a2 = mnemonic.to_public_key(__mnemonic)\n    \n    #acct = accts.pop()\n\n    print('Algod Client Status: ',algod_client.status())\n\n    print (accts[1])\n\n    #other accounts\n    accts[2] = {}\n    accts[2]['pk'] = mnemonic.to_public_key(__mnemonic_2)\n    accts[2]['sk'] = mnemonic.to_private_key(__mnemonic_2)\n\n    accts[3] = {}\n    accts[3]['pk'] = mnemonic.to_public_key(__mnemonic_3)\n    accts[3]['sk'] = mnemonic.to_private_key(__mnemonic_3)\n\n\n\n    mnemonic_obj_b1 = mnemonic.to_private_key(__mnemonic_2)\n    mnemonic_obj_b2 = mnemonic.to_public_key(__mnemonic_2)\n    \n\n\n    # Create an Application client containing both an algod client and my app\n    \n    app_client = algod.AlgodClient(algod_token, algod_address,headers={'User-Agent': 'DoYouLoveMe?'})\n\n    \n\n    _app_id : int = 157718578  \n\n    escrow_address =get_application_address(_app_id)\n\n    pc :int = 79\n\n    print('Algod Client Status: ',algod_client.status())\n\n    command = input(\"Enter command  [deploy,pay,withdraw,deposit,mint,fetch, fetch2, balance, delete, update ,debug ]  \")\n    \n    \"*****************Perform Transactions Operations**********************\"\n\n    match command:\n        case \"deploy\":\n\n            \n\n\n\n            \"Deploy Smart Contract\"\n            deploy(_params, accts[1]['sk'],algod_client, 2500)\n        case \"delete\":\n    \n            \"Delete Smart Contract\"\n            delete_app(algod_client, accts[1]['sk'], _app_id)\n        case \"pay\" :\n        \n            \n\n            \"Pay to Account\"\n            pay(algod_client, accts[1]['sk'], escrow_address, 1101101)\n\n        case \"withdraw\":\n    \n            \n            call_app_method(app_client,accts[3]['sk'],_app_id, 2500,get_method(\"withdraw\"), 10_000,accts[3]['pk'] )\n\n        case \"deposit\":\n\n        \n\n            print (\"depositing 101100 MicroAlgos to Escrow Address \", escrow_address)\n\n            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)\n\n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"deposit\"), txn ,accts[2]['pk'] )\n        case \"update\":\n\n\n            update_(app_client, _app_id, _params,accts[1]['sk'])\n\n\n        case \"mint\":\n\n            txn = pay_construct(app_client, accts[2]['pk'], escrow_address , accts[2]['sk'], 101100)            \n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"mint\"), accts[2]['pk'] ,txn )\n            \n\n        case \"fetch\" :\n            \n            #Prints Withdrawal & Deposit Information from box storage as Raw Bytes\n            \n\n            print(\"Withdrawal Amounts: \",app_client.application_box_by_name(_app_id,bytes(\"BoxB\".encode('utf-8', 'strict'))))\n\n            print(\"Withdrawal recipients: \",app_client.application_box_by_name(_app_id,bytes(\"BoxC\".encode('utf-8', 'strict'))))\n  \n            print(\"Depositors Address: \", app_client.application_box_by_name(_app_id,bytes(\"BoxA\".encode('utf-8', 'strict'))))\n\n        case \"fetch2\" :\n            #Prints Withdrawal & Deposit Information from box storage Decoded to Int and String\n            #Documentation: https://developer.algorand.org/docs/get-details/encoding/\n            \n            result2 = app_client.application_box_by_name(_app_id,bytes(\"BoxC\".encode('utf-8', 'strict')))\n            q =encode_address(base64.b64decode(result2[\"value\"]))\n            print (\"Withdrawal recipients: \",q)\n\n\n            result3 = app_client.application_box_by_name(_app_id,bytes(\"BoxA\".encode('utf-8', 'strict')))\n            g =encode_address(base64.b64decode(result3[\"value\"]))\n            print (\"Depositors Addresses: \",g)\n\n\n\n            result =app_client.application_box_by_name(_app_id,bytes(\"BoxB\".encode('utf-8', 'strict')))\n            \n            p = int.from_bytes(base64.b64decode(result[\"value\"]), byteorder=\"big\")\n            print(\"Withdrawal Amount: \",p)\n\n            \n\n        case \"balance\":\n\n            call_app_method(app_client,accts[2]['sk'],_app_id, 2500,get_method(\"balance\"),accts[2]['pk'] )\n\n        case \"debug\":\n            pc =input (\"enter program counter\")\n            # Using system() method  and Teal Inspector to\n            # execute shell commands\n            subprocess.Popen('tealinspector --network testnet --application_id {} --program_counter {}'.format(_app_id, pc), shell=True)\n\n        case other:\n            print (\"No Match Found, Please Pass a Valid command to this Method in ln 309\")\n\n\n# Utility function to get the Method object for a given method name\ndef get_method(name: str) :\n    with open(\"algobank.json\") as f:\n        js = f.read()\n    c = Contract.from_json(js)\n    for m in c.methods:\n        if m.name == name:\n            print (\"M: \",m.name)\n            return m\n    raise Exception(\"No method with the name {}\".format(name))\n\n\ndef update_(algod_client, app_id, params, private_key):\n\n    #Docs: https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/transaction.html?highlight=ApplicationUpdateTxn#algosdk.transaction.ApplicationUpdateTxn\n\n\n    # Read the compiled approvl & clear programs Teal files \n    \n    \"\"\"\n   \n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"r\") as f:\n        approval_program = f.read()\n\n    with open(\"algobank_clear_state.teal\", \"r\") as f:\n        clear_state_program= f.read()\n   \n\n    # compile program to binary\n    approval_program_compiled = compile_program(algod_client, approval_program)\n\n    # compile program to binary\n    clear_state_program_compiled = compile_program(algod_client, clear_state_program)\n\n    update_app(algod_client, app_id, params ,private_key, approval_program_compiled,clear_state_program_compiled)\n\n\n\ndef deploy(_params, mnemonic_ ,algod_client, fee):\n\n    _params.flat_fee = True\n    _params.fee = fee\n\n\n    # declare application state storage (immutable)\n    local_ints = 0\n    local_bytes = 0\n    global_ints = 1\n    global_bytes = 1\n    global_schema = transaction.StateSchema(global_ints, global_bytes)\n    local_schema = transaction.StateSchema(local_ints, local_bytes)\n\n\n    # Read the compiled approvl & clear programs Teal files \n    \n    \"\"\"\n   \n    \"\"\"\n\n    with open(\"algobank_approval.teal\", \"r\") as f:\n        approval_program = f.read()\n\n    with open(\"algobank_clear_state.teal\", \"r\") as f:\n        clear_state_program= f.read()\n   \n\n\n    \n\n\n\n    response = algod_client.compile(approval_program)\n    print (\"Raw Response =\",response )\n    print(\"Response Result = \",response['result'])\n    print(\"Response Hash = \",response['hash'])\n\n\n    # compile program to binary\n    approval_program_compiled = compile_program(algod_client, approval_program)\n\n    # compile program to binary\n    clear_state_program_compiled = compile_program(algod_client, clear_state_program)\n\n\n    app_id = create_app(algod_client,_params ,mnemonic_, approval_program_compiled, clear_state_program_compiled, global_schema, local_schema)\n\n    # Create the applicatiion on chain, set the app id for the app client & store app secret\n    print(f\"Created App with id: {app_id} \")\n\n\n\"\"\"\nTHE MAIN METHOD\n\"\"\"\n\nif __name__ == \"__main__\":\n    \n    #Builds the progam and deploys\n    ca = BoxEscrow()\n    \n\n    # Application State Machine\n    create_algorand_node_and_acct(\"\")"}
{"instruction": "The code simulates a donation process to charities using Algorand. It compiles a smart signature escrow account for donations, allows the user to choose a charity, activates the escrow by sending Algos, mints an NFT as a certificate of donation, withdraws Algos from the escrow to the charity, transfers the NFT to the donor, and then freezes the NFT to prevent further transfer.", "output": "import base64\nfrom typing import Tuple\nfrom algosdk import mnemonic, transaction, account\nfrom algosdk.v2client import algod\nfrom pyteal import *\n\nprint(\"  \")\nprint(\"  \")\n\ntxn_history = {}\n\n\ndef donation_escrow(benefactor):\n\n    # Getting AppID\n    # AppID = AppParamObject\n    # Getting Minimum Allowed Fee\n    Fee = Global.min_txn_fee()\n\n    program = And(\n        Global.group_size() == Int(1),\n        Txn.rekey_to() == Global.zero_address(),\n        Txn.fee() <= Fee,\n        Or(\n            And(\n                Txn.type_enum() == TxnType.Payment,\n                Txn.receiver() == Addr(benefactor),\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetConfig,\n                Txn.config_asset_total() == Int(1),\n                Txn.config_asset_unit_name() == Bytes(\"AlD\")\n                # ensure nft is the logo of the charity\n                # Txn.config_asset_url()\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetTransfer,\n\n            ),\n            And(\n                Txn.type_enum() == TxnType.AssetFreeze,\n            )\n        )\n    )\n\n    return compileTeal(program, Mode.Signature, version=5)\n\n\n# user declared account mnemonics\nbenefactor_mnemonic = \"mom lottery uniform olive visa occur garlic artefact minimum reward custom legend suit stock install leg doctor favorite retreat cart all exact camp able cute\"\nsender_mnemonic = \"shoe onion turkey shallow belt drop owner merit eager reflect radio gravity stone eyebrow busy dolphin verb bonus load unit engage young decrease ability fame\"\n\n\n# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config\nalgod_address = \"http://localhost:4001\"\nalgod_token = \"a\" * 64\n\n# helper function to compile program source\n\n\ndef compile_smart_signature(\n    client: algod.AlgodClient, source_code: str\n) -> Tuple[str, str]:\n    compile_response = client.compile(source_code)\n    return compile_response[\"result\"], compile_response[\"hash\"]\n\n\ndef payment_transaction(\n    creator_mnemonic: str, amt: int, rcv: str, algod_client: algod.AlgodClient\n) -> dict:\n    creator_pk = mnemonic.to_private_key(creator_mnemonic)\n    creator_address = account.address_from_private_key(creator_pk)\n\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(creator_address, params, rcv, amt)\n    signed = unsigned_txn.sign(creator_pk)\n\n    txid = algod_client.send_transaction(signed)\n    pmtx = transaction.wait_for_confirmation(algod_client, txid, 5)\n    return txid, pmtx[\"txn\"][\"txn\"]\n\n\n# for minting nft\ndef mint_nft(encoded_program: str, algod_client: algod.AlgodClient):\n    sp = algod_client.suggested_params()\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # define NFT asset parameters\n    txn = transaction.AssetConfigTxn(\n        sender=lsig.address(),\n        sp=sp,\n        default_frozen=False,\n        unit_name=\"AlD\",\n        asset_name=\"AlDonate NFT\",\n        manager=lsig.address(),\n        reserve=lsig.address(),\n        freeze=lsig.address(),\n        clawback=lsig.address(),\n        url=\"https://tinyurl.com/mt3yzhz4\",\n        total=1,\n        decimals=0,\n    )\n\n    # sign the transaction using the logic signature\n    stxn = transaction.LogicSigTransaction(txn, lsig)\n\n    # send the transaction to the network\n    tx_id = algod_client.send_transaction(stxn)\n    print(\"\")\n    print(f\"Minting Transaction ID: {tx_id}\")\n    print(\"\")\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 5)\n\n    return pmtx\n\n# perform opt in transaction for minted NFT\n\n\ndef opt_in_nft(\n    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str\n):\n    sp = algod_client.suggested_params()\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n    optin_txn = transaction.AssetOptInTxn(\n        sender=receiver_address, sp=sp, index=asset_id\n    )\n    signed_optin_txn = optin_txn.sign(receiver_pk)\n    txid = algod_client.send_transaction(signed_optin_txn)\n    print(\"\")\n    print(f\"Opting in your wallet to receive NFT: {txid}\")\n\n    # Wait for the transaction to be confirmed\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n    print(\"\")\n\n\ndef transfer_nft_to_donor(\n        encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str, id, txn):\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n    opt_in_nft(encoded_program, asset_id, algod_client, receiver_mnemonic)\n\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n    note = f\"Transaction: {id}, Amount: {txn['amt']}, Fee: {txn['fee']}\".encode(\n    )\n    # Transfer the newly created NFT from escrow to donor\n    txn = transaction.AssetTransferTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        receiver=receiver_address,\n        amt=1,\n        index=asset_id,\n        note=note\n    )\n    stxn = transaction.LogicSigTransaction(txn, lsig)\n    txid = algod_client.send_transaction(stxn)\n\n    print(f\"Sent asset transfer transaction with txid: {txid}\")\n    # Wait for the transaction to be confirmed\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n\n\ndef freeze_donor_nft(\n    encoded_program: str, asset_id: int, algod_client: algod.AlgodClient, receiver_mnemonic: str\n):\n    receiver_pk = mnemonic.to_private_key(receiver_mnemonic)\n    receiver_address = account.address_from_private_key(receiver_pk)\n\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # Create freeze transaction to freeze the asset in acct2 balance\n    freeze_txn = transaction.AssetFreezeTxn(\n        sender=lsig.address(),\n        sp=algod_client.suggested_params(),\n        target=receiver_address,\n        index=asset_id,\n        new_freeze_state=True,\n    )\n\n    stxn = transaction.LogicSigTransaction(freeze_txn, lsig)\n    txid = algod_client.send_transaction(stxn)\n    results = transaction.wait_for_confirmation(algod_client, txid, 4)\n    print(\"\")\n    print(f\"Sent freeze transaction with txid: {txid}\")\n    print(f\"Result confirmed in round: {results['confirmed-round']}\")\n    print(\"\")\n    print(\"Congrats! NFT has been transferred to you! Note: You will not be able to transfer this asset\")\n\n\ndef lsig_payment_txn(\n    encoded_program: str, amt: int, rcv: str, algod_client: algod.AlgodClient\n):\n    # Create an lsig object using the compiled, b64 encoded program\n    program = base64.b64decode(encoded_program)\n    lsig = transaction.LogicSigAccount(program)\n\n    # Create transaction with the lsig address as the sender\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(lsig.address(), params, rcv, amt)\n\n    # sign the transaction using the logic\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\ndef main():\n    # initialize an algodClient\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n    # define private keys\n    private_key = mnemonic.to_private_key(benefactor_mnemonic)\n    # receiver_public_key = account.address_from_private_key(private_key)\n\n    print(\"\")\n    print(\"\")\n    print(\"\")\n    print(\"Thank you for your donation! Which charity will you like to send the donation to? Key in the number:\")\n    print(\"\")\n    print(\"\")\n\n    choice = 0\n\n    while (choice != 3):\n\n        print(\"1: NKF  || Onboarded suppliers: - Penny Appeal(Turkey Food Donation), - Ikea Foundation(Turkey Shelters)\")\n        print(\"2: WWF  || Onboarded suppliers: - Ghana Stores(Ghana Food Donation)\")\n        print(\"3: To exit this application\")\n        print(\"4: View your Donations\")\n        choice = int(input())\n        charity = \"\"\n\n        if choice == 1:\n            print(\"sending donation to NKF\")\n            charity = \"NKF\"\n            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'\n\n        elif choice == 2:\n            print(\"sending donation to WWF\")\n            charity = \"WWF\"\n            receiver_public_key = 'XHT4KIAFOP4626AFLA6GMOMST4QO3AO2XADMIJJOACMFEGT5GLA6LOCLWQ'\n\n        elif choice == 3:\n            break\n\n        elif choice == 4:\n            for charity, transactions_list in txn_history.items():\n                print(f\"Transactions for {charity}:\")\n                for txn in transactions_list:\n                    print(f\"\\tTransaction ID: {txn['txn_id']}\")\n                    print(f\"\\tAmount Donated: {txn['amount_donated']}\")\n                    print(f\"\\tCertificate ID: {txn['certificate_id']}\\n\")\n\n            continue\n\n        else:\n            print(\"Sending donation to NKF\")\n            charity = \"NKF\"\n            receiver_public_key = 'S5EEOYBI6FDZT6AF6O342CJEMX3JOO5J2KLX6ST3JOGKDKMBYGDHZYJA6E'\n\n        print(\"\")\n        print(\"Compiling Donation Smart Signature......\")\n        print(\"\")\n        stateless_program_teal = donation_escrow(receiver_public_key)\n        escrow_result, escrow_address = compile_smart_signature(\n            algod_client, stateless_program_teal\n        )\n\n        print(\"Program:\", escrow_result)\n        print(\"LSig Address: \", escrow_address)\n        print(\"\")\n        print(\"Activating Donation Smart Signature......\")\n\n        # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator\n        amt = 100000\n        id, txn = payment_transaction(\n            sender_mnemonic, amt, escrow_address, algod_client)\n\n        if charity not in txn_history.keys():\n            txn_history[charity] = []\n\n        # Mint NFT using the escrow address\n        print(\"Thank you for your donation, Minting NFT......\")\n        pmtx = mint_nft(escrow_result, algod_client)\n        created_asset = pmtx[\"asset-index\"]\n\n        txn_history[charity].append(\n            {\"txn_id\": id, \"amount_donated\": amt, \"certificate_id\": created_asset})\n\n        print(\"\")\n        print(\"Withdrawing from Donation Smart Signature......\")\n        print(f\"NFT Address: {created_asset}\")\n\n        # Withdraws 1 ALGO from smart signature using logic signature.\n        withdrawal_amt = 10000\n        lsig_payment_txn(escrow_result, withdrawal_amt,\n                         receiver_public_key, algod_client)\n\n        transfer_nft_to_donor(escrow_result, created_asset,\n                              algod_client, sender_mnemonic, id, txn)\n        freeze_donor_nft(escrow_result, created_asset,\n                         algod_client, sender_mnemonic)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"instruction": "This Algorand smart contract implements a non-fungible token (NFT) called 'Pure NFT' with unit name 'NFP1023'. It allows for initializing an admin role, setting a new admin, minting tokens to accounts, and transferring tokens between accounts.  The contract manages a global reserve to track the number of available tokens for minting.  When an account closes out, their local balance is returned to the global reserve.", "output": "from pyteal import *\n\ndef approval():\n    on_creation = Seq([\n        App.globalPut(Bytes(\"AssetName\"), Bytes(\"Pure NFT\")),\n        App.globalPut(Bytes(\"UnitName\"), Bytes(\"NFP1023\")),\n        App.globalPut(Bytes(\"Decimals\"), Int(0)),\n        App.globalPut(Bytes(\"Total\"), Int(1)),\n        App.globalPut(Bytes(\"GlobalReserve\"), Int(1)),\n        Return(Int(1)),\n    ])\n\n    opt_in = Seq([\n        App.localPut(Int(0), Bytes(\"LocalBalance\"), Int(0)),\n        Return(Int(1))\n    ])\n\n    init_admin = Seq([\n        Assert(Txn.sender() == Global.creator_address()),\n        App.localPut(Int(0), Bytes(\"Admin\"), Int(1)),\n        Return(Int(1))\n    ])\n\n    is_admin = App.localGet(Int(0), Bytes(\"Admin\"))\n\n    set_admin = Seq([\n        Assert(And(is_admin, Txn.application_args.length() == Int(1))),\n        App.localPut(Int(1), Bytes(\"Admin\"), Int(1)),\n        Return(Int(1)),\n    ])\n\n    on_closeout = Seq([\n        App.globalPut(Bytes(\"GlobalReserve\"), App.globalGet(Bytes(\"GlobalReserve\")) + App.localGet(Int(0), Bytes(\"LocalBalance\"))),\n        Return(Int(1)),\n    ])\n\n    mint = Seq([\n        Assert(Txn.application_args.length() == Int(2)),\n        Assert(Btoi(Txn.application_args[1]) <= App.globalGet(Bytes(\"GlobalReserve\"))),\n        App.globalPut(Bytes(\"GlobalReserve\"), App.globalGet(Bytes(\"GlobalReserve\")) - Btoi(Txn.application_args[1])),\n        App.localPut(Int(0), Bytes(\"LocalBalance\"), App.localGet(Int(0), Bytes(\"LocalBalance\")) + Btoi(Txn.application_args[1])),\n        Return(is_admin),\n    ])\n\n    transfer_amount = Btoi(Txn.application_args[1])\n    transfer = Seq([\n        Assert(Txn.application_args.length() == Int(2)),\n        Assert(transfer_amount <= App.localGet(Int(0), Bytes(\"LocalBalance\"))),\n        App.localPut(Int(0), Bytes(\"LocalBalance\"), App.localGet(Int(0), Bytes(\"LocalBalance\")) - transfer_amount),\n        App.localPut(Int(1), Bytes(\"LocalBalance\"), App.localGet(Int(1), Bytes(\"LocalBalance\")) + transfer_amount),\n        Return(Int(1)),\n    ])\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, opt_in],\n        [Txn.application_args[0] == Bytes(\"Init_Admin\"), init_admin],\n        [Txn.application_args[0] == Bytes(\"Set_Admin\"), set_admin],\n        [Txn.application_args[0] == Bytes(\"Mint\"), mint],\n        [Txn.application_args[0] == Bytes(\"Transfer\"), transfer],\n    )\n\n    return program\n\ndef clear():\n    return Seq([\n        App.globalPut(Bytes(\"GlobalReserve\"), App.globalGet(Bytes(\"GlobalReserve\")) + App.localGet(Int(0), Bytes(\"LocalBalance\"))),\n        Return(Int(1))\n    ])\n\nif __name__ == \"__main__\":\n    with open(\"approval.teal\", \"w\") as f:\n        f.write(compileTeal(approval(), mode=Mode.Application, version=6))\n    with open(\"clear.teal\", \"w\") as f:\n        f.write(compileTeal(clear(), mode=Mode.Application, version=6))"}
{"instruction": "Generate two TEAL programs: an approval program that sets a global state variable 'Initialized' to 1, and a clear state program that always succeeds. Write the compiled TEAL code for each program to separate files.", "output": "from pyteal import *\n\nclass MyContract:\n    def __init__(self):\n        self.global_uints = 1\n        self.global_bytes = 1\n        self.local_uints = 1\n        self.local_bytes = 1\n\n    def approval_program(self):\n        return Seq([\n            App.globalPut(Bytes(\"Initialized\"), Int(1)),\n            Return(Int(1))\n        ])\n\n    def clear_state_program(self):\n        return Return(Int(1))\n\nif __name__ == \"__main__\":\n    contract = MyContract()\n    with open(\"approval.teal\", \"w\") as f:\n        compiled = compileTeal(contract.approval_program(), mode=Mode.Application, version=6)\n        f.write(compiled)\n    with open(\"clear.teal\", \"w\") as f:\n        compiled = compileTeal(contract.clear_state_program(), mode=Mode.Application, version=6)\n        f.write(compiled)"}
{"instruction": "Deploy an Algorand Smart Contract that maintains a global counter. The contract initializes the counter to 0 and sets the deployer as the admin upon creation. Users can increment the counter by calling the contract with the argument 'increment'. The contract also implements a clear state program that always returns success.", "output": "from pyteal import *\n\ndef approval_program():\n    counter_key = Bytes(\"counter\")\n    admin_key = Bytes(\"admin\")\n\n    on_creation = Seq([\n        App.globalPut(counter_key, Int(0)),\n        App.globalPut(admin_key, Txn.sender()),\n        Return(Int(1))\n    ])\n\n    increment_counter = Seq([\n        App.globalPut(counter_key, App.globalGet(counter_key) + Int(1)),\n        Return(Int(1))\n    ])\n\n    handle_noop = Cond(\n        [Txn.application_args[0] == Bytes(\"increment\"), increment_counter]\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.NoOp, handle_noop]\n    )\n\n    return program\n\ndef clear_state_program():\n    return Return(Int(1))"}
{"instruction": "Create an Algorand smart contract with the following functionality: On creation, store the creator's address and a fee amount (provided as the first application argument) in global state. Upon receiving a 'respond' NoOp transaction, verify that the sender is the creator and then send a payment of the stored fee amount to the address provided as the second application argument. Clear state calls are always approved.", "output": "from pyteal import *\n\ndef approval_program():\n    creator_key = Bytes(\"creator\")\n    fee_key = Bytes(\"fee\")\n\n    on_create = Seq([\n        App.globalPut(creator_key, Txn.sender()),\n        App.globalPut(fee_key, Btoi(Txn.application_args[0])),\n        Return(Int(1))\n    ])\n\n    respond_to_incident = Seq([\n        Assert(Txn.sender() == App.globalGet(creator_key)),\n        Assert(Txn.application_args.length() == Int(2)),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.application_args[1],\n            TxnField.amount: App.globalGet(fee_key),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n\n    handle_noop = Cond(\n        [Txn.application_args[0] == Bytes(\"respond\"), respond_to_incident]\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, handle_noop]\n    )\n\n    return program\n\ndef clear_state_program():\n    return Return(Int(1))"}
{"instruction": "Provides an Algorand smart contract client for interacting with an Escrow application, including methods for calling contract functions, creating transactions, deploying the contract, and managing its state.", "output": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": []}, \"methods\": [{\"actions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"args\": [{\"type\": \"uint64\", \"name\": \"value\"}, {\"type\": \"account\", \"name\": \"seller\"}, {\"type\": \"account\", \"name\": \"buyer\"}, {\"type\": \"account\", \"name\": \"arbitrator\"}, {\"type\": \"uint64\", \"name\": \"escrow_duration\"}], \"name\": \"create_application\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"pay\", \"name\": \"payment\"}], \"name\": \"deposit_funds\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"release_funds_to_seller\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"refund_funds_to_buyer\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"raise_dispute\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"string\", \"name\": \"decision\"}], \"name\": \"resolve_dispute\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"expire_escrow\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"DeleteApplication\"], \"create\": []}, \"args\": [], \"name\": \"delete_application\", \"returns\": {\"type\": \"void\"}, \"events\": [], \"readonly\": false, \"recommendations\": {}}], \"name\": \"Escrow\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"seller\": {\"key\": \"c2VsbGVy\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}, \"buyer\": {\"key\": \"YnV5ZXI=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}, \"arbitrator\": {\"key\": \"YXJiaXRyYXRvcg==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}, \"amount\": {\"key\": \"YW1vdW50\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"escrow_expiry\": {\"key\": \"ZXNjcm93X2V4cGlyeQ==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"is_disputed\": {\"key\": \"aXNfZGlzcHV0ZWQ=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"is_settled\": {\"key\": \"aXNfc2V0dGxlZA==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"value\": {\"key\": \"dmFsdWU=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}}, \"local\": {}}, \"maps\": {\"box\": {}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 3, \"ints\": 5}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {}, \"byteCode\": {\"approval\": \"CiADAAHoByYHCmlzX3NldHRsZWQFYnV5ZXIFdmFsdWUGc2VsbGVyCmFyYml0cmF0b3ILaXNfZGlzcHV0ZWQNZXNjcm93X2V4cGlyeTEbQQA/gggEP+TTmgT9xpXCBDHOdZcENMl5yQRDmCZdBJG0UyoEUSH3QQQzs0meNhoAjggAaABSAEYAOgAuABwAEAACIkMxGYEFEkQxGESIAekjQzEZFEQxGESIAcojQzEZFEQxGEQ2GgFXAgCIAWUjQzEZFEQxGESIASQjQzEZFEQxGESIANYjQzEZFEQxGESIAIgjQzEZFEQxGEQxFiMJSTgQIxJEiABOI0MxGRREMRgURDYaARc2GgIXwBw2GgMXwBw2GgQXwBw2GgUXiAACI0OKBQAqi/tnK4v8ZymL/WcnBIv+ZzIHi/8IJwZMZycFImcoImeJigEAMQAiKWVEEkSL/zgHMgoSRIv/OAgiKmVEEkQiKGVEFESJigAAMQBJIillRCInBGVMTgNEEkAACIsAiwESQQAgI0QiKGVEFESxIitlRCIqZUSyCLIHI7IQJLIBsygjZ4kiQv/digAAMQBJIitlRCInBGVMTgNEEkAACIsAiwESQQAgI0QiKGVEFESxIillRCIqZUSyCLIHI7IQJLIBsygjZ4kiQv/digAAMQBJIillRCIrZUxOA0QSQAAIiwCLARJBABQjRCInBWVEFEQiKGVEFEQnBSNniSJC/+mKAQAxACInBGVEEkQiJwVlREQiKGVEFESL/4ARcmVsZWFzZV90b19zZWxsZXISQQAHiP8TKCNniYv/gA9yZWZ1bmRfdG9fYnV5ZXISRIj/OUL/4TIHIicGZUQPRCIoZUQURIj/JIkiKGVERDEAMgkSRIk=\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 4}}, \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTAwMAogICAgYnl0ZWNibG9jayAiaXNfc2V0dGxlZCIgImJ1eWVyIiAidmFsdWUiICJzZWxsZXIiICJhcmJpdHJhdG9yIiAiaXNfZGlzcHV0ZWQiICJlc2Nyb3dfZXhwaXJ5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2FmdGVyX2lmX2Vsc2VAMTQKICAgIHB1c2hieXRlc3MgMHgzZmU0ZDM5YSAweGZkYzY5NWMyIDB4MzFjZTc1OTcgMHgzNGM5NzljOSAweDQzOTgyNjVkIDB4OTFiNDUzMmEgMHg1MTIxZjc0MSAweDMzYjM0OTllIC8vIG1ldGhvZCAiY3JlYXRlX2FwcGxpY2F0aW9uKHVpbnQ2NCxhY2NvdW50LGFjY291bnQsYWNjb3VudCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVwb3NpdF9mdW5kcyhwYXkpdm9pZCIsIG1ldGhvZCAicmVsZWFzZV9mdW5kc190b19zZWxsZXIoKXZvaWQiLCBtZXRob2QgInJlZnVuZF9mdW5kc190b19idXllcigpdm9pZCIsIG1ldGhvZCAicmFpc2VfZGlzcHV0ZSgpdm9pZCIsIG1ldGhvZCAicmVzb2x2ZV9kaXNwdXRlKHN0cmluZyl2b2lkIiwgbWV0aG9kICJleHBpcmVfZXNjcm93KCl2b2lkIiwgbWV0aG9kICJkZWxldGVfYXBwbGljYXRpb24oKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NyZWF0ZV9hcHBsaWNhdGlvbl9yb3V0ZUAzIG1haW5fZGVwb3NpdF9mdW5kc19yb3V0ZUA0IG1haW5fcmVsZWFzZV9mdW5kc190b19zZWxsZXJfcm91dGVANSBtYWluX3JlZnVuZF9mdW5kc190b19idXllcl9yb3V0ZUA2IG1haW5fcmFpc2VfZGlzcHV0ZV9yb3V0ZUA3IG1haW5fcmVzb2x2ZV9kaXNwdXRlX3JvdXRlQDggbWFpbl9leHBpcmVfZXNjcm93X3JvdXRlQDkgbWFpbl9kZWxldGVfYXBwbGljYXRpb25fcm91dGVAMTAKCm1haW5fYWZ0ZXJfaWZfZWxzZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NQogICAgLy8gY2xhc3MgRXNjcm93KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9hcHBsaWNhdGlvbl9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTA5LTExMAogICAgLy8gIyBEZWxldGUgdGhlIGFwcGxpY2F0aW9uIChvbmx5IGFmdGVyIHNldHRsZW1lbnQpCiAgICAvLyBAYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJEZWxldGVBcHBsaWNhdGlvbiJdKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZXhwaXJlX2VzY3Jvd19yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyAjIFRpbWUtbG9jazogQXV0b21hdGljYWxseSByZWZ1bmQgYnV5ZXIgaWYgZXNjcm93IGV4cGlyZXMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGV4cGlyZV9lc2Nyb3cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVzb2x2ZV9kaXNwdXRlX3JvdXRlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg0CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg0CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgcmVzb2x2ZV9kaXNwdXRlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3JhaXNlX2Rpc3B1dGVfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzQtNzUKICAgIC8vICMgUmFpc2UgYSBkaXNwdXRlIChjYWxsZWQgYnkgYnV5ZXIgb3Igc2VsbGVyKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmFpc2VfZGlzcHV0ZQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9yZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NTgtNTkKICAgIC8vICMgUmVmdW5kIGZ1bmRzIHRvIGJ1eWVyIChjYWxsZWQgYnkgc2VsbGVyIG9yIGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVsZWFzZV9mdW5kc190b19zZWxsZXJfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NDItNDMKICAgIC8vICMgUmVsZWFzZSBmdW5kcyB0byBzZWxsZXIgKGNhbGxlZCBieSBidXllciBvciBhcmJpdHJhdG9yKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgcmVsZWFzZV9mdW5kc190b19zZWxsZXIKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZGVwb3NpdF9mdW5kc19yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNC0zNQogICAgLy8gIyBEZXBvc2l0IGZ1bmRzIGludG8gZXNjcm93IChjYWxsZWQgYnkgYnV5ZXIpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1CiAgICAvLyBjbGFzcyBFc2Nyb3coQVJDNENvbnRyYWN0KToKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNC0zNQogICAgLy8gIyBEZXBvc2l0IGZ1bmRzIGludG8gZXNjcm93IChjYWxsZWQgYnkgYnV5ZXIpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZGVwb3NpdF9mdW5kcwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfYXBwbGljYXRpb25fcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTcKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwgY3JlYXRlPSJyZXF1aXJlIikKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUKICAgIC8vIGNsYXNzIEVzY3JvdyhBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBidG9pCiAgICB0eG5hcyBBY2NvdW50cwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxNwogICAgLy8gQGFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiTm9PcCJdLCBjcmVhdGU9InJlcXVpcmUiKQogICAgY2FsbHN1YiBjcmVhdGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5jcmVhdGVfYXBwbGljYXRpb24odmFsdWU6IHVpbnQ2NCwgc2VsbGVyOiBieXRlcywgYnV5ZXI6IGJ5dGVzLCBhcmJpdHJhdG9yOiBieXRlcywgZXNjcm93X2R1cmF0aW9uOiB1aW50NjQpIC0+IHZvaWQ6CmNyZWF0ZV9hcHBsaWNhdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTctMjUKICAgIC8vIEBhYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwgY3JlYXRlPSJyZXF1aXJlIikKICAgIC8vIGRlZiBjcmVhdGVfYXBwbGljYXRpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB2YWx1ZTogVUludDY0LAogICAgLy8gICAgIHNlbGxlcjogQWNjb3VudCwKICAgIC8vICAgICBidXllcjogQWNjb3VudCwKICAgIC8vICAgICBhcmJpdHJhdG9yOiBBY2NvdW50LAogICAgLy8gICAgIGVzY3Jvd19kdXJhdGlvbjogVUludDY0LCAgIyBEdXJhdGlvbiBpbiBzZWNvbmRzCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byA1IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MjYKICAgIC8vIHNlbGYudmFsdWUgPSB2YWx1ZQogICAgYnl0ZWNfMiAvLyAidmFsdWUiCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI3CiAgICAvLyBzZWxmLnNlbGxlciA9IHNlbGxlcgogICAgYnl0ZWNfMyAvLyAic2VsbGVyIgogICAgZnJhbWVfZGlnIC00CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToyOAogICAgLy8gc2VsZi5idXllciA9IGJ1eWVyCiAgICBieXRlY18xIC8vICJidXllciIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MjkKICAgIC8vIHNlbGYuYXJiaXRyYXRvciA9IGFyYml0cmF0b3IKICAgIGJ5dGVjIDQgLy8gImFyYml0cmF0b3IiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwCiAgICAvLyBzZWxmLmVzY3Jvd19leHBpcnkgPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIGVzY3Jvd19kdXJhdGlvbgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBieXRlYyA2IC8vICJlc2Nyb3dfZXhwaXJ5IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzEKICAgIC8vIHNlbGYuaXNfZGlzcHV0ZWQgPSBGYWxzZQogICAgYnl0ZWMgNSAvLyAiaXNfZGlzcHV0ZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzIKICAgIC8vIHNlbGYuaXNfc2V0dGxlZCA9IEZhbHNlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5kZXBvc2l0X2Z1bmRzKHBheW1lbnQ6IHVpbnQ2NCkgLT4gdm9pZDoKZGVwb3NpdF9mdW5kczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MzQtMzYKICAgIC8vICMgRGVwb3NpdCBmdW5kcyBpbnRvIGVzY3JvdyAoY2FsbGVkIGJ5IGJ1eWVyKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZGVwb3NpdF9mdW5kcyhzZWxmLCBwYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbikgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozNwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5idXllciwgIk9ubHkgdGhlIGJ1eWVyIGNhbiBkZXBvc2l0IGZ1bmRzIgogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBidXllciBjYW4gZGVwb3NpdCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTozOAogICAgLy8gYXNzZXJ0IHBheW1lbnQucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywgIlBheW1lbnQgbXVzdCBiZSBzZW50IHRvIHRoZSBlc2Nyb3ciCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byB0aGUgZXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyBhc3NlcnQgcGF5bWVudC5hbW91bnQgPT0gc2VsZi52YWx1ZSwgIlBheW1lbnQgbXVzdCBtYXRjaCB0aGUgYXNzZXQgcHJpY2UiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gInZhbHVlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhbHVlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgbWF0Y2ggdGhlIGFzc2V0IHByaWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwCiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcigpIC0+IHZvaWQ6CnJlbGVhc2VfZnVuZHNfdG9fc2VsbGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo0Mi00NAogICAgLy8gIyBSZWxlYXNlIGZ1bmRzIHRvIHNlbGxlciAoY2FsbGVkIGJ5IGJ1eWVyIG9yIGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcihzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciBpbiAoc2VsZi5idXllciwgc2VsZi5hcmJpdHJhdG9yKSwgIk9ubHkgYnV5ZXIgb3IgYXJiaXRyYXRvciBjYW4gcmVsZWFzZSBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDQgLy8gImFyYml0cmF0b3IiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXJiaXRyYXRvciBleGlzdHMKICAgID09CiAgICBibnogcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgPT0KICAgIGJ6IHJlbGVhc2VfZnVuZHNfdG9fc2VsbGVyX2Jvb2xfZmFsc2VAMwoKcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF90cnVlQDI6CiAgICBpbnRjXzEgLy8gMQoKcmVsZWFzZV9mdW5kc190b19zZWxsZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo0NQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuYnV5ZXIsIHNlbGYuYXJiaXRyYXRvciksICJPbmx5IGJ1eWVyIG9yIGFyYml0cmF0b3IgY2FuIHJlbGVhc2UgZnVuZHMiCiAgICBhc3NlcnQgLy8gT25seSBidXllciBvciBhcmJpdHJhdG9yIGNhbiByZWxlYXNlIGZ1bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ2CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTUzCiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgLy8gICAgIGFtb3VudD1zZWxmLnZhbHVlLAogICAgLy8gICAgIGZlZT0xXzAwMCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NTAKICAgIC8vIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInNlbGxlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zZWxsZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUxCiAgICAvLyBhbW91bnQ9c2VsZi52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJ2YWx1ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWx1ZSBleGlzdHMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTQ5CiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo1MgogICAgLy8gZmVlPTFfMDAwLAogICAgaW50Y18yIC8vIDEwMDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4LTUzCiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIHRvIHNlbGxlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuc2VsbGVyLAogICAgLy8gICAgIGFtb3VudD1zZWxmLnZhbHVlLAogICAgLy8gICAgIGZlZT0xXzAwMCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU1LTU2CiAgICAvLyAjIE1hcmsgYXMgc2V0dGxlZAogICAgLy8gc2VsZi5pc19zZXR0bGVkID0gVHJ1ZQogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGludGNfMSAvLyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpyZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcl9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZWZ1bmRfZnVuZHNfdG9fYnV5ZXIoKSAtPiB2b2lkOgpyZWZ1bmRfZnVuZHNfdG9fYnV5ZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4LTYwCiAgICAvLyAjIFJlZnVuZCBmdW5kcyB0byBidXllciAoY2FsbGVkIGJ5IHNlbGxlciBvciBhcmJpdHJhdG9yKQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgcmVmdW5kX2Z1bmRzX3RvX2J1eWVyKHNlbGYpIC0+IE5vbmU6CiAgICBwcm90byAwIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NjEKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIChzZWxmLnNlbGxlciwgc2VsZi5hcmJpdHJhdG9yKSwgIk9ubHkgc2VsbGVyIG9yIGFyYml0cmF0b3IgY2FuIHJlZnVuZCBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInNlbGxlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zZWxsZXIgZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNCAvLyAiYXJiaXRyYXRvciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAzCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hcmJpdHJhdG9yIGV4aXN0cwogICAgPT0KICAgIGJueiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF90cnVlQDIKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgPT0KICAgIGJ6IHJlZnVuZF9mdW5kc190b19idXllcl9ib29sX2ZhbHNlQDMKCnJlZnVuZF9mdW5kc190b19idXllcl9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpyZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuc2VsbGVyLCBzZWxmLmFyYml0cmF0b3IpLCAiT25seSBzZWxsZXIgb3IgYXJiaXRyYXRvciBjYW4gcmVmdW5kIGZ1bmRzIgogICAgYXNzZXJ0IC8vIE9ubHkgc2VsbGVyIG9yIGFyYml0cmF0b3IgY2FuIHJlZnVuZCBmdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2MgogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NC02OQogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyBiYWNrIHRvIGJ1eWVyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5idXllciwKICAgIC8vICAgICBhbW91bnQ9c2VsZi52YWx1ZSwKICAgIC8vICAgICBmZWU9MV8wMDAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2CiAgICAvLyByZWNlaXZlcj1zZWxmLmJ1eWVyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gImJ1eWVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmJ1eWVyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NwogICAgLy8gYW1vdW50PXNlbGYudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAidmFsdWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmFsdWUgZXhpc3RzCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo2NC02NQogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyBiYWNrIHRvIGJ1eWVyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBmZWU9MV8wMDAsCiAgICBpbnRjXzIgLy8gMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NjQtNjkKICAgIC8vICMgVHJhbnNmZXIgZnVuZHMgYmFjayB0byBidXllcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuYnV5ZXIsCiAgICAvLyAgICAgYW1vdW50PXNlbGYudmFsdWUsCiAgICAvLyAgICAgZmVlPTFfMDAwLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzEtNzIKICAgIC8vICMgTWFyayBhcyBzZXR0bGVkCiAgICAvLyBzZWxmLmlzX3NldHRsZWQgPSBUcnVlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJlZnVuZF9mdW5kc190b19idXllcl9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiByZWZ1bmRfZnVuZHNfdG9fYnV5ZXJfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cucmFpc2VfZGlzcHV0ZSgpIC0+IHZvaWQ6CnJhaXNlX2Rpc3B1dGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0LTc2CiAgICAvLyAjIFJhaXNlIGEgZGlzcHV0ZSAoY2FsbGVkIGJ5IGJ1eWVyIG9yIHNlbGxlcikKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIHJhaXNlX2Rpc3B1dGUoc2VsZikgLT4gTm9uZToKICAgIHByb3RvIDAgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo3NwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgaW4gKHNlbGYuYnV5ZXIsIHNlbGYuc2VsbGVyKSwgIk9ubHkgYnV5ZXIgb3Igc2VsbGVyIGNhbiByYWlzZSBhIGRpc3B1dGUiCiAgICB0eG4gU2VuZGVyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJidXllciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5idXllciBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJzZWxsZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc2VsbGVyIGV4aXN0cwogICAgPT0KICAgIGJueiByYWlzZV9kaXNwdXRlX2Jvb2xfdHJ1ZUAyCiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIDEKICAgID09CiAgICBieiByYWlzZV9kaXNwdXRlX2Jvb2xfZmFsc2VAMwoKcmFpc2VfZGlzcHV0ZV9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpyYWlzZV9kaXNwdXRlX2Jvb2xfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzcKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyIGluIChzZWxmLmJ1eWVyLCBzZWxmLnNlbGxlciksICJPbmx5IGJ1eWVyIG9yIHNlbGxlciBjYW4gcmFpc2UgYSBkaXNwdXRlIgogICAgYXNzZXJ0IC8vIE9ubHkgYnV5ZXIgb3Igc2VsbGVyIGNhbiByYWlzZSBhIGRpc3B1dGUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6NzgKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5pc19kaXNwdXRlZCwgIkRpc3B1dGUgYWxyZWFkeSByYWlzZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAiaXNfZGlzcHV0ZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfZGlzcHV0ZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gRGlzcHV0ZSBhbHJlYWR5IHJhaXNlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo3OQogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4MQogICAgLy8gc2VsZi5pc19kaXNwdXRlZCA9IFRydWUKICAgIGJ5dGVjIDUgLy8gImlzX2Rpc3B1dGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJhaXNlX2Rpc3B1dGVfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgcmFpc2VfZGlzcHV0ZV9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMuZXNjcm93X2NvbnRyYWN0LmNvbnRyYWN0LkVzY3Jvdy5yZXNvbHZlX2Rpc3B1dGUoZGVjaXNpb246IGJ5dGVzKSAtPiB2b2lkOgpyZXNvbHZlX2Rpc3B1dGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgzLTg1CiAgICAvLyAjIFJlc29sdmUgZGlzcHV0ZSAoY2FsbGVkIGJ5IGFyYml0cmF0b3IpCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiByZXNvbHZlX2Rpc3B1dGUoc2VsZiwgZGVjaXNpb246IFN0cmluZykgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4NgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5hcmJpdHJhdG9yLCAiT25seSB0aGUgYXJiaXRyYXRvciBjYW4gcmVzb2x2ZSBkaXNwdXRlcyIKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA0IC8vICJhcmJpdHJhdG9yIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmFyYml0cmF0b3IgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIGFyYml0cmF0b3IgY2FuIHJlc29sdmUgZGlzcHV0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6ODcKICAgIC8vIGFzc2VydCBzZWxmLmlzX2Rpc3B1dGVkLCAiTm8gZGlzcHV0ZSB0byByZXNvbHZlIgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gImlzX2Rpc3B1dGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX2Rpc3B1dGVkIGV4aXN0cwogICAgYXNzZXJ0IC8vIE5vIGRpc3B1dGUgdG8gcmVzb2x2ZQogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo4OAogICAgLy8gYXNzZXJ0IG5vdCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNldHRsZWQiCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiaXNfc2V0dGxlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5pc19zZXR0bGVkIGV4aXN0cwogICAgIQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weTo5MAogICAgLy8gaWYgZGVjaXNpb24gPT0gInJlbGVhc2VfdG9fc2VsbGVyIjoKICAgIGZyYW1lX2RpZyAtMQogICAgcHVzaGJ5dGVzICJyZWxlYXNlX3RvX3NlbGxlciIKICAgID09CiAgICBieiByZXNvbHZlX2Rpc3B1dGVfZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTEKICAgIC8vIHNlbGYucmVsZWFzZV9mdW5kc190b19zZWxsZXIoKQogICAgY2FsbHN1YiByZWxlYXNlX2Z1bmRzX3RvX3NlbGxlcgoKcmVzb2x2ZV9kaXNwdXRlX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTctOTgKICAgIC8vICMgTWFyayBhcyBzZXR0bGVkCiAgICAvLyBzZWxmLmlzX3NldHRsZWQgPSBUcnVlCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgaW50Y18xIC8vIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnJlc29sdmVfZGlzcHV0ZV9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6OTIKICAgIC8vIGVsaWYgZGVjaXNpb24gPT0gInJlZnVuZF90b19idXllciI6CiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hieXRlcyAicmVmdW5kX3RvX2J1eWVyIgogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGRlY2lzaW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzCiAgICAvLyBzZWxmLnJlZnVuZF9mdW5kc190b19idXllcigpCiAgICBjYWxsc3ViIHJlZnVuZF9mdW5kc190b19idXllcgogICAgYiByZXNvbHZlX2Rpc3B1dGVfYWZ0ZXJfaWZfZWxzZUA2CgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cuZXhwaXJlX2VzY3JvdygpIC0+IHZvaWQ6CmV4cGlyZV9lc2Nyb3c6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMwogICAgLy8gYXNzZXJ0IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wID49IHNlbGYuZXNjcm93X2V4cGlyeSwgIkVzY3JvdyBoYXMgbm90IGV4cGlyZWQgeWV0IgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDYgLy8gImVzY3Jvd19leHBpcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZXNjcm93X2V4cGlyeSBleGlzdHMKICAgID49CiAgICBhc3NlcnQgLy8gRXNjcm93IGhhcyBub3QgZXhwaXJlZCB5ZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9lc2Nyb3dfY29udHJhY3QvY29udHJhY3QucHk6MTA0CiAgICAvLyBhc3NlcnQgbm90IHNlbGYuaXNfc2V0dGxlZCwgIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2V0dGxlZCIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJpc19zZXR0bGVkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmlzX3NldHRsZWQgZXhpc3RzCiAgICAhCiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzZXR0bGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNi0xMDcKICAgIC8vICMgUmVmdW5kIGJ1eWVyCiAgICAvLyBzZWxmLnJlZnVuZF9mdW5kc190b19idXllcigpCiAgICBjYWxsc3ViIHJlZnVuZF9mdW5kc190b19idXllcgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmVzY3Jvd19jb250cmFjdC5jb250cmFjdC5Fc2Nyb3cuZGVsZXRlX2FwcGxpY2F0aW9uKCkgLT4gdm9pZDoKZGVsZXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2VzY3Jvd19jb250cmFjdC9jb250cmFjdC5weToxMTIKICAgIC8vIGFzc2VydCBzZWxmLmlzX3NldHRsZWQsICJUcmFuc2FjdGlvbiBtdXN0IGJlIHNldHRsZWQgYmVmb3JlIGRlbGV0aW5nIgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImlzX3NldHRsZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuaXNfc2V0dGxlZCBleGlzdHMKICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiBtdXN0IGJlIHNldHRsZWQgYmVmb3JlIGRlbGV0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZXNjcm93X2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExMwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgIk9ubHkgdGhlIGNyZWF0b3IgY2FuIGRlbGV0ZSB0aGUgYXBwbGljYXRpb24iCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgY3JlYXRvciBjYW4gZGVsZXRlIHRoZSBhcHBsaWNhdGlvbgogICAgcmV0c3ViCg==\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [529], \"errorMessage\": \"Dispute already raised\"}, {\"pc\": [636], \"errorMessage\": \"Escrow has not expired yet\"}, {\"pc\": [621], \"errorMessage\": \"Invalid decision\"}, {\"pc\": [562], \"errorMessage\": \"No dispute to resolve\"}, {\"pc\": [151], \"errorMessage\": \"OnCompletion is not DeleteApplication\"}, {\"pc\": [163, 175, 193, 205, 217, 229, 251], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [391], \"errorMessage\": \"Only buyer or arbitrator can release funds\"}, {\"pc\": [522], \"errorMessage\": \"Only buyer or seller can raise a dispute\"}, {\"pc\": [457], \"errorMessage\": \"Only seller or arbitrator can refund funds\"}, {\"pc\": [556], \"errorMessage\": \"Only the arbitrator can resolve disputes\"}, {\"pc\": [334], \"errorMessage\": \"Only the buyer can deposit funds\"}, {\"pc\": [657], \"errorMessage\": \"Only the creator can delete the application\"}, {\"pc\": [342], \"errorMessage\": \"Payment must be sent to the escrow\"}, {\"pc\": [352], \"errorMessage\": \"Payment must match the asset price\"}, {\"pc\": [358, 397, 463, 535, 568, 642], \"errorMessage\": \"Transaction is already settled\"}, {\"pc\": [651], \"errorMessage\": \"Transaction must be settled before deleting\"}, {\"pc\": [255], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [154, 166, 178, 196, 208, 220, 232], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [377, 443, 554], \"errorMessage\": \"check self.arbitrator exists\"}, {\"pc\": [332, 369, 468, 501], \"errorMessage\": \"check self.buyer exists\"}, {\"pc\": [634], \"errorMessage\": \"check self.escrow_expiry exists\"}, {\"pc\": [527, 561], \"errorMessage\": \"check self.is_disputed exists\"}, {\"pc\": [356, 395, 461, 533, 566, 640, 650], \"errorMessage\": \"check self.is_settled exists\"}, {\"pc\": [402, 435, 508], \"errorMessage\": \"check self.seller exists\"}, {\"pc\": [350, 406, 472], \"errorMessage\": \"check self.value exists\"}, {\"pc\": [242], \"errorMessage\": \"transaction type is pay\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass DepositFundsArgs:\n    \"\"\"Dataclass for deposit_funds arguments\"\"\"\n    payment: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"deposit_funds(pay)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ResolveDisputeArgs:\n    \"\"\"Dataclass for resolve_dispute arguments\"\"\"\n    decision: str\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"resolve_dispute(string)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass CreateApplicationArgs:\n    \"\"\"Dataclass for create_application arguments\"\"\"\n    value: int\n    seller: str | bytes\n    buyer: str | bytes\n    arbitrator: str | bytes\n    escrow_duration: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"create_application(uint64,account,account,account,uint64)void\"\n\n\nclass _EscrowDelete:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppDeleteMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass EscrowParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_EscrowDelete\":\n        return _EscrowDelete(self.app_client)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"deposit_funds(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"release_funds_to_seller()void\",\n        }))\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"refund_funds_to_buyer()void\",\n        }))\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"raise_dispute()void\",\n        }))\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"resolve_dispute(string)void\",\n            \"args\": method_args,\n        }))\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"expire_escrow()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _EscrowDeleteTransaction:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass EscrowCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_EscrowDeleteTransaction\":\n        return _EscrowDeleteTransaction(self.app_client)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"deposit_funds(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"release_funds_to_seller()void\",\n        }))\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"refund_funds_to_buyer()void\",\n        }))\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"raise_dispute()void\",\n        }))\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"resolve_dispute(string)void\",\n            \"args\": method_args,\n        }))\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"expire_escrow()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _EscrowDeleteSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n\nclass EscrowSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_EscrowDeleteSend\":\n        return _EscrowDeleteSend(self.app_client)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"deposit_funds(pay)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"release_funds_to_seller()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"refund_funds_to_buyer()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"raise_dispute()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"resolve_dispute(string)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"expire_escrow()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    seller: bytes\n    buyer: bytes\n    arbitrator: bytes\n    amount: int\n    escrow_expiry: int\n    is_disputed: int\n    is_settled: int\n    value: int\n\nclass EscrowState:\n    \"\"\"Methods to access state for the current Escrow app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def seller(self) -> bytes:\n        \"\"\"Get the current value of the seller key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"seller\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\n    @property\n    def buyer(self) -> bytes:\n        \"\"\"Get the current value of the buyer key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"buyer\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\n    @property\n    def arbitrator(self) -> bytes:\n        \"\"\"Get the current value of the arbitrator key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"arbitrator\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\n    @property\n    def amount(self) -> int:\n        \"\"\"Get the current value of the amount key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"amount\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def escrow_expiry(self) -> int:\n        \"\"\"Get the current value of the escrow_expiry key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"escrow_expiry\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def is_disputed(self) -> int:\n        \"\"\"Get the current value of the is_disputed key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"is_disputed\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def is_settled(self) -> int:\n        \"\"\"Get the current value of the is_settled key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"is_settled\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def value(self) -> int:\n        \"\"\"Get the current value of the value key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"value\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\nclass EscrowClient:\n    \"\"\"Client for interacting with Escrow smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = EscrowParams(self.app_client)\n        self.create_transaction = EscrowCreateTransactionParams(self.app_client)\n        self.send = EscrowSend(self.app_client)\n        self.state = EscrowState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"EscrowClient\":\n        return EscrowClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"EscrowClient\":\n        return EscrowClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"EscrowClient\":\n        return EscrowClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"EscrowComposer\":\n        return EscrowComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"deposit_funds(pay)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"release_funds_to_seller()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"refund_funds_to_buyer()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"raise_dispute()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"resolve_dispute(string)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"expire_escrow()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"create_application(uint64,account,account,account,uint64)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"delete_application()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass EscrowMethodCallCreateParams(\n    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[\n        CreateApplicationArgs,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for creating Escrow contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallCreateParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\n@dataclasses.dataclass(frozen=True)\nclass EscrowMethodCallDeleteParams(\n    algokit_utils.BaseAppClientMethodCallParams[\n        typing.Any,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for calling Escrow contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\nclass EscrowFactory(algokit_utils.TypedAppFactoryProtocol[EscrowMethodCallCreateParams, None, EscrowMethodCallDeleteParams]):\n    \"\"\"Factory for deploying and managing EscrowClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = EscrowFactoryParams(self.app_factory)\n        self.create_transaction = EscrowFactoryCreateTransaction(self.app_factory)\n        self.send = EscrowFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: EscrowMethodCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: EscrowMethodCallDeleteParams | None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[EscrowClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return EscrowClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> EscrowClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return EscrowClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> EscrowClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return EscrowClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass EscrowFactoryParams:\n    \"\"\"Parameters for creating transactions for Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = EscrowFactoryCreateParams(app_factory)\n        self.update = EscrowFactoryUpdateParams(app_factory)\n        self.delete = EscrowFactoryDeleteParams(app_factory)\n\nclass EscrowFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the deposit_funds(pay)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"deposit_funds(pay)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def release_funds_to_seller(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the release_funds_to_seller()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"release_funds_to_seller()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def refund_funds_to_buyer(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the refund_funds_to_buyer()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"refund_funds_to_buyer()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def raise_dispute(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the raise_dispute()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"raise_dispute()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the resolve_dispute(string)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"resolve_dispute(string)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def expire_escrow(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the expire_escrow()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"expire_escrow()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the create_application(uint64,account,account,account,uint64)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def delete_application(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the delete_application()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"delete_application()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass EscrowFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass EscrowFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass EscrowFactoryCreateTransaction:\n    \"\"\"Create transactions for Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = EscrowFactoryCreateTransactionCreate(app_factory)\n\n\nclass EscrowFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass EscrowFactorySend:\n    \"\"\"Send calls to Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = EscrowFactorySendCreate(app_factory)\n\n\nclass EscrowFactorySendCreate:\n    \"\"\"Send create calls to Escrow contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[EscrowClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return EscrowClient(result[0]), result[1]\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> tuple[EscrowClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:\n            \"\"\"Creates and sends a transaction using the create_application(uint64,account,account,account,uint64)void ABI method\"\"\"\n            params = params or algokit_utils.CommonAppCallCreateParams()\n            client, result = self.app_factory.send.create(\n                algokit_utils.AppFactoryCreateMethodCallParams(\n                    **{\n                    **dataclasses.asdict(params),\n                    \"method\": \"create_application(uint64,account,account,account,uint64)void\",\n                    \"args\": _parse_abi_args(args),\n                    }\n                ),\n                send_params=send_params,\n                compilation_params=compilation_params\n            )\n            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)\n    \n            return EscrowClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](\n                **{\n                    **result.__dict__,\n                    \"app_id\": result.app_id,\n                    \"abi_return\": return_value,\n                    \"transaction\": result.transaction,\n                    \"confirmation\": result.confirmation,\n                    \"group_id\": result.group_id,\n                    \"tx_ids\": result.tx_ids,\n                    \"transactions\": result.transactions,\n                    \"confirmations\": result.confirmations,\n                    \"app_address\": result.app_address,\n                }\n            )\n\n\nclass _EscrowDeleteComposer:\n    def __init__(self, composer: \"EscrowComposer\"):\n        self.composer = composer\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self.composer._composer.add_app_delete_method_call(\n            self.composer.client.params.delete.delete_application(\n                \n                params=params,\n                \n            )\n        )\n        self.composer._result_mappers.append(\n            lambda v: self.composer.client.decode_return_value(\n                \"delete_application()void\", v\n            )\n        )\n        return self.composer\n\n\nclass EscrowComposer:\n    \"\"\"Composer for creating transaction groups for Escrow contract calls\"\"\"\n\n    def __init__(self, client: \"EscrowClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    @property\n    def delete(self) -> \"_EscrowDeleteComposer\":\n        return _EscrowDeleteComposer(self)\n\n    def deposit_funds(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | DepositFundsArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.deposit_funds(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"deposit_funds(pay)void\", v\n            )\n        )\n        return self\n\n    def release_funds_to_seller(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.release_funds_to_seller(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"release_funds_to_seller()void\", v\n            )\n        )\n        return self\n\n    def refund_funds_to_buyer(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.refund_funds_to_buyer(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"refund_funds_to_buyer()void\", v\n            )\n        )\n        return self\n\n    def raise_dispute(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.raise_dispute(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"raise_dispute()void\", v\n            )\n        )\n        return self\n\n    def resolve_dispute(\n        self,\n        args: tuple[str] | ResolveDisputeArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.resolve_dispute(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"resolve_dispute(string)void\", v\n            )\n        )\n        return self\n\n    def expire_escrow(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.expire_escrow(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"expire_escrow()void\", v\n            )\n        )\n        return self\n\n    def create_application(\n        self,\n        args: tuple[int, str | bytes, str | bytes, str | bytes, int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.create_application(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"create_application(uint64,account,account,account,uint64)void\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"EscrowComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"EscrowComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"instruction": "This code defines a client for interacting with a smart contract named `CirculatingSupply`. It provides methods to call the contract's ABI methods such as `set_asset`, `set_not_circulating_address`, and `arc62_get_circulating_supply`, as well as bare calls like `clear_state`. It also includes utilities for creating, deploying, and managing instances of the contract, as well as accessing its global state.", "output": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"methods\": [{\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"uint64\", \"desc\": \"ASA ID of the circulating supply\", \"name\": \"asset_id\"}], \"name\": \"set_asset\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Set the ASA ID for the circulating supply - Authorization: ASA Manager Address\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"address\", \"desc\": \"Address to assign to the label to\", \"name\": \"address\"}, {\"type\": \"string\", \"desc\": \"Not-circulating label selector\", \"name\": \"label\"}], \"name\": \"set_not_circulating_address\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Set non-circulating supply addresses - Authorization: ASA Manager Address\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"uint64\", \"desc\": \"ASA ID of the circulating supply\", \"name\": \"asset_id\"}], \"name\": \"arc62_get_circulating_supply\", \"returns\": {\"type\": \"uint64\", \"desc\": \"ASA circulating supply\"}, \"desc\": \"Get ASA circulating supply\", \"events\": [], \"readonly\": true, \"recommendations\": {}}], \"name\": \"CirculatingSupply\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"asset_id\": {\"key\": \"YXNzZXRfaWQ=\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"not_circulating_label_1\": {\"key\": \"YnVybmVk\", \"keyType\": \"AVMString\", \"valueType\": \"address\"}, \"not_circulating_label_2\": {\"key\": \"bG9ja2Vk\", \"keyType\": \"AVMString\", \"valueType\": \"address\"}, \"not_circulating_label_3\": {\"key\": \"Z2VuZXJpYw==\", \"keyType\": \"AVMString\", \"valueType\": \"address\"}}, \"local\": {}}, \"maps\": {\"box\": {}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 3, \"ints\": 1}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {}, \"byteCode\": {\"approval\": \"CiADAAEgJgQIYXNzZXRfaWQGYnVybmVkBmxvY2tlZAdnZW5lcmljMRhAAA8oImcpMgNnKjIDZysyA2cxG0EAXYIDBHCbgKgEC2LHKARcwsU1NhoAjgMAMQAcAAIiQzEZFEQxGEQ2GgEXiACXFoAEFR98dUxQsCNDMRkURDEYRDYaATYaAlcCAIgAPSNDMRkURDEYRDYaAReIAA0jQzEZQP+6MRgURCNDigEAMQCL/3EHRBJBAA4iKGVEQAAHI0Qoi/9niSJC//aKAgAiKGVEMQBLAXEHRBJEi/4VJBJEi/5McABFAUQpKiuL/44DAAsABgABACuL/meJKov+Z4kpi/5niYoBAYAARwIiKWVMSU8CRBUkEkQiKmVMSU8CRBUkEkQiK2VMSU8CRBUkEkQiKGVEi/8SRIv/cQhEMgMSQAAOi/9xCESL/3AARQFAAHgijAKLAzIDEkAAC4sDi/9wAEUBQABWIowAiwQyAxJAAAuLBIv/cABFAUAANCKMAYsFMgMSQAALiwWL/3AARQFAABQii/9xAESLAgmLAAmLAQlMCYwAiYsFi/9wAERC/+OLBIv/cABEjAFC/8OLA4v/cABEjABC/6GL/3EIRIv/cABEjAJC/3w=\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 0}}, \"desc\": \"ARC-62 Reference Implementation\", \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMuY2lyY3VsYXRpbmdfc3VwcGx5LmNvbnRyYWN0LkNpcmN1bGF0aW5nU3VwcGx5Ll9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDAgMSAzMgogICAgYnl0ZWNibG9jayAiYXNzZXRfaWQiICJidXJuZWQiICJsb2NrZWQiICJnZW5lcmljIgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyNC0yNQogICAgLy8gIyBHbG9iYWwgU3RhdGUKICAgIC8vIHNlbGYuYXNzZXRfaWQgPSBVSW50NjQoKQogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjcKICAgIC8vIEFkZHJlc3MoKSwga2V5PWNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMQogICAgYnl0ZWNfMSAvLyAiYnVybmVkIgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjI2LTI4CiAgICAvLyBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8xID0gR2xvYmFsU3RhdGUoCiAgICAvLyAgICAgQWRkcmVzcygpLCBrZXk9Y2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8xCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozMAogICAgLy8gQWRkcmVzcygpLCBrZXk9Y2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8yCiAgICBieXRlY18yIC8vICJsb2NrZWQiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjktMzEKICAgIC8vIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzIgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzIKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjMzCiAgICAvLyBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzMKICAgIGJ5dGVjXzMgLy8gImdlbmVyaWMiCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MzItMzQKICAgIC8vIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBBZGRyZXNzKCksIGtleT1jZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzMKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAKICAgIC8vIGNsYXNzIENpcmN1bGF0aW5nU3VwcGx5KEFSQzRDb250cmFjdCk6CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9iYXJlX3JvdXRpbmdAOAogICAgcHVzaGJ5dGVzcyAweDcwOWI4MGE4IDB4MGI2MmM3MjggMHg1Y2MyYzUzNSAvLyBtZXRob2QgInNldF9hc3NldCh1aW50NjQpdm9pZCIsIG1ldGhvZCAic2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKGFkZHJlc3Msc3RyaW5nKXZvaWQiLCBtZXRob2QgImFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHkodWludDY0KXVpbnQ2NCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fc2V0X2Fzc2V0X3JvdXRlQDUgbWFpbl9zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfcm91dGVANiBtYWluX2FyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfcm91dGVANwoKbWFpbl9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIGludGNfMCAvLyAwCiAgICByZXR1cm4KCm1haW5fYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjIwCiAgICAvLyBjbGFzcyBDaXJjdWxhdGluZ1N1cHBseShBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5CiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3NldF9hc3NldF9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozNgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MjAKICAgIC8vIGNsYXNzIENpcmN1bGF0aW5nU3VwcGx5KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjM2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgc2V0X2Fzc2V0CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2JhcmVfcm91dGluZ0A4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToyMAogICAgLy8gY2xhc3MgQ2lyY3VsYXRpbmdTdXBwbHkoQVJDNENvbnRyYWN0KToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGJueiBtYWluX2FmdGVyX2lmX2Vsc2VAMTAKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfYXNzZXQoYXNzZXRfaWQ6IHVpbnQ2NCkgLT4gdm9pZDoKc2V0X2Fzc2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTozNi0zNwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X2Fzc2V0KHNlbGYsIGFzc2V0X2lkOiBVSW50NjQpIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NDUtNDYKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlciBhbmQgbm90IHNlbGYuYXNzZXRfaWQsIGVyci5VTkFVVEhPUklaRUQKICAgIHR4biBTZW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldE1hbmFnZXIKICAgIGFzc2VydCAvLyBhc3NldCBleGlzdHMKICAgID09CiAgICBieiBzZXRfYXNzZXRfYm9vbF9mYWxzZUAzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuYXNzZXRfaWQgZXhpc3RzCiAgICBibnogc2V0X2Fzc2V0X2Jvb2xfZmFsc2VAMwogICAgaW50Y18xIC8vIDEKCnNldF9hc3NldF9ib29sX21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjQ1LTQ2CiAgICAvLyAjIFByZWNvbmRpdGlvbnMKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IGFzc2V0Lm1hbmFnZXIgYW5kIG5vdCBzZWxmLmFzc2V0X2lkLCBlcnIuVU5BVVRIT1JJWkVECiAgICBhc3NlcnQgLy8gVW5hdXRob3JpemVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjQ3LTQ4CiAgICAvLyAjIEVmZmVjdHMKICAgIC8vIHNlbGYuYXNzZXRfaWQgPSBhc3NldF9pZAogICAgYnl0ZWNfMCAvLyAiYXNzZXRfaWQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnNldF9hc3NldF9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzZXRfYXNzZXRfYm9vbF9tZXJnZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLmNpcmN1bGF0aW5nX3N1cHBseS5jb250cmFjdC5DaXJjdWxhdGluZ1N1cHBseS5zZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3MoYWRkcmVzczogYnl0ZXMsIGxhYmVsOiBieXRlcykgLT4gdm9pZDoKc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo1MC01MQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzKHNlbGYsIGFkZHJlc3M6IEFkZHJlc3MsIGxhYmVsOiBTdHJpbmcpIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NTkKICAgIC8vIGFzc2V0ID0gQXNzZXQoc2VsZi5hc3NldF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJhc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc3NldF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjAtNjEKICAgIC8vICMgUHJlY29uZGl0aW9ucwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gYXNzZXQubWFuYWdlciwgZXJyLlVOQVVUSE9SSVpFRAogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRNYW5hZ2VyCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIFVuYXV0aG9yaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2MgogICAgLy8gYXNzZXJ0IEFjY291bnQoYWRkcmVzcy5ieXRlcykuaXNfb3B0ZWRfaW4oYXNzZXQpLCBlcnIuTk9UX09QVEVEX0lOCiAgICBmcmFtZV9kaWcgLTIKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIEFkZHJlc3MgbGVuZ3RoIGlzIDMyIGJ5dGVzCiAgICBmcmFtZV9kaWcgLTIKICAgIHN3YXAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gTm90IE9wdGVkLUluCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjY1CiAgICAvLyBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMToKICAgIGJ5dGVjXzEgLy8gImJ1cm5lZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NjcKICAgIC8vIGNhc2UgY2ZnLk5PVF9DSVJDVUxBVElOR19MQUJFTF8yOgogICAgYnl0ZWNfMiAvLyAibG9ja2VkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2OQogICAgLy8gY2FzZSBjZmcuTk9UX0NJUkNVTEFUSU5HX0xBQkVMXzM6CiAgICBieXRlY18zIC8vICJnZW5lcmljIgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2My03MgogICAgLy8gIyBFZmZlY3RzCiAgICAvLyBtYXRjaCBsYWJlbDoKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMToKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMjoKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMi52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIGNmZy5OT1RfQ0lSQ1VMQVRJTkdfTEFCRUxfMzoKICAgIC8vICAgICAgICAgc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMy52YWx1ZSA9IGFkZHJlc3MKICAgIC8vICAgICBjYXNlIF86CiAgICAvLyAgICAgICAgIGFzc2VydCBGYWxzZSwgZXJyLklOVkFMSURfTEFCRUwKICAgIGZyYW1lX2RpZyAtMQogICAgbWF0Y2ggc2V0X25vdF9jaXJjdWxhdGluZ19hZGRyZXNzX3N3aXRjaF9jYXNlXzBAMSBzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMUAyIHNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8yQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6NzIKICAgIC8vIGFzc2VydCBGYWxzZSwgZXJyLklOVkFMSURfTEFCRUwKICAgIGVyciAvLyBJbnZhbGlkIExhYmVsCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMkAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo3MAogICAgLy8gc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMy52YWx1ZSA9IGFkZHJlc3MKICAgIGJ5dGVjXzMgLy8gImdlbmVyaWMiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCnNldF9ub3RfY2lyY3VsYXRpbmdfYWRkcmVzc19zd2l0Y2hfY2FzZV8xQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjY4CiAgICAvLyBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8yLnZhbHVlID0gYWRkcmVzcwogICAgYnl0ZWNfMiAvLyAibG9ja2VkIgogICAgZnJhbWVfZGlnIC0yCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgpzZXRfbm90X2NpcmN1bGF0aW5nX2FkZHJlc3Nfc3dpdGNoX2Nhc2VfMEAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo2NgogICAgLy8gc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZSA9IGFkZHJlc3MKICAgIGJ5dGVjXzEgLy8gImJ1cm5lZCIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jaXJjdWxhdGluZ19zdXBwbHkuY29udHJhY3QuQ2lyY3VsYXRpbmdTdXBwbHkuYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseShhc3NldF9pZDogdWludDY0KSAtPiB1aW50NjQ6CmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojc0LTc1CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseShzZWxmLCBhc3NldF9pZDogVUludDY0KSAtPiBVSW50NjQ6CiAgICBwcm90byAxIDEKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojg2CiAgICAvLyBub3RfY2lyY3VsYXRpbmdfMSA9IEFjY291bnQoc2VsZi5ub3RfY2lyY3VsYXRpbmdfbGFiZWxfMS52YWx1ZS5ieXRlcykKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJidXJuZWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8xIGV4aXN0cwogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gQWRkcmVzcyBsZW5ndGggaXMgMzIgYnl0ZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6ODcKICAgIC8vIG5vdF9jaXJjdWxhdGluZ18yID0gQWNjb3VudChzZWxmLm5vdF9jaXJjdWxhdGluZ19sYWJlbF8yLnZhbHVlLmJ5dGVzKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImxvY2tlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzIgZXhpc3RzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo4OAogICAgLy8gbm90X2NpcmN1bGF0aW5nXzMgPSBBY2NvdW50KHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMudmFsdWUuYnl0ZXMpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAiZ2VuZXJpYyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubm90X2NpcmN1bGF0aW5nX2xhYmVsXzMgZXhpc3RzCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo4OS05MAogICAgLy8gIyBQcmVjb25kaXRpb25zCiAgICAvLyBhc3NlcnQgYXNzZXRfaWQgPT0gc2VsZi5hc3NldF9pZCwgZXJyLklOVkFMSURfQVNTRVRfSUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJhc3NldF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5hc3NldF9pZCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIEFTQSBJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5NAogICAgLy8gaWYgYXNzZXQucmVzZXJ2ZSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRSZXNlcnZlCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojk0LTk1CiAgICAvLyBpZiBhc3NldC5yZXNlcnZlID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIG9yIG5vdCBhc3NldC5yZXNlcnZlLmlzX29wdGVkX2luKGFzc2V0KQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTUKICAgIC8vIG9yIG5vdCBhc3NldC5yZXNlcnZlLmlzX29wdGVkX2luKGFzc2V0KQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0UmVzZXJ2ZQogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAzCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weTo5MwogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAyCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTAwCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMSA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzEuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVANgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDEKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMS5pc19vcHRlZF9pbihhc3NldCkKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDcKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV90cnVlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5Ojk5CiAgICAvLyBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDAKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDYKICAgIC8vIGlmIG5vdF9jaXJjdWxhdGluZ18yID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGZyYW1lX2RpZyA0CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjEwNi0xMDcKICAgIC8vIGlmIG5vdF9jaXJjdWxhdGluZ18yID09IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMi5pc19vcHRlZF9pbihhc3NldCkKICAgIGJueiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDcKICAgIC8vIG9yIG5vdCBub3RfY2lyY3VsYXRpbmdfMi5pc19vcHRlZF9pbihhc3NldCkKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDExCgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfdHJ1ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA1CiAgICAvLyBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDEKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTEyCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMyA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBmcmFtZV9kaWcgNQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTItMTEzCiAgICAvLyBpZiBub3RfY2lyY3VsYXRpbmdfMyA9PSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzMuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBibnogYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTEzCiAgICAvLyBvciBub3Qgbm90X2NpcmN1bGF0aW5nXzMuaXNfb3B0ZWRfaW4oYXNzZXQpCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxNQoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X3RydWVAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExMQogICAgLy8gVUludDY0KDApCiAgICBpbnRjXzAgLy8gMAoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X21lcmdlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTcKICAgIC8vIGFzc2V0LnRvdGFsCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRUb3RhbAogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTE4CiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIGZyYW1lX2RpZyAyCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2lyY3VsYXRpbmdfc3VwcGx5L2NvbnRyYWN0LnB5OjExNy0xMTkKICAgIC8vIGFzc2V0LnRvdGFsCiAgICAvLyAtIHJlc2VydmVfYmFsYW5jZQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8xCiAgICBmcmFtZV9kaWcgMAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTIwCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gbm90X2NpcmN1bGF0aW5nX2JhbGFuY2VfMQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICBmcmFtZV9kaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTctMTIxCiAgICAvLyBhc3NldC50b3RhbAogICAgLy8gLSByZXNlcnZlX2JhbGFuY2UKICAgIC8vIC0gbm90X2NpcmN1bGF0aW5nX2JhbGFuY2VfMQogICAgLy8gLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICAvLyAtIG5vdF9jaXJjdWxhdGluZ19iYWxhbmNlXzMKICAgIHN3YXAKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTE2LTEyMgogICAgLy8gcmV0dXJuICgKICAgIC8vICAgICBhc3NldC50b3RhbAogICAgLy8gICAgIC0gcmVzZXJ2ZV9iYWxhbmNlCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8xCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8yCiAgICAvLyAgICAgLSBub3RfY2lyY3VsYXRpbmdfYmFsYW5jZV8zCiAgICAvLyApCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKYXJjNjJfZ2V0X2NpcmN1bGF0aW5nX3N1cHBseV90ZXJuYXJ5X2ZhbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMTQKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShub3RfY2lyY3VsYXRpbmdfMykKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTYKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6MTA4CiAgICAvLyBlbHNlIGFzc2V0LmJhbGFuY2Uobm90X2NpcmN1bGF0aW5nXzIpCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGZyYW1lX2J1cnkgMQogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VAMTIKCmFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9mYWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NpcmN1bGF0aW5nX3N1cHBseS9jb250cmFjdC5weToxMDIKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShub3RfY2lyY3VsYXRpbmdfMSkKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgZnJhbWVfYnVyeSAwCiAgICBiIGFyYzYyX2dldF9jaXJjdWxhdGluZ19zdXBwbHlfdGVybmFyeV9tZXJnZUA4CgphcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfZmFsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jaXJjdWxhdGluZ19zdXBwbHkvY29udHJhY3QucHk6OTYKICAgIC8vIGVsc2UgYXNzZXQuYmFsYW5jZShhc3NldC5yZXNlcnZlKQogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9wYXJhbXNfZ2V0IEFzc2V0UmVzZXJ2ZQogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGZyYW1lX2J1cnkgMgogICAgYiBhcmM2Ml9nZXRfY2lyY3VsYXRpbmdfc3VwcGx5X3Rlcm5hcnlfbWVyZ2VANAo=\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [221, 277, 289, 301], \"errorMessage\": \"Address length is 32 bytes\"}, {\"pc\": [309], \"errorMessage\": \"Invalid ASA ID\"}, {\"pc\": [243], \"errorMessage\": \"Invalid Label\"}, {\"pc\": [229], \"errorMessage\": \"Not Opted-In\"}, {\"pc\": [97, 123, 144], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [190, 215], \"errorMessage\": \"Unauthorized\"}, {\"pc\": [427, 437, 449, 464], \"errorMessage\": \"account opted into asset\"}, {\"pc\": [177, 213, 314, 325, 406, 459], \"errorMessage\": \"asset exists\"}, {\"pc\": [165], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [100, 126, 147], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [185, 206, 305], \"errorMessage\": \"check self.asset_id exists\"}, {\"pc\": [273], \"errorMessage\": \"check self.not_circulating_label_1 exists\"}, {\"pc\": [285], \"errorMessage\": \"check self.not_circulating_label_2 exists\"}, {\"pc\": [297], \"errorMessage\": \"check self.not_circulating_label_3 exists\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass SetAssetArgs:\n    \"\"\"Dataclass for set_asset arguments\"\"\"\n    asset_id: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"set_asset(uint64)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass SetNotCirculatingAddressArgs:\n    \"\"\"Dataclass for set_not_circulating_address arguments\"\"\"\n    address: str\n    label: str\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"set_not_circulating_address(address,string)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass Arc62GetCirculatingSupplyArgs:\n    \"\"\"Dataclass for arc62_get_circulating_supply arguments\"\"\"\n    asset_id: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"arc62_get_circulating_supply(uint64)uint64\"\n\n\nclass CirculatingSupplyParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_asset(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_not_circulating_address(address,string)void\",\n            \"args\": method_args,\n        }))\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass CirculatingSupplyCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_asset(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_not_circulating_address(address,string)void\",\n            \"args\": method_args,\n        }))\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass CirculatingSupplySend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_asset(uint64)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"set_not_circulating_address(address,string)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[int]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    asset_id: int\n    not_circulating_label_1: str\n    not_circulating_label_2: str\n    not_circulating_label_3: str\n\nclass CirculatingSupplyState:\n    \"\"\"Methods to access state for the current CirculatingSupply app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def asset_id(self) -> int:\n        \"\"\"Get the current value of the asset_id key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"asset_id\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def not_circulating_label_1(self) -> str:\n        \"\"\"Get the current value of the not_circulating_label_1 key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"not_circulating_label_1\")\n        if isinstance(value, dict) and \"address\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"address\"], value)  # type: ignore\n        return typing.cast(str, value)\n\n    @property\n    def not_circulating_label_2(self) -> str:\n        \"\"\"Get the current value of the not_circulating_label_2 key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"not_circulating_label_2\")\n        if isinstance(value, dict) and \"address\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"address\"], value)  # type: ignore\n        return typing.cast(str, value)\n\n    @property\n    def not_circulating_label_3(self) -> str:\n        \"\"\"Get the current value of the not_circulating_label_3 key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"not_circulating_label_3\")\n        if isinstance(value, dict) and \"address\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"address\"], value)  # type: ignore\n        return typing.cast(str, value)\n\nclass CirculatingSupplyClient:\n    \"\"\"Client for interacting with CirculatingSupply smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = CirculatingSupplyParams(self.app_client)\n        self.create_transaction = CirculatingSupplyCreateTransactionParams(self.app_client)\n        self.send = CirculatingSupplySend(self.app_client)\n        self.state = CirculatingSupplyState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"CirculatingSupplyClient\":\n        return CirculatingSupplyClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"CirculatingSupplyClient\":\n        return CirculatingSupplyClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"CirculatingSupplyClient\":\n        return CirculatingSupplyClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"CirculatingSupplyComposer\":\n        return CirculatingSupplyComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"set_asset(uint64)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"set_not_circulating_address(address,string)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"arc62_get_circulating_supply(uint64)uint64\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> int | None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | int:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass CirculatingSupplyBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):\n    \"\"\"Parameters for creating CirculatingSupply contract with bare calls\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:\n        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)\n\nclass CirculatingSupplyFactory(algokit_utils.TypedAppFactoryProtocol[CirculatingSupplyBareCallCreateParams, None, None]):\n    \"\"\"Factory for deploying and managing CirculatingSupplyClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = CirculatingSupplyFactoryParams(self.app_factory)\n        self.create_transaction = CirculatingSupplyFactoryCreateTransaction(self.app_factory)\n        self.send = CirculatingSupplyFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: CirculatingSupplyBareCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[CirculatingSupplyClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return CirculatingSupplyClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> CirculatingSupplyClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return CirculatingSupplyClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> CirculatingSupplyClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return CirculatingSupplyClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass CirculatingSupplyFactoryParams:\n    \"\"\"Parameters for creating transactions for CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = CirculatingSupplyFactoryCreateParams(app_factory)\n        self.update = CirculatingSupplyFactoryUpdateParams(app_factory)\n        self.delete = CirculatingSupplyFactoryDeleteParams(app_factory)\n\nclass CirculatingSupplyFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the set_asset(uint64)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"set_asset(uint64)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the set_not_circulating_address(address,string)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"set_not_circulating_address(address,string)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the arc62_get_circulating_supply(uint64)uint64 ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"arc62_get_circulating_supply(uint64)uint64\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass CirculatingSupplyFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass CirculatingSupplyFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass CirculatingSupplyFactoryCreateTransaction:\n    \"\"\"Create transactions for CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = CirculatingSupplyFactoryCreateTransactionCreate(app_factory)\n\n\nclass CirculatingSupplyFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass CirculatingSupplyFactorySend:\n    \"\"\"Send calls to CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = CirculatingSupplyFactorySendCreate(app_factory)\n\n\nclass CirculatingSupplyFactorySendCreate:\n    \"\"\"Send create calls to CirculatingSupply contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[CirculatingSupplyClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return CirculatingSupplyClient(result[0]), result[1]\n\n\nclass CirculatingSupplyComposer:\n    \"\"\"Composer for creating transaction groups for CirculatingSupply contract calls\"\"\"\n\n    def __init__(self, client: \"CirculatingSupplyClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    def set_asset(\n        self,\n        args: tuple[int] | SetAssetArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.set_asset(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"set_asset(uint64)void\", v\n            )\n        )\n        return self\n\n    def set_not_circulating_address(\n        self,\n        args: tuple[str, str] | SetNotCirculatingAddressArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.set_not_circulating_address(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"set_not_circulating_address(address,string)void\", v\n            )\n        )\n        return self\n\n    def arc62_get_circulating_supply(\n        self,\n        args: tuple[int] | Arc62GetCirculatingSupplyArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.arc62_get_circulating_supply(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"arc62_get_circulating_supply(uint64)uint64\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"CirculatingSupplyComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"CirculatingSupplyComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"instruction": "Generate a client library for interacting with a Lottery smart contract, providing methods for creating, calling, deleting, and managing the application, as well as accessing its state.", "output": "# flake8: noqa\n# fmt: off\n# mypy: ignore-errors\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^3.0.0\n\n# common\nimport dataclasses\nimport typing\n# core algosdk\nimport algosdk\nfrom algosdk.transaction import OnComplete\nfrom algosdk.atomic_transaction_composer import TransactionSigner\nfrom algosdk.source_map import SourceMap\nfrom algosdk.transaction import Transaction\nfrom algosdk.v2client.models import SimulateTraceConfig\n# utils\nimport algokit_utils\nfrom algokit_utils import AlgorandClient as _AlgoKitAlgorandClient\n\n_APP_SPEC_JSON = r\"\"\"{\"arcs\": [22, 28], \"bareActions\": {\"call\": [], \"create\": []}, \"methods\": [{\"actions\": {\"call\": [], \"create\": [\"NoOp\"]}, \"args\": [{\"type\": \"uint64\", \"name\": \"entry_fee\"}], \"name\": \"create_application\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Initialize the lottery contract with an entry fee.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [{\"type\": \"pay\", \"name\": \"payment_txn\"}], \"name\": \"enter_lottery\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Allow users to enter the lottery by sending the entry fee.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"NoOp\"], \"create\": []}, \"args\": [], \"name\": \"pick_winner\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Allows the contract creator to randomly pick a winner.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}, {\"actions\": {\"call\": [\"DeleteApplication\"], \"create\": []}, \"args\": [], \"name\": \"delete_application\", \"returns\": {\"type\": \"void\"}, \"desc\": \"Allows the creator to delete the application.\", \"events\": [], \"readonly\": false, \"recommendations\": {}}], \"name\": \"Lottery\", \"state\": {\"keys\": {\"box\": {}, \"global\": {\"entry_fee\": {\"key\": \"ZW50cnlfZmVl\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"total_entries\": {\"key\": \"dG90YWxfZW50cmllcw==\", \"keyType\": \"AVMString\", \"valueType\": \"AVMUint64\"}, \"creator_address\": {\"key\": \"Y3JlYXRvcl9hZGRyZXNz\", \"keyType\": \"AVMString\", \"valueType\": \"AVMBytes\"}}, \"local\": {}}, \"maps\": {\"box\": {}, \"global\": {}, \"local\": {}}, \"schema\": {\"global\": {\"bytes\": 1, \"ints\": 2}, \"local\": {\"bytes\": 0, \"ints\": 0}}}, \"structs\": {}, \"byteCode\": {\"approval\": \"CiADAAHoByYDD2NyZWF0b3JfYWRkcmVzcw10b3RhbF9lbnRyaWVzCWVudHJ5X2ZlZTEbQQAjggQEoDuB0gSH6knXBL4L3r8EM7NJnjYaAI4EADIAHAAQAAIiQzEZgQUSRDEYRIgAlyNDMRkURDEYRIgAVyNDMRkURDEYRDEWIwlJOBAjEkSIACIjQzEZFEQxGBRENhoBF4gAAiNDigEAKov/ZygyCWcpImeJigEAi/84BzIKEkSL/zgIIiplRBJEIillRCMIKUxniTEAIihlRBJEIillREQyBjIEIillRE8CTBhMGDgAsTIKcwBEgcCEPQmyCLIHI7IQJLIBs4kxACIoZUQSRLEiKGVEIihlRLIJIrIIsgcjshAksgGziQ==\", \"clear\": \"CoEBQw==\"}, \"compilerInfo\": {\"compiler\": \"puya\", \"compilerVersion\": {\"major\": 4, \"minor\": 4, \"patch\": 1}}, \"events\": [], \"networks\": {}, \"source\": {\"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAwIDEgMTAwMAogICAgYnl0ZWNibG9jayAiY3JlYXRvcl9hZGRyZXNzIiAidG90YWxfZW50cmllcyIgImVudHJ5X2ZlZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjEyLTEzCiAgICAvLyAjIFdlIHdhbnQgdGhlIG1ldGhvZHMgaW4gb3VyIGNvbnRyYWN0IHRvIGZvbGxvdyB0aGUgQVJDNCBzdGFuZGFyZAogICAgLy8gY2xhc3MgTG90dGVyeShBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYWZ0ZXJfaWZfZWxzZUAxMAogICAgcHVzaGJ5dGVzcyAweGEwM2I4MWQyIDB4ODdlYTQ5ZDcgMHhiZTBiZGViZiAweDMzYjM0OTllIC8vIG1ldGhvZCAiY3JlYXRlX2FwcGxpY2F0aW9uKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJlbnRlcl9sb3R0ZXJ5KHBheSl2b2lkIiwgbWV0aG9kICJwaWNrX3dpbm5lcigpdm9pZCIsIG1ldGhvZCAiZGVsZXRlX2FwcGxpY2F0aW9uKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl9jcmVhdGVfYXBwbGljYXRpb25fcm91dGVAMyBtYWluX2VudGVyX2xvdHRlcnlfcm91dGVANCBtYWluX3BpY2tfd2lubmVyX3JvdXRlQDUgbWFpbl9kZWxldGVfYXBwbGljYXRpb25fcm91dGVANgoKbWFpbl9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MTItMTMKICAgIC8vICMgV2Ugd2FudCB0aGUgbWV0aG9kcyBpbiBvdXIgY29udHJhY3QgdG8gZm9sbG93IHRoZSBBUkM0IHN0YW5kYXJkCiAgICAvLyBjbGFzcyBMb3R0ZXJ5KEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9hcHBsaWNhdGlvbl9yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6ODItODQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgKICAgIC8vICAgICBhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXQogICAgLy8gKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA1IC8vIERlbGV0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBkZWxldGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fcGlja193aW5uZXJfcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjUyCiAgICAvLyBAYXJjNC5hYmltZXRob2QKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBwaWNrX3dpbm5lcgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9lbnRlcl9sb3R0ZXJ5X3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjEyLTEzCiAgICAvLyAjIFdlIHdhbnQgdGhlIG1ldGhvZHMgaW4gb3VyIGNvbnRyYWN0IHRvIGZvbGxvdyB0aGUgQVJDNCBzdGFuZGFyZAogICAgLy8gY2xhc3MgTG90dGVyeShBUkM0Q29udHJhY3QpOgogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kCiAgICBjYWxsc3ViIGVudGVyX2xvdHRlcnkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX2FwcGxpY2F0aW9uX3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weToyMy0yNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKAogICAgLy8gICAgIGFsbG93X2FjdGlvbnM9WyJOb09wIl0sCiAgICAvLyAgICAgY3JlYXRlPSJyZXF1aXJlIiwKICAgIC8vICkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAhCiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weToxMi0xMwogICAgLy8gIyBXZSB3YW50IHRoZSBtZXRob2RzIGluIG91ciBjb250cmFjdCB0byBmb2xsb3cgdGhlIEFSQzQgc3RhbmRhcmQKICAgIC8vIGNsYXNzIExvdHRlcnkoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjIzLTI2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoCiAgICAvLyAgICAgYWxsb3dfYWN0aW9ucz1bIk5vT3AiXSwKICAgIC8vICAgICBjcmVhdGU9InJlcXVpcmUiLAogICAgLy8gKQogICAgY2FsbHN1YiBjcmVhdGVfYXBwbGljYXRpb24KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMubG90dGVyeS5jb250cmFjdC5Mb3R0ZXJ5LmNyZWF0ZV9hcHBsaWNhdGlvbihlbnRyeV9mZWU6IHVpbnQ2NCkgLT4gdm9pZDoKY3JlYXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MjMtMzAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgKICAgIC8vICAgICBhbGxvd19hY3Rpb25zPVsiTm9PcCJdLAogICAgLy8gICAgIGNyZWF0ZT0icmVxdWlyZSIsCiAgICAvLyApCiAgICAvLyBkZWYgY3JlYXRlX2FwcGxpY2F0aW9uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZW50cnlfZmVlOiBVSW50NjQsICAjIFRoZSBlbnRyeSBmZWUgcmVxdWlyZWQgdG8gcGFydGljaXBhdGUgaW4gdGhlIGxvdHRlcnkKICAgIC8vICkgLT4gTm9uZToKICAgIHByb3RvIDEgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MzQtMzUKICAgIC8vICMgSW5pdGlhbGl6ZSB0aGUgZW50cnkgZmVlIGFuZCBjcmVhdG9yIGFkZHJlc3MgaW4gdGhlIGNvbnRyYWN0J3Mgc3RhdGUKICAgIC8vIHNlbGYuZW50cnlfZmVlID0gZW50cnlfZmVlCiAgICBieXRlY18yIC8vICJlbnRyeV9mZWUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozNgogICAgLy8gc2VsZi5jcmVhdG9yX2FkZHJlc3MgPSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzCiAgICBieXRlY18wIC8vICJjcmVhdG9yX2FkZHJlc3MiCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTozNwogICAgLy8gc2VsZi50b3RhbF9lbnRyaWVzID0gVUludDY0KDApICAjIEluaXRpYWxpemUgdGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIHRvIDAKICAgIGJ5dGVjXzEgLy8gInRvdGFsX2VudHJpZXMiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5sb3R0ZXJ5LmNvbnRyYWN0LkxvdHRlcnkuZW50ZXJfbG90dGVyeShwYXltZW50X3R4bjogdWludDY0KSAtPiB2b2lkOgplbnRlcl9sb3R0ZXJ5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6MzktNDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZAogICAgLy8gZGVmIGVudGVyX2xvdHRlcnkoc2VsZiwgcGF5bWVudF90eG46IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo0NC00NQogICAgLy8gIyBFbnN1cmUgdGhhdCB0aGUgcGF5bWVudCBpcyBzZW50IHRvIHRoZSBhcHBsaWNhdGlvbiBhZGRyZXNzCiAgICAvLyBhc3NlcnQgcGF5bWVudF90eG4ucmVjZWl2ZXIgPT0gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjQ3LTQ4CiAgICAvLyAjICMgRW5zdXJlIHRoYXQgdGhlIHBheW1lbnQgYW1vdW50KG1pY3JvYWxnbykgaXMgZXF1YWwgdG8gdGhlIGVudHJ5IGZlZQogICAgLy8gYXNzZXJ0IHBheW1lbnRfdHhuLmFtb3VudCA9PSBzZWxmLmVudHJ5X2ZlZQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBbW91bnQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJlbnRyeV9mZWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZW50cnlfZmVlIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NTAKICAgIC8vIHNlbGYudG90YWxfZW50cmllcyArPSBVSW50NjQoMSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJ0b3RhbF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2VudHJpZXMgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWNfMSAvLyAidG90YWxfZW50cmllcyIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMubG90dGVyeS5jb250cmFjdC5Mb3R0ZXJ5LnBpY2tfd2lubmVyKCkgLT4gdm9pZDoKcGlja193aW5uZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo1Ny01OAogICAgLy8gIyAjIEVuc3VyZSB0aGF0IG9ubHkgdGhlIGNyZWF0b3IgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gc2VsZi5jcmVhdG9yX2FkZHJlc3MKICAgIHR4biBTZW5kZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJjcmVhdG9yX2FkZHJlc3MiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY3JlYXRvcl9hZGRyZXNzIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NjAtNjEKICAgIC8vICMgRW5zdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwYXJ0aWNpcGFudAogICAgLy8gYXNzZXJ0IHNlbGYudG90YWxfZW50cmllcyA+IFVJbnQ2NCgwKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInRvdGFsX2VudHJpZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudG90YWxfZW50cmllcyBleGlzdHMKICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NjMtNjQKICAgIC8vICMgU2ltcGxlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB1c2luZyByb3VuZCBhbmQgaW5kZXgKICAgIC8vIHJvdW5kX251bWJlciA9IEdsb2JhbC5yb3VuZAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo2NQogICAgLy8gZ3JvdXBfc2l6ZSA9IEdsb2JhbC5ncm91cF9zaXplCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo2Ny02OAogICAgLy8gIyBDYWxjdWxhdGUgcHNldWRvLXJhbmRvbSBpbmRleCBiYXNlZCBvbiByb3VuZCBudW1iZXIgYW5kIGdyb3VwIHNpemUKICAgIC8vIHJhbmRvbV9udW1iZXIgPSByb3VuZF9udW1iZXIgJSBzZWxmLnRvdGFsX2VudHJpZXMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJ0b3RhbF9lbnRyaWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnRvdGFsX2VudHJpZXMgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjcwLTcxCiAgICAvLyAjIEdldCB0aGUgd2lubmVyJ3MgYWRkcmVzcyBmcm9tIHRoZSB0cmFuc2FjdGlvbiBhdCB0aGUgY2FsY3VsYXRlZCBpbmRleAogICAgLy8gd2lubmVyX2luZGV4ID0gcmFuZG9tX251bWJlciAlIGdyb3VwX3NpemUKICAgIHN3YXAKICAgICUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5OjcyCiAgICAvLyB3aW5uZXJfYWRkcmVzcyA9IGd0eG4uVHJhbnNhY3Rpb24od2lubmVyX2luZGV4KS5zZW5kZXIKICAgIGd0eG5zIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzQtODAKICAgIC8vICMgaXR4bi5mZWUoVUludDY0KDEwMDApKQogICAgLy8gIyBUcmFuc2ZlciBhbGwgQUxHT3MgY29sbGVjdGVkIHRvIHRoZSB3aW5uZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlIC0gVUludDY0KDEwMF8wMF8wMCksICMgMSBBbGdvID0gMTAwMDAwMCBtaWNyb2FsZ29zCiAgICAvLyAgICAgcmVjZWl2ZXI9d2lubmVyX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzcKICAgIC8vIGFtb3VudD1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBVSW50NjQoMTAwXzAwXzAwKSwgIyAxIEFsZ28gPSAxMDAwMDAwIG1pY3JvYWxnb3MKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgcHVzaGludCAxMDAwMDAwIC8vIDEwMDAwMDAKICAgIC0KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo3NC03NgogICAgLy8gIyBpdHhuLmZlZShVSW50NjQoMTAwMCkpCiAgICAvLyAjIFRyYW5zZmVyIGFsbCBBTEdPcyBjb2xsZWN0ZWQgdG8gdGhlIHdpbm5lcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzkKICAgIC8vIGZlZT1VSW50NjQoMTAwMCkKICAgIGludGNfMiAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6NzQtODAKICAgIC8vICMgaXR4bi5mZWUoVUludDY0KDEwMDApKQogICAgLy8gIyBUcmFuc2ZlciBhbGwgQUxHT3MgY29sbGVjdGVkIHRvIHRoZSB3aW5uZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBhbW91bnQ9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5iYWxhbmNlIC0gVUludDY0KDEwMF8wMF8wMCksICMgMSBBbGdvID0gMTAwMDAwMCBtaWNyb2FsZ29zCiAgICAvLyAgICAgcmVjZWl2ZXI9d2lubmVyX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5sb3R0ZXJ5LmNvbnRyYWN0LkxvdHRlcnkuZGVsZXRlX2FwcGxpY2F0aW9uKCkgLT4gdm9pZDoKZGVsZXRlX2FwcGxpY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6ODktOTAKICAgIC8vICMgT25seSBhbGxvdyB0aGUgY3JlYXRvciB0byBkZWxldGUgdGhlIGFwcGxpY2F0aW9uCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBzZWxmLmNyZWF0b3JfYWRkcmVzcwogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gImNyZWF0b3JfYWRkcmVzcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jcmVhdG9yX2FkZHJlc3MgZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5Mi05OAogICAgLy8gIyBTZW5kIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0byB0aGUgY3JlYXRvcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuY3JlYXRvcl9hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gICAgIGNsb3NlX3JlbWFpbmRlcl90bz1zZWxmLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBmZWU9VUludDY0KDEwMDApCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5NAogICAgLy8gcmVjZWl2ZXI9c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiY3JlYXRvcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNyZWF0b3JfYWRkcmVzcyBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9sb3R0ZXJ5L2NvbnRyYWN0LnB5Ojk2CiAgICAvLyBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiY3JlYXRvcl9hZGRyZXNzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNyZWF0b3JfYWRkcmVzcyBleGlzdHMKICAgIGl0eG5fZmllbGQgQ2xvc2VSZW1haW5kZXJUbwogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTUKICAgIC8vIGFtb3VudD0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvbG90dGVyeS9jb250cmFjdC5weTo5Mi05MwogICAgLy8gIyBTZW5kIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0byB0aGUgY3JlYXRvcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTcKICAgIC8vIGZlZT1VSW50NjQoMTAwMCkKICAgIGludGNfMiAvLyAxMDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2xvdHRlcnkvY29udHJhY3QucHk6OTItOTgKICAgIC8vICMgU2VuZCB0aGUgcmVtYWluaW5nIGJhbGFuY2UgdG8gdGhlIGNyZWF0b3IKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmNyZWF0b3JfYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5jcmVhdG9yX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxMDAwKQogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIHJldHN1Ygo=\", \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K\"}, \"sourceInfo\": {\"approval\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": [{\"pc\": [96], \"errorMessage\": \"OnCompletion is not DeleteApplication\"}, {\"pc\": [108, 120, 142], \"errorMessage\": \"OnCompletion is not NoOp\"}, {\"pc\": [236], \"errorMessage\": \"account funded\"}, {\"pc\": [146], \"errorMessage\": \"can only call when creating\"}, {\"pc\": [99, 111, 123], \"errorMessage\": \"can only call when not creating\"}, {\"pc\": [207, 259, 266, 270], \"errorMessage\": \"check self.creator_address exists\"}, {\"pc\": [189], \"errorMessage\": \"check self.entry_fee exists\"}, {\"pc\": [195, 213, 222], \"errorMessage\": \"check self.total_entries exists\"}, {\"pc\": [133], \"errorMessage\": \"transaction type is pay\"}]}, \"clear\": {\"pcOffsetMethod\": \"none\", \"sourceInfo\": []}}, \"templateVariables\": {}}\"\"\"\nAPP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)\n\ndef _parse_abi_args(args: object | None = None) -> list[object] | None:\n    \"\"\"Helper to parse ABI args into the format expected by underlying client\"\"\"\n    if args is None:\n        return None\n\n    def convert_dataclass(value: object) -> object:\n        if dataclasses.is_dataclass(value):\n            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))\n        elif isinstance(value, (list, tuple)):\n            return type(value)(convert_dataclass(item) for item in value)\n        return value\n\n    match args:\n        case tuple():\n            method_args = list(args)\n        case _ if dataclasses.is_dataclass(args):\n            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]\n        case _:\n            raise ValueError(\"Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.\")\n\n    return [\n        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg\n        for arg in method_args\n    ] if method_args else None\n\ndef _init_dataclass(cls: type, data: dict) -> object:\n    \"\"\"\n    Recursively instantiate a dataclass of type `cls` from `data`.\n\n    For each field on the dataclass, if the field type is also a dataclass\n    and the corresponding data is a dict, instantiate that field recursively.\n    \"\"\"\n    field_values = {}\n    for field in dataclasses.fields(cls):\n        field_value = data.get(field.name)\n        # Check if the field expects another dataclass and the value is a dict.\n        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):\n            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)\n        else:\n            field_values[field.name] = field_value\n    return cls(**field_values)\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass EnterLotteryArgs:\n    \"\"\"Dataclass for enter_lottery arguments\"\"\"\n    payment_txn: algokit_utils.AppMethodCallTransactionArgument\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"enter_lottery(pay)void\"\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass CreateApplicationArgs:\n    \"\"\"Dataclass for create_application arguments\"\"\"\n    entry_fee: int\n\n    @property\n    def abi_method_signature(self) -> str:\n        return \"create_application(uint64)void\"\n\n\nclass _LotteryDelete:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppDeleteMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass LotteryParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_LotteryDelete\":\n        return _LotteryDelete(self.app_client)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"enter_lottery(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"pick_winner()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.AppCallMethodCallParams:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> algokit_utils.AppCallParams:\n        return self.app_client.params.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _LotteryDeleteTransaction:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }))\n\n\nclass LotteryCreateTransactionParams:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_LotteryDeleteTransaction\":\n        return _LotteryDeleteTransaction(self.app_client)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"enter_lottery(pay)void\",\n            \"args\": method_args,\n        }))\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"pick_winner()void\",\n        }))\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> algokit_utils.BuiltTransactions:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64)void\",\n            \"args\": method_args,\n        }))\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        \n    ) -> Transaction:\n        return self.app_client.create_transaction.bare.clear_state(\n            params,\n            \n        )\n\n\nclass _LotteryDeleteSend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.delete(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"delete_application()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n\nclass LotterySend:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def delete(self) -> \"_LotteryDeleteSend\":\n        return _LotteryDeleteSend(self.app_client)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"enter_lottery(pay)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n    \n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"pick_winner()void\",\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[None]:\n        method_args = _parse_abi_args(args)\n        params = params or algokit_utils.CommonAppCallParams()\n        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{\n            **dataclasses.asdict(params),\n            \"method\": \"create_application(uint64)void\",\n            \"args\": method_args,\n        }), send_params=send_params)\n        parsed_response = response\n        return typing.cast(algokit_utils.SendAppTransactionResult[None], parsed_response)\n\n    def clear_state(\n        self,\n        params: algokit_utils.AppClientBareCallParams | None = None,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:\n        return self.app_client.send.bare.clear_state(\n            params,\n            send_params=send_params,\n        )\n\n\nclass GlobalStateValue(typing.TypedDict):\n    \"\"\"Shape of global_state state key values\"\"\"\n    entry_fee: int\n    total_entries: int\n    creator_address: bytes\n\nclass LotteryState:\n    \"\"\"Methods to access state for the current Lottery app\"\"\"\n\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n\n    @property\n    def global_state(\n        self\n    ) -> \"_GlobalState\":\n            \"\"\"Methods to access global_state for the current app\"\"\"\n            return _GlobalState(self.app_client)\n\nclass _GlobalState:\n    def __init__(self, app_client: algokit_utils.AppClient):\n        self.app_client = app_client\n        \n        # Pre-generated mapping of value types to their struct classes\n        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}\n\n    def get_all(self) -> GlobalStateValue:\n        \"\"\"Get all current keyed values from global_state state\"\"\"\n        result = self.app_client.state.global_state.get_all()\n        if not result:\n            return typing.cast(GlobalStateValue, {})\n\n        converted = {}\n        for key, value in result.items():\n            key_info = self.app_client.app_spec.state.keys.global_state.get(key)\n            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None\n            converted[key] = (\n                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)\n                else value\n            )\n        return typing.cast(GlobalStateValue, converted)\n\n    @property\n    def entry_fee(self) -> int:\n        \"\"\"Get the current value of the entry_fee key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"entry_fee\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def total_entries(self) -> int:\n        \"\"\"Get the current value of the total_entries key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"total_entries\")\n        if isinstance(value, dict) and \"AVMUint64\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMUint64\"], value)  # type: ignore\n        return typing.cast(int, value)\n\n    @property\n    def creator_address(self) -> bytes:\n        \"\"\"Get the current value of the creator_address key in global_state state\"\"\"\n        value = self.app_client.state.global_state.get_value(\"creator_address\")\n        if isinstance(value, dict) and \"AVMBytes\" in self._struct_classes:\n            return _init_dataclass(self._struct_classes[\"AVMBytes\"], value)  # type: ignore\n        return typing.cast(bytes, value)\n\nclass LotteryClient:\n    \"\"\"Client for interacting with Lottery smart contract\"\"\"\n\n    @typing.overload\n    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...\n    \n    @typing.overload\n    def __init__(\n        self,\n        *,\n        algorand: _AlgoKitAlgorandClient,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        app_client: algokit_utils.AppClient | None = None,\n        *,\n        algorand: _AlgoKitAlgorandClient | None = None,\n        app_id: int | None = None,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> None:\n        if app_client:\n            self.app_client = app_client\n        elif algorand and app_id:\n            self.app_client = algokit_utils.AppClient(\n                algokit_utils.AppClientParams(\n                    algorand=algorand,\n                    app_spec=APP_SPEC,\n                    app_id=app_id,\n                    app_name=app_name,\n                    default_sender=default_sender,\n                    default_signer=default_signer,\n                    approval_source_map=approval_source_map,\n                    clear_source_map=clear_source_map,\n                )\n            )\n        else:\n            raise ValueError(\"Either app_client or algorand and app_id must be provided\")\n    \n        self.params = LotteryParams(self.app_client)\n        self.create_transaction = LotteryCreateTransactionParams(self.app_client)\n        self.send = LotterySend(self.app_client)\n        self.state = LotteryState(self.app_client)\n\n    @staticmethod\n    def from_creator_and_name(\n        creator_address: str,\n        app_name: str,\n        algorand: _AlgoKitAlgorandClient,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n    ) -> \"LotteryClient\":\n        return LotteryClient(\n            algokit_utils.AppClient.from_creator_and_name(\n                creator_address=creator_address,\n                app_name=app_name,\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n                ignore_cache=ignore_cache,\n                app_lookup_cache=app_lookup_cache,\n            )\n        )\n    \n    @staticmethod\n    def from_network(\n        algorand: _AlgoKitAlgorandClient,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"LotteryClient\":\n        return LotteryClient(\n            algokit_utils.AppClient.from_network(\n                app_spec=APP_SPEC,\n                algorand=algorand,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n    \n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n    \n    @property\n    def app_name(self) -> str:\n        return self.app_client.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_client.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_client.algorand\n\n    def clone(\n        self,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> \"LotteryClient\":\n        return LotteryClient(\n            self.app_client.clone(\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                approval_source_map=approval_source_map,\n                clear_source_map=clear_source_map,\n            )\n        )\n\n    def new_group(self) -> \"LotteryComposer\":\n        return LotteryComposer(self)\n\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"enter_lottery(pay)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"pick_winner()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"create_application(uint64)void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: typing.Literal[\"delete_application()void\"],\n        return_value: algokit_utils.ABIReturn | None\n    ) -> None: ...\n    @typing.overload\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...\n\n    def decode_return_value(\n        self,\n        method: str,\n        return_value: algokit_utils.ABIReturn | None\n    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None:\n        \"\"\"Decode ABI return value for the given method.\"\"\"\n        if return_value is None:\n            return None\n    \n        arc56_method = self.app_spec.get_arc56_method(method)\n        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)\n    \n        # If method returns a struct, convert the dict to appropriate dataclass\n        if (arc56_method and\n            arc56_method.returns and\n            arc56_method.returns.struct and\n            isinstance(decoded, dict)):\n            struct_class = globals().get(arc56_method.returns.struct)\n            if struct_class:\n                return struct_class(**typing.cast(dict, decoded))\n        return decoded\n\n\n@dataclasses.dataclass(frozen=True)\nclass LotteryMethodCallCreateParams(\n    algokit_utils.AppClientCreateSchema, algokit_utils.BaseAppClientMethodCallParams[\n        CreateApplicationArgs,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for creating Lottery contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallCreateParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallCreateParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\n@dataclasses.dataclass(frozen=True)\nclass LotteryMethodCallDeleteParams(\n    algokit_utils.BaseAppClientMethodCallParams[\n        typing.Any,\n        str | None,\n    ]\n):\n    \"\"\"Parameters for calling Lottery contract using ABI\"\"\"\n    on_complete: typing.Literal[OnComplete.DeleteApplicationOC] | None = None\n    method: str | None = None\n\n    def to_algokit_utils_params(self) -> algokit_utils.AppClientMethodCallParams:\n        method_args = _parse_abi_args(self.args)\n        return algokit_utils.AppClientMethodCallParams(\n            **{\n                **self.__dict__,\n                \"method\": self.method or getattr(self.args, \"abi_method_signature\", None),\n                \"args\": method_args,\n            }\n        )\n\nclass LotteryFactory(algokit_utils.TypedAppFactoryProtocol[LotteryMethodCallCreateParams, None, LotteryMethodCallDeleteParams]):\n    \"\"\"Factory for deploying and managing LotteryClient smart contracts\"\"\"\n\n    def __init__(\n        self,\n        algorand: _AlgoKitAlgorandClient,\n        *,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        version: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ):\n        self.app_factory = algokit_utils.AppFactory(\n            params=algokit_utils.AppFactoryParams(\n                algorand=algorand,\n                app_spec=APP_SPEC,\n                app_name=app_name,\n                default_sender=default_sender,\n                default_signer=default_signer,\n                version=version,\n                compilation_params=compilation_params,\n            )\n        )\n        self.params = LotteryFactoryParams(self.app_factory)\n        self.create_transaction = LotteryFactoryCreateTransaction(self.app_factory)\n        self.send = LotteryFactorySend(self.app_factory)\n\n    @property\n    def app_name(self) -> str:\n        return self.app_factory.app_name\n    \n    @property\n    def app_spec(self) -> algokit_utils.Arc56Contract:\n        return self.app_factory.app_spec\n    \n    @property\n    def algorand(self) -> _AlgoKitAlgorandClient:\n        return self.app_factory.algorand\n\n    def deploy(\n        self,\n        *,\n        on_update: algokit_utils.OnUpdate | None = None,\n        on_schema_break: algokit_utils.OnSchemaBreak | None = None,\n        create_params: LotteryMethodCallCreateParams | None = None,\n        update_params: None = None,\n        delete_params: LotteryMethodCallDeleteParams | None = None,\n        existing_deployments: algokit_utils.ApplicationLookup | None = None,\n        ignore_cache: bool = False,\n        app_name: str | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n    ) -> tuple[LotteryClient, algokit_utils.AppFactoryDeployResult]:\n        \"\"\"Deploy the application\"\"\"\n        deploy_response = self.app_factory.deploy(\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            create_params=create_params.to_algokit_utils_params() if create_params else None,\n            update_params=update_params,\n            delete_params=delete_params.to_algokit_utils_params() if delete_params else None,\n            existing_deployments=existing_deployments,\n            ignore_cache=ignore_cache,\n            app_name=app_name,\n            compilation_params=compilation_params,\n            send_params=send_params,\n        )\n\n        return LotteryClient(deploy_response[0]), deploy_response[1]\n\n    def get_app_client_by_creator_and_name(\n        self,\n        creator_address: str,\n        app_name: str,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        ignore_cache: bool | None = None,\n        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> LotteryClient:\n        \"\"\"Get an app client by creator address and name\"\"\"\n        return LotteryClient(\n            self.app_factory.get_app_client_by_creator_and_name(\n                creator_address,\n                app_name,\n                default_sender,\n                default_signer,\n                ignore_cache,\n                app_lookup_cache,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n    def get_app_client_by_id(\n        self,\n        app_id: int,\n        app_name: str | None = None,\n        default_sender: str | None = None,\n        default_signer: TransactionSigner | None = None,\n        approval_source_map: SourceMap | None = None,\n        clear_source_map: SourceMap | None = None,\n    ) -> LotteryClient:\n        \"\"\"Get an app client by app ID\"\"\"\n        return LotteryClient(\n            self.app_factory.get_app_client_by_id(\n                app_id,\n                app_name,\n                default_sender,\n                default_signer,\n                approval_source_map,\n                clear_source_map,\n            )\n        )\n\n\nclass LotteryFactoryParams:\n    \"\"\"Parameters for creating transactions for Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = LotteryFactoryCreateParams(app_factory)\n        self.update = LotteryFactoryUpdateParams(app_factory)\n        self.delete = LotteryFactoryDeleteParams(app_factory)\n\nclass LotteryFactoryCreateParams:\n    \"\"\"Parameters for 'create' operations of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateParams:\n        \"\"\"Creates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            compilation_params=compilation_params)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the enter_lottery(pay)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"enter_lottery(pay)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def pick_winner(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the pick_winner()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"pick_winner()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the create_application(uint64)void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"create_application(uint64)void\",\n                \"args\": _parse_abi_args(args),\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\n    def delete_application(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> algokit_utils.AppCreateMethodCallParams:\n        \"\"\"Creates a new instance using the delete_application()void ABI method\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.create(\n            algokit_utils.AppFactoryCreateMethodCallParams(\n                **{\n                **dataclasses.asdict(params),\n                \"method\": \"delete_application()void\",\n                \"args\": None,\n                }\n            ),\n            compilation_params=compilation_params\n        )\n\nclass LotteryFactoryUpdateParams:\n    \"\"\"Parameters for 'update' operations of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppUpdateParams:\n        \"\"\"Updates an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_update(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\nclass LotteryFactoryDeleteParams:\n    \"\"\"Parameters for 'delete' operations of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        \n    ) -> algokit_utils.AppDeleteParams:\n        \"\"\"Deletes an instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.params.bare.deploy_delete(\n            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),\n            )\n\n\nclass LotteryFactoryCreateTransaction:\n    \"\"\"Create transactions for Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = LotteryFactoryCreateTransactionCreate(app_factory)\n\n\nclass LotteryFactoryCreateTransactionCreate:\n    \"\"\"Create new instances of Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n    ) -> Transaction:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        return self.app_factory.create_transaction.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n        )\n\n\nclass LotteryFactorySend:\n    \"\"\"Send calls to Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n        self.create = LotteryFactorySendCreate(app_factory)\n\n\nclass LotteryFactorySendCreate:\n    \"\"\"Send create calls to Lottery contract\"\"\"\n\n    def __init__(self, app_factory: algokit_utils.AppFactory):\n        self.app_factory = app_factory\n\n    def bare(\n        self,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None,\n    ) -> tuple[LotteryClient, algokit_utils.SendAppCreateTransactionResult]:\n        \"\"\"Creates a new instance using a bare call\"\"\"\n        params = params or algokit_utils.CommonAppCallCreateParams()\n        result = self.app_factory.send.bare.create(\n            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),\n            send_params=send_params,\n            compilation_params=compilation_params\n        )\n        return LotteryClient(result[0]), result[1]\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        *,\n        params: algokit_utils.CommonAppCallCreateParams | None = None,\n        send_params: algokit_utils.SendParams | None = None,\n        compilation_params: algokit_utils.AppClientCompilationParams | None = None\n    ) -> tuple[LotteryClient, algokit_utils.AppFactoryCreateMethodCallResult[None]]:\n            \"\"\"Creates and sends a transaction using the create_application(uint64)void ABI method\"\"\"\n            params = params or algokit_utils.CommonAppCallCreateParams()\n            client, result = self.app_factory.send.create(\n                algokit_utils.AppFactoryCreateMethodCallParams(\n                    **{\n                    **dataclasses.asdict(params),\n                    \"method\": \"create_application(uint64)void\",\n                    \"args\": _parse_abi_args(args),\n                    }\n                ),\n                send_params=send_params,\n                compilation_params=compilation_params\n            )\n            return_value = None if result.abi_return is None else typing.cast(None, result.abi_return)\n    \n            return LotteryClient(client), algokit_utils.AppFactoryCreateMethodCallResult[None](\n                **{\n                    **result.__dict__,\n                    \"app_id\": result.app_id,\n                    \"abi_return\": return_value,\n                    \"transaction\": result.transaction,\n                    \"confirmation\": result.confirmation,\n                    \"group_id\": result.group_id,\n                    \"tx_ids\": result.tx_ids,\n                    \"transactions\": result.transactions,\n                    \"confirmations\": result.confirmations,\n                    \"app_address\": result.app_address,\n                }\n            )\n\n\nclass _LotteryDeleteComposer:\n    def __init__(self, composer: \"LotteryComposer\"):\n        self.composer = composer\n    def delete_application(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self.composer._composer.add_app_delete_method_call(\n            self.composer.client.params.delete.delete_application(\n                \n                params=params,\n                \n            )\n        )\n        self.composer._result_mappers.append(\n            lambda v: self.composer.client.decode_return_value(\n                \"delete_application()void\", v\n            )\n        )\n        return self.composer\n\n\nclass LotteryComposer:\n    \"\"\"Composer for creating transaction groups for Lottery contract calls\"\"\"\n\n    def __init__(self, client: \"LotteryClient\"):\n        self.client = client\n        self._composer = client.algorand.new_group()\n        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []\n\n    @property\n    def delete(self) -> \"_LotteryDeleteComposer\":\n        return _LotteryDeleteComposer(self)\n\n    def enter_lottery(\n        self,\n        args: tuple[algokit_utils.AppMethodCallTransactionArgument] | EnterLotteryArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.enter_lottery(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"enter_lottery(pay)void\", v\n            )\n        )\n        return self\n\n    def pick_winner(\n        self,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.pick_winner(\n                \n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"pick_winner()void\", v\n            )\n        )\n        return self\n\n    def create_application(\n        self,\n        args: tuple[int] | CreateApplicationArgs,\n        params: algokit_utils.CommonAppCallParams | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_app_call_method_call(\n            self.client.params.create_application(\n                args=args,\n                params=params,\n            )\n        )\n        self._result_mappers.append(\n            lambda v: self.client.decode_return_value(\n                \"create_application(uint64)void\", v\n            )\n        )\n        return self\n\n    def clear_state(\n        self,\n        *,\n        args: list[bytes] | None = None,\n        params: algokit_utils.CommonAppCallParams | None = None,\n    ) -> \"LotteryComposer\":\n        params=params or algokit_utils.CommonAppCallParams()\n        self._composer.add_app_call(\n            self.client.params.clear_state(\n                algokit_utils.AppClientBareCallParams(\n                    **{\n                        **dataclasses.asdict(params),\n                        \"args\": args\n                    }\n                )\n            )\n        )\n        return self\n    \n    def add_transaction(\n        self, txn: Transaction, signer: TransactionSigner | None = None\n    ) -> \"LotteryComposer\":\n        self._composer.add_transaction(txn, signer)\n        return self\n    \n    def composer(self) -> algokit_utils.TransactionComposer:\n        return self._composer\n    \n    def simulate(\n        self,\n        allow_more_logs: bool | None = None,\n        allow_empty_signatures: bool | None = None,\n        allow_unnamed_resources: bool | None = None,\n        extra_opcode_budget: int | None = None,\n        exec_trace_config: SimulateTraceConfig | None = None,\n        simulation_round: int | None = None,\n        skip_signatures: bool | None = None,\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.simulate(\n            allow_more_logs=allow_more_logs,\n            allow_empty_signatures=allow_empty_signatures,\n            allow_unnamed_resources=allow_unnamed_resources,\n            extra_opcode_budget=extra_opcode_budget,\n            exec_trace_config=exec_trace_config,\n            simulation_round=simulation_round,\n            skip_signatures=skip_signatures,\n        )\n    \n    def send(\n        self,\n        send_params: algokit_utils.SendParams | None = None\n    ) -> algokit_utils.SendAtomicTransactionComposerResults:\n        return self._composer.send(send_params)"}
{"instruction": "Implement a Smart ASA (Algorand Standard Asset) using PyTeal, adhering to the ARC-20 standard, including creation, configuration, transfer, freezing, clawback, destruction, and related getter methods, along with ABI methods for application calls.", "output": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nSmart ASA PyTEAL reference implementation based on ARC-20\n\"\"\"\n\n__author__ = \"Cosimo Bassi, Stefano De Angelis\"\n__email__ = \"<cosimo.bassi@algorand.com>, <stefano.deangelis@algorand.com>\"\n\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    AssetHolding,\n    AssetParam,\n    BareCallActions,\n    Bytes,\n    CallConfig,\n    Concat,\n    Expr,\n    Extract,\n    Global,\n    Gtxn,\n    If,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Len,\n    Mode,\n    Not,\n    OnCompleteAction,\n    OptimizeOptions,\n    Or,\n    Reject,\n    Return,\n    Router,\n    Seq,\n    Subroutine,\n    Suffix,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n    compileTeal,\n)\nfrom algosdk.future.transaction import StateSchema\nfrom algosdk.constants import key_len_bytes\n\n\n# / --- CONSTANTS\nTEAL_VERSION = 7\n\n# Descriptive field for the binding of Smart ASA App ID into the Underlying ASA url.\nSMART_ASA_APP_BINDING = \"smart-asa-app-id:\"\n\n# NOTE: The following costs could change over time with protocol upgrades.\nOPTIN_COST = 100_000\nUINTS_COST = 28_500\nBYTES_COST = 50_000\n\n\ndef static_attrs(cls):\n    return [k for k in cls.__dict__ if not k.startswith(\"__\")]\n\n\n# / --- SMART ASA ASC\n# / --- --- ERRORS\nclass Error:\n    address_length = \"Invalid Address length (must be 32 bytes)\"\n    missing_smart_asa_id = \"Smart ASA ID does not exist\"\n    invalid_smart_asa_id = \"Invalid Smart ASA ID\"\n    not_creator_addr = \"Caller not authorized (must be: App Creator Address)\"\n    not_manager_addr = \"Caller not authorized (must be: Manager Address)\"\n    not_reserve_addr = \"Caller not authorized (must be: Reserve Address)\"\n    not_freeze_addr = \"Caller not authorized (must be: Freeze Address)\"\n    not_clawback_addr = \"Caller not authorized (must be: Clawback Address)\"\n    asset_frozen = \"Smart ASA is frozen\"\n    sender_frozen = \"Sender is frozen\"\n    receiver_frozen = \"Receiver is frozen\"\n\n\n# / --- --- GLOBAL STATE\nclass GlobalInts:\n    total = Bytes(\"total\")\n    decimals = Bytes(\"decimals\")\n    default_frozen = Bytes(\"default_frozen\")\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass GlobalBytes:\n    unit_name = Bytes(\"unit_name\")\n    name = Bytes(\"name\")\n    url = Bytes(\"url\")\n    metadata_hash = Bytes(\"metadata_hash\")\n    manager_addr = Bytes(\"manager_addr\")\n    reserve_addr = Bytes(\"reserve_addr\")\n    freeze_addr = Bytes(\"freeze_addr\")\n    clawback_addr = Bytes(\"clawback_addr\")\n\n\nclass GlobalState(GlobalInts, GlobalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(GlobalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(GlobalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\nclass SmartASAConfig(abi.NamedTuple):\n    total: abi.Field[abi.Uint64]\n    decimals: abi.Field[abi.Uint32]\n    default_frozen: abi.Field[abi.Bool]\n    unit_name: abi.Field[abi.String]\n    name: abi.Field[abi.String]\n    url: abi.Field[abi.String]\n    metadata_hash: abi.Field[abi.DynamicArray[abi.Byte]]\n    manager_addr: abi.Field[abi.Address]\n    reserve_addr: abi.Field[abi.Address]\n    freeze_addr: abi.Field[abi.Address]\n    clawback_addr: abi.Field[abi.Address]\n\n\n# / --- --- LOCAL STATE\n# NOTE: Local State is needed only if the Smart ASA has `account_frozen`.\n# Local State is not needed in case Smart ASA has just \"global\" `asset_freeze`.\nclass LocalInts:\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass LocalBytes:\n    ...\n\n\nclass LocalState(LocalInts, LocalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(LocalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(LocalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\n# / --- --- SUBROUTINES\n@Subroutine(TealType.none)\ndef init_global_state() -> Expr:\n    return Seq(\n        App.globalPut(GlobalState.smart_asa_id, Int(0)),\n        App.globalPut(GlobalState.total, Int(0)),\n        App.globalPut(GlobalState.decimals, Int(0)),\n        App.globalPut(GlobalState.default_frozen, Int(0)),\n        # NOTE: ASA behaves excluding `unit_name` field if not declared:\n        App.globalPut(GlobalState.unit_name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `name` field if not declared:\n        App.globalPut(GlobalState.name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `url` field if not declared:\n        App.globalPut(GlobalState.url, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `metadata_hash` field if not declared:\n        App.globalPut(GlobalState.metadata_hash, Bytes(\"\")),\n        App.globalPut(GlobalState.manager_addr, Global.zero_address()),\n        App.globalPut(GlobalState.reserve_addr, Global.zero_address()),\n        App.globalPut(GlobalState.freeze_addr, Global.zero_address()),\n        App.globalPut(GlobalState.clawback_addr, Global.zero_address()),\n        # Special Smart ASA fields\n        App.globalPut(GlobalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.none)\ndef init_local_state() -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    return Seq(\n        App.localPut(Txn.sender(), LocalState.smart_asa_id, smart_asa_id),\n        App.localPut(Txn.sender(), LocalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef digit_to_ascii(i: Expr) -> Expr:\n    \"\"\"digit_to_ascii converts an integer < 10 to the ASCII byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), i, Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i: Expr) -> Expr:\n    \"\"\"itoa converts an integer to the ASCII byte string it represents.\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            digit_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef strip_len_prefix(abi_encoded: Expr) -> Expr:\n    return Suffix(abi_encoded, Int(abi.Uint16TypeSpec().byte_length_static()))\n\n\n# / --- --- UNDERLYING ASA CONFIG\nUNDERLYING_ASA_TOTAL = Int(2**64 - 1)\nUNDERLYING_ASA_DECIMALS = Int(0)\nUNDERLYING_ASA_DEFAULT_FROZEN = Int(1)\nUNDERLYING_ASA_UNIT_NAME = Bytes(\"S-ASA\")\nUNDERLYING_ASA_NAME = Bytes(\"SMART-ASA\")\nUNDERLYING_ASA_URL = Concat(\n    Bytes(SMART_ASA_APP_BINDING), itoa(Global.current_application_id())\n)\nUNDERLYING_ASA_METADATA_HASH = Bytes(\"\")\nUNDERLYING_ASA_MANAGER_ADDR = Global.current_application_address()\nUNDERLYING_ASA_RESERVE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_FREEZE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_CLAWBACK_ADDR = Global.current_application_address()\n\n\n@Subroutine(TealType.uint64)\ndef underlying_asa_create_inner_tx() -> Expr:\n    return Seq(\n        InnerTxnBuilder.Execute(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: UNDERLYING_ASA_TOTAL,\n                TxnField.config_asset_decimals: UNDERLYING_ASA_DECIMALS,\n                TxnField.config_asset_default_frozen: UNDERLYING_ASA_DEFAULT_FROZEN,\n                TxnField.config_asset_unit_name: UNDERLYING_ASA_UNIT_NAME,\n                TxnField.config_asset_name: UNDERLYING_ASA_NAME,\n                TxnField.config_asset_url: UNDERLYING_ASA_URL,\n                TxnField.config_asset_manager: UNDERLYING_ASA_MANAGER_ADDR,\n                TxnField.config_asset_reserve: UNDERLYING_ASA_RESERVE_ADDR,\n                TxnField.config_asset_freeze: UNDERLYING_ASA_FREEZE_ADDR,\n                TxnField.config_asset_clawback: UNDERLYING_ASA_CLAWBACK_ADDR,\n            }\n        ),\n        Return(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_transfer_inner_txn(\n    smart_asa_id: Expr,\n    asset_amount: Expr,\n    asset_sender: Expr,\n    asset_receiver: Expr,\n) -> Expr:\n    return InnerTxnBuilder.Execute(\n        {\n            TxnField.fee: Int(0),\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.xfer_asset: smart_asa_id,\n            TxnField.asset_amount: asset_amount,\n            TxnField.asset_sender: asset_sender,\n            TxnField.asset_receiver: asset_receiver,\n        }\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_destroy_inner_txn(smart_asa_id: Expr) -> Expr:\n    return InnerTxnBuilder.Execute(\n        {\n            TxnField.fee: Int(0),\n            TxnField.type_enum: TxnType.AssetConfig,\n            TxnField.config_asset: smart_asa_id,\n        }\n    )\n\n\n@Subroutine(TealType.none)\ndef is_valid_address_bytes_length(address: Expr) -> Expr:\n    # WARNING: Note this check only ensures proper bytes' length on `address`,\n    # but doesn't ensure that those 32 bytes are a _proper_ Algorand address.\n    return Assert(Len(address) == Int(key_len_bytes), comment=Error.address_length)\n\n\n@Subroutine(TealType.uint64)\ndef circulating_supply(asset_id: Expr):\n    smart_asa_reserve = AssetHolding.balance(\n        Global.current_application_address(), asset_id\n    )\n    return Seq(smart_asa_reserve, UNDERLYING_ASA_TOTAL - smart_asa_reserve.value())\n\n\n@Subroutine(TealType.none)\ndef getter_preconditions(asset_id: Expr) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset_id\n    return Seq(\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n    )\n\n\n# / --- --- ABI\n# / --- --- BARE CALLS\n@Subroutine(TealType.none)\ndef asset_app_create() -> Expr:\n    return Seq(\n        # Preconditions\n        # Not mandatory - Smart ASA Application self validate its state.\n        Assert(\n            Txn.global_num_uints() == Int(GlobalState.num_uints()),\n            comment=f\"Wrong State Schema - Expexted Global Ints: \"\n            f\"{GlobalState.num_uints()}\",\n        ),\n        Assert(\n            Txn.global_num_byte_slices() == Int(GlobalState.num_bytes()),\n            comment=f\"Wrong State Schema - Expexted Global Bytes: \"\n            f\"{GlobalState.num_bytes()}\",\n        ),\n        Assert(\n            Txn.local_num_uints() == Int(LocalState.num_uints()),\n            comment=f\"Wrong State Schema - Expexted Local Ints: \"\n            f\"{LocalState.num_uints()}\",\n        ),\n        Assert(\n            Txn.local_num_byte_slices() == Int(LocalState.num_bytes()),\n            comment=f\"Wrong State Schema - Expexted Local Bytes: \"\n            f\"{LocalState.num_bytes()}\",\n        ),\n        init_global_state(),\n        Approve(),\n    )\n\n\nsmart_asa_abi = Router(\n    \"Smart ASA ref. implementation\",\n    BareCallActions(\n        no_op=OnCompleteAction.create_only(asset_app_create()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not updatable.\n        update_application=OnCompleteAction.always(Reject()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not deletable.\n        delete_application=OnCompleteAction.always(Reject()),\n        clear_state=OnCompleteAction.call_only(Reject()),\n    ),\n)\n\n\n# / --- --- METHODS\n@smart_asa_abi.method(opt_in=CallConfig.ALL)\ndef asset_app_optin(\n    asset: abi.Asset,\n    underlying_asa_optin: abi.AssetTransferTransaction,\n) -> Expr:\n    \"\"\"\n    Smart ASA atomic opt-in to Smart ASA App and Underlying ASA.\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n        underlying_asa_optin: Underlying ASA opt-in transaction.\n    \"\"\"\n    # On OptIn the frozen status must be set to `True` if account owns any\n    # units of the underlying ASA. This prevents malicious users to circumvent\n    # the `default_frozen` status by clearing their Local State. Note that this\n    # could be avoided by the use of Boxes once available.\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset.asset_id()\n    default_frozen = App.globalGet(GlobalState.default_frozen)\n    freeze_account = App.localPut(Txn.sender(), LocalState.frozen, Int(1))\n    account_balance = AssetHolding().balance(Txn.sender(), asset.asset_id())\n    optin_to_underlying_asa = account_balance.hasValue()\n    return Seq(\n        # Preconditions\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        Assert(\n            underlying_asa_optin.get().type_enum() == TxnType.AssetTransfer,\n            comment=\"Underlying ASA Opt-In Txn: Wrong Txn Type (Expected: Axfer)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().xfer_asset() == smart_asa_id,\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset ID (Expected: Smart ASA ID)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().sender() == Txn.sender(),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Sender (Expected: App Caller)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().asset_receiver() == Txn.sender(),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset Receiver (Expected: App Caller)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().asset_amount() == Int(0),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset Amount (Expected: 0)\",\n        ),\n        Assert(\n            underlying_asa_optin.get().asset_close_to() == Global.zero_address(),\n            comment=\"Underlying ASA Opt-In Txn: Wrong Asset CloseTo (Expected: Zero Address)\",\n        ),\n        account_balance,\n        Assert(optin_to_underlying_asa, comment=\"Missing Opt-In to Underlying ASA\"),\n        # Effects\n        init_local_state(),\n        If(Or(default_frozen, account_balance.value() > Int(0))).Then(freeze_account),\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_create(\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n    *,\n    output: abi.Uint64,\n) -> Expr:\n    \"\"\"\n    Create a Smart ASA (triggers inner creation of an Underlying ASA).\n\n    Args:\n        total: The total number of base units of the Smart ASA to create.\n        decimals: The number of digits to use after the decimal point when displaying the Smart ASA. If 0, the Smart ASA is not divisible.\n        default_frozen: Smart ASA default frozen status (True to freeze holdings by default).\n        unit_name: The name of a unit of Smart ASA.\n        name: The name of the Smart ASA.\n        url: Smart ASA external URL.\n        metadata_hash: Smart ASA metadata hash (suggested 32 bytes hash).\n        manager_addr: The address of the account that can manage the configuration of the Smart ASA and destroy it.\n        reserve_addr: The address of the account that holds the reserve (non-minted) units of the asset and can mint or burn units of Smart ASA.\n        freeze_addr: The address of the account that can freeze/unfreeze holdings of this Smart ASA globally or locally (specific accounts). If empty, freezing is not permitted.\n        clawback_addr: The address of the account that can clawback holdings of this asset. If empty, clawback is not permitted.\n\n    Returns:\n        New Smart ASA ID.\n    \"\"\"\n\n    is_creator = Txn.sender() == Global.creator_address()\n    smart_asa_not_created = Not(App.globalGet(GlobalState.smart_asa_id))\n    smart_asa_id = underlying_asa_create_inner_tx()\n\n    return Seq(\n        # Preconditions\n        Assert(is_creator, comment=Error.not_creator_addr),\n        Assert(smart_asa_not_created, comment=\"Smart ASA ID already exists\"),\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        # Effects\n        # Underlying ASA creation\n        App.globalPut(GlobalState.smart_asa_id, smart_asa_id),\n        # Smart ASA properties\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n        output.set(App.globalGet(GlobalState.smart_asa_id)),\n    )\n\n\n@smart_asa_abi.method\ndef asset_config(\n    config_asset: abi.Asset,\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n) -> Expr:\n    \"\"\"\n    Configure the Smart ASA. Use existing values for unchanged parameters. Setting Smart ASA roles to zero-address is irreversible.\n\n    Args:\n        config_asset: Underlying ASA ID to configure (ref. App Global State: \"smart_asa_id\").\n        total: The total number of base units of the Smart ASA to create. It can not be configured to less than its current circulating supply.\n        decimals: The number of digits to use after the decimal point when displaying the Smart ASA. If 0, the Smart ASA is not divisible.\n        default_frozen: Smart ASA default frozen status (True to freeze holdings by default).\n        unit_name: The name of a unit of Smart ASA.\n        name: The name of the Smart ASA.\n        url: Smart ASA external URL.\n        metadata_hash: Smart ASA metadata hash (suggested 32 bytes hash).\n        manager_addr: The address of the account that can manage the configuration of the Smart ASA and destroy it.\n        reserve_addr: The address of the account that holds the reserve (non-minted) units of the asset and can mint or burn units of Smart ASA.\n        freeze_addr: The address of the account that can freeze/unfreeze holdings of this Smart ASA globally or locally (specific accounts). If empty, freezing is not permitted.\n        clawback_addr: The address of the account that can clawback holdings of this asset. If empty, clawback is not permitted.\n    \"\"\"\n\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    current_manager_addr = App.globalGet(GlobalState.manager_addr)\n    current_reserve_addr = App.globalGet(GlobalState.reserve_addr)\n    current_freeze_addr = App.globalGet(GlobalState.freeze_addr)\n    current_clawback_addr = App.globalGet(GlobalState.clawback_addr)\n\n    is_manager_addr = Txn.sender() == current_manager_addr\n    is_correct_smart_asa_id = smart_asa_id == config_asset.asset_id()\n\n    update_reserve_addr = current_reserve_addr != reserve_addr.get()\n    update_freeze_addr = current_freeze_addr != freeze_addr.get()\n    update_clawback_addr = current_clawback_addr != clawback_addr.get()\n\n    # NOTE: In ref. implementation Smart ASA total can not be configured to\n    # less than its current circulating supply.\n    is_valid_total = total.get() >= circulating_supply(smart_asa_id)\n\n    return Seq(\n        # Preconditions\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        # NOTE: useless in ref. impl since 1 ASA : 1 App\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        Assert(is_manager_addr, comment=Error.not_manager_addr),\n        If(update_reserve_addr).Then(\n            Assert(\n                current_reserve_addr != Global.zero_address(),\n                comment=\"Reserve Address has been deleted\",\n            )\n        ),\n        If(update_freeze_addr).Then(\n            Assert(\n                current_freeze_addr != Global.zero_address(),\n                comment=\"Freeze Address has been deleted\",\n            )\n        ),\n        If(update_clawback_addr).Then(\n            Assert(\n                current_clawback_addr != Global.zero_address(),\n                comment=\"Clawback Address has been deleted\",\n            )\n        ),\n        Assert(is_valid_total, comment=\"Invalid Total (must be >= Circulating Supply)\"),\n        # Effects\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n    )\n\n\n@smart_asa_abi.method\ndef asset_transfer(\n    xfer_asset: abi.Asset,\n    asset_amount: abi.Uint64,\n    asset_sender: abi.Account,\n    asset_receiver: abi.Account,\n) -> Expr:\n    \"\"\"\n    Smart ASA transfers: regular, clawback (Clawback Address), mint or burn (Reserve Address).\n\n    Args:\n        xfer_asset: Underlying ASA ID to transfer (ref. App Global State: \"smart_asa_id\").\n        asset_amount: Smart ASA amount to transfer.\n        asset_sender: Smart ASA sender, for regular transfer this must be equal to the Smart ASA App caller.\n        asset_receiver: The recipient of the Smart ASA transfer.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    clawback_addr = App.globalGet(GlobalState.clawback_addr)\n    is_not_clawback = And(\n        Txn.sender() == asset_sender.address(),\n        Txn.sender() != clawback_addr,\n    )\n\n    # NOTE: Ref. implementation grants _minting_ premission to `reserve_addr`,\n    # has restriction no restriction on who is the minting _receiver_.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off minting.\n    is_minting = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == Global.current_application_address(),\n    )\n\n    # NOTE: Ref. implementation grants _burning_ premission to `reserve_addr`,\n    # has restriction both on burning _sender_ and _receiver_ to prevent\n    # _clawback_ throug burning.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off burning.\n    is_burning = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == App.globalGet(GlobalState.reserve_addr),\n        asset_receiver.address() == Global.current_application_address(),\n    )\n\n    is_clawback = Txn.sender() == clawback_addr\n    is_correct_smart_asa_id = smart_asa_id == xfer_asset.asset_id()\n\n    # NOTE: Ref. implementation checks that `smart_asa_id` is correct in Local\n    # State since the App could generate a new Smart ASA (if the previous one\n    # has been dystroied) requiring users to opt-in again to gain a coherent\n    # new `frozen` status.\n    is_current_smart_asa_id = And(\n        smart_asa_id == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n        smart_asa_id == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n    )\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_sender_frozen = App.localGet(asset_sender.address(), LocalState.frozen)\n    asset_receiver_frozen = App.localGet(asset_receiver.address(), LocalState.frozen)\n    return Seq(\n        # Preconditions\n        Assert(smart_asa_id, comment=Error.missing_smart_asa_id),\n        Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        is_valid_address_bytes_length(asset_sender.address()),\n        is_valid_address_bytes_length(asset_receiver.address()),\n        If(is_not_clawback)\n        .Then(\n            # Asset Regular Transfer Preconditions\n            Assert(Not(asset_frozen), comment=Error.asset_frozen),\n            Assert(Not(asset_sender_frozen), comment=Error.sender_frozen),\n            Assert(Not(asset_receiver_frozen), comment=Error.receiver_frozen),\n            Assert(is_current_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        )\n        .ElseIf(is_minting)\n        .Then(\n            # Asset Minting Preconditions\n            Assert(Not(asset_frozen), comment=Error.asset_frozen),\n            Assert(Not(asset_receiver_frozen), comment=Error.receiver_frozen),\n            Assert(\n                smart_asa_id\n                == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n                comment=Error.invalid_smart_asa_id,\n            ),\n            # NOTE: Ref. implementation prevents minting more than `total`.\n            Assert(\n                circulating_supply(smart_asa_id) + asset_amount.get()\n                <= App.globalGet(GlobalState.total),\n                comment=\"Over-minting (can not mint more than Total)\",\n            ),\n        )\n        .ElseIf(is_burning)\n        .Then(\n            # Asset Burning Preconditions\n            Assert(Not(asset_frozen), comment=Error.asset_frozen),\n            Assert(Not(asset_sender_frozen), comment=Error.sender_frozen),\n            Assert(\n                smart_asa_id\n                == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n                comment=Error.invalid_smart_asa_id,\n            ),\n        )\n        .Else(\n            # Asset Clawback Preconditions\n            Assert(is_clawback, comment=Error.not_clawback_addr),\n            # NOTE: `is_current_smart_asa_id` implicitly checks that both\n            # `asset_sender` and `asset_receiver` opted-in the Smart ASA\n            # App. This ensures that _mint_ and _burn_ can not be\n            # executed as _clawback_, since the Smart ASA App can not\n            # opt-in to itself.\n            Assert(is_current_smart_asa_id, comment=Error.invalid_smart_asa_id),\n        ),\n        # Effects\n        smart_asa_transfer_inner_txn(\n            xfer_asset.asset_id(),\n            asset_amount.get(),\n            asset_sender.address(),\n            asset_receiver.address(),\n        ),\n    )\n\n\n@smart_asa_abi.method\ndef asset_freeze(freeze_asset: abi.Asset, asset_frozen: abi.Bool) -> Expr:\n    \"\"\"\n    Smart ASA global freeze (all accounts), called by the Freeze Address.\n\n    Args:\n        freeze_asset: Underlying ASA ID to freeze/unfreeze (ref. App Global State: \"smart_asa_id\").\n        asset_frozen: Smart ASA ID forzen status.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Asset Freeze Preconditions\n        Assert(\n            smart_asa_id,\n            comment=Error.missing_smart_asa_id,\n        ),\n        Assert(\n            is_correct_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            is_freeze_addr,\n            comment=Error.not_freeze_addr,\n        ),\n        # Effects\n        App.globalPut(GlobalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method\ndef account_freeze(\n    freeze_asset: abi.Asset,\n    freeze_account: abi.Account,\n    asset_frozen: abi.Bool,\n) -> Expr:\n    \"\"\"\n    Smart ASA local freeze (account specific), called by the Freeze Address.\n\n    Args:\n        freeze_asset: Underlying ASA ID to freeze/unfreeze (ref. App Global State: \"smart_asa_id\").\n        freeze_account: Account to freeze/unfreeze.\n        asset_frozen: Smart ASA ID forzen status.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Account Freeze Preconditions\n        is_valid_address_bytes_length(freeze_account.address()),\n        Assert(\n            smart_asa_id,\n            comment=Error.missing_smart_asa_id,\n        ),\n        Assert(\n            is_correct_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            is_freeze_addr,\n            comment=Error.not_freeze_addr,\n        ),\n        # Effects\n        App.localPut(freeze_account.address(), LocalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method(close_out=CallConfig.ALL)\ndef asset_app_closeout(\n    close_asset: abi.Asset,\n    close_to: abi.Account,\n) -> Expr:\n    \"\"\"\n    Smart ASA atomic close-out of Smart ASA App and Underlying ASA.\n\n    Args:\n        close_asset: Underlying ASA ID to close-out (ref. App Global State: \"smart_asa_id\").\n        close_to: Account to send all Smart ASA reminder to. If the asset/account is forzen then this must be set to Smart ASA Creator.\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == close_asset.asset_id()\n    current_smart_asa_id = App.localGet(Txn.sender(), LocalState.smart_asa_id)\n    is_current_smart_asa_id = current_smart_asa_id == close_asset.asset_id()\n    account_balance = AssetHolding().balance(Txn.sender(), close_asset.asset_id())\n    asset_creator = AssetParam().creator(close_asset.asset_id())\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_closer_frozen = App.localGet(Txn.sender(), LocalState.frozen)\n    asa_closeout_relative_idx = Txn.group_index() + Int(1)\n    return Seq(\n        # Preconditions\n        # NOTE: Smart ASA existence is not checked by default on close-out\n        # since would be impossible to close-out destroyed assets.\n        is_valid_address_bytes_length(close_to.address()),\n        Assert(\n            is_current_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            Global.group_size() > asa_closeout_relative_idx,\n            comment=\"Smart ASA CloseOut: Wrong group size (Expected: 2)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].type_enum() == TxnType.AssetTransfer,\n            comment=\"Underlying ASA CloseOut Txn: Wrong Txn type (Expected: Axfer)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].xfer_asset() == close_asset.asset_id(),\n            comment=\"Underlying ASA CloseOut Txn: Wrong ASA ID (Expected: Smart ASA ID)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].sender() == Txn.sender(),\n            comment=\"Underlying ASA CloseOut Txn: Wrong sender (Expected: Smart ASA CloseOut caller)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].asset_amount() == Int(0),\n            comment=\"Underlying ASA CloseOut Txn: Wrong amount (Expected: 0)\",\n        ),\n        Assert(\n            Gtxn[asa_closeout_relative_idx].asset_close_to()\n            == Global.current_application_address(),\n            comment=\"Underlying ASA CloseOut Txn: Wrong CloseTo address (Expected: Smart ASA App Account)\",\n        ),\n        # Effects\n        asset_creator,\n        # NOTE: Skip checks if Underlying ASA has been destroyed to avoid\n        # users' lock-in.\n        If(asset_creator.hasValue()).Then(\n            # NOTE: Smart ASA has not been destroyed.\n            Assert(is_correct_smart_asa_id, comment=Error.invalid_smart_asa_id),\n            If(Or(asset_frozen, asset_closer_frozen)).Then(\n                # NOTE: If Smart ASA is frozen, users can only close-out to\n                # Creator\n                Assert(\n                    close_to.address() == Global.current_application_address(),\n                    comment=\"Wrong CloseTo address: Frozen Smart ASA must be closed-out to creator\",\n                ),\n            ),\n            If(close_to.address() != Global.current_application_address()).Then(\n                # NOTE: If the target of close-out is not Creator, it MUST be\n                # opted-in to the current Smart ASA.\n                Assert(\n                    smart_asa_id\n                    == App.localGet(close_to.address(), LocalState.smart_asa_id),\n                    comment=Error.invalid_smart_asa_id,\n                )\n            ),\n            account_balance,\n            smart_asa_transfer_inner_txn(\n                close_asset.asset_id(),\n                account_balance.value(),\n                Txn.sender(),\n                close_to.address(),\n            ),\n        ),\n        # NOTE: If Smart ASA has been destroyed:\n        #   1. The close-to address could be anyone\n        #   2. No InnerTxn happens\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_destroy(destroy_asset: abi.Asset) -> Expr:\n    \"\"\"\n    Destroy the Underlying ASA, must be called by Manager Address.\n\n    Args:\n        destroy_asset: Underlying ASA ID to destroy (ref. App Global State: \"smart_asa_id\").\n    \"\"\"\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == destroy_asset.asset_id()\n    is_manager_addr = Txn.sender() == App.globalGet(GlobalState.manager_addr)\n    return Seq(\n        # Asset Destroy Preconditions\n        Assert(\n            smart_asa_id,\n            comment=Error.missing_smart_asa_id,\n        ),\n        Assert(\n            is_correct_smart_asa_id,\n            comment=Error.invalid_smart_asa_id,\n        ),\n        Assert(\n            is_manager_addr,\n            comment=Error.not_manager_addr,\n        ),\n        # Effects\n        smart_asa_destroy_inner_txn(destroy_asset.asset_id()),\n        init_global_state(),\n    )\n\n\n# / --- --- GETTERS\n@smart_asa_abi.method\ndef get_asset_is_frozen(freeze_asset: abi.Asset, *, output: abi.Bool) -> Expr:\n    \"\"\"\n    Get Smart ASA global frozen status.\n\n    Args:\n        freeze_asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA global frozen status.\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        # Effects\n        output.set(App.globalGet(GlobalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_account_is_frozen(\n    freeze_asset: abi.Asset, freeze_account: abi.Account, *, output: abi.Bool\n) -> Expr:\n    \"\"\"\n    Get Smart ASA local frozen status (account specific).\n\n    Args:\n        freeze_asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n        freeze_account: Account to check.\n\n    Returns:\n        Smart ASA local frozen status (account specific).\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        is_valid_address_bytes_length(freeze_account.address()),\n        # Effects\n        output.set(App.localGet(freeze_account.address(), LocalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_circulating_supply(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Get Smart ASA circulating supply.\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA circulating supply.\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(circulating_supply(asset.asset_id())),\n    )\n\n\n@smart_asa_abi.method\ndef get_optin_min_balance(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    \"\"\"\n    Get Smart ASA required minimum balance (including Underlying ASA and App Local State).\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA required minimum balance in microALGO.\n    \"\"\"\n    min_balance = Int(\n        OPTIN_COST\n        + UINTS_COST * LocalState.num_uints()\n        + BYTES_COST * LocalState.num_bytes()\n    )\n\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(min_balance),\n    )\n\n\n@smart_asa_abi.method\ndef get_asset_config(asset: abi.Asset, *, output: SmartASAConfig) -> Expr:\n    \"\"\"\n    Get Smart ASA configuration.\n\n    Args:\n        asset: Underlying ASA ID (ref. App Global State: \"smart_asa_id\").\n\n    Returns:\n        Smart ASA configuration parameters.\n    \"\"\"\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        (total := abi.Uint64()).set(App.globalGet(GlobalState.total)),\n        (decimals := abi.Uint32()).set(App.globalGet(GlobalState.decimals)),\n        (default_frozen := abi.Bool()).set(App.globalGet(GlobalState.default_frozen)),\n        (unit_name := abi.String()).set(App.globalGet(GlobalState.unit_name)),\n        (name := abi.String()).set(App.globalGet(GlobalState.name)),\n        (url := abi.String()).set(App.globalGet(GlobalState.url)),\n        (metadata_hash_str := abi.String()).set(\n            App.globalGet(GlobalState.metadata_hash)\n        ),\n        (metadata_hash := abi.make(abi.DynamicArray[abi.Byte])).decode(\n            metadata_hash_str.encode()\n        ),\n        (manager_addr := abi.Address()).set(App.globalGet(GlobalState.manager_addr)),\n        (reserve_addr := abi.Address()).set(App.globalGet(GlobalState.reserve_addr)),\n        (freeze_addr := abi.Address()).set(App.globalGet(GlobalState.freeze_addr)),\n        (clawback_addr := abi.Address()).set(App.globalGet(GlobalState.clawback_addr)),\n        output.set(\n            total,\n            decimals,\n            default_frozen,\n            unit_name,\n            name,\n            url,\n            metadata_hash,\n            manager_addr,\n            reserve_addr,\n            freeze_addr,\n            clawback_addr,\n        ),\n    )\n\n\ndef compile_stateful(program: Expr) -> str:\n    return compileTeal(\n        program,\n        Mode.Application,\n        version=TEAL_VERSION,\n        assembleConstants=True,\n        optimize=OptimizeOptions(scratch_slots=True),\n    )\n\n\nif __name__ == \"__main__\":\n    # Allow quickly testing compilation.\n    from smart_asa_test import test_compile\n\n    test_compile(*smart_asa_abi.build_program())"}
{"instruction": "Generate code to interact with an Algorand smart contract named 'Cert', providing methods to call its ABI methods, create, update, and delete the application, and clear state. The code should include classes for handling method arguments, deploying the application, and composing atomic transactions.", "output": "# flake8: noqa\n# fmt: off\n# mypy: disable-error-code=\"no-any-return, no-untyped-call, misc, type-arg\"\n# This file was automatically generated by algokit-client-generator.\n# DO NOT MODIFY IT BY HAND.\n# requires: algokit-utils@^1.2.0\nimport base64\nimport dataclasses\nimport decimal\nimport typing\nfrom abc import ABC, abstractmethod\n\nimport algokit_utils\nimport algosdk\nfrom algosdk.v2client import models\nfrom algosdk.atomic_transaction_composer import (\n    AtomicTransactionComposer,\n    AtomicTransactionResponse,\n    SimulateAtomicTransactionResponse,\n    TransactionSigner,\n    TransactionWithSigner\n)\n\n_APP_SPEC_JSON = r\"\"\"{\n    \"hints\": {\n        \"hello(string)string\": {\n            \"call_config\": {\n                \"no_op\": \"CALL\"\n            }\n        },\n        \"create_certificate_nft((string,string,uint64,string,string))uint64\": {\n            \"structs\": {\n                \"args\": {\n                    \"name\": \"NewCertificateNftArgs\",\n                    \"elements\": [\n                        [\n                            \"name\",\n                            \"string\"\n                        ],\n                        [\n                            \"image_url\",\n                            \"string\"\n                        ],\n                        [\n                            \"certificate_id\",\n                            \"uint64\"\n                        ],\n                        [\n                            \"metadata_hash\",\n                            \"string\"\n                        ],\n                        [\n                            \"unit_name\",\n                            \"string\"\n                        ]\n                    ]\n                }\n            },\n            \"call_config\": {\n                \"no_op\": \"CALL\"\n            }\n        },\n        \"update()bool\": {\n            \"call_config\": {\n                \"update_application\": \"CALL\"\n            }\n        },\n        \"delete()bool\": {\n            \"call_config\": {\n                \"delete_application\": \"CALL\"\n            }\n        }\n    },\n    \"source\": {\n        \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmFwcHJvdmFsX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fYmFyZV9yb3V0aW5nQDgKICAgIG1ldGhvZCAiaGVsbG8oc3RyaW5nKXN0cmluZyIKICAgIG1ldGhvZCAiY3JlYXRlX2NlcnRpZmljYXRlX25mdCgoc3RyaW5nLHN0cmluZyx1aW50NjQsc3RyaW5nLHN0cmluZykpdWludDY0IgogICAgbWV0aG9kICJ1cGRhdGUoKWJvb2wiCiAgICBtZXRob2QgImRlbGV0ZSgpYm9vbCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5faGVsbG9fcm91dGVAMiBtYWluX2NyZWF0ZV9jZXJ0aWZpY2F0ZV9uZnRfcm91dGVAMyBtYWluX3VwZGF0ZV9yb3V0ZUA0IG1haW5fZGVsZXRlX3JvdXRlQDUKICAgIGVyciAvLyByZWplY3QgdHJhbnNhY3Rpb24KCm1haW5faGVsbG9fcm91dGVAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6MTgKICAgIC8vIGNsYXNzIENlcnQoQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBoZWxsbwogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfY2VydGlmaWNhdGVfbmZ0X3JvdXRlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBpcyBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE4CiAgICAvLyBjbGFzcyBDZXJ0KEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyMwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY3JlYXRlX2NlcnRpZmljYXRlX25mdAogICAgYnl0ZSAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50IDEKICAgIHJldHVybgoKbWFpbl91cGRhdGVfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjQ0CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIlVwZGF0ZUFwcGxpY2F0aW9uIl0pCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBpbnQgVXBkYXRlQXBwbGljYXRpb24KICAgID09CiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIFVwZGF0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGlzIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiB1cGRhdGUKICAgIGJ5dGUgMHgwMAogICAgaW50IDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnQgMQogICAgcmV0dXJuCgptYWluX2RlbGV0ZV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGludCBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgRGVsZXRlQXBwbGljYXRpb24KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gaXMgbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGRlbGV0ZQogICAgYnl0ZSAweDAwCiAgICBpbnQgMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGUgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludCAxCiAgICByZXR1cm4KCm1haW5fYmFyZV9yb3V0aW5nQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIHJlamVjdCB0cmFuc2FjdGlvbgogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBpcyBjcmVhdGluZwogICAgaW50IDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0LmNvbnRyYWN0LkNlcnQuaGVsbG8obmFtZTogYnl0ZXMpIC0+IGJ5dGVzOgpoZWxsbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjE5LTIwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGhlbGxvKHNlbGYsIG5hbWU6IGFyYzQuU3RyaW5nKSAtPiBhcmM0LlN0cmluZzoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6MjEKICAgIC8vIHJldHVybiAiSGVsbG8sICIgKyBuYW1lCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBieXRlICJIZWxsbywgIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmNlcnQuY29udHJhY3QuQ2VydC5jcmVhdGVfY2VydGlmaWNhdGVfbmZ0KGFyZ3M6IGJ5dGVzKSAtPiBieXRlczoKY3JlYXRlX2NlcnRpZmljYXRlX25mdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjIzLTI3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9jZXJ0aWZpY2F0ZV9uZnQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBhcmdzOiBOZXdDZXJ0aWZpY2F0ZU5mdEFyZ3MsCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyOQogICAgLy8gYXNzZXRfbmFtZT1hcmdzLm5hbWUubmF0aXZlLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDEKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnQgMgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjMxCiAgICAvLyB1bml0X25hbWU9YXJncy51bml0X25hbWUubmF0aXZlLAogICAgZnJhbWVfZGlnIC0xCiAgICBpbnQgMTQKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMgogICAgLy8gdXJsPWFyZ3MuaW1hZ2VfdXJsLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyAtMQogICAgaW50IDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgLTEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50IDIKICAgICsKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMwogICAgLy8gbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM0LTM2CiAgICAvLyBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyByZXNlcnZlPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICBkdXBuIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM3CiAgICAvLyBtZXRhZGF0YV9oYXNoPWFyZ3MubWV0YWRhdGFfaGFzaC5uYXRpdmUuYnl0ZXMsCiAgICBmcmFtZV9kaWcgLTEKICAgIGludCAxMgogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAtMQogICAgZGlnIDEKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnQgMgogICAgKwogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyB0eG4uc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNZXRhZGF0YUhhc2gKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRSZXNlcnZlCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0Q2xhd2JhY2sKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRGcmVlemUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRNYW5hZ2VyCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VVJMCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToyOAogICAgLy8gdHhuID0gaXR4bi5Bc3NldENvbmZpZygKICAgIGludCBhY2ZnCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTozMAogICAgLy8gZmVlPTEwMDAsCiAgICBpbnQgMTAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9jZXJ0L2NvbnRyYWN0LnB5OjM5CiAgICAvLyB0eG4uc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0MAogICAgLy8gYXNzZXQgPSBvcC5JVHhuLmNyZWF0ZWRfYXNzZXRfaWQoKQogICAgaXR4biBDcmVhdGVkQXNzZXRJRAogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDIKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChhc3NldC5pZCkKICAgIGl0b2IKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5jZXJ0LmNvbnRyYWN0LkNlcnQudXBkYXRlKCkgLT4gdWludDY0Ogp1cGRhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0NC00NQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJVcGRhdGVBcHBsaWNhdGlvbiJdKQogICAgLy8gZGVmIHVwZGF0ZShzZWxmKSAtPiBib29sOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weTo0NgogICAgLy8gcmV0dXJuIFRydWUKICAgIGludCAxCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmRlbGV0ZSgpIC0+IHVpbnQ2NDoKZGVsZXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NDgtNDkKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIC8vIGRlZiBkZWxldGUoc2VsZikgLT4gYm9vbDoKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2NlcnQvY29udHJhY3QucHk6NTAKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnQgMQogICAgcmV0c3ViCg==\",\n        \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgpzbWFydF9jb250cmFjdHMuY2VydC5jb250cmFjdC5DZXJ0LmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvY2VydC9jb250cmFjdC5weToxOAogICAgLy8gY2xhc3MgQ2VydChBUkM0Q29udHJhY3QpOgogICAgaW50IDEKICAgIHJldHVybgo=\"\n    },\n    \"state\": {\n        \"global\": {\n            \"num_byte_slices\": 0,\n            \"num_uints\": 0\n        },\n        \"local\": {\n            \"num_byte_slices\": 0,\n            \"num_uints\": 0\n        }\n    },\n    \"schema\": {\n        \"global\": {\n            \"declared\": {},\n            \"reserved\": {}\n        },\n        \"local\": {\n            \"declared\": {},\n            \"reserved\": {}\n        }\n    },\n    \"contract\": {\n        \"name\": \"Cert\",\n        \"methods\": [\n            {\n                \"name\": \"hello\",\n                \"args\": [\n                    {\n                        \"type\": \"string\",\n                        \"name\": \"name\"\n                    }\n                ],\n                \"returns\": {\n                    \"type\": \"string\"\n                }\n            },\n            {\n                \"name\": \"create_certificate_nft\",\n                \"args\": [\n                    {\n                        \"type\": \"(string,string,uint64,string,string)\",\n                        \"name\": \"args\"\n                    }\n                ],\n                \"returns\": {\n                    \"type\": \"uint64\"\n                }\n            },\n            {\n                \"name\": \"update\",\n                \"args\": [],\n                \"returns\": {\n                    \"type\": \"bool\"\n                }\n            },\n            {\n                \"name\": \"delete\",\n                \"args\": [],\n                \"returns\": {\n                    \"type\": \"bool\"\n                }\n            }\n        ],\n        \"networks\": {}\n    },\n    \"bare_call_config\": {\n        \"no_op\": \"CREATE\"\n    }\n}\"\"\"\nAPP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)\n_TReturn = typing.TypeVar(\"_TReturn\")\n\n\nclass _ArgsBase(ABC, typing.Generic[_TReturn]):\n    @staticmethod\n    @abstractmethod\n    def method() -> str:\n        ...\n\n\n_TArgs = typing.TypeVar(\"_TArgs\", bound=_ArgsBase[typing.Any])\n\n\n@dataclasses.dataclass(kw_only=True)\nclass _TArgsHolder(typing.Generic[_TArgs]):\n    args: _TArgs\n\n\n@dataclasses.dataclass(kw_only=True)\nclass Deploy(algokit_utils.DeployCallArgs, _TArgsHolder[_TArgs], typing.Generic[_TArgs]):\n    pass\n\n\ndef _filter_none(value: dict | typing.Any) -> dict | typing.Any:\n    if isinstance(value, dict):\n        return {k: _filter_none(v) for k, v in value.items() if v is not None}\n    return value\n\n\ndef _as_dict(data: typing.Any, *, convert_all: bool = True) -> dict[str, typing.Any]:\n    if data is None:\n        return {}\n    if not dataclasses.is_dataclass(data):\n        raise TypeError(f\"{data} must be a dataclass\")\n    if convert_all:\n        result = dataclasses.asdict(data)\n    else:\n        result = {f.name: getattr(data, f.name) for f in dataclasses.fields(data)}\n    return _filter_none(result)\n\n\ndef _convert_transaction_parameters(\n    transaction_parameters: algokit_utils.TransactionParameters | None,\n) -> algokit_utils.TransactionParametersDict:\n    return typing.cast(algokit_utils.TransactionParametersDict, _as_dict(transaction_parameters))\n\n\ndef _convert_call_transaction_parameters(\n    transaction_parameters: algokit_utils.TransactionParameters | None,\n) -> algokit_utils.OnCompleteCallParametersDict:\n    return typing.cast(algokit_utils.OnCompleteCallParametersDict, _as_dict(transaction_parameters))\n\n\ndef _convert_create_transaction_parameters(\n    transaction_parameters: algokit_utils.TransactionParameters | None,\n    on_complete: algokit_utils.OnCompleteActionName,\n) -> algokit_utils.CreateCallParametersDict:\n    result = typing.cast(algokit_utils.CreateCallParametersDict, _as_dict(transaction_parameters))\n    on_complete_enum = on_complete.replace(\"_\", \" \").title().replace(\" \", \"\") + \"OC\"\n    result[\"on_complete\"] = getattr(algosdk.transaction.OnComplete, on_complete_enum)\n    return result\n\n\ndef _convert_deploy_args(\n    deploy_args: algokit_utils.DeployCallArgs | None,\n) -> algokit_utils.ABICreateCallArgsDict | None:\n    if deploy_args is None:\n        return None\n\n    deploy_args_dict = typing.cast(algokit_utils.ABICreateCallArgsDict, _as_dict(deploy_args))\n    if isinstance(deploy_args, _TArgsHolder):\n        deploy_args_dict[\"args\"] = _as_dict(deploy_args.args)\n        deploy_args_dict[\"method\"] = deploy_args.args.method()\n\n    return deploy_args_dict\n\n\n@dataclasses.dataclass(kw_only=True)\nclass HelloArgs(_ArgsBase[str]):\n    name: str\n\n    @staticmethod\n    def method() -> str:\n        return \"hello(string)string\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass NewCertificateNftArgs:\n    name: str\n    image_url: str\n    certificate_id: int\n    metadata_hash: str\n    unit_name: str\n\n\n@dataclasses.dataclass(kw_only=True)\nclass CreateCertificateNftArgs(_ArgsBase[int]):\n    args: NewCertificateNftArgs\n\n    @staticmethod\n    def method() -> str:\n        return \"create_certificate_nft((string,string,uint64,string,string))uint64\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass UpdateArgs(_ArgsBase[bool]):\n    @staticmethod\n    def method() -> str:\n        return \"update()bool\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass DeleteArgs(_ArgsBase[bool]):\n    @staticmethod\n    def method() -> str:\n        return \"delete()bool\"\n\n\n@dataclasses.dataclass(kw_only=True)\nclass SimulateOptions:\n    allow_more_logs: bool = dataclasses.field(default=False)\n    allow_empty_signatures: bool = dataclasses.field(default=False)\n    extra_opcode_budget: int = dataclasses.field(default=0)\n    exec_trace_config: models.SimulateTraceConfig | None         = dataclasses.field(default=None)\n\n\nclass Composer:\n\n    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):\n        self.app_client = app_client\n        self.atc = atc\n\n    def build(self) -> AtomicTransactionComposer:\n        return self.atc\n\n    def simulate(self, options: SimulateOptions | None = None) -> SimulateAtomicTransactionResponse:\n        request = models.SimulateRequest(\n            allow_more_logs=options.allow_more_logs,\n            allow_empty_signatures=options.allow_empty_signatures,\n            extra_opcode_budget=options.extra_opcode_budget,\n            exec_trace_config=options.exec_trace_config,\n            txn_groups=[]\n        ) if options else None\n        result = self.atc.simulate(self.app_client.algod_client, request)\n        return result\n\n    def execute(self) -> AtomicTransactionResponse:\n        return self.app_client.execute_atc(self.atc)\n\n    def hello(\n        self,\n        *,\n        name: str,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `hello(string)string` ABI method\n        \n        :param str name: The `name` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = HelloArgs(\n            name=name,\n        )\n        self.app_client.compose_call(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def create_certificate_nft(\n        self,\n        *,\n        args: NewCertificateNftArgs,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `create_certificate_nft((string,string,uint64,string,string))uint64` ABI method\n        \n        :param NewCertificateNftArgs args: The `args` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = CreateCertificateNftArgs(\n            args=args,\n        )\n        self.app_client.compose_call(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def create_bare(\n        self,\n        *,\n        on_complete: typing.Literal[\"no_op\"] = \"no_op\",\n        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to create an application using the no_op bare method\n        \n        :param typing.Literal[no_op] on_complete: On completion type to use\n        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        self.app_client.compose_create(\n            self.atc,\n            call_abi_method=False,\n            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),\n        )\n        return self\n\n    def update_update(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `update()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = UpdateArgs()\n        self.app_client.compose_update(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def delete_delete(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to `delete()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns Composer: This Composer instance\"\"\"\n\n        args = DeleteArgs()\n        self.app_client.compose_delete(\n            self.atc,\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return self\n\n    def clear_state(\n        self,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n        app_args: list[bytes] | None = None,\n    ) -> \"Composer\":\n        \"\"\"Adds a call to the application with on completion set to ClearState\n    \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :param list[bytes] | None app_args: (optional) Application args to pass\"\"\"\n    \n        self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)\n        return self\n\n\nclass CertClient:\n    \"\"\"A class for interacting with the Cert app providing high productivity and\n    strongly typed methods to deploy and call the app\"\"\"\n\n    @typing.overload\n    def __init__(\n        self,\n        algod_client: algosdk.v2client.algod.AlgodClient,\n        *,\n        app_id: int = 0,\n        signer: TransactionSigner | algokit_utils.Account | None = None,\n        sender: str | None = None,\n        suggested_params: algosdk.transaction.SuggestedParams | None = None,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        app_name: str | None = None,\n    ) -> None:\n        ...\n\n    @typing.overload\n    def __init__(\n        self,\n        algod_client: algosdk.v2client.algod.AlgodClient,\n        *,\n        creator: str | algokit_utils.Account,\n        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,\n        existing_deployments: algokit_utils.AppLookup | None = None,\n        signer: TransactionSigner | algokit_utils.Account | None = None,\n        sender: str | None = None,\n        suggested_params: algosdk.transaction.SuggestedParams | None = None,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        app_name: str | None = None,\n    ) -> None:\n        ...\n\n    def __init__(\n        self,\n        algod_client: algosdk.v2client.algod.AlgodClient,\n        *,\n        creator: str | algokit_utils.Account | None = None,\n        indexer_client: algosdk.v2client.indexer.IndexerClient | None = None,\n        existing_deployments: algokit_utils.AppLookup | None = None,\n        app_id: int = 0,\n        signer: TransactionSigner | algokit_utils.Account | None = None,\n        sender: str | None = None,\n        suggested_params: algosdk.transaction.SuggestedParams | None = None,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        app_name: str | None = None,\n    ) -> None:\n        \"\"\"\n        CertClient can be created with an app_id to interact with an existing application, alternatively\n        it can be created with a creator and indexer_client specified to find existing applications by name and creator.\n        \n        :param AlgodClient algod_client: AlgoSDK algod client\n        :param int app_id: The app_id of an existing application, to instead find the application by creator and name\n        use the creator and indexer_client parameters\n        :param str | Account creator: The address or Account of the app creator to resolve the app_id\n        :param IndexerClient indexer_client: AlgoSDK indexer client, only required if deploying or finding app_id by\n        creator and app name\n        :param AppLookup existing_deployments:\n        :param TransactionSigner | Account signer: Account or signer to use to sign transactions, if not specified and\n        creator was passed as an Account will use that.\n        :param str sender: Address to use as the sender for all transactions, will use the address associated with the\n        signer if not specified.\n        :param TemplateValueMapping template_values: Values to use for TMPL_* template variables, dictionary keys should\n        *NOT* include the TMPL_ prefix\n        :param str | None app_name: Name of application to use when deploying, defaults to name defined on the\n        Application Specification\n            \"\"\"\n\n        self.app_spec = APP_SPEC\n        \n        # calling full __init__ signature, so ignoring mypy warning about overloads\n        self.app_client = algokit_utils.ApplicationClient(  # type: ignore[call-overload, misc]\n            algod_client=algod_client,\n            app_spec=self.app_spec,\n            app_id=app_id,\n            creator=creator,\n            indexer_client=indexer_client,\n            existing_deployments=existing_deployments,\n            signer=signer,\n            sender=sender,\n            suggested_params=suggested_params,\n            template_values=template_values,\n            app_name=app_name,\n        )\n\n    @property\n    def algod_client(self) -> algosdk.v2client.algod.AlgodClient:\n        return self.app_client.algod_client\n\n    @property\n    def app_id(self) -> int:\n        return self.app_client.app_id\n\n    @app_id.setter\n    def app_id(self, value: int) -> None:\n        self.app_client.app_id = value\n\n    @property\n    def app_address(self) -> str:\n        return self.app_client.app_address\n\n    @property\n    def sender(self) -> str | None:\n        return self.app_client.sender\n\n    @sender.setter\n    def sender(self, value: str) -> None:\n        self.app_client.sender = value\n\n    @property\n    def signer(self) -> TransactionSigner | None:\n        return self.app_client.signer\n\n    @signer.setter\n    def signer(self, value: TransactionSigner) -> None:\n        self.app_client.signer = value\n\n    @property\n    def suggested_params(self) -> algosdk.transaction.SuggestedParams | None:\n        return self.app_client.suggested_params\n\n    @suggested_params.setter\n    def suggested_params(self, value: algosdk.transaction.SuggestedParams | None) -> None:\n        self.app_client.suggested_params = value\n\n    def hello(\n        self,\n        *,\n        name: str,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[str]:\n        \"\"\"Calls `hello(string)string` ABI method\n        \n        :param str name: The `name` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[str]: The result of the transaction\"\"\"\n\n        args = HelloArgs(\n            name=name,\n        )\n        result = self.app_client.call(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def create_certificate_nft(\n        self,\n        *,\n        args: NewCertificateNftArgs,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[int]:\n        \"\"\"Calls `create_certificate_nft((string,string,uint64,string,string))uint64` ABI method\n        \n        :param NewCertificateNftArgs args: The `args` ABI parameter\n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[int]: The result of the transaction\"\"\"\n\n        args = CreateCertificateNftArgs(\n            args=args,\n        )\n        result = self.app_client.call(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def create_bare(\n        self,\n        *,\n        on_complete: typing.Literal[\"no_op\"] = \"no_op\",\n        transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,\n    ) -> algokit_utils.TransactionResponse:\n        \"\"\"Creates an application using the no_op bare method\n        \n        :param typing.Literal[no_op] on_complete: On completion type to use\n        :param algokit_utils.CreateTransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.TransactionResponse: The result of the transaction\"\"\"\n\n        result = self.app_client.create(\n            call_abi_method=False,\n            transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),\n        )\n        return result\n\n    def update_update(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[bool]:\n        \"\"\"Calls `update()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction\"\"\"\n\n        args = UpdateArgs()\n        result = self.app_client.update(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def delete_delete(\n        self,\n        *,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n    ) -> algokit_utils.ABITransactionResponse[bool]:\n        \"\"\"Calls `delete()bool` ABI method\n        \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :returns algokit_utils.ABITransactionResponse[bool]: The result of the transaction\"\"\"\n\n        args = DeleteArgs()\n        result = self.app_client.delete(\n            call_abi_method=args.method(),\n            transaction_parameters=_convert_transaction_parameters(transaction_parameters),\n            **_as_dict(args, convert_all=True),\n        )\n        return result\n\n    def clear_state(\n        self,\n        transaction_parameters: algokit_utils.TransactionParameters | None = None,\n        app_args: list[bytes] | None = None,\n    ) -> algokit_utils.TransactionResponse:\n        \"\"\"Calls the application with on completion set to ClearState\n    \n        :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters\n        :param list[bytes] | None app_args: (optional) Application args to pass\n        :returns algokit_utils.TransactionResponse: The result of the transaction\"\"\"\n    \n        return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)\n\n    def deploy(\n        self,\n        version: str | None = None,\n        *,\n        signer: TransactionSigner | None = None,\n        sender: str | None = None,\n        allow_update: bool | None = None,\n        allow_delete: bool | None = None,\n        on_update: algokit_utils.OnUpdate = algokit_utils.OnUpdate.Fail,\n        on_schema_break: algokit_utils.OnSchemaBreak = algokit_utils.OnSchemaBreak.Fail,\n        template_values: algokit_utils.TemplateValueMapping | None = None,\n        create_args: algokit_utils.DeployCallArgs | None = None,\n        update_args: Deploy[UpdateArgs],\n        delete_args: Deploy[DeleteArgs],\n    ) -> algokit_utils.DeployResponse:\n        \"\"\"Deploy an application and update client to reference it.\n        \n        Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator\n        account, including deploy-time template placeholder substitutions.\n        To understand the architecture decisions behind this functionality please see\n        <https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md>\n        \n        ```{note}\n        If there is a breaking state schema change to an existing app (and `on_schema_break` is set to\n        'ReplaceApp' the existing app will be deleted and re-created.\n        ```\n        \n        ```{note}\n        If there is an update (different TEAL code) to an existing app (and `on_update` is set to 'ReplaceApp')\n        the existing app will be deleted and re-created.\n        ```\n        \n        :param str version: version to use when creating or updating app, if None version will be auto incremented\n        :param algosdk.atomic_transaction_composer.TransactionSigner signer: signer to use when deploying app\n        , if None uses self.signer\n        :param str sender: sender address to use when deploying app, if None uses self.sender\n        :param bool allow_delete: Used to set the `TMPL_DELETABLE` template variable to conditionally control if an app\n        can be deleted\n        :param bool allow_update: Used to set the `TMPL_UPDATABLE` template variable to conditionally control if an app\n        can be updated\n        :param OnUpdate on_update: Determines what action to take if an application update is required\n        :param OnSchemaBreak on_schema_break: Determines what action to take if an application schema requirements\n        has increased beyond the current allocation\n        :param dict[str, int|str|bytes] template_values: Values to use for `TMPL_*` template variables, dictionary keys\n        should *NOT* include the TMPL_ prefix\n        :param algokit_utils.DeployCallArgs | None create_args: Arguments used when creating an application\n        :param Deploy[UpdateArgs] update_args: Arguments used when updating an application\n        :param Deploy[DeleteArgs] delete_args: Arguments used when deleting an application\n        :return DeployResponse: details action taken and relevant transactions\n        :raises DeploymentError: If the deployment failed\"\"\"\n\n        return self.app_client.deploy(\n            version,\n            signer=signer,\n            sender=sender,\n            allow_update=allow_update,\n            allow_delete=allow_delete,\n            on_update=on_update,\n            on_schema_break=on_schema_break,\n            template_values=template_values,\n            create_args=_convert_deploy_args(create_args),\n            update_args=_convert_deploy_args(update_args),\n            delete_args=_convert_deploy_args(delete_args),\n        )\n\n    def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:\n        return Composer(self.app_client, atc or AtomicTransactionComposer())"}
{"instruction": "Implement a smart contract representing a mango tree. The contract allows users to 'water' the tree, which results in the creation of a unique NFT mango. Users can also 'pick' the mango, which transfers the NFT from the contract to the user, resetting the tree to a state where it has no mangoes.", "output": "Algorand Smart Contract Pe de Manga: rega, diga ox e receba sua manga NFT! \\n\\nfrom algosdk.future.transaction import StateSchema\\nfrom pyteal import (\\n And, App, Approve, Assert, Bytes, Cond, Expr, Global, If, InnerTxn, InnerTxnBuilder, Int, Mode, OnComplete, Reject, Seq, Txn, TxnField, TxnType, compileTeal\\n)\\n\\nTEAL_VERSION = 5\\n\\nGLOBAL_NA_MANGUEIRA = Bytes(\\\"naMangueira\\\")\\nGLOBAL_STATE = StateSchema(num_uints=1, num_byte_slices=0)\\nLOCAL_STATE = StateSchema(num_uints=0, num_byte_slices=0)\\n\\nMETHOD_REGA = \\\"rega\\\"\\nMETHOD_COLHE = \\\"ox\\\"\\n\\ndef pe_de_manga_approval() -> Expr:\\n return Cond([Txn.application_id() == Int(0), on_app_create()], [Txn.on_completion() == OnComplete.NoOp, on_app_call()])\\n\\ndef pe_de_manga_clear() -> Expr:\\n return Reject()\\n\\ndef on_app_create() -> Expr:\\n precondition = And(\\n  Txn.global_num_uints() == Int(GLOBAL_STATE.num_uints),\\n  Txn.global_num_byte_slices() == Int(GLOBAL_STATE.num_byte_slices),\\n  Txn.local_num_uints() == Int(LOCAL_STATE.num_uints),\\n  Txn.local_num_byte_slices() == Int(LOCAL_STATE.num_byte_slices)\\n )\\n return Seq(App.globalPut(GLOBAL_NA_MANGUEIRA, Int(0)), Approve())\\n\\ndef on_app_call() -> Expr:\\n method_selector = Txn.application_args[0]\\n return Seq(Assert(Txn.application_args.length() == Int(1)), Cond([method_selector == Bytes(METHOD_REGA), rega_pe_de_manga()], [method_selector == Bytes(METHOD_COLHE), colhe_manga()]), Approve())\\n\\ndef rega_pe_de_manga() -> Expr:\\n mangueira_account = Global.current_application_address()\\n nao_tem_manga = App.globalGet(GLOBAL_NA_MANGUEIRA) == Int(0)\\n nasce_manga = Seq(InnerTxnBuilder.Begin(), InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.AssetConfig, TxnField.config_asset_name: Bytes(\\\"MANGA\\\"), TxnField.config_asset_unit_name: Bytes(\\\"\\\"), TxnField.config_asset_url: Bytes(\\\"ipfs:bafkreibojeqclpzpz73gotdzqtondllgkncdzarmpad3i5alcvhodv7ujy#arc3\\\"), TxnField.config_asset_metadata_hash: Bytes(\\\"LkkgJb8vz/ZnTHmE3NGtZlNEPIIseAe0dAsVTuHX9E4=\\\"), TxnField.config_asset_decimals: Int(0), TxnField.config_asset_total: Int(1), TxnField.config_asset_manager: mangueira_account, TxnField.config_asset_clawback: Global.zero_address(), TxnField.config_asset_freeze: Global.zero_address(), TxnField.fee: Int(0)}), InnerTxnBuilder.Submit(), App.globalPut(GLOBAL_NA_MANGUEIRA, InnerTxn.created_asset_id()), Approve())\\n return Seq(If(nao_tem_manga).Then(nasce_manga).Else(Reject()))\\n\\ndef colhe_manga() -> Expr:\\n manga = App.globalGet(GLOBAL_NA_MANGUEIRA)\\n colher_da_mangueira = Seq(InnerTxnBuilder.Begin(), InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.AssetTransfer, TxnField.xfer_asset: manga, TxnField.asset_amount: Int(1), TxnField.asset_receiver: Txn.sender(), TxnField.fee: Int(0)}), InnerTxnBuilder.Submit(), App.globalPut(GLOBAL_NA_MANGUEIRA, Int(0)), Approve())\\n return colher_da_mangueira\\n\\ndef compile_stateful(program) -> str:\\n return compileTeal(program, Mode.Application, assembleConstants=True, version=TEAL_VERSION)\\n\\nif __name__ == \\\"__main__\\\":\\n print(compile_stateful(pe_de_manga_approval()))"}
{"instruction": "Implement a Smart ASA (Algorand Standard Asset) contract with functionalities for creation, configuration, transfer, freezing, and destruction, adhering to the ARC-20 standard, including methods for asset management, account freezing, and retrieval of asset information like circulating supply and configuration details.", "output": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nSmart ASA PyTEAL reference implementation based on ARC-20\n\"\"\"\n\n__author__ = \"Cosimo Bassi, Stefano De Angelis\"\n__email__ = \"<cosimo.bassi@algorand.com>, <stefano.deangelis@algorand.com>\"\n\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    AssetHolding,\n    AssetParam,\n    BareCallActions,\n    Bytes,\n    CallConfig,\n    Concat,\n    Expr,\n    Extract,\n    Global,\n    Gtxn,\n    If,\n    InnerTxn,\n    InnerTxnBuilder,\n    Int,\n    Len,\n    Mode,\n    Not,\n    OnCompleteAction,\n    OptimizeOptions,\n    Or,\n    Reject,\n    Return,\n    Router,\n    Seq,\n    Subroutine,\n    Suffix,\n    TealType,\n    Txn,\n    TxnField,\n    TxnType,\n    abi,\n    compileTeal,\n)\nfrom algosdk.future.transaction import StateSchema\nfrom algosdk.constants import key_len_bytes\n\n\n# / --- CONSTANTS\nTEAL_VERSION = 6\n\n# Descriptive field for the binding of Smart ASA App ID into the Underlying ASA url.\nSMART_ASA_APP_BINDING = \"smart-asa-app-id:\"\n\n# NOTE: The following costs could change over time with protocol upgrades.\nOPTIN_COST = 100_000\nUINTS_COST = 28_500\nBYTES_COST = 50_000\n\n\ndef static_attrs(cls):\n    return [k for k in cls.__dict__ if not k.startswith(\"__\")]\n\n\n# / --- SMART ASA ASC\n# / --- --- GLOBAL STATE\nclass GlobalInts:\n    total = Bytes(\"total\")\n    decimals = Bytes(\"decimals\")\n    default_frozen = Bytes(\"default_frozen\")\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass GlobalBytes:\n    unit_name = Bytes(\"unit_name\")\n    name = Bytes(\"name\")\n    url = Bytes(\"url\")\n    metadata_hash = Bytes(\"metadata_hash\")\n    manager_addr = Bytes(\"manager_addr\")\n    reserve_addr = Bytes(\"reserve_addr\")\n    freeze_addr = Bytes(\"freeze_addr\")\n    clawback_addr = Bytes(\"clawback_addr\")\n\n\nclass GlobalState(GlobalInts, GlobalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(GlobalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(GlobalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\nclass SmartASAConfig(abi.NamedTuple):\n    total: abi.Field[abi.Uint64]\n    decimals: abi.Field[abi.Uint32]\n    default_frozen: abi.Field[abi.Bool]\n    unit_name: abi.Field[abi.String]\n    name: abi.Field[abi.String]\n    url: abi.Field[abi.String]\n    metadata_hash: abi.Field[abi.DynamicArray[abi.Byte]]\n    manager_addr: abi.Field[abi.Address]\n    reserve_addr: abi.Field[abi.Address]\n    freeze_addr: abi.Field[abi.Address]\n    clawback_addr: abi.Field[abi.Address]\n\n\n# / --- --- LOCAL STATE\n# NOTE: Local State is needed only if the Smart ASA has `account_frozen`.\n# Local State is not needed in case Smart ASA has just \"global\" `asset_freeze`.\nclass LocalInts:\n    smart_asa_id = Bytes(\"smart_asa_id\")\n    frozen = Bytes(\"frozen\")\n\n\nclass LocalBytes:\n    ...\n\n\nclass LocalState(LocalInts, LocalBytes):\n    @staticmethod\n    def num_uints():\n        return len(static_attrs(LocalInts))\n\n    @staticmethod\n    def num_bytes():\n        return len(static_attrs(LocalBytes))\n\n    @classmethod\n    def schema(cls):\n        return StateSchema(\n            num_uints=cls.num_uints(),\n            num_byte_slices=cls.num_bytes(),\n        )\n\n\n# / --- --- SUBROUTINES\n@Subroutine(TealType.none)\ndef init_global_state() -> Expr:\n    return Seq(\n        App.globalPut(GlobalState.smart_asa_id, Int(0)),\n        App.globalPut(GlobalState.total, Int(0)),\n        App.globalPut(GlobalState.decimals, Int(0)),\n        App.globalPut(GlobalState.default_frozen, Int(0)),\n        # NOTE: ASA behaves excluding `unit_name` field if not declared:\n        App.globalPut(GlobalState.unit_name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `name` field if not declared:\n        App.globalPut(GlobalState.name, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `url` field if not declared:\n        App.globalPut(GlobalState.url, Bytes(\"\")),\n        # NOTE: ASA behaves excluding `metadata_hash` field if not declared:\n        App.globalPut(GlobalState.metadata_hash, Bytes(\"\")),\n        App.globalPut(GlobalState.manager_addr, Global.zero_address()),\n        App.globalPut(GlobalState.reserve_addr, Global.zero_address()),\n        App.globalPut(GlobalState.freeze_addr, Global.zero_address()),\n        App.globalPut(GlobalState.clawback_addr, Global.zero_address()),\n        # Special Smart ASA fields\n        App.globalPut(GlobalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.none)\ndef init_local_state() -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    return Seq(\n        App.localPut(Txn.sender(), LocalState.smart_asa_id, smart_asa_id),\n        App.localPut(Txn.sender(), LocalState.frozen, Int(0)),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef digit_to_ascii(i: Expr) -> Expr:\n    \"\"\"digit_to_ascii converts an integer < 10 to the ASCII byte that represents it\"\"\"\n    return Extract(Bytes(\"0123456789\"), i, Int(1))\n\n\n@Subroutine(TealType.bytes)\ndef itoa(i: Expr) -> Expr:\n    \"\"\"itoa converts an integer to the ASCII byte string it represents.\"\"\"\n    return If(\n        i == Int(0),\n        Bytes(\"0\"),\n        Concat(\n            If(i / Int(10) > Int(0), itoa(i / Int(10)), Bytes(\"\")),\n            digit_to_ascii(i % Int(10)),\n        ),\n    )\n\n\n@Subroutine(TealType.bytes)\ndef strip_len_prefix(abi_encoded: Expr) -> Expr:\n    return Suffix(abi_encoded, Int(abi.Uint16TypeSpec().byte_length_static()))\n\n\n# / --- --- UNDERLYING ASA CONFIG\nUNDERLYING_ASA_TOTAL = Int(2**64 - 1)\nUNDERLYING_ASA_DECIMALS = Int(0)\nUNDERLYING_ASA_DEFAULT_FROZEN = Int(1)\nUNDERLYING_ASA_UNIT_NAME = Bytes(\"S-ASA\")\nUNDERLYING_ASA_NAME = Bytes(\"SMART-ASA\")\nUNDERLYING_ASA_URL = Concat(\n    Bytes(SMART_ASA_APP_BINDING), itoa(Global.current_application_id())\n)\nUNDERLYING_ASA_METADATA_HASH = Bytes(\"\")\nUNDERLYING_ASA_MANAGER_ADDR = Global.current_application_address()\nUNDERLYING_ASA_RESERVE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_FREEZE_ADDR = Global.current_application_address()\nUNDERLYING_ASA_CLAWBACK_ADDR = Global.current_application_address()\n\n\n@Subroutine(TealType.uint64)\ndef underlying_asa_create_inner_tx() -> Expr:\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset_total: UNDERLYING_ASA_TOTAL,\n                TxnField.config_asset_decimals: UNDERLYING_ASA_DECIMALS,\n                TxnField.config_asset_default_frozen: UNDERLYING_ASA_DEFAULT_FROZEN,\n                TxnField.config_asset_unit_name: UNDERLYING_ASA_UNIT_NAME,\n                TxnField.config_asset_name: UNDERLYING_ASA_NAME,\n                TxnField.config_asset_url: UNDERLYING_ASA_URL,\n                TxnField.config_asset_manager: UNDERLYING_ASA_MANAGER_ADDR,\n                TxnField.config_asset_reserve: UNDERLYING_ASA_RESERVE_ADDR,\n                TxnField.config_asset_freeze: UNDERLYING_ASA_FREEZE_ADDR,\n                TxnField.config_asset_clawback: UNDERLYING_ASA_CLAWBACK_ADDR,\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        Return(InnerTxn.created_asset_id()),\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_transfer_inner_txn(\n    smart_asa_id: Expr,\n    asset_amount: Expr,\n    asset_sender: Expr,\n    asset_receiver: Expr,\n) -> Expr:\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.xfer_asset: smart_asa_id,\n                TxnField.asset_amount: asset_amount,\n                TxnField.asset_sender: asset_sender,\n                TxnField.asset_receiver: asset_receiver,\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef smart_asa_destroy_inner_txn(smart_asa_id: Expr) -> Expr:\n    return Seq(\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.fee: Int(0),\n                TxnField.type_enum: TxnType.AssetConfig,\n                TxnField.config_asset: smart_asa_id,\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    )\n\n\n@Subroutine(TealType.none)\ndef is_valid_address_bytes_length(address: Expr) -> Expr:\n    # WARNING: Note this check only ensures proper bytes' length on `address`,\n    # but doesn't ensure that those 32 bytes are a _proper_ Algorand address.\n    return Assert(Len(address) == Int(key_len_bytes))\n\n\n@Subroutine(TealType.uint64)\ndef circulating_supply(asset_id: Expr):\n    smart_asa_reserve = AssetHolding.balance(\n        Global.current_application_address(), asset_id\n    )\n    return Seq(smart_asa_reserve, UNDERLYING_ASA_TOTAL - smart_asa_reserve.value())\n\n\n@Subroutine(TealType.none)\ndef getter_preconditions(asset_id: Expr) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset_id\n    return Assert(\n        smart_asa_id,\n        is_correct_smart_asa_id,\n    )\n\n\n# / --- --- ABI\n# / --- --- BARE CALLS\n@Subroutine(TealType.none)\ndef asset_app_create() -> Expr:\n    return Seq(\n        # Preconditions\n        # Not mandatory - Smart ASA Application self validate its state.\n        Assert(\n            Txn.global_num_uints() == Int(GlobalState.num_uints()),\n            Txn.global_num_byte_slices() == Int(GlobalState.num_bytes()),\n            Txn.local_num_uints() == Int(LocalState.num_uints()),\n            Txn.local_num_byte_slices() == Int(LocalState.num_bytes()),\n        ),\n        init_global_state(),\n        Approve(),\n    )\n\n\nsmart_asa_abi = Router(\n    \"Smart ASA ref. implementation\",\n    BareCallActions(\n        no_op=OnCompleteAction.create_only(asset_app_create()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not updatable.\n        update_application=OnCompleteAction.always(Reject()),\n        # Rules governing a Smart ASA are only in place as long as the\n        # controlling Smart Contract is not deletable.\n        delete_application=OnCompleteAction.always(Reject()),\n        clear_state=OnCompleteAction.call_only(Reject()),\n    ),\n)\n\n\n# / --- --- METHODS\n@smart_asa_abi.method(opt_in=CallConfig.ALL)\ndef asset_app_optin(\n    asset: abi.Asset,\n    underlying_asa_optin: abi.AssetTransferTransaction,\n) -> Expr:\n    # On OptIn the frozen status must be set to `True` if account owns any\n    # units of the underlying ASA. This prevents malicious users to circumvent\n    # the `default_frozen` status by clearing their Local State. Note that this\n    # could be avoided by the use of Boxes once available.\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == asset.asset_id()\n    default_frozen = App.globalGet(GlobalState.default_frozen)\n    freeze_account = App.localPut(Txn.sender(), LocalState.frozen, Int(1))\n    account_balance = AssetHolding().balance(Txn.sender(), asset.asset_id())\n    optin_to_underlying_asa = account_balance.hasValue()\n    return Seq(\n        # Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n            underlying_asa_optin.get().type_enum() == TxnType.AssetTransfer,\n            underlying_asa_optin.get().xfer_asset() == smart_asa_id,\n            underlying_asa_optin.get().sender() == Txn.sender(),\n            underlying_asa_optin.get().asset_receiver() == Txn.sender(),\n            underlying_asa_optin.get().asset_amount() == Int(0),\n            underlying_asa_optin.get().asset_close_to() == Global.zero_address(),\n        ),\n        account_balance,\n        Assert(optin_to_underlying_asa),\n        # Effects\n        init_local_state(),\n        If(Or(default_frozen, account_balance.value() > Int(0))).Then(freeze_account),\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_create(\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n    *,\n    output: abi.Uint64,\n) -> Expr:\n\n    is_creator = Txn.sender() == Global.creator_address()\n    smart_asa_not_created = Not(App.globalGet(GlobalState.smart_asa_id))\n    smart_asa_id = underlying_asa_create_inner_tx()\n\n    return Seq(\n        # Preconditions\n        Assert(is_creator, smart_asa_not_created),\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        # Effects\n        # Underlying ASA creation\n        App.globalPut(GlobalState.smart_asa_id, smart_asa_id),\n        # Smart ASA properties\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n        output.set(App.globalGet(GlobalState.smart_asa_id)),\n    )\n\n\n@smart_asa_abi.method\ndef asset_config(\n    config_asset: abi.Asset,\n    total: abi.Uint64,\n    decimals: abi.Uint32,\n    default_frozen: abi.Bool,\n    unit_name: abi.String,\n    name: abi.String,\n    url: abi.String,\n    metadata_hash: abi.DynamicArray[abi.Byte],\n    manager_addr: abi.Address,\n    reserve_addr: abi.Address,\n    freeze_addr: abi.Address,\n    clawback_addr: abi.Address,\n) -> Expr:\n\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    current_manager_addr = App.globalGet(GlobalState.manager_addr)\n    current_reserve_addr = App.globalGet(GlobalState.reserve_addr)\n    current_freeze_addr = App.globalGet(GlobalState.freeze_addr)\n    current_clawback_addr = App.globalGet(GlobalState.clawback_addr)\n\n    is_manager_addr = Txn.sender() == current_manager_addr\n    is_correct_smart_asa_id = smart_asa_id == config_asset.asset_id()\n\n    update_reserve_addr = current_reserve_addr != reserve_addr.get()\n    update_freeze_addr = current_freeze_addr != freeze_addr.get()\n    update_clawback_addr = current_clawback_addr != clawback_addr.get()\n\n    # NOTE: In ref. implementation Smart ASA total can not be configured to\n    # less than its current circulating supply.\n    is_valid_total = total.get() >= circulating_supply(smart_asa_id)\n\n    return Seq(\n        # Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n        ),  # NOTE: usless in ref. impl since 1 ASA : 1 App\n        is_valid_address_bytes_length(manager_addr.get()),\n        is_valid_address_bytes_length(reserve_addr.get()),\n        is_valid_address_bytes_length(freeze_addr.get()),\n        is_valid_address_bytes_length(clawback_addr.get()),\n        Assert(is_manager_addr),\n        If(update_reserve_addr).Then(\n            Assert(current_reserve_addr != Global.zero_address())\n        ),\n        If(update_freeze_addr).Then(\n            Assert(current_freeze_addr != Global.zero_address())\n        ),\n        If(update_clawback_addr).Then(\n            Assert(current_clawback_addr != Global.zero_address())\n        ),\n        Assert(is_valid_total),\n        # Effects\n        App.globalPut(GlobalState.total, total.get()),\n        App.globalPut(GlobalState.decimals, decimals.get()),\n        App.globalPut(GlobalState.default_frozen, default_frozen.get()),\n        App.globalPut(GlobalState.unit_name, unit_name.get()),\n        App.globalPut(GlobalState.name, name.get()),\n        App.globalPut(GlobalState.url, url.get()),\n        App.globalPut(\n            GlobalState.metadata_hash, strip_len_prefix(metadata_hash.encode())\n        ),\n        App.globalPut(GlobalState.manager_addr, manager_addr.get()),\n        App.globalPut(GlobalState.reserve_addr, reserve_addr.get()),\n        App.globalPut(GlobalState.freeze_addr, freeze_addr.get()),\n        App.globalPut(GlobalState.clawback_addr, clawback_addr.get()),\n    )\n\n\n@smart_asa_abi.method\ndef asset_transfer(\n    xfer_asset: abi.Asset,\n    asset_amount: abi.Uint64,\n    asset_sender: abi.Account,\n    asset_receiver: abi.Account,\n) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    clawback_addr = App.globalGet(GlobalState.clawback_addr)\n    is_not_clawback = And(\n        Txn.sender() == asset_sender.address(),\n        Txn.sender() != clawback_addr,\n    )\n\n    # NOTE: Ref. implementation grants _minting_ premission to `reserve_addr`,\n    # has restriction no restriction on who is the minting _receiver_.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off minting.\n    is_minting = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == Global.current_application_address(),\n    )\n\n    # NOTE: Ref. implementation grants _burning_ premission to `reserve_addr`,\n    # has restriction both on burning _sender_ and _receiver_ to prevent\n    # _clawback_ throug burning.\n    # WARNING: Setting Smart ASA `reserve` to ZERO_ADDRESS switchs-off burning.\n    is_burning = And(\n        Txn.sender() == App.globalGet(GlobalState.reserve_addr),\n        asset_sender.address() == App.globalGet(GlobalState.reserve_addr),\n        asset_receiver.address() == Global.current_application_address(),\n    )\n\n    is_clawback = Txn.sender() == clawback_addr\n    is_correct_smart_asa_id = smart_asa_id == xfer_asset.asset_id()\n\n    # NOTE: Ref. implementation checks that `smart_asa_id` is correct in Local\n    # State since the App could generate a new Smart ASA (if the previous one\n    # has been dystroied) requiring users to opt-in again to gain a coherent\n    # new `frozen` status.\n    is_current_smart_asa_id = And(\n        smart_asa_id == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n        smart_asa_id == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n    )\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_sender_frozen = App.localGet(asset_sender.address(), LocalState.frozen)\n    asset_receiver_frozen = App.localGet(asset_receiver.address(), LocalState.frozen)\n    return Seq(\n        # Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n        ),\n        is_valid_address_bytes_length(asset_sender.address()),\n        is_valid_address_bytes_length(asset_receiver.address()),\n        If(is_not_clawback)\n        .Then(\n            # Asset Regular Transfer Preconditions\n            Assert(\n                Not(asset_frozen),\n                Not(asset_sender_frozen),\n                Not(asset_receiver_frozen),\n                is_current_smart_asa_id,\n            ),\n        )\n        .ElseIf(is_minting)\n        .Then(\n            # Asset Minting Preconditions\n            Assert(\n                Not(asset_frozen),\n                Not(asset_receiver_frozen),\n                smart_asa_id\n                == App.localGet(asset_receiver.address(), LocalState.smart_asa_id),\n                # NOTE: Ref. implementation prevents minting more than `total`.\n                circulating_supply(smart_asa_id) + asset_amount.get()\n                <= App.globalGet(GlobalState.total),\n            ),\n        )\n        .ElseIf(is_burning)\n        .Then(\n            # Asset Burning Preconditions\n            Assert(\n                Not(asset_frozen),\n                Not(asset_sender_frozen),\n                smart_asa_id\n                == App.localGet(asset_sender.address(), LocalState.smart_asa_id),\n            ),\n        )\n        .Else(\n            # Asset Clawback Preconditions\n            Assert(is_clawback),\n            # NOTE: `is_current_smart_asa_id` implicitly checks that both\n            # `asset_sender` and `asset_receiver` opted-in the Smart ASA\n            # App. This ensures that _mint_ and _burn_ can not be\n            # executed as _clawback_, since the Smart ASA App can not\n            # opt-in to itself.\n            Assert(is_current_smart_asa_id),\n        ),\n        # Effects\n        smart_asa_transfer_inner_txn(\n            xfer_asset.asset_id(),\n            asset_amount.get(),\n            asset_sender.address(),\n            asset_receiver.address(),\n        ),\n    )\n\n\n@smart_asa_abi.method\ndef asset_freeze(freeze_asset: abi.Asset, asset_frozen: abi.Bool) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Asset Freeze Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n            is_freeze_addr,\n        ),\n        # Effects\n        App.globalPut(GlobalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method\ndef account_freeze(\n    freeze_asset: abi.Asset,\n    freeze_account: abi.Account,\n    asset_frozen: abi.Bool,\n) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == freeze_asset.asset_id()\n    is_freeze_addr = Txn.sender() == App.globalGet(GlobalState.freeze_addr)\n    return Seq(\n        # Account Freeze Preconditions\n        is_valid_address_bytes_length(freeze_account.address()),\n        Assert(smart_asa_id, is_correct_smart_asa_id, is_freeze_addr),\n        # Effects\n        App.localPut(freeze_account.address(), LocalState.frozen, asset_frozen.get()),\n    )\n\n\n@smart_asa_abi.method(close_out=CallConfig.ALL)\ndef asset_app_closeout(\n    close_asset: abi.Asset,\n    close_to: abi.Account,\n) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == close_asset.asset_id()\n    current_smart_asa_id = App.localGet(Txn.sender(), LocalState.smart_asa_id)\n    is_current_smart_asa_id = current_smart_asa_id == close_asset.asset_id()\n    account_balance = AssetHolding().balance(Txn.sender(), close_asset.asset_id())\n    asset_creator = AssetParam().creator(close_asset.asset_id())\n    asset_frozen = App.globalGet(GlobalState.frozen)\n    asset_closer_frozen = App.localGet(Txn.sender(), LocalState.frozen)\n    asa_closeout_relative_idx = Txn.group_index() + Int(1)\n    return Seq(\n        # Preconditions\n        # NOTE: Smart ASA existence is not checked by default on close-out\n        # since would be impossible to close-out destroyed assets.\n        is_valid_address_bytes_length(close_to.address()),\n        Assert(\n            is_current_smart_asa_id,\n            Global.group_size() > asa_closeout_relative_idx,\n            Gtxn[asa_closeout_relative_idx].type_enum() == TxnType.AssetTransfer,\n            Gtxn[asa_closeout_relative_idx].xfer_asset() == close_asset.asset_id(),\n            Gtxn[asa_closeout_relative_idx].sender() == Txn.sender(),\n            Gtxn[asa_closeout_relative_idx].asset_amount() == Int(0),\n            Gtxn[asa_closeout_relative_idx].asset_close_to()\n            == Global.current_application_address(),\n        ),\n        # Effects\n        asset_creator,\n        # NOTE: Skip checks if Underlying ASA has been destroyed to avoid\n        # users' lock-in.\n        If(asset_creator.hasValue()).Then(\n            # NOTE: Smart ASA has not been destroyed.\n            Assert(is_correct_smart_asa_id),\n            If(Or(asset_frozen, asset_closer_frozen)).Then(\n                # NOTE: If Smart ASA is frozen, users can only close-out to\n                # Creator\n                Assert(close_to.address() == Global.current_application_address())\n            ),\n            If(close_to.address() != Global.current_application_address()).Then(\n                # NOTE: If the target of close-out is not Creator, it MUST be\n                # opted-in to the current Smart ASA.\n                Assert(\n                    smart_asa_id\n                    == App.localGet(close_to.address(), LocalState.smart_asa_id)\n                )\n            ),\n            account_balance,\n            smart_asa_transfer_inner_txn(\n                close_asset.asset_id(),\n                account_balance.value(),\n                Txn.sender(),\n                close_to.address(),\n            ),\n        ),\n        # NOTE: If Smart ASA has been destroyed:\n        #   1. The close-to address could be anyone\n        #   2. No InnerTxn happens\n        Approve(),\n    )\n\n\n@smart_asa_abi.method\ndef asset_destroy(destroy_asset: abi.Asset) -> Expr:\n    smart_asa_id = App.globalGet(GlobalState.smart_asa_id)\n    is_correct_smart_asa_id = smart_asa_id == destroy_asset.asset_id()\n    is_manager_addr = Txn.sender() == App.globalGet(GlobalState.manager_addr)\n    return Seq(\n        # Asset Destroy Preconditions\n        Assert(\n            smart_asa_id,\n            is_correct_smart_asa_id,\n            is_manager_addr,\n        ),\n        # Effects\n        smart_asa_destroy_inner_txn(destroy_asset.asset_id()),\n        init_global_state(),\n    )\n\n\n# / --- --- GETTERS\n@smart_asa_abi.method\ndef get_asset_is_frozen(freeze_asset: abi.Asset, *, output: abi.Bool) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        # Effects\n        output.set(App.globalGet(GlobalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_account_is_frozen(\n    freeze_asset: abi.Asset, freeze_account: abi.Account, *, output: abi.Bool\n) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(freeze_asset.asset_id()),\n        is_valid_address_bytes_length(freeze_account.address()),\n        # Effects\n        output.set(App.localGet(freeze_account.address(), LocalState.frozen)),\n    )\n\n\n@smart_asa_abi.method\ndef get_circulating_supply(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(circulating_supply(asset.asset_id())),\n    )\n\n\n@smart_asa_abi.method\ndef get_optin_min_balance(asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    min_balance = Int(\n        OPTIN_COST\n        + UINTS_COST * LocalState.num_uints()\n        + BYTES_COST * LocalState.num_bytes()\n    )\n\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        output.set(min_balance),\n    )\n\n\n@smart_asa_abi.method\ndef get_asset_config(asset: abi.Asset, *, output: SmartASAConfig) -> Expr:\n    return Seq(\n        # Preconditions\n        getter_preconditions(asset.asset_id()),\n        # Effects\n        (total := abi.Uint64()).set(App.globalGet(GlobalState.total)),\n        (decimals := abi.Uint32()).set(App.globalGet(GlobalState.decimals)),\n        (default_frozen := abi.Bool()).set(App.globalGet(GlobalState.default_frozen)),\n        (unit_name := abi.String()).set(App.globalGet(GlobalState.unit_name)),\n        (name := abi.String()).set(App.globalGet(GlobalState.name)),\n        (url := abi.String()).set(App.globalGet(GlobalState.url)),\n        (metadata_hash_str := abi.String()).set(\n            App.globalGet(GlobalState.metadata_hash)\n        ),\n        (metadata_hash := abi.make(abi.DynamicArray[abi.Byte])).decode(\n            metadata_hash_str.encode()\n        ),\n        (manager_addr := abi.Address()).set(App.globalGet(GlobalState.manager_addr)),\n        (reserve_addr := abi.Address()).set(App.globalGet(GlobalState.reserve_addr)),\n        (freeze_addr := abi.Address()).set(App.globalGet(GlobalState.freeze_addr)),\n        (clawback_addr := abi.Address()).set(App.globalGet(GlobalState.clawback_addr)),\n        output.set(\n            total,\n            decimals,\n            default_frozen,\n            unit_name,\n            name,\n            url,\n            metadata_hash,\n            manager_addr,\n            reserve_addr,\n            freeze_addr,\n            clawback_addr,\n        ),\n    )\n\n\ndef compile_stateful(program: Expr) -> str:\n    return compileTeal(\n        program,\n        Mode.Application,\n        version=TEAL_VERSION,\n        assembleConstants=True,\n        optimize=OptimizeOptions(scratch_slots=True),\n    )\n\n\nif __name__ == \"__main__\":\n    # Allow quickly testing compilation.\n    from smart_asa_test import test_compile\n\n    test_compile(*smart_asa_abi.build_program())"}
{"instruction": "Implement a PyTeal smart contract for managing key fragment requests and approvals. The contract allows delegatee accounts to opt-in, specifying a threshold and a list of trustee accounts. Trustees can then approve key fragment requests for the delegatee. Once the approval count reaches the threshold, a global state variable is updated.", "output": "from pyteal import *\nimport os\n\n# Global state \n# - totalApproved (int)\n\n# Local state \n# Delegatee account (6 int)\n# - NumOfTrustees (int)\n# - Threshold (int) \n# - Trustee_address (max 4): Trustee_approval_status (unapproved: Int(1), approved: Int(2)) (int)\n\ndef approval_program():\n    \n    on_create = Seq(\n        App.globalPut(Bytes(\"totalApproved\"), Int(0)),\n        Approve(),\n    )\n\n\n    # Ensure trustee has not approved before\n    # get(delegatee_account, key_of_sender_aka_trustee)\n    # Note: if the key is not there, Int(0) is returned so we cannot initialise it as UInt(0) \n    ensure_trustee_unapproved = Int(1) == App.localGet(Txn.accounts[1], Txn.accounts[0])\n    ensure_unapproved = Int(1) == App.localGet(Txn.accounts[1], Txn.accounts[0])\n    num_of_approved_trustees = App.localGet(Txn.accounts[1], Bytes(\"Approved\"))\n    threshold = App.localGet(Txn.accounts[1], Bytes(\"Threshold\"))\n    g_approved = App.globalGet(Bytes(\"totalApproved\"))\n\n    new_num_of_approved_trustees = ScratchVar(TealType.uint64)\n    new_g_approved = ScratchVar(TealType.uint64)\n    on_req_kfrags = Seq(\n        # Ensure there is a target account to apporve for\n        Assert(Txn.accounts.length() == Int(1)),\n        # Ensure this trustee has not previously approved this account\n        Assert(ensure_trustee_unapproved),\n        # Ensure this account has not been approved\n        Assert(ensure_unapproved),\n        # Store state to approve the account\n        App.localPut(Txn.accounts[1], Txn.accounts[0], Int(2)),\n        # Store state of new total approved trustees \n        new_num_of_approved_trustees.store(num_of_approved_trustees + Int(1)),\n        App.localPut(Txn.accounts[1], Bytes(\"Approved\"), new_num_of_approved_trustees.load()),\n        # Update global state if it has been approved\n        If(new_num_of_approved_trustees.load() >= threshold)\n        .Then(App.globalPut(Bytes(\"totalApproved\"), g_approved + Int(1))),\n        Approve(),\n    )\n\n    on_call = Seq(\n        # First, lets fail immediately if this transaction is grouped with any others\n        Assert(Global.group_size() == Int(1)), \n        Cond(\n            [Txn.application_args[0] == Bytes(\"reqKfrags\"), on_req_kfrags ],\n        )\n    )\n\n    # OptIn from the delegatee\n    # - allows the app to write into their local state\n    # - take the Txn.accounts max 4 https://developer.algorand.org/docs/get-details/parameter_tables/?from_query=reference%20#smart-signature-constraints\n    i = ScratchVar(TealType.uint64)\n    on_optIn = Seq(\n        Assert(Txn.accounts.length() > Int(0)),\n        # Threshold for approval\n        Assert(Btoi(Txn.application_args[0]) <= Txn.accounts.length()),\n        # Loop through all the foreign accounts (aka trustees)\n        i.store(Int(1)),\n        While(i.load() < Txn.accounts.length()+Int(1) ).Do(Seq([\n        # Set Approved state as unapproved Int(1)\n        App.localPut(Txn.accounts[0], Txn.accounts[i.load()], Int(1)),\n        i.store(i.load() + Int(1))\n        ])),\n        # Set NumOfTrustees given\n        App.localPut(Txn.accounts[0], Bytes(\"NumOfTrustees\"), Txn.accounts.length()),\n        # Set Threshold required to approve kfrags \n        App.localPut(Txn.accounts[0], Bytes(\"Threshold\"), Btoi(Txn.application_args[0])),\n        App.localPut(Txn.accounts[0], Bytes(\"Approved\"), Int(0)),\n        Approve(),\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_create],\n        [Txn.on_completion() == OnComplete.NoOp, on_call],\n        [Txn.on_completion() == OnComplete.OptIn, on_optIn],\n        [\n            Or(\n                Txn.on_completion() == OnComplete.CloseOut,\n                Txn.on_completion() == OnComplete.UpdateApplication,\n            ),\n            Reject(),\n        ],\n    )\n\n    return compileTeal(program, Mode.Application, version=5)\n\ndef clear_state_program():\n   program = Approve()\n   # Mode.Application specifies that this is a stateful smart contract\n   return compileTeal(program, Mode.Application, version=5)\n\npath = os.path.dirname(os.path.abspath(__file__))\n\n\n# compile program to TEAL assembly\nwith open(os.path.join(path, \"./approval.teal\"), \"w\") as f:\n    approval_program_teal = approval_program()\n    f.write(approval_program_teal)\n\n\n    # compile program to TEAL assembly\nwith open(os.path.join(path, \"./clear.teal\"), \"w\") as f:\n    clear_state_program_teal = clear_state_program()\n    f.write(clear_state_program_teal)\n    \nprint(approval_program())\nprint(clear_state_program())"}
{"instruction": "Create an Algorand smart contract with the following behavior: On application creation, approve the transaction. On application deletion, only allow the creator to delete the application and approve. On NoOp calls, approve. Reject application updates. On CloseOut and OptIn, approve. The clear state program should always approve.", "output": "from pyteal import *\n\ndef approval_program():\n    handle_creation = Seq([\n        Approve()\n    ])\n\n    handle_deletion = Seq([\n        # Only allow the creator to delete the app\n        Assert(Txn.sender() == Global.creator_address()),\n        Approve()\n    ])\n\n    handle_noop = Seq([\n        Approve()\n    ])\n\n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, handle_deletion],\n        [Txn.on_completion() == OnComplete.NoOp, handle_noop],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Reject()],\n        [Txn.on_completion() == OnComplete.CloseOut, Approve()],\n        [Txn.on_completion() == OnComplete.OptIn, Approve()],\n    )\n\n    return compileTeal(program, mode=Mode.Application, version=6)\n\ndef clear_state_program():\n    return compileTeal(Approve(), mode=Mode.Application, version=6)\n\nprint(approval_program())\nprint(clear_state_program())"}
{"instruction": "Construct a KInner term representing an Algorand application's state, given its ID, global and local state schemas, and global state key-value pairs.  The term includes the application's ID, empty approval and clear state programs, global and local state schemas with number of integers and byte slices, and global state in bytes and integers, within a structured KApply format.", "output": "from base64 import b64decode\nfrom typing import List, Optional, cast\n\nfrom algosdk.v2client import models\nfrom pyk.kast.inner import KApply, KInner, KLabel, KSort, KToken\nfrom pyk.kast.manip import split_config_from\n\nfrom kavm.adaptors.teal_key_value import (\n    list_state_to_dict_bytes_bytes,\n    list_state_to_dict_bytes_ints,\n    teal_key_value_store_from_k_cell,\n)\nfrom kavm.pyk_utils import map_bytes_bytes, map_bytes_ints\n\n\nclass KAVMApplicationParams(models.ApplicationParams):\n    inverted_attribute_map = {v: k for k, v in models.ApplicationParams.attribute_map.items()}\n\n\nclass KAVMApplication(models.Application):\n    \"\"\"\n    Convenience class abstracting an Algorand smart contract (aka stateful application)\n    \"\"\"\n\n    inverted_attribute_map = {v: k for k, v in models.Application.attribute_map.items()}\n\n    @staticmethod\n    def from_k_cell(term: KInner, creator: str) -> 'KAVMApplication':\n        \"\"\"\n        Parse a KAVMApplication instance from a Kast term\n        \"\"\"\n        (_, subst) = split_config_from(term)\n        parsed_app_id = int(cast(KToken, subst['APPID_CELL']).token)\n        parsed_approval_program = b64decode(cast(KToken, subst['APPROVALPGM_CELL']).token)\n        parsed_clear_state_program = b64decode(cast(KToken, subst['CLEARSTATEPGM_CELL']).token)\n        parsed_global_state = teal_key_value_store_from_k_cell(\n            subst['GLOBALINTS_CELL']\n        ) + teal_key_value_store_from_k_cell(subst['GLOBALBYTES_CELL'])\n        parsed_params = KAVMApplicationParams(\n            # approval_pgm_src=subst['APPROVALPGMSRC_CELL'],\n            # clear_state_pgm_src=subst['CLEARSTATEPGMSRC_CELL'],\n            creator=creator,\n            approval_program=parsed_approval_program if parsed_approval_program else None,\n            clear_state_program=parsed_clear_state_program if parsed_clear_state_program else None,\n            local_state_schema=models.ApplicationStateSchema(\n                num_uint=int(cast(KToken, subst['LOCALNUMINTS_CELL']).token),\n                num_byte_slice=int(cast(KToken, subst['LOCALNUMBYTES_CELL']).token),\n            ),\n            global_state_schema=models.ApplicationStateSchema(\n                num_uint=int(cast(KToken, subst['GLOBALNUMINTS_CELL']).token),\n                num_byte_slice=int(cast(KToken, subst['GLOBALNUMBYTES_CELL']).token),\n            ),\n            global_state=parsed_global_state if len(parsed_global_state) else None,\n            # extra_pages=int(cast(KToken, subst['EXTRAPAGES_CELL']).token),\n        )\n        return KAVMApplication(id=parsed_app_id, params=parsed_params)\n\n\ndef application_k_term(\n    app_id: int,\n    global_state_schema: Optional[models.ApplicationStateSchema] = None,\n    local_state_schema: Optional[models.ApplicationStateSchema] = None,\n    global_state: Optional[List[models.TealKeyValue]] = None,\n) -> KInner:\n    global_num_ints = global_state_schema.num_uint if global_state_schema else 0\n    global_num_byte_slice = global_state_schema.num_byte_slice if global_state_schema else 0\n    local_num_ints = local_state_schema.num_uint if local_state_schema else 0\n    local_num_byte_slice = local_state_schema.num_byte_slice if local_state_schema else 0\n    global_bytes = list_state_to_dict_bytes_bytes(global_state) if global_state else {}\n    global_ints = list_state_to_dict_bytes_ints(global_state) if global_state else {}\n\n    return KApply(\n        label=KLabel(name='<app>', params=()),\n        args=(\n            KApply(label=KLabel(name='<appID>', params=()), args=(KToken(token=str(app_id), sort=KSort(name='Int')),)),\n            KApply(\n                label=KLabel(name='<approvalPgmSrc>', params=()),\n                args=(KApply(label=KLabel(name='.K', params=()), args=()),),\n            ),\n            KApply(\n                label=KLabel(name='<clearStatePgmSrc>', params=()),\n                args=(KApply(label=KLabel(name='.K', params=()), args=()),),\n            ),\n            KApply(\n                label=KLabel(name='<approvalPgm>', params=()), args=(KToken(token='\"\"', sort=KSort(name='String')),)\n            ),\n            KApply(\n                label=KLabel(name='<clearStatePgm>', params=()), args=(KToken(token='\"\"', sort=KSort(name='String')),)\n            ),\n            KApply(\n                label=KLabel(name='<globalState>', params=()),\n                args=(\n                    KApply(\n                        label=KLabel(name='<globalNumInts>', params=()),\n                        args=(KToken(token=str(global_num_ints), sort=KSort(name='Int')),),\n                    ),\n                    KApply(\n                        label=KLabel(name='<globalNumBytes>', params=()),\n                        args=(KToken(token=str(global_num_byte_slice), sort=KSort(name='Int')),),\n                    ),\n                    KApply(\n                        label=KLabel(name='<globalBytes>', params=()),\n                        args=[map_bytes_bytes(global_bytes)],\n                    ),\n                    KApply(\n                        label=KLabel(name='<globalInts>', params=()),\n                        args=[map_bytes_ints(global_ints)],\n                    ),\n                ),\n            ),\n            KApply(\n                label=KLabel(name='<localState>', params=()),\n                args=(\n                    KApply(\n                        label=KLabel(name='<localNumInts>', params=()),\n                        args=(KToken(token=str(local_num_ints), sort=KSort(name='Int')),),\n                    ),\n                    KApply(\n                        label=KLabel(name='<localNumBytes>', params=()),\n                        args=(KToken(token=str(local_num_byte_slice), sort=KSort(name='Int')),),\n                    ),\n                ),\n            ),\n            KApply(label=KLabel(name='<extraPages>', params=()), args=(KToken(token='0', sort=KSort(name='Int')),)),\n        ),\n    )"}
{"instruction": "Implement a permissioned voting application smart contract on Algorand. The contract allows a central authority (creator) to define registration and voting periods, and distribute voting tokens (ASA). Users can register during the registration period and vote for either 'candidatea' or 'candidateb' during the voting period by transferring their voting token back to the creator in a grouped transaction with the smart contract call. The contract tracks votes for each candidate and prevents users from voting more than once.", "output": "from pyteal import *\n\ndef approval_program():\n    \"\"\"\n    https://developer.algorand.org/solutions/example-permissioned-voting-stateful-smart-contract-application/?query=asset%2520contract\n    To implement a permissioned voting application on Algorand, a central authority is needed to\n    provide users the right to vote. In this example, this is handled by an Algorand Standard\n    Asset. The central authority creates a vote token and then gives voters who have registered\n    one voting token. The voter then registers within a round range with the voting smart\n    contract, by Opting into the contract. Voters then vote by grouping two transactions.\n    The first is a smart contract call to vote for either candidate A or candidate B, and\n    the second is transferring the vote token back to the central authority. Voting is only\n    allowed within the voting range.\n    \"\"\"\n    # Check to see that the application ID is not set, indicating this is a creation call.\n    # Store the creator address to global state.\n    # Store both register and voting round ranges to global state.\n    # Store Asset ID to global state\n    on_creation = Seq([\n        App.globalPut(Bytes(\"Creator\"), Txn.sender()),\n        Assert(Txn.application_args.length() == Int(5)),\n        App.globalPut(Bytes(\"RegBegin\"), Btoi(Txn.application_args[0])),\n        App.globalPut(Bytes(\"RegEnd\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"VoteBegin\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"VoteEnd\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"AssetID\"), Btoi(Txn.application_args[4])),\n        Return(Int(1))\n    ])\n\n    # Always verify that the RekeyTo property of any transaction is set to the ZeroAddress\n    # unless the contract is specifically involved ina rekeying operation.\n    no_rekey_addr = Txn.rekey_to() == Global.zero_address()\n\n    # Checks whether the sender is creator.\n    is_creator = Txn.sender() == App.globalGet(Bytes(\"Creator\"))\n\n    # Checks whether sender has voted before or not.\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n\n    on_closeout = Seq([\n        get_vote_of_sender,\n        If(And(Global.round() <= App.globalGet(Bytes(\"VoteEnd\")), get_vote_of_sender.hasValue()),\n            App.globalPut(get_vote_of_sender.value(), App.globalGet(get_vote_of_sender.value()) - Int(1))\n        ),\n        Return(Int(1))\n    ])\n\n    # Checks that the first argument to the smart contract is the word register.\n    # Verifies that the round is currently between registration begin and end rounds.\n    on_register = Return(\n        And(\n        no_rekey_addr,\n        Txn.application_args[0] == Bytes(\"register\"),\n        Global.round() >= App.globalGet(Bytes(\"RegBegin\")),\n        Global.round() <= App.globalGet(Bytes(\"RegEnd\")))\n    )\n\n    # Verifies the first application argument contains the string vote.\n    # Verifies the vote call is between the beginning and end of the voting round ranges.\n    # Verifies that two transactions are in the group.\n    # Checks that the second transaction is an asset transfer, and the token transferred is the vote token.\n    # Checks that the second transaction receiver is the creator of the application.\n    # Checks if the account has already voted, and if so, just returns true with no change to global state.\n    # Verifies that the user is either voting for candidate A or B.\n    # Reads the candidates current total from the global state and increments the value.\n    # Stores the candidate choice to the users local state.\n    choice = Txn.application_args[1]\n    choice_tally = App.globalGet(choice)\n    on_vote = Seq([\n        Assert(And(\n            no_rekey_addr,\n            Global.round() >= App.globalGet(Bytes(\"VoteBegin\")),\n            Global.round() <= App.globalGet(Bytes(\"VoteEnd\"))\n        )),\n        Assert(And(\n            Global.group_size() == Int(2),\n            Gtxn[1].type_enum() == TxnType.AssetTransfer,\n            Gtxn[1].asset_receiver() == App.globalGet(Bytes(\"Creator\")),\n            Gtxn[1].xfer_asset() == App.globalGet(Bytes(\"AssetID\")),\n            Gtxn[1].asset_amount() == Int(1),\n            Or(choice == Bytes(\"candidatea\"), choice == Bytes(\"candidateb\"))\n        )),\n        get_vote_of_sender,\n        If(get_vote_of_sender.hasValue(),\n            Return(Int(0))\n        ),\n        App.globalPut(choice, choice_tally + Int(1)),\n        App.localPut(Int(0), Bytes(\"voted\"), choice),\n        Return(Int(1))\n    ])\n\n    # Verfies that the application_id is 0, jumps to on_creation.\n    # Verifies that DeleteApplication is used and verifies that sender is creator.\n    # Verifies that UpdateApplication is used and verifies that sender is creator.\n    # Verifies that closeOut is used and jumps to on_closeout.\n    # Verifies that the account has opted in and jumps to on_register.\n    # Verifies that first argument is \"vote\" and jumps to on_vote.\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, on_register],\n        [Txn.application_args[0] == Bytes(\"vote\"), on_vote]\n    )\n\n    return program\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(approval_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"instruction": "The smart contract allows updating the price and decimal places stored in the application's global state, but only if the first argument of the transaction is 'update_price'. The contract also allows the creator to delete or update the application. Any other transaction will fail.", "output": "from pyteal import *\n\ndef approval_program():\n    on_update_price = Seq([\n        Assert(And(\n            Txn.application_args.length() == Int(3),\n            Txn.application_args[0] == Bytes(\"update_price\")\n        )),\n        App.globalPut(Bytes(\"price\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"decimals\"), Btoi(Txn.application_args[2])),\n        Return(Int(1))\n    ])\n\n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(Txn.sender() == Global.creator_address())],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(Txn.sender() == Global.creator_address())],\n        [Txn.on_completion() == OnComplete.NoOp, on_update_price]\n    )\n\n    return program\n\nif __name__ == \"__main__\":\n    print(compileTeal(approval_program(), mode=Mode.Application, version=6))"}
{"instruction": "Develop a TEAL smart contract for a transfer-controlled Algorand Standard Asset (TC-ASA). The contract should manage the minting, burning, and transferring of an ASA, enabling custom transfer logic and incorporating features such as global freezing, address whitelisting, and locking mechanisms. Use PyTeal to implement the smart contract, defining application and local state configurations, and utilizing ABI methods for interaction.", "output": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nTransfer-controlled Algorand Standard Asset (TC-ASA).\n\nTies an ASA to an ASC (Algorand Smart Contract) and exposes methods to\nmint/burn/transfer.\n\nEnables custom / extended logic around transfers.\n\"\"\"\n\nimport dataclasses\n\nfrom pyteal import (\n    And,\n    App,\n    Approve,\n    Assert,\n    AssetHolding,\n    Bytes,\n    Cond,\n    Expr,\n    Global,\n    InnerTxnBuilder,\n    Int,\n    Mode,\n    Not,\n    OnComplete,\n    Or,\n    Reject,\n    Seq,\n    Txn,\n    TxnField,\n    TxnType,\n    compileTeal,\n)\nfrom pyteal.ast.asset import AssetParam\n\nfrom state import AVMState\nfrom abi import ABI\n\nTEAL_VERSION = 6\n\n\n@dataclasses.dataclass\nclass Config(AVMState):\n    master: AVMState.Address  # Master address (can be multi-sig)\n\n    # The asset may be globally \"frozen\", no transfers will be approved until it is \"unfrozen\".\n    is_frozen: AVMState.UInt = AVMState.UInt(0)\n\n    # Corresponding ASA token\n    asa: AVMState.UInt = AVMState.UInt(0)  # Will be set by `init`\n\n\n@dataclasses.dataclass\nclass LocalConfig(AVMState):\n    is_locked: AVMState.UInt = AVMState.UInt(0)\n    is_whitelisted: AVMState.UInt = AVMState.UInt(0)\n\n\nKeys = Config.to_keys(\"Keys\")\nLocalKeys = LocalConfig.to_keys(\"LocalKeys\")\n\n\nTC_ASA_RESERVE = Global.current_application_address()\n\n\n# (rest of the contract continues exactly as you had provided)\n"}
{"instruction": "Compile, activate, and withdraw from a donation smart contract on the Algorand blockchain. The smart contract allows a specified benefactor to withdraw funds. The script compiles the smart contract, funds the escrow account to activate it, and then executes a logic signature transaction to withdraw funds to the benefactor.", "output": "import base64\nimport os\nfrom algosdk.future import transaction\nfrom algosdk import mnemonic\nfrom algosdk.v2client import algod\nfrom pyteal import *\nfrom dotenv import load_dotenv\n\nAPI_KEY = \"3L6Urqa3Bs1PE1ghfZcgx9FHti0mtDSp2ECv3jql\"\n# user declared account mnemonics\nbenefactor_mnemonic = \"angry spend ice estate spoil title deer divide once crazy head magnet supreme icon secret unfair domain section clean scrub want stairs excite abandon dad\"\nsender_mnemonic = \"across wrap wisdom museum piece patch custom wait price discover cloud group garbage dry prize purity fetch burger blood purchase wrist ramp between above lesson\"\n\nprint(\"API_KEY\")\nprint(API_KEY)\n\nprint(\"MNEMONIC\")\nprint(sender_mnemonic)\n\n# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config\nalgod_address = \"https://testnet-algorand.api.purestake.io/ps2\"\nalgod_token = API_KEY\n\n# helper function to compile program source\ndef compile_smart_signature(client, source_code):\n    compile_response = client.compile(source_code)\n    return compile_response['result'], compile_response['hash']\n\n# helper function that converts a mnemonic passphrase into a private signing key\ndef get_private_key_from_mnemonic(mn) :\n    private_key = mnemonic.to_private_key(mn)\n    return private_key\n\ndef payment_transaction(creator_mnemonic, amt, rcv, algod_client)->dict:\n    params = algod_client.suggested_params()\n    add = mnemonic.to_public_key(creator_mnemonic)\n    key = mnemonic.to_private_key(creator_mnemonic)\n    unsigned_txn = transaction.PaymentTxn(add, params, rcv, amt)\n    signed = unsigned_txn.sign(key)\n    txid = algod_client.send_transaction(signed)\n    pmtx = transaction.wait_for_confirmation(algod_client, txid , 5)\n    return pmtx\n\ndef lsig_payment_txn(escrowProg, escrow_address, amt, rcv, algod_client):\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(escrow_address, params, rcv, amt)\n    encodedProg = escrowProg.encode()\n    program = base64.decodebytes(encodedProg)\n    lsig = transaction.LogicSigAccount(program)\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = transaction.wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\"\"\"Basic Donation Escrow\"\"\"\n\ndef donation_escrow(benefactor):\n    Fee = Int(1000)\n\n    #Only the benefactor account can withdraw from this escrow\n    program = And(\n        Txn.type_enum() == TxnType.Payment,\n        Txn.fee() <= Fee,\n        Txn.receiver() == Addr(benefactor),\n        Global.group_size() == Int(1),\n        Txn.rekey_to() == Global.zero_address()\n    )\n\n    # Mode.Signature specifies that this is a smart signature\n    return compileTeal(program, Mode.Signature, version=5)\n\ndef main() :\n    # initialize an algodClient\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n    # define private keys\n    receiver_public_key = mnemonic.to_public_key(benefactor_mnemonic)\n\n    print(\"--------------------------------------------\")\n    print(\"Compiling Donation Smart Signature......\")\n\n    stateless_program_teal = donation_escrow(receiver_public_key)\n    escrow_result, escrow_address= compile_smart_signature(algod_client, stateless_program_teal)\n\n    print(\"Program:\", escrow_result)\n    print(\"hash: \", escrow_address)\n\n    print(\"--------------------------------------------\")\n    print(\"Activating Donation Smart Signature......\")\n\n    # Activate escrow contract by sending 2 algo and 1000 microalgo for transaction fee from creator\n    amt = 2001000\n    payment_transaction(sender_mnemonic, amt, escrow_address, algod_client)\n\n    print(\"--------------------------------------------\")\n    print(\"Withdraw from Donation Smart Signature......\")\n\n    # Withdraws 1 ALGO from smart signature using logic signature.\n    withdrawal_amt = 1000000\n    lsig_payment_txn(escrow_result, escrow_address, withdrawal_amt, receiver_public_key, algod_client)\n\nmain()"}
{"instruction": "Identify execution paths in the TEAL code that approve transactions without validating the RekeyTo field, potentially allowing an attacker to rekey the account and gain control.", "output": "\"\"\"Detector for finding execution paths missing RekeyTo check.\"\"\"\n\nfrom typing import List, TYPE_CHECKING, Tuple\n\nfrom tealer.detectors.abstract_detector import (\n    AbstractDetector,\n    DetectorClassification,\n    DetectorType,\n)\nfrom tealer.detectors.utils import detect_missing_tx_field_validations_group\nfrom tealer.utils.output import ExecutionPaths\n\n\nif TYPE_CHECKING:\n    from tealer.teal.basic_blocks import BasicBlock\n    from tealer.utils.output import Listoutput\n    from tealer.teal.context.block_transaction_context import BlockTransactionContext\n    from tealer.teal.teal import Teal\n\n\nclass CanRekey(AbstractDetector):  # pylint: disable=too-few-public-methods\n    \"\"\"Detector to find execution paths missing RekeyTo check.\n\n    TEAL, from version 2 onwards supports rekeying of accounts.\n    An account can be rekeyed to a different address. Once rekeyed,\n    rekeyed address has entire authority over the account. Contract\n    Accounts can also be rekeyed. If RekeyTo field of the transaction\n    is set to malicious actor's address, then they can control the account\n    funds, assets directly bypassing the contract's restrictions.\n\n    This detector tries to find execution paths that approve the algorand\n    transaction(\"return 1\") and doesn't check the RekeyTo transaction field.\n    Additional to checking rekeying of it's own contract, detector also finds\n    execution paths that doesn't check RekeyTo field of other transactions\n    in the atomic group.\n    \"\"\"\n\n    NAME = \"rekey-to\"\n    DESCRIPTION = \"Rekeyable Logic Signatures\"\n    TYPE = DetectorType.STATELESS\n\n    IMPACT = DetectorClassification.HIGH\n    CONFIDENCE = DetectorClassification.HIGH\n\n    WIKI_URL = \"https://github.com/crytic/tealer/wiki/Detector-Documentation#rekeyable-logicsig\"\n    WIKI_TITLE = \"Rekeyable LogicSig\"\n    WIKI_DESCRIPTION = (\n        \"Logic signature does not validate `RekeyTo` field.\"\n        \" Attacker can submit a transaction with `RekeyTo` field set to their address and take control over the account.\"\n        \" More at [building-secure-contracts/not-so-smart-contracts/algorand/rekeying]\"\n        \"(https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/algorand/rekeying)\"\n    )\n    WIKI_EXPLOIT_SCENARIO = \"\"\"\n```py\ndef withdraw(...) -> Expr:\n    return Seq(\n        [\n            Assert(\n                And(\n                    Txn.type_enum() == TxnType.Payment,\n                    Txn.first_valid() % period == Int(0),\n                    Txn.last_valid() == Txn.first_valid() + duration,\n                    Txn.receiver() == receiver,\n                    Txn.amount() == amount,\n                    Txn.first_valid() < timeout,\n                )\n            ),\n            Approve(),\n        ]\n    )\n```\n\nAlice signs the logic-sig to allow recurring payments to Bob.\\\n Eve uses the logic-sig and submits a valid transaction with `RekeyTo` field set to her address.\\\n Eve takes over Alice's account.\n\"\"\"\n\n    WIKI_RECOMMENDATION = \"\"\"\nValidate `RekeyTo` field in the LogicSig.\n\"\"\"\n\n    def detect(self) -> \"Listoutput\":\n        \"\"\"Detect execution paths with missing CloseRemainderTo check.\n\n        Returns:\n            ExecutionPaths instance containing the list of vulnerable execution\n            paths along with name, check, impact, confidence and other detector\n            information.\n        \"\"\"\n\n        def checks_field(block_ctx: \"BlockTransactionContext\") -> bool:\n            # return False if RekeyTo field can have any address.\n            # return True if RekeyTo should have some address or zero address\n            return not block_ctx.rekeyto.any_addr\n\n        output: List[\n            Tuple[\"Teal\", List[List[\"BasicBlock\"]]]\n        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)\n        detector_output: \"Listoutput\" = []\n        for contract, vulnerable_paths in output:\n            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))\n\n        return detector_output"}
{"instruction": "Implement a decentralized voting system on the Algorand blockchain using Choice Coin as the voting token. The system should support both standard elections and corporate voting with weighted votes based on stake. It includes features such as SHA-512 hashing for voter privacy, vote tabulation using stateless smart contracts, dynamic result visualization using Matplotlib, and account resetting for new voting processes using clawback functionality.", "output": "# Open Source under Apache License\n\n# This code defines a decenteralized voting system on the Algorand Blockchain.\n# It uses Choice Coin, an Algorand Standard Asset, to record votes on a distributed ledger.\n# The system makes both efficiency and security a priority.\n# An escrow account holds the total number of Choice Coin required for the voting process, and Algorand accounts for each of the decisions made.\n# Each of the individual decisions made by the voters connect back to the escrow account.\n# In turn, one Choice Coin transfers to the appropriate decision account through a stateless smart contract.\n# Furthermore, a SHA-512 hashing algorithm is used to encrypt voter information at all stages, ensuring that private information is made secure.\n# This is especially useful where voters need to give personal identification for verification purposes.\n\n# Imports and dependicies include the Algorand Python SDK, the Python Hashlib library, and the Python Matplotlib library.\nfrom algosdk import account, encoding, mnemonic, transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\nimport hashlib\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport random\nimport base64\nimport io\n\nplt.style.use('fivethirtyeight')\n\n\n# Matplot parameters for the matplotlib function to generate a new plot.\nmatplotlib.use('TkAgg')\nalgod_address = \"\"  # Put Algod Token here\nalgod_token = \"\"  # Put Algod Client address here\nheaders = {\"X-API-Key\": algod_token}\n# Initializes client for node.\nalgod_client = algod.AlgodClient(algod_token, algod_address, headers)\n\n# Escrow creation.\nescrow_address = \"\"  # Put in main fund address here\n# Put in main fund receiver_mnemonic here\nescrow_mnemonic = \"\"\nescrow_key = mnemonic.to_private_key(escrow_mnemonic)\nchoice_id = 21364625  # Official Test Asset ID for Choice Coin\n\n# Decisions.\n# To add more decisions for the election process, add the address for the new decision here.\n# Then, add an appropriate boolean statement at line 100 of this file. Be sure to also add additional\n# counts at line 148 of this file as well.\ndecision_one = \"\"\ndecision_two = \"\"\ncorporate_decision_one = \"\"\ncorporate_decision_two = \"\"\n\n# Clawback Address required to reset accounts to start new voting process.\n# Sets up accounts for both the regular election process and the corporate decision process.\n# Add more accounts to adjust for more decisions.\nclawback_address = \"\"\nclawback_mnemonic = \"\"\nclawback_key = mnemonic.to_private_key(clawback_mnemonic)\n\n# This function counts the number of Choice Coin in an account.\n# It first fetches the account_info, and specifically searches among the assets that the account owns for Choice Coin.\n# It then returns the number of Choice Coin that the account owns.\n\n\ndef count(address):\n    message = ''\n    error = ''\n    account_info = algod_client.account_info(address)  # Fetch account information for the address.\n    assets = account_info.get(\"assets\")  # Fetch asset information.\n    for asset in assets:\n        # Iterate over assets until Choice Coin is reached. Return the amount if it exists.\n        if asset[\"asset-id\"] == choice_id:\n            amount = asset.get(\"amount\")\n            message = amount\n            return message\n    error = 'The account has not opted-in to the asset yet.'\n    return error\n\n# This function hashes a string using the SHA-512 cryptographic scheme.\n# SHA-512 is a post-quantum cryptographic scheme, thus ensuring that private information is made secure from malicious attackers.\n\n\ndef hashing(item):\n    # Assumes the default UTF-8.\n    hash_object = hashlib.sha512(item.encode())  # This encodes the string with the SHA-512 scheme.\n    item = hash_object.hexdigest()  # This returns the hexadecimal encode as a string.\n    return item\n\n# This function defines a stateless smart contract on the Algorand Network.\n# It sends Choice Coin to the appropriate destination address based on user input.\n\n\ndef choice_vote(sender, key, receiver, amount, comment):\n    parameters = algod_client.suggested_params()  # Sets suggested parameters\n    # transaction = AssetTransferTxn(sender, parameters, receiver, amount, choice_id, note=comment)\n    transaction = AssetTransferTxn(sender, parameters, receiver, 0, choice_id, note=comment)\n    # Defines an inital transaction for Choice Coin\n    signature = transaction.sign(key)\n    # Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    # Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n# This function describes a methodology for Electoral Voting on the Choice Coin platform.\n# It calls the choice_vote() function with the appropriate inputs based on which decision the voter selected.\n# It is currently defined for two candidates/decisions, but it can be easily amended to include more.\n\n\ndef election_voting(vote):\n    message = ''\n    if vote == 'YES':  # Add more boolean statements for more decisions or candidates.\n        # choice_vote() function called for \"YES\".\n        TX_ID = choice_vote(escrow_address, escrow_key, decision_one,\n                            100, \"Tabulated using Choice Coin\")\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n            TX_ID[1] + \".\"\n        # AlgoExplorer returned for validation.\n    elif vote == 'NO':\n        TX_ID = choice_vote(escrow_address, escrow_key, decision_two,\n                            100, \"Tabulated using Choice Coin\")\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n            TX_ID[1] + \".\"\n    return message\n\n# This defines a corporate voting mechanism using Choice Coin.\n# It works very similarly to the electoral voting scheme defined earlier.\n# However, it does introduce the stake as a new variable.\n# The stake defines the ownership stake of the shareholder that is voting.\n\n\ndef corporate_voting(vote, stake):\n    message = ''\n    stake = int(stake)  # Define the ownership stake.\n    amount = 100 * stake\n    comment = \"Tabulated using Choice Coin\"\n    if vote == 'YES':\n        choice_vote(escrow_address, escrow_key, corporate_decision_one, amount, comment)\n        # Call the choice_vote() function that sends the appropriate number of Choice Coin based on the ownership stake.\n        message = \"Ballot Tabulated\"\n    elif vote == 'NO':\n        choice_vote(escrow_address, escrow_key, corporate_decision_two, amount, comment)\n        message = \"Ballot Tabulated\"\n    return message\n\n# Returns a dynamic bar-graph showing the results of the vote.\n# Uses PyPlot for both corporate and electoral voting.\n\n\ndef show_results(yes_count, no_count):\n    names = ['Candidate 1', 'Candidate 2']  # Define the two decisions.\n    values = [yes_count, no_count]  # Fetch the total number of votes for each decision.\n    # Define a new pyplot\n    s = io.BytesIO()\n    plt.figure(figsize=(9, 3))\n    plt.subplots()\n    plt.xlabel('Candidates')\n    plt.ylabel('Vote Count')\n    plt.bar(names, values)\n    for i, v in enumerate(values):\n        plt.text(i, v, int(v), color='black', fontweight='bold')\n    \n    plt.suptitle('Election Results')\n    plt.savefig('./static/img/plot.png', dpi=400, format='png', bbox_inches=\"tight\")\n    plt.close()\n    s = base64.b64encode(s.getvalue()).decode('utf-8').replace(\"\\n\", \"\")\n    # Return the results.\n\n\ndef show_corporate_results(yes_count, no_count):\n    names = ['Decision 1', 'Decision 2']\n    values = [yes_count, no_count]\n    plt.figure(figsize=(9, 3))\n    plt.subplots()\n    plt.xlabel('Candidates')\n    plt.ylabel('Vote Count')\n    plt.bar(names, values)\n    for i, v in enumerate(values):\n        plt.text(i, v, int(v), color='black', fontweight='bold')\n    \n    plt.suptitle('Corporate Voting Results')\n    plt.savefig('/home/archie/Inital_Demo/static/img/Figure_2.png')\n\n# Counts the total number of votes to return a statement regarding which candidate has won.\n# Applies to both corporate and electoral voting.\n\n\ndef count_votes():\n    yes_count = count(decision_one)\n    no_count = count(decision_two)\n    show_results(yes_count, no_count)\n    if yes_count > no_count:\n        if yes_count == 1:\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} vote.\".format(yes_count)\n        else:\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} votes.\".format(yes_count)\n    if no_count > yes_count:\n        if no_count == 1:\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} vote.\".format(no_count)\n        else:\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} votes.\".format(no_count)\n\n    else:\n        # Random sample generated from adiabatic quantum computer.\n        # Generated using QunatumQuery.py.\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0,\n                          1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n        # Random sample from quantum sample.\n        Q = random.choice(quantum_sample)\n        if Q:\n            return(\"Tie. The Quantum Oracle selects Candidate One!\")\n        else:\n            return(\"Tie. The Quantum Oracle selects Candidate Two!\")\n\n\ndef count_corporate_votes():\n    yes_count = count(corporate_decision_one)\n    no_count = count(corporate_decision_two)\n    show_corporate_results(yes_count, no_count)\n    if yes_count > no_count:\n        return \"The Voting Process has ended. Decision One had the most votes!\"\n    if no_count > yes_count:\n        return \"Decision Two had the most votes!\"\n    else:\n        # Random sample generated from adiabatic quantum computer.\n        # Generated using QunatumQuery.py.\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0,\n                          1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n        # Random sample from quantum sample.\n        Q = random.choice(quantum_sample)\n        if Q:\n            return(\"Tie. The Quantum Oracle selects Decision One!\")\n        else:\n            return(\"Tie. The Quantum Oracle selects Decision Two!\")\n\n# This function resets the voting accounts to start a new voting process.\n# It uses the clawback functionality built into Choice Coin to send the Choice Coin back to the main escrow account.\n\n\ndef reset_votes():\n    message = ''\n    params = algod_client.suggested_params()\n    yes_count = count(decision_one)\n    no_count = count(decision_two)\n    # Fetches the total number of Choice Coin in each account.\n    if yes_count > 0:\n        transaction_2 = AssetTransferTxn(\n            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=decision_one)\n        signature_2 = transaction_2.sign(clawback_key)\n        algod_client.send_transaction(signature_2)\n        # Defines a clawback transaction to send Choice Coin back to the escrow account if the number of Choice Coin in the account exceeds zero.\n    if no_count > 0:\n        transaction_3 = AssetTransferTxn(\n            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=decision_two)\n        signature_3 = transaction_3.sign(clawback_key)\n        algod_client.send_transaction(signature_3)\n    message = 'Vote accounts reset. New Voting Process started.'\n    return message\n\n\ndef reset_corporate_votes():\n    message = ''\n    params = algod_client.suggested_params()\n    yes_count = count(corporate_decision_one)\n    no_count = count(corporate_decision_two)\n    if yes_count > 0:\n        transaction_2 = AssetTransferTxn(\n            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=corporate_decision_one)\n        signature_2 = transaction_2.sign(clawback_key)\n        algod_client.send_transaction(signature_2)\n    if no_count > 0:\n        transaction_3 = AssetTransferTxn(\n            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=corporate_decision_two)\n        signature_3 = transaction_3.sign(clawback_key)\n        algod_client.send_transaction(signature_3)\n    message = 'Vote accounts reset. New Voting Process started.'\n    return message"}
{"instruction": "Implement an Algorand-based worker class that manages stateless and stateful smart contract deployment, user creation, subscription, unsubscription, granting, revoking, and account balance retrieval, utilizing the Algorand SDK and KMD for key management and transaction signing.", "output": "#   ver:    0.5\n#   date:   24/10/2022\n#   author: georgiana-bud\nimport os\nimport base64\nfrom typing import Tuple, Type, Optional, Union\n\n\n \n#\tWARNING:\n#\tNOTE:\tthe kmd.net and kmd.token files are in a folder\n#\t\t    named based on the release of kmd - HOWEVER - to date\n#\t\t    no easy way has been found to determine the version of kmd\n#\t\t    programmatically - find a way or pass the version\n#\t\t    as a configuration parameter\n\n\n\nimport  algosdk                                      #   better type support (not necessary)                \nfrom    algosdk                     import mnemonic                                  \nfrom    algosdk                     import account\nfrom    algosdk.v2client            import algod\nfrom    algosdk.wallet              import Wallet\nfrom    algosdk                     import kmd\nfrom    algosdk.future              import transaction\nfrom    algosdk.future.transaction  import PaymentTxn\nfrom    algosdk.future.transaction  import ApplicationNoOpTxn\nfrom    algosdk.future.transaction  import ApplicationCreateTxn\nfrom    algosdk.future.transaction  import ApplicationOptInTxn\nfrom    algosdk.future.transaction  import ApplicationCloseOutTxn\n\nfrom error import DopError \n\n#   class workerAlgorand\n#   the following methods have to be implemented\n#\n#   (x) begin_transaction\n#   (x) rollback\n#   (x) commit\n#   (x) create_user\n#   (x) deploy_contract\n#   (x) get_wallet_balance\n#   (x) subscribe\n#   (x) unsubscribe\n#   balance                 NOTE:   not in first implementation\n#   (x) get_balance         NOTE:   not fully implemented (product related balance)\n#   admin_get_grants        NOTE:   not in first implementation - to be moved to chain 2 (offchain)\n#   get_receipt             NOTE:   to be removed - to be considered a private/provider specific method\n#   set_starting_balance    \n#   (x) grant\n#   (x) revoke\n\n\nclass workerAlgorand():\n    \n    def __init__ (self):\n        pass\n\n\n    def begin_transaction(self) -> DopError:\n        return DopError(0,\"\")\n\n    def rollback(self) -> DopError:\n        return DopError(0,\"\")\n\n    def commit(self) -> DopError:\n        return DopError(0,\"\")\n\n    def __wallet_id(\n        self,\n        wallet_name: str\n        ) -> Tuple[str, DopError]:\n\n        \"\"\"\n            returns the wallet id of the wallet named wallet_name\n        \"\"\"\n        if self._i_kmd_client == None:\n            return \"\",DopError(2,\"Missing value for kmd client.\")\n\n        wallets = self._i_kmd_client.list_wallets()\n        for arrayitem in wallets:\n            if arrayitem.get(\"name\") == wallet_name:\n                walletid = arrayitem.get(\"id\")\n                return walletid,DopError(0,'')\n                break\n        return '',DopError(101,\"The wallet id for the specified wallet name could not be retrieved.\")\n\n    def __account_mnemonic(\n        self,\n        wallet_name: str,\n        wallet_password: str,\n        account_address: str\n        ) -> Tuple[str, DopError]:\n\n        if self._i_kmd_client == None:\n            return \"\",DopError(2,\"Missing value for kmd client.\")\n\n        err: DopError\n        wallet_id, err = self.__wallet_id(wallet_name)\n        if err.isError():\n            return \"\",err\n\n        wallet_handle = self._i_kmd_client.init_wallet_handle(wallet_id, wallet_password)\n        account_key = self._i_kmd_client.export_key(wallet_handle, wallet_password, account_address )\n        key_mnemonic = mnemonic.from_private_key(account_key)\n\n        #   check for error, exceptions, etc.\n        return key_mnemonic, DopError(0,\"\")\n\n\n\n\n    @staticmethod\n    def dop_stateless_create(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   teal_template_path: str                 #   the absolute path of the teal contract template\n    ,   creator_address: str                    #   the address of the creator of the smart contract\n        ) -> Tuple[str, DopError]:\n        \"\"\"\n            creates the stateless smart contract\n            if successful   -> returns the address of the stateless smart contract \n            otherwise       -> returns an empty string\n        \"\"\"\n\n        #   compile the stateless teal prog\n        #   set source code \n        #       the source code to be used for this example is DOP/dop.account/dop.account.teal.template\n        #       NOTE:   the dop.account.teal (the source code to be compiled) is generated using the file \n        #               dop.account.teal.template by replacing the macro \"_RECEIVERADDRESS_\" with the \"creator_address\"\n        #               see DOP/dop.account/00_create.sh - that contains the following cmd\n        #               sed \"s/_RECEIVERADDRESS_/$CREATOR/g\" dop.account.teal.template > dop.account.teal\n\n\n        #   read the template\n        teal_template: str = \"\"\n        try:\n            with open(teal_template_path, 'r', encoding='utf-8') as f:\n                teal_template = f.read()\n        except Exception:\n            return \"\",DopError(3,\"Teal template file not found.\")\n\n        #   now the _RECEIVERADDRESS_ nacro has to be substituted with creator_address\n        teal_source = teal_template.replace('_RECEIVERADDRESS_', creator_address)\n\n        \n        try:\n            compile_response = client.compile(teal_source)\n            #   return base64.b64decode(compile_response['result'])\n            #   compile_response example\n            #   {\n            #       'hash': 'LILX6GOG4N6LAOTFT4WW5VTXK5AN4KA5TAN5CYAE7LX5GPC2XXU6NNHDTA', \n            #       'result': 'AyAHAgEABmTIAaCNBiYBIOKaz1eO1YI9t+Lp5CmWTNrK6kvjiZCylN6neTTnB6YYMgQiD0AAKTIEIxJAAAIkQzMAECMSQAAKMwAQJRJAAA0kQzMABygTQAAlIQRDIQVDMwAQIxNAABczARAlE0AADzMBGCQSQAAHMwAIIQYPQyRD'\n            #   }\n            #   where   'result'    holds the compiled code\n            #           'hash'      is the address of the smart contract\n        except Exception:\n            return \"\",DopError(4,\"Error compiling teal source.\")\n\n        smart_contract_address = compile_response['hash']\n\n        #   TODO:   \n        #           check if the stateless smart contract needs to be immediately funded\n        return smart_contract_address,DopError(0,\"\")\n\n    @staticmethod\n    def dop_stateful_create(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   teal_clear_program_path: str\n    ,   teal_approval_program_path: str\n    ,   creator_address: str\n    ,   creator_private_key: str\n    ,   smart_contract_address: str                     #   address of the stateless smart contract\n        ) -> Tuple[str, DopError]:\n        \"\"\"\n            creates the stateful smart contract\n            if successful   -> returns the txn_id of the stateful smart contract creation transaction\n            otherwise       -> returns an empty string\n        \"\"\"\n\n        #ApplicationCreateTxn\n\n        #   get and compile the clear program\n        teal_clear_source: str = \"\"\n        try:\n            with open(teal_clear_program_path, 'r', encoding='utf-8') as f:\n                teal_clear_source = f.read()\n        except Exception:\n            return \"\",DopError(5,\"Teal clear file not found.\")\n\n        compile_response = client.compile(teal_clear_source)            \n        clear_program = base64.b64decode(compile_response['result'])\n\n\n        # declare on_complete as NoOp\n        on_complete = transaction.OnComplete.NoOpOC.real\n\n        #   get and compile the approval program\n        teal_approval_source: str = \"\"\n        try:\n            with open(teal_approval_program_path, 'r', encoding='utf-8') as f:\n                teal_approval_source = f.read()\n        except Exception:\n            return \"\",DopError(6,\"Teal approval file not found.\")\n\n        compile_response = client.compile(teal_approval_source) \n        approval_program = base64.b64decode(compile_response['result'])           \n\n        params = client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n\n        #compile_result = base64.b64decode(compile_response['result'])\n        \n        smart_contract_arguments = {\n            \"args\":     [smart_contract_address]    #   list of app arguments (goal app create --app-arg)\n#       ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n        }\n\n        app_args: list   = workerAlgorand.getArgs(smart_contract_arguments)\n\n        # declare application state storage (immutable)\n        local_ints      = 5\n        local_bytes     = 5\n        global_ints     = 5\n        global_bytes    = 5\n\n        # define schema (<class 'algosdk.future.transaction.StateSchema'>)\n        global_schema   = transaction.StateSchema(global_ints, global_bytes)\n        local_schema    = transaction.StateSchema(local_ints, local_bytes)\n\n        unsigned_txn = ApplicationCreateTxn(creator_address, params, on_complete, approval_program, clear_program, global_schema, local_schema, app_args)\n        # sign transaction\n        signed_txn = unsigned_txn.sign(creator_private_key)\n        txn_id = signed_txn.transaction.get_txid()\n\n        #   send transaction\n        try: \n            client.send_transactions([signed_txn])    \n        except Exception as err:\n            return txn_id, DopError(120, f\"An error occurred while creating stateful \\\n                smart contract.\")\n        return (txn_id,DopError(0,\"\"))\n\n    @staticmethod\n    def mnemonic_to_private_key(mnemonic_key: str) -> Tuple[str, DopError]:\n        \"\"\"\n        convert a menmonic key into a \"single string\" private key\n        \"\"\"\n        private_key: str = \"\"\n        try:\n            private_key = mnemonic.to_private_key(mnemonic_key)\n        except Exception:\n            return \"\",DopError(10,\"Mnemonic could not be converted to private key.\")\n\n        return private_key,DopError(0,\"\")\n\n\n    \n    #   private method\n    def __algorand_smart_contract_create(\n        self\n    ,   client: algosdk.v2client.algod.AlgodClient\n    ,   creator_mnemonic: str\n        ) -> Tuple[str, str, DopError]:\n        \n        \"\"\"\n            the DOP smart contract is a linked smart contract\n            (there is a stateless part, to represent the smart contract account\n            and a stateful part, holding the DOP logic)\n            RETURNS:    \n                    address of the stateless smart contract\n                    app index of the stateful smart contract\n                    DopError\n\n            see https://developer.algorand.org/docs/get-details/dapps/smart-contracts/frontend/apps/?from_query=call%20smart%20contract%20from%20javascript#call-noop\n            see https://github.com/algorand/py-algorand-sdk/blob/5b496e0928af1dcae4e393693421f590a6111907/algosdk/future/transaction.py\n            see https://developer.algorand.org/docs/rest-apis/algod/v2/\n        \"\"\"\n\n        err: DopError\n        creator_private_key: str\n\n        creator_private_key, err = self.mnemonic_to_private_key(creator_mnemonic)\n        if err.isError():\n            return (\"\",0,err)\n        creator_address       = account.address_from_private_key(creator_private_key)         #   this line to be deleted\n\n        smart_contract_address, err = self.dop_stateless_create(client, self._i_stateless_teal_template_path, creator_address)\n        if err.isError():\n            return (\"\",0,err)\n\n        txn_id, err = self.dop_stateful_create(client, self._i_teal_clear_program_path, self._i_teal_approval_program_path, creator_address, creator_private_key, smart_contract_address)\n\n        if err.isError():\n            return \"\",0,err\n\n        # await confirmation\n        confirmed_txn = self.wait_for_confirmation(client, txn_id, 4)  \n\n\n        #   confirmed_txn holds:\n        #   {\n        #       'application-index': 392, \n        #       'confirmed-round': 66118, \n        #       'global-state-delta': [\n        #                               {'key': 'a2V5', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, \n        #                               {'key': 'a2lk', 'value': {'action': 1, 'bytes': 'MHgwMA=='}}, \n        #                               {'key': 'bGlua2Vk', 'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}}, \n        #                               {'key': 'Y3JlYXRvcg==', 'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}}\n        #                               ], \n        #       'pool-error': '', \n        #       'sender-rewards': 16230, \n        #       'txn': {'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', \n        #               'txn': {'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], \n        #                       'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', \n        #                       'apgs': {'nbs': 5, 'nui': 5}, \n        #                       'apls': {'nbs': 5, 'nui': 5}, \n        #                       'apsu': 'AyABASI=', \n        #                       'fee': 1000, \n        #                       'fv': 66017, \n        #                       'gen': 'private-v1', \n        #                       'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', \n        #                       'lv': 67017, \n        #                       'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', \n        #                       'type': 'appl'}\n        #               }\n        #       }\n\n\n        # display results\n        transaction_response = client.pending_transaction_info(txn_id)\n\n        #   transaction_response\n        #   {\n        #       'application-index': 392, \n        #       'confirmed-round': 66118, \n        #       'global-state-delta': [\n        #                               {\n        #                                   'key': 'Y3JlYXRvcg==', \n        #                                   'value': {'action': 1, 'bytes': 'tpw3hll7wAFNFzreNA5uPoRnNAnJ28KBEYxhgtJW4to='}\n        #                               }, \n        #                               {\n        #                                   'key': 'a2V5', \n        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}\n        #                               }, \n        #                               {\n        #                                   'key': 'a2lk', \n        #                                   'value': {'action': 1, 'bytes': 'MHgwMA=='}\n        #                               }, \n        #                               {\n        #                                   'key': 'bGlua2Vk', \n        #                                   'value': {'action': 1, 'bytes': 'RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='}\n        #                               }\n        #                               ], \n        #       'pool-error': '', \n        #       'sender-rewards': 16230, \n        #       'txn': {\n        #                   'sig': 'NiAHaHCPSs/APuWMBvpmfiG1iYDod0RzeRZd2YzFSCQ+mfwVGgH5MEE1oxJ4f7VVOIoSpaEZTRu1uKlXOnadAQ==', \n        #                   'txn': {\n        #                               'apaa': ['RjZWVkZNTEY1RVM0S1VZTUg3TFlGVlZLRUFUQlJMQjdHRllSMk1IQkRCWEpOM1pHUURZUUVNUEE3UQ=='], \n        #                               'apap': 'BSAGAAECBucJZCYMA2tpZANrZXkFZ3JhbnQGZXJyPTA7DHN1YnNjcmlwdGlvbgE7B2NyZWF0b3IGZ2V0a2V5CGVycj0yNTU7BGtleT0GbGlua2VkBDB4MDAxGCISQAGSMRkjEkABpDEZJBJAAaAxGYEFEkABkjIEIxJAAAkyBCQSQAFQIkMxECUTQAGEJwZkMQASQAChNhoAgAlzdWJzY3JpYmUSQAAjNhoAgAt1bnN1YnNjcmliZRJAABw2GgAnBxJAABwnCLAhBEMiJwQjZiIqImaB6AdDIicEImaB8gdDIicEYiMTQAApIipiIxNAAC02GgEoZBNAADAiKChkZiIpKWRmK7AnCSlkUCcFULAhBUOABmVycj0xO7CBZUOABmVycj0yO7CBZkOABmVycj0zO7CBZ0M2GgAqEkAAbTYaAIAGcmV2b2tlEkAAaDYaAIAGY2hhcmdlEkAAYzYaAIAGc2V0a2V5EkAAWDYaACcHEkAABicIsCEEQzYaAShkE0AAGyuwJwkpZFAnBVCwgARraWQ9KGRQJwVQsCEFQ4AHZXJyPTEwO7CBbkMjKiNmK7CB0A9DIyoiZiuwgdoPQ4HkD0MpNhoBZyg2GgJnK7CB7g9DMwAQIxNAADUzARAlE0AALTMABycKZBNAACOB9ANDJwYxAGcnCjYaAGcpJwtnKCcLZ4EKQ4EUQ4EeQ4EoQyJD', \n        #                               'apgs': {'nbs': 5, 'nui': 5}, \n        #                               'apls': {'nbs': 5, 'nui': 5}, \n        #                               'apsu': 'AyABASI=', \n        #                               'fee': 1000, \n        #                               'fv': 66017, \n        #                               'gen': 'private-v1', \n        #                               'gh': '85lTOmM+7boPryKD0hCIWMkcoKAZZaFZ+Gi9YSitq0g=', \n        #                               'lv': 67017, \n        #                               'snd': 'W2ODPBSZPPAACTIXHLPDIDTOH2CGONAJZHN4FAIRRRQYFUSW4LNODF4EVY', \n        #                               'type': 'appl'\n        #                           }\n        #               }\n        #       }\n\n        app_id = transaction_response['application-index']\n        return (smart_contract_address, str(app_id), DopError(0,\"\"))\n\n\n    #   private method\n    def __account_send(self, from_mnemonic, to_address, amount) -> Tuple[str,DopError]:\n\n        \"\"\"\n        Sends tokens from one account to another\n        \"\"\"\n        if self._i_algod_client == None:\n            return \"\",DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTIN\".encode()\n\n        err: DopError\n\n        from_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return \"\",err\n        from_address = account.address_from_private_key(from_private_key)\n\n        \n        params = self._i_algod_client.suggested_params()\n        # comment out the next two (2) lines to use suggested fees\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP funds\".encode()\n\n        #   create an unsigned transaction\n        unsigned_txn = PaymentTxn(from_address, params, to_address, amount, None, txn_note)\n\n        #   sign the transaction using the private key of the sender (from_address)\n        signed_txn = unsigned_txn.sign(from_private_key)\n\n        #submit transaction\n        txid = self._i_algod_client.send_transaction(signed_txn)\n        print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        # wait for confirmation \n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n        except Exception as err:\n            print(err)\n            return \"\", DopError(301,'An exception occurred while waiting \\\n                for the confirmation of the send transaction.')\n        \n        return txid, DopError(0,)\n    \n    @staticmethod\n    def wait_for_confirmation(\n        client: algosdk.v2client.algod.AlgodClient\n    ,   transaction_id: str\n    ,   timeout: int\n    ):\n        \"\"\"\n        Wait until the transaction is confirmed or rejected, or until 'timeout'\n        number of rounds have passed.\n        Args:\n            transaction_id (str): the transaction to wait for\n            timeout (int): maximum number of rounds to wait    \n        Returns:\n            dict: pending transaction information, or throws an error if the transaction\n                is not confirmed or rejected in the next timeout rounds\n        \"\"\"\n        start_round = client.status()[\"last-round\"] + 1\n        current_round = start_round\n\n        while current_round < start_round + timeout:\n            try:\n                pending_txn = client.pending_transaction_info(transaction_id)\n            except Exception:\n                return \n            if pending_txn.get(\"confirmed-round\", 0) > 0:\n                return pending_txn\n            elif pending_txn[\"pool-error\"]:  \n                raise Exception(\n                    'pool error: {}'.format(pending_txn[\"pool-error\"]))\n            client.status_after_block(current_round)                   \n            current_round += 1\n        raise Exception(\n            'pending tx not found in timeout rounds, timeout value = : {}'.format(timeout))\n\n    @staticmethod\n    def Token(token: str, path: str) -> Tuple[DopError, str]:\n        ntoken: str = token\n        if ntoken == '':\n            try:\n                with open(path, 'r') as f:\n                    ntoken = f.readline()\n            except Exception as e:\n                #print(str(e))\n                return (DopError(20,\"An exception occurred while reading token file.\"),ntoken)\n\n            l: list = ntoken.split('\\n')\n            ntoken = l[0]\n        return (DopError(), ntoken)\n\n    @staticmethod \n    def Port(port: str, path: str) -> Tuple[DopError, str]:\n        nport: str = port\n        host: str = ''\n        if nport == '':\n            try:\n                with open(path, 'r') as f:\n                    host = f.readline()\n            except:\n                return (DopError(21,\"An exception occurred while reading port file.\"),nport)\n\n        l: list = host.split('\\n')\n        host = l[0]\n        l = host.split(':')\n        if len(l) > 1:\n            nport = l[1]\n\n        return (DopError(), nport)\n        \n    def algodToken(self) -> Tuple[DopError, str]:\n        \"\"\"\n        returns the token of necessary to connect to the algod node\n        NOTE:   the token is retrieved by reading and parsing the file \"$ALGORAND_DATA/algod.token\"\n                so this function requires the macro ALGORAND_DATA to be defined and available\n                to the process calling this method\n        \"\"\"\n\n        token: str\n        if 'atoken' in self._i_config:\n            #   atoken passed in connstring - ignore file containing token\n            token = self._i_config['atoken']\n            self._i_algo_token = token\n            return DopError(),token\n\n        err, token = self.Token(self._i_algo_token, self._i_algo_token_file)\n        if err.code == 0:\n            self._i_algo_token = token\n\n        return (err,token)\n\n    def algodPort(self) -> Tuple[DopError, str]:\n        \"\"\"\n        returns the TCP port the algod node is listening to\n        NOTE:   the port is retrieved by reading and parsing the file \"$ALGORAND_DATA/algod.net\"\n                so this function requires the macro ALGORAND_DATA to be defined and available\n                to the process calling this method\n        \"\"\"\n        port: int\n        if 'anetprt' in self._i_config:\n            #   anetprt passed in connstring - ignore file containing port\n            port = int(self._i_config['anetprt'])\n            self._i_algo_port = port\n            return DopError(),port\n\n        err, port = self.Port(self._i_algo_port, self._i_algo_net_file)\n        if err.code == 0:\n            self._i_algo_port = port\n        return (err, port)\n\n    def kmdToken(self) -> Tuple[DopError, str]:\n        token: str\n        if 'ktoken' in self._i_config:\n            #   atoken passed in connstring - ignore file containing token\n            token = self._i_config['ktoken']\n            self._i_kmd_token = token\n            return DopError(),token\n\n        err, token = self.Token(self._i_kmd_token, self._i_kmd_token_file)\n        if err.code == 0:\n            self._i_kmd_token = token\n        return (err, token)\n\n    def kmdPort(self) -> Tuple[DopError, str]:\n        port: int\n        if 'knetprt' in self._i_config:\n            #   anetprt passed in connstring - ignore file containing port\n            port = int(self._i_config['knetprt'])\n            self._i_kmd_port = port\n            return DopError(),port\n\n        err, port = self.Port(self._i_kmd_port, self._i_kmd_net_file)\n        if err.code == 0:\n            self._i_kmd_port = port\n        return (err, port)\n\n    def kmd(self) -> Tuple[DopError, algosdk.kmd.KMDClient]:\n        err, kmd_token = self.kmdToken()\n        if err.code != 0:\n            return (err,None)\n        err, kmd_port = self.kmdPort()\n        if err.code != 0:\n            return (err,None)\n\n        kmd_ip_address: str = 'http://localhost:' \n        if 'knetip' in self._i_config:\n            kmd_ip_address = 'http://' + self._i_config['knetip'] + ':'\n        kmd_address = kmd_ip_address + str(kmd_port)\n\n        kcl = kmd.KMDClient(kmd_token, kmd_address)\n\n        try:\n            #   NOTE:           it seems that the kmd can be instantiated only if using localhost\n            #                   to be checked with algorand\n            kcl.versions()  #   generates an exception if the kcl is not connected\n        except Exception:\n            return(DopError(22, \"An exception occurred while initializing kmd client.\"),kcl)\n\n        return(DopError(),kcl)\n    \n    def algod(self) -> Tuple[DopError, algosdk.v2client.algod.AlgodClient]:\n        #   get algod token\n        err, algod_token = self.algodToken()\n        if err.code != 0:\n            return (err,None)\n        #   get algod port\n        err, algod_port = self.algodPort()\n        if err.code != 0:\n            return (err,None)\n        #   get algo node address (default is localhost)\n\n        algod_ip_address: str = 'http://localhost:' \n        if 'anetip' in self._i_config:\n            algod_ip_address = 'http://' + self._i_config['anetip'] + ':'\n        #algod_address = 'http://localhost:' + str(algod_port)\n        algod_address = algod_ip_address + str(algod_port)\n        algocl = algod.AlgodClient(algod_token, algod_address)\n\n        #   check if the algod client is valid\n        try:\n            algocl.status()\n        except Exception:\n            return(DopError(23, \"Error in initializing algod client.\"),algocl)\n\n        return(DopError(),algocl)\n\n    @staticmethod\n    def getArgs(argsobj: dict) -> list:\n        args = argsobj.get(\"args\")\n\n        if args==None:\n            return None\n\n        if len(args) < 1:\n            return None\n\n        b_args: list = []\n        for item in args:\n            b_args.append(bytes(item,'utf-8'))\n        return b_args\n\n    @staticmethod\n    def getAccounts(argsobj: dict) -> list:\n        args = argsobj.get(\"addrs\")\n\n        if args==None:\n            return None\n\n        if len(args) < 1:\n            return None\n\n        return args\n\n    def dopSmartContract(\n        self\n    ,   algod_client: algosdk.v2client.algod.AlgodClient\n    ,   appid:  int                     #   smart contract index (address)\n    ,   owner_mnemonic: str             #   private key (mnemonic) of the owner of the smart contract\n    ,   scarguments: dict               #   {\"args\":[argslist], \"addrs\":[accountaddresseslist]}\n    ,   transaction_note: str           #   the note field withon the transaction\n    ) -> Tuple[str, DopError]:               #   error code, transaction id\n\n        #   retrieve and change suggested params (for the transaction)        \n        #   this could become an argument, to be investigated (future releases)\n        params = algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n\n        txn_note = transaction_note.encode()\n\n        err: DopError\n        owner_private_key: str\n        owner_private_key,err   = self.mnemonic_to_private_key(owner_mnemonic)\n        if err.isError():\n            return \"\",err\n\n        owner_address       = account.address_from_private_key(owner_private_key)         #   this line to be deleted\n\n        arguments_list   = self.getArgs(scarguments)\n        accounts_list    = self.getAccounts(scarguments)\n\n        unsigned_txn = ApplicationNoOpTxn(owner_address, params, appid, arguments_list, accounts_list, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(owner_private_key)\n\n        txid = ''\n        try:\n            txid = algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #print(err)\n            return \"\", DopError(202,f\"An exception occurred when sending transaction.\")\n\n        return(txid, DopError(0,\"\"))      #   now the transaction can be waited for\n\n    def __default(self):\n        #   set default parameters\n        self._i_algo_token      = ''\n        self._i_algo_port       = ''\n        self._i_algod_client    = None\n\n        self._i_kmd_token       = ''\n        self._i_kmd_port        = ''\n        self._i_kmd_client      = None\n\n        self._i_config: dict   = {}\n        \n        algorand_data_path: str = '/home/ecosteer/dop/externals/algorand/net1/Primary'\n        if 'ALGORAND_DATA' in os.environ:\n            algorand_data_path = os.environ['ALGORAND_DATA']\n\n        self._i_algo_token_file     = algorand_data_path + '/algod.token'           #   this has to go\n        self._i_config['atokf']     = algorand_data_path + '/algod.token'\n\n        self._i_algo_net_file       = algorand_data_path + '/algod.net'             #   this has to go\n        self._i_config['anetf']     = algorand_data_path + '/algod.net'\n\n        self._i_kmd_token_file      = algorand_data_path + '/kmd-v0.5/kmd.token'    #   this has to go\n        self._i_config['ktokf']     = algorand_data_path + '/kmd-v0.5/kmd.token'\n\n        self._i_kmd_net_file        = algorand_data_path + '/kmd-v0.5/kmd.net'      #   this has to go\n        self._i_config['knetf']     = algorand_data_path + '/kmd-v0.5/kmd.net'\n        \n\n        dop_smart_contract_root_path: str = '/home/ecosteer/dop/intermediation/algorand/DOP'\n        self._i_config['scrf'] = dop_smart_contract_root_path\n\n        user_wallet: str            = \"unencrypted-default-wallet\"                  # wallet where the users are created\n        user_wallet_password: str   = \"\"                                            # password to access the wallet\n        self._i_config['usrwlab']   = user_wallet\n        self._i_config['usrwpwd']   = user_wallet_password\n\n\n        if 'DOP_SMART_CONTRACT_ROOT_FOLDER' in os.environ:\n            dop_smart_contract_root_path = os.environ['DOP_SMART_CONTRACT_ROOT_FOLDER']\n            \n        self._i_stateless_teal_template_path    = dop_smart_contract_root_path + '/dop.account/dop.account.teal.template'\n        self._i_config['sttp'] = 'dop.account/dop.account.teal.template'\n        self._i_teal_approval_program_path      = dop_smart_contract_root_path + '/dop.stateful/dop.stateful.teal'\n        self._i_config['tapp'] = 'dop.stateful/dop.stateful.teal'\n        self._i_teal_clear_program_path         = dop_smart_contract_root_path + '/dop.clear/basicClear.teal'\n        self._i_config['tcpp'] = 'dop.clear/basicClear.teal'\n\n        self._i_config['ownmne'] = ''\n\n\n    #============================================================================\n    #   abstract methods\n    #============================================================================\n    #   NOTE:   init must become an abstract method\n    def init(self, constring: str) -> DopError:\n\n        self.__default()\n                \n        #   convert connstring into a dict (see config_to_dict in shared.utils.py)\n        temp_config: dict = {}\n\n        temp_list: list = constring.split(';')\n        for el in temp_list:\n            ell = el.split('=')\n            if len(ell) != 2:\n                continue\n            temp_config[ell[0]]=ell[1]\n\n        pars: list = [\n            'atokf',\n            'anetf',\n            'ktokf',\n            'knetf',\n            'atoken',\n            'anetprt',\n            'anetip',\n            'ktoken',\n            'knetprt',\n            'knetip',\n            'scrf',\n            'sttp',\n            'tapp',\n            'tcpp',\n            'usrwlab',\n            'usrwpwd',\n            'ownmne'\n            ]\n\n        for p in pars:\n            if p in temp_config:\n                self._i_config[p] = temp_config[p]\n\n\n        \n        #   connection string parameters\n        #   label   type        logic\n        #   ------+---------+------------------------------------------------------------------------------------------------\n        #   atokf   string      absolute path of the algod.token file\n        #   anetf   string      absolute path of the algod.net file     \n        #   ktokf   string      absolute path of the kmd.token file\n        #   knetf   string      absolute path of the kmd.net file\n        #   atoken  string      algod token (if this is defined then atokf will not be used)\n        #   anetprt int         algod tcp ip port (if this is defined then the anetf will not be used - anetip required)\n        #   anetip  string      algod tcp ip address (if this is defined then the anetf will not be used - anetprt required)\n        #   ktoken  string      kmd token (if this is defined then atokf will not be used)\n        #   knetprt int         kmd tcp ip port (if this is defined then the knetf will not be used - knetip required)\n        #   knetip  string      kmd tcp ip address (if this is defined then the knetf will not be used - knetprt required)\n        #   scrf    string      smart contract root folder      : absolute path of the folder containing sttp, atpt and tcpp\n        #   sttp    string      stateless teal template path    : relative path of the stateless teal template\n        #   tapp    string      teal approval program path      : relative path of the teal approval program\n        #   tcpp    string      teal clear program path         : relative path of the teal clear program\n        #\tusrwlab\tstring\t\tuser wallet (the wallet used by the worker to create accounts)\n\t\t#\tusrwpwd\tstring\t\tuser wallet password\n\n        #   ownmne  string      mnemonic of the owner account to be used to fund newly created accounts\n\n        #   example 1 (can be used only if the kmd and algod are running on localhost)\n        #   atokf=/home/ecosteer/algorand/net1/Primary/algod.token;anetf=/home/ecosteer/algorand/net1/Primary/algod.net;\\\n        #   ktokf=/home/ecosteer/algorand/net1/Primary/kmd.token;knetf=/home/ecosteer/algorand/net1/Primary/kmd.net;\\\n        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\\\n        #   sttp=dop.account/dop.account.teal.template;\\\n        #   tapp=dop.stateful/dop.stateful.teal;\\\n        #   tcpp=dop.clear/basicClear.teal;\n\n        #   example 2 (to be used if the kmd and algod are running on a remote host)\n        #   atoken=45d2689bb4b555b757b00972d82c0a872f7b2aa136a5351768280dbe7cf2e9b2;\\\n        #   anetprt=18445;\\\n        #   anetip=192.178.20.30;\\\n        #   ktoken=d278689bb4b555b7502030465782c0a872f7b2aa136a5351768280dbe7cf2ab90;\\\n        #   knetprt=18435;\\\n        #   knetip=192.178.20.30;\\\n        #   scrf=/home/ecosteer/algorand/smartcontracts/DOP;\\\n        #   sttp=dop.account/dop.account.teal.template;\\\n        #   tapp=dop.stateful/dop.stateful.teal;\\\n        #   tcpp=dop.clear/basicClear.teal;\n\n        #   test only\n        for el in self._i_config:\n            print(el + ':[' + self._i_config[el] + ']')\n        \n        return DopError(0, \"\")\n\n    def open(self) -> DopError:\n        \"\"\"\n            open the algod client and the kmd client\n            the following properties are valorized:\n            1)  _i_algod_token\n            2)  _i_algod_port\n            3)  _i_kmd_token\n            4)  _i_kmd_port\n        \"\"\"\n\n\n        #   self.algod\n        #   sets self._i_algod_token and self._i_algod_port\n        err, self._i_algod_client = self.algod()\n        if err.isError():\n            return err\n\n        err, self._i_kmd_client = self.kmd()\n        if err.isError():\n            return err\n\n        if 'ownmne' in self._i_config: \n            self._own_mnemonic = self._i_config['ownmne']\n        else:\n            self._own_mnemonic = None\n            return DopError(201, \"Owner mnemonic not provided.\")\n\n        return err\n\n    def close(self) -> DopError:\n        #   TODO:   check if algod and kmd client have to be \"closed\" \n        return DopError(0,\"\")\n\n\n    def get_balance(self,\n                    publisher_address: str,                         #   EoA address of the publisher (contract owner)\n                    subscriber_address: str,                        #   EoA address of the subscriber we want to check the balance \n                    contract_address: str) -> Tuple[dict, DopError]:   #   address (blockchain layer) of the contract) -> Tuple[dict, DopError]:\n        \"\"\"\n        in this version this method is not \"really\" implemented\n        \"\"\"\n        response = {}\n        response['subscribed'] = 1\n        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use DB\n        response['credit'] = 100\n        response['debit'] = 0\n\n        return response, DopError(0,\"\")\n\n    def create_user(self, username: str, password: str) -> Tuple[str, str, DopError]: \n        \"\"\"\n            creates a blockchain account and returns the address (public key) of the account and the password\n            of the account (ethereum: input password, algorand, generated private key)\n\n        \"\"\"\n        user_address = \"\"\n        wallet_id: str\n        err: DopError\n\n        wallet_name = self._i_config['usrwlab']\n        wallet_password = self._i_config['usrwpwd']\n\n        wallet_id, err = self.__wallet_id(wallet_name)\n        if err.isError():\n            return \"\",\"\",err\n\n        \n        try:\n            wallet = Wallet(wallet_name, wallet_password, self._i_kmd_client)\n            #   create the account\n            account_address     = wallet.generate_key()\n            account_mnemonic, err    = self.__account_mnemonic(wallet_name,wallet_password,account_address)\n            if err.isError():\n                return \"\",\"\",err\n            #   return err=0,account_address\n            return account_address, account_mnemonic,DopError(0,\"\")\n\n        except Exception as err:\n            #   likely the password is wrong\n            print(err)      #   logging etc.\n            return \"\",\"\",DopError(203,\"An exception occurred while creating user.\")\n\n        return \"\",\"\",DopError(1000,\"\")             # never hit\n\n\n        return (user_address,user_mnemonic,DopError(0,\"\"))\n    \n\n\n    def get_wallet_balance(self, account_address: str, currency=\"algo\") -> Tuple[str, DopError]:\n        \"\"\"\n            TODO:       return account_balance, DopError (as usual)\n            TODO:       the method name should be change into \"get_account_balance\" to disambiguate between account and wallet\n            NOTE:       the abstract was defined with a str return value\n        \"\"\"\n        if self._i_algod_client == None:\n            return \"\", DopError(1,\"Missing value for algod client.\")\n\n        try:\n            #   address is the account address - for instance: \"4KNM6V4O2WBD3N7C5HSCTFSM3LFOUS7DRGILFFG6U54TJZYHUYMDPN26KY\"\n            from_account_info = self._i_algod_client.account_info(account_address)\n            #   the account balance is in micro algos\n            account_balance = from_account_info.get('amount')\n            #print(\"Origin Account balance     : [{} microAlgos]\".format(from_account_info.get('amount')))\n            return account_balance, DopError(0,\"\")\n        except Exception:\n            return \"\",DopError(204,\"An exception occurred while getting wallet balance.\")\n\n        \n    def deploy_contract(self,\n                        publisher_address: str,                 #   address of the owner account\n                        secret: str,                            #   secret for the owner account (algorand: private key mnemonic of the owner)\n                        tariff_period: int,                     #   period of the tariff \n                        tariff_price: int                       #   price of a period\n                        ) -> Tuple[Optional[str], DopError]:\n        \"\"\"\n            NOTE:\n                The abstract method returns a transaction hash that is inserted into the \n                rdbms (transactions schema) - as this is typically a pending operation finalized by an event emitted by the monitor.\n                For Algorand: this might require a complete different logic of the processor \"product_create.py\" - possibly a \n                processor specific for Algorand will have to be implemented.\n                See also monitor_des.py - it processes the event (DEPLOY_CONTRACT) that is\n                meant to close the pending op\n\n                NOTE:   EnableDeveloperAPI must be set to true (node configuration file)\n                NOTE:   https://developer.algorand.org/docs/run-a-node/reference/config/\n\n                TODO:   review static and private method dop_stateful/dop_stateless/__algorand_smart_contract_create\n        \"\"\"\n\n        #   publisher_address:      not used\n        #   tariff_period:          not used (for future release)\n        #   tariff_price:           not used (for future release)\n        #   secret: is the mnemonic of the publisher\n        \n        smart_contract_address: str     #   the address of the stateless smart contract (the smart contract linked to the stateful smart contract)\n                                        #   as the previously defined abstract method allows tp return just two values\n                                        #   we will not return the smart contract address for the moment - to be checked\n                                        #   in this release the smart_comtract_address will be encoded using the following string:\n                                        #   %smart_contract_adress%@%app_id\n\n        app_id: str                     #   the application id (this id will have to be used for invoking the smart contract)\n        err: DopError\n\n        if self._i_algod_client == None:\n            #   must open before\n            return (\"\",DopError(1,\"Missing value for algod client.\"))\n\n        smart_contract_address, app_id, err = self.__algorand_smart_contract_create(self._i_algod_client, secret) \n        if err.isError():\n            return \"\", err\n        #   TODO check if stateless contract has to be funded\n        encoded_smart_contract_address: str = smart_contract_address + '@' + str(app_id)\n        return (encoded_smart_contract_address, err)\n\n    def algorand_sub_optin(     #   ALGORAND SPECIFIC\n        self,\n        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in\n        application_address: str    #   application index of the smart contract the account wants to opt into\n        ) -> DopError:\n        \"\"\"\n        Algorand specific (an account has to optin before subscribing to a smart contract)\n        this methid can be called by a specific Algorand processor provider (not an abstract method),\n        for instance by the processor provider that implement the subscription logic\n        SO: it has not be implemented as a private method - but an Algorand specific method.\n\n        NOTE:   the subscriber, before subscribing the contract X, MUST opt-in to the contract X\n        \"\"\"\n        #   see 01_sub_optin.py\n        \n        if self._i_algod_client == None:\n            return DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTIN\".encode()\n\n        err: DopError\n\n        #subscriber_private_key = mnemonic.to_private_key(from_mnemonic)\n        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return err\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        appid = int(application_address)\n        unsigned_txn = ApplicationOptInTxn(subscriber_address, params, appid, None, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid =''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(205,\"An exception occurred when sending optin transaction.\")\n\n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n            #   TODO: confirmed_txn can be used to provide detailed log, see next\n            #   commented lines\n            #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(302,\"An exception occurred while waiting for confirmation of optin transaction.\")\n\n        return DopError(0,\"\")\n\n\n    def algorand_sub_optout(     #   ALGORAND SPECIFIC\n        self,\n        from_mnemonic: str,         #   mnemonic (secret) of the account that is opting in\n        application_address: str    #   application index of the smart contract the account wants to opt into\n        ) -> DopError:\n        \"\"\"\n        Algorand specific (symmetric to algorand_sub_optin)\n        NOTE:   a subscriber that has unsubscribed should call optout, too\n        \"\"\"\n        \n        if self._i_algod_client == None:\n            return DopError(1,\"Missing value for algod client.\")\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP OPTOUT\".encode()\n\n        err: DopError\n        subscriber_private_key: str\n\n        subscriber_private_key, err = self.mnemonic_to_private_key(from_mnemonic)\n        if err.isError():\n            return err\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        appid = int(application_address)\n        unsigned_txn = ApplicationCloseOutTxn(subscriber_address, params, appid, None, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid =''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #   print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(206,\"An exception occurred when sending optout transaction.\")\n\n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n            #   TODO: confirmed_txn can be used to provide detailed log, see next\n            #   commented lines\n            #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #   print(err)\n            return DopError(303,\"An exception occurred while waiting for \\\n                        confirmation of optout transaction.\")\n\n        return DopError(0,\"\")\n\n\n    def subscribe(self,\n                  subscriber_addr: str,             #   subscriber address\n                  subscriber_psw: str,              #   private key mnemonic\n                  contract_address: str,            #   algorand application index\n                  secret: str                       #   not used in this release\n                  ) -> Tuple[str, DopError]:  \n        \"\"\"\n        Subscribe to a contract\n        \"\"\"\n\n        if self._i_algod_client == None:\n            return \"\",DopError(1,\"\")        #   must be connected to a node\n\n        params = self._i_algod_client.suggested_params()\n        params.flat_fee = True\n        params.fee = 1000\n        txn_note = \"DOP SUBSCRIBE\".encode()\n\n    #   the transaction type that has to be sent is of type ApplicationNoOpTxn\n    #   see https://github.com/algorand/py-algorand-sdk/blob/5ca32cea62168ae339ccfdfbefaa6bc6ac094052/algosdk/future/transaction.py#L2040\n    #   line 2040\n        \n        err: DopError\n        subscriber_private_key: str\n\n        subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)\n        if err.isError():\n            return \"\",err\n\n        subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n        app_args : list = []\n        app_args.append(bytes('subscribe','utf-8'))\n        unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, contract_address, app_args, None, None, None, txn_note)\n        signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n        txid = ''\n        try:\n            txid = self._i_algod_client.send_transaction(signed_txn)\n            #print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n        except Exception as err:\n            #print(err)\n            return \"\", DopError(207,\"An exception occurred when sending subscribe transaction.\")\n\n        # wait for confirmation \n        try:\n            confirmed_txn = self.wait_for_confirmation(self._i_algod_client,txid,4)\n\n            #print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n            #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n        except Exception as err:\n            #print(err)\n            return \"\",DopError(304,\"An exception occurred while waiting for confirmation \\\n                    of subscribe transaction.\")\n\n        return txid,DopError(0,\"\")\n\n\n    def unsubscribe(self, \n                    subscriber_addr: str,               #   not used\n                    subscriber_psw: str,                #   subscriber account private key mnemonic\n                    contract_address: str             #   application index\n                    #,secret: str                         #   not used \n                    ) -> Tuple[str, DopError]:\n            \"\"\"\n            UnSubscribe from a contract\n            return transaction id\n            \"\"\"\n\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")        #   must be connected to a node\n\n            params = self._i_algod_client.suggested_params()\n            params.flat_fee = True\n            params.fee = 1000\n            txn_note = \"DOP UNSUBSCRIBE\".encode()\n\n            err: DopError\n            subscriber_private_key: str\n            subscriber_private_key, err = self.mnemonic_to_private_key(subscriber_psw)\n            if err.isError():\n                return \"\",err\n            subscriber_address = account.address_from_private_key(subscriber_private_key)\n\n            application_index = int(contract_address)\n\n            app_args : list = []\n            app_args.append(bytes('unsubscribe','utf-8'))\n            unsigned_txn = ApplicationNoOpTxn(subscriber_address, params, application_index, app_args, None, None, None, txn_note)\n            signed_txn = unsigned_txn.sign(subscriber_private_key)\n\n            txid = ''\n            try:\n                txid = self._i_algod_client.send_transaction(signed_txn)\n                #print(\"Successfully sent transaction with txID: {}\".format(txid))\n\n            except Exception as err:\n                #print(err)\n                return \"\", DopError(208,'An exception occurred when sending unsubscribe transaction.')\n\n            # wait for confirmation \n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n\n                return \"\",DopError(305,'An exception occurred while waiting for \\\n                            confirmation of unsubscribe transaction')\n\n            return txid,DopError(0,'')\n\n\n    def grant(self,\n              publisher_address: str,       #   not used\n              publisher_passw: str,         #   publisher private key mnemonic\n              contract_address: str,        #   application index            \n              subscriber_address: str       #   address of the subscriber to be granted\n              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError\n              \n            # see 06_pub_call_grant.py\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")\n\n            smart_contract_arguments = {\n                    \"args\":     ['grant']                   #   list of app arguments\n                ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n                }\n\n            transaction_note = \"DOP GRANT\"\n\n            err: DopError\n            txid: str = \"\"\n            txid, err = self.dopSmartContract(\n                self._i_algod_client\n            ,   int(contract_address)\n            ,   publisher_passw\n            ,   smart_contract_arguments\n            ,   transaction_note\n            )\n\n            if err.isError():\n                return \"\",err\n\n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n                #print(err)\n                return txid,DopError(306,\"An exception occurred while waiting for \\\n                    confirmation of grant transaction.\")\n\n            return txid,DopError(0,\"\")\n            \n\n\n\n    def revoke(self,\n              publisher_address: str,       #   not used\n              publisher_passw: str,         #   publisher private key mnemonic\n              contract_address: str,        #   application index            \n              subscriber_address: str       #   address of the subscriber to be revoked\n              ) -> Tuple[str, DopError]:    #   returns transactionid, DopError\n\n              # see 07_pub_call_revoke.py\n            if self._i_algod_client == None:\n                return \"\",DopError(1,\"Missing value for algod client.\")\n\n            smart_contract_arguments = {\n                \"args\":     ['revoke']                   #   list of app arguments\n            ,   \"addrs\":    [subscriber_address]        #   list of account arguments\n            }\n\n            transaction_note = \"DOP REVOKE\"\n\n            txid: str = \"\"\n            err: DopError\n            txid, err = self.dopSmartContract(\n                self._i_algod_client\n            ,   contract_address\n            ,   publisher_passw\n            ,   smart_contract_arguments\n            ,   transaction_note\n            )\n\n            if err.isError():\n                return \"\",err\n\n            try:\n                confirmed_txn = self.wait_for_confirmation(self._i_algod_client, txid, 4)  \n\n                #   print(\"Transaction information: {}\".format(json.dumps(confirmed_txn, indent=4)))\n                #   print(\"Decoded note: {}\".format(base64.b64decode(confirmed_txn[\"txn\"][\"txn\"][\"note\"]).decode()))\n\n            except Exception as err:\n                #print(err)\n                return txid,DopError(307,\"An exception occurred while waiting for \\\n                    confirmation of revoke transaction.\")\n\n            return txid,DopError(0,\"\")\n\n\n\n    def balance(self,\n                subscriber_address: str,                            #   subscriber EoA address\n                secret: str,                                        #   subscriber contract secret\n                contract_address: str) -> Tuple[dict, DopError]:       #   address (blockchain layer) of the contract\n        \"\"\"\n        Get the balance of a user with `address` of the contract with `contract_address`\n        \"\"\"\n        \"\"\"\n        in this version this method is not \"really\" implemented\n        \"\"\"\n        response = {}\n        response['subscribed'] = 1\n        response['granted'] = 1             #   shortcut - use sub_keyget to valorize this field or use postgres DB\n        response['credit'] = 100\n        response['debit'] = 0\n\n        return (response, DopError(0,\"\"))\n\n    \n    def admin_get_grants(self,\n                        publisher_address: str,             #   EoA address of the publisher (contract owner)\n                        contract_address: str) -> Tuple[list, DopError]:    #   address (blockchain layer) of the contract\n        \"\"\"\n        This method is used by the publisher only in order to retrieve the list \n        of the EoA address of the granted subscribers\n        \"\"\"\n        return [], DopError()\n\n\n    def set_starting_balance(self, \n                            address,\n                            amount) -> str: # EoA of the user \n        \"\"\"\n        Sets the starting balance of an EoA\n        \"\"\"\n        #self._own_mnemonic = \"ability improve suspect canyon castle fire flock forum monitor travel know write similar denial thought \\\n        #    online ripple squeeze this finish jar parrot rabbit ability crouch\"\n        if self._own_mnemonic == None:\n            return \"\"\n\n        txid, err = self.__account_send(from_mnemonic = self._own_mnemonic, to_address=address, amount=amount)\n        if err.isError():\n            return \"\" \n\n        return txid"}
{"instruction": "Simulate a command-line RPG that teaches users about the Algorand blockchain through interactive quests and a Q&A section, and quiz. The game presents a menu with options for a Q&A with AI, starting the RPG game with multiple quests related to Algorand concepts, taking a quiz, or quitting.", "output": "plot_summary = \"\"\"\nA text-based RPG unfolds entirely within the command-line interface, where players' actions directly interact with the Algorand blockchain.\n\nA command-line interface (CLI) based RPG guides new users through the concepts of the Algorand blockchain.\n\nThe game mechanics directly utilize Algorand's features, turning abstract technical concepts into tangible actions within the game's narrative.\n\nThis provides a hands-on, interactive learning experience for newcomers to Algorand, making the technology more accessible and engaging.\n\"\"\"\n\nquests = [\n    \"Environmental Check [red](command: env)[/red] Before we begin our journey, let's ensure your surroundings are properly configured. Use the env command to check if your system meets the requirements for interacting with the Algorand blockchain. This involves verifying the necessary software and tools are installed and that your environment variables are set correctly.\",\n    \n    \"Account Creation [red](command: account)[/red] Every adventurer needs an identity! Create your Algorand account using the account command. This will generate a unique address and private key, which are essential for managing your assets and interacting with the blockchain. Keep your private key safe  it's the key to your digital kingdom!\",\n    \n    \"Funding Your Adventure [red](command: fund)[/red] Every great quest requires provisions. Fund your newly created Algorand account using the fund command. You'll need some Algo (Algorand's native cryptocurrency) to pay for transaction fees and interact with the blockchain. Think of it as stocking up on potions and supplies before embarking on a dangerous journey.\",\n    \n    \"Checking Your Provisions [red](command: balance)[/red] Wise adventurers keep track of their resources. Use the balance command to check the balance of your Algorand account. This will show you how much Algo you have available for your quests.\",\n    \n    \"Sharing the Spoils [red](command: send)[/red] Generosity is a virtue, even in the digital realm. Use the send command to send Algo to another Algorand account. This is like sharing your treasure with a fellow adventurer [bold](note: 1 Algo = 1_000_000 MicroAlgos)[/bold]\",\n    \n    \"Project Genesis [red](command: init)[/red] Time to craft something new! Use the init command to initialize a new Algorand project. This creates the foundation for building your own smart contracts  the magical spells of the Algorand world. We recommend using project name [red]auction_project[/red] match with my default template.\",\n    \n    \"Constructing the Spell [red](command: build)[/red]: With a project in place, you can now begin building your smart contract. The build command compiles your code into the bytecode that the Algorand Virtual Machine (AVM) understands. This is like carefully inscribing the runes of your spell.\",\n    \n    \"Trial Run [red](command: test)[/red]: Before unleashing your magic upon the world, it's wise to practice. Use the test command to test your smart contract in a safe, isolated environment. This allows you to identify and fix any bugs or vulnerabilities before deploying it to the main blockchain.\",\n    \n    \"Scrutiny of the Sages [red](command: audit)[/red] Even the most skilled mages seek peer review. Use the audit command to analyze your smart contract for potential security flaws and inefficiencies. This is like having a council of wise mages examine your spell for weaknesses.\",\n    \n    \"Unleashing the Magic [red](command: deploy)[/red] Once you're confident in your creation, it's time to deploy your smart contract to the Algorand blockchain. The deploy command makes your contract live, allowing other users to interact with it. Your spell is now active in the world!\",\n    \n    \"Preserving the Lore [red](command: upload)[/red] Important artifacts and knowledge deserve to be preserved. Use the upload command to upload files to IPFS (InterPlanetary File System), a decentralized storage network. This ensures that your data is immutable and accessible to anyone, even if parts of the network go offline. Think of it as storing your magical scrolls in a secure, distributed library.\"\n]\n\nqa_dict = {\n    \"Who founded Algorand?\": [[\"Vitalik Buterin\", \"Satoshi Nakamoto\", \"Silvio Micali\", \"Charles Hoskinson\"], \"Silvio Micali\"],\n    \n    \"What consensus mechanism does Algorand use?\": [[\"Proof-of-Work\", \"Delegated Proof-of-Stake\", \"Byzantine Fault Tolerance\", \"Pure Proof-of-Stake (PPoS)\"], \"Pure Proof-of-Stake (PPoS)\"],\n    \n    \"What is the native cryptocurrency of Algorand?\": [[\"ALGO\", \"ETH\", \"BTC\", \"SOL\"], \"ALGO\"],\n    \n    \"How does Algorand ensure decentralization?\": [[\"Mining\", \"Random selection of validators\", \"Staking\", \"Proof of Work\"], \"Random selection of validators\"],\n    \n    \"What is the average block time on Algorand?\": [[\"3.7 seconds\", \"10 minutes\", \"15 seconds\", \"1 hour\"], \"3.7 seconds\"],\n    \n    \"How does Algorand solve the blockchain trilemma?\": [[\"Mining\", \"Proof-of-Stake\", \"Scalability, security, decentralization\", \"Validators\"], \"Scalability, security, decentralization\"],\n    \n    \"How does Algorand handle transaction finality?\": [[\"Immediate finality\", \"Confirmation in 10 blocks\", \"Delayed finality\", \"Stochastic finality\"], \"Immediate finality\"],\n    \n    \"What is the main purpose of Algorand?\": [[\"Smart contracts\", \"NFT minting\", \"High-speed transactions\", \"DeFi\"], \"High-speed transactions\"],\n    \n    \"What is Algorands approach to scalability?\": [[\"Sidechains\", \"Layer-2\", \"Sharding\", \"Efficient consensus\"], \"Efficient consensus\"],\n    \n    \"How does Algorand achieve low transaction costs?\": [[\"High gas fees\", \"Layer-2\", \"Efficient consensus\", \"Sharding\"], \"Efficient consensus\"],\n    \n    \"What feature allows Algorand to handle multiple transactions simultaneously?\": [[\"Parallel processing\", \"Atomic transfers\", \"Sharding\", \"Multi-threading\"], \"Atomic transfers\"],\n    \n    \"What is the Algorand Foundations role?\": [[\"Funding and research\", \"Governance and development\", \"Marketing and promotion\", \"Community building\"], \"Governance and development\"],\n    \n    \"How does TEAL ensure smart contract security in Algorand?\": [[\"Formal verification\", \"Stack-based language\", \"Sandboxing\", \"Static analysis\"], \"Stack-based language\"],\n    \n    \"How does Algorand handle stateful vs. stateless smart contracts?\": [[\"Combined execution\", \"Separate execution environments\", \"Dynamic switching\", \"Hybrid approach\"], \"Separate execution environments\"],\n    \n    \"Explain Algorands approach to optimizing transaction throughput in its protocol?\": [[\"Sharding\", \"Fast consensus and block finality\", \"Large block sizes\", \"Off-chain transactions\"], \"Fast consensus and block finality\"],\n    \n    \"What role do relay nodes play in Algorands network architecture?\": [[\"Facilitate communication\", \"Validate transactions\", \"Store blockchain data\", \"Execute smart contracts\"], \"Facilitate communication\"],\n    \n    \"Discuss the role of Algorands Virtual Machine (AVM) in executing contracts?\": [[\"Compiles TEAL code\", \"Executes TEAL scripts\", \"Manages state\", \"Verifies transactions\"], \"Executes TEAL scripts\"],\n    \n    \"Explain how atomic transfers are implemented in Algorand?\": [[\"Single transactions\", \"Grouped transactions\", \"Chained transactions\", \"Smart contracts\"], \"Grouped transactions\"],\n    \n    \"What are the engineering challenges in implementing Algorand Standard Assets (ASA)?\": [[\"Tokenization standards\", \"Custom asset creation\", \"Decentralized exchange\", \"Security audits\"], \"Custom asset creation\"],\n    \n    \"How does Algorand manage network latency and ensure consistency?\": [[\"Centralized servers\", \"Fast block propagation\", \"Caching mechanisms\", \"Redundant networks\"], \"Fast block propagation\"],\n    \n    \"What is the TEAL programming language used for in Algorand?\": [[\"Writing smart contracts\", \"Developing dApps\", \"Building blockchain infrastructure\", \"Creating cryptographic algorithms\"], \"Writing smart contracts\"],\n    \n    \"What are Algorand Smart Contracts (ASC1)?\": [[\"Off-chain contracts\", \"Layer-2 smart contracts\", \"Layer-1 smart contracts\", \"Hybrid smart contracts\"], \"Layer-1 smart contracts\"],\n    \n    \"What is an Algorand Standard Asset (ASA)?\": [[\"Native cryptocurrency\", \"Custom tokens framework\", \"Stablecoin protocol\", \"Decentralized exchange\"], \"Custom tokens framework\"],\n    \n    \"How does Algorand handle smart contract execution fees?\": [[\"Fixed fees\", \"Based on complexity\", \"Gas fees\", \"Transaction size\"], \"Based on complexity\"],\n    \n    \"What is a Stateful Smart Contract in Algorand?\": [[\"Stateless contract\", \"Maintains state\", \"Temporary contract\", \"Immutable contract\"], \"Maintains state\"],\n    \n    \"How are nodes incentivized in the Algorand network?\": [[\"Transaction fees\", \"Block rewards\", \"Staking rewards\", \"Mining rewards\"], \"Block rewards\"],\n    \n    \"What are the security implications of Algorands PPoS model?\": [[\"Increases centralization risk\", \"Reduces centralization risk\", \"Vulnerable to 51% attacks\", \"Requires high energy consumption\"], \"Reduces centralization risk\"],\n    \n    \"What is Cryptographic Sortition in Algorand?\": [[\"Random number generation\", \"Selects consensus participants\", \"Encrypts transactions\", \"Verifies block integrity\"], \"Selects consensus participants\"],\n    \n    \"Can anyone participate in Algorand's consensus?\": [[\"Yes\", \"No\", \"Only selected nodes\", \"Only authorized participants\"], \"Yes\"],\n    \n    \"What year was Algorand launched?\": [[\"2017\", \"2018\", \"2019\", \"2020\"], \"2019\"]\n}\n\nchoice_content = \"[bold green]Choose an option you would like:\\n1. Option [red]Q&A[/red]  you can interactive with AI really insteresting huh.\\n2. With [red]Game[/red]  we start the game explore 11 quests.\\n3. Let [red]Quiz[/red]  if you want to test your knowledge.\\n4. Or [red]Quit[/red]  quit the game, your journey is over.[/bold green]\\nTell me what your choice\"\n\nafter_credits = \"\"\"\nThank you for playing AlgoRPG!\n\nWe hope you enjoyed your adventure through the world of Algorand and that the game helped you learn more about blockchain technology. Your feedback is valuable to us, so please let us know what you thought of your experience. Did you find the game helpful in understanding Algorand? What did you enjoy most? What could we improve?\n\nWe're constantly working to make AlgoRPG even better, so your input is greatly appreciated.\n\"\"\""}
{"instruction": "Implement a decentralized voting system on the Algorand blockchain using Choice Coin (an Algorand Standard Asset) to record votes. The system includes functions for counting votes in an account, hashing data using SHA-512, processing votes via a stateless smart contract (AssetTransferTxn), conducting standard elections, handling corporate voting based on stake, displaying voting results as bar graphs, determining the winner (or a tiebreaker using a quantum oracle), and resetting voting accounts using the clawback function to prepare for a new voting process.", "output": "# Open Source under Apache License\n\n\n\n# This code defines a decenteralized voting system on the Algorand Blockchain.\n\n# It uses Choice Coin, an Algorand Standard Asset, to record votes on a distributed ledger.\n\n# The system makes both efficiency and security a priority.\n\n# An escrow account holds the total number of Choice Coin required for the voting process, and Algorand accounts for each of the decisions are made.\n\n# Each of the individual decisions made by the voters connect back to the escrow account.\n\n# In turn, one Choice Coin transfers to the appropriate decision account through a stateless smart contract.\n\n# Furthermore, a SHA-512 hashing algorithm is used to encrypt voter information at all stages, ensuring that private information is made secure.\n\n# This is especially useful where voters need to give personal identification for verification purposes.\n\n\n\n# Imports and dependicies include the Algorand Python SDK, the Python Hashlib library, and the Python Matplotlib library.\n\nfrom algosdk import account, encoding, mnemonic, transaction\n\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\n\nfrom algosdk.v2client import algod\n\nimport hashlib\n\nimport matplotlib\n\nimport matplotlib.pyplot as plt\n\nimport random\n\nimport numpy as np\n\n\n\n# Matplot parameters for the matplotlib function to generate a new plot.\n\nmatplotlib.use('TkAgg')\n\n# Put Algod Client address here\n\nalgod_address = \"https://testnet-algorand.api.purestake.io/ps2\"\n\n# Put Algod Token here\n\nalgod_token = \"3nErwJTbc94LTx3AxczGBNymarZg6cF8gWTqiDIf\"\n\nheaders = {\"X-API-Key\": algod_token}\n\n# Initializes client for node.\n\nalgod_client = algod.AlgodClient(algod_token, algod_address, headers)\n\n\n\n# Escrow creation.\n\n# Put in main fund address here\n\n# Put in main fund receiver_mnemonic here\n\nescrow_address = \"\"\n\nescrow_mnemonic = \"\"\n\nescrow_key = mnemonic.to_private_key(escrow_mnemonic)\n\nchoice_id = 21364625  # Official Test Asset ID for Choice Coin\n\n\n\n# Decisions.\n\n# To add more decisions for the election process, add the address for the new decision here.\n\n# Then, add an appropriate boolean statement at line 100 of this file. Be sure to also add additional\n\n# counts at line 148 of this file as well.\n\ndecision_one = \"\"\n\ndecision_two = \"\"\n\ncorporate_decision_one = \"\"\n\ncorporate_decision_two = \"\"\n\n\n\n# Clawback Address required to reset accounts to start new voting process.\n\n# Sets up accounts for both the regular election process and the corporate decision process.\n\n# Add more accounts to adjust for more decisions.\n\nclawback_address = \"\"\n\nclawback_mnemonic = \"\"\n\nclawback_key = mnemonic.to_private_key(clawback_mnemonic)\n\n\n\n# This function counts the number of Choice Coin in an account.\n\n# It first fetches the account_info, and specifically searches among the assets that the account owns for Choice Coin.\n\n# It then returns the number of Choice Coin that the account owns.\n\n\n\n\n\ndef count(address):\n\n    message = ''\n\n    error = ''\n\n    # Fetch account information for the address.\n\n    account_info = algod_client.account_info(address)\n\n    assets = account_info.get(\"assets\")  # Fetch asset information.\n\n    for asset in assets:\n\n        # Iterate over assets until Choice Coin is reached. Return the amount if it exists.\n\n        if asset[\"asset-id\"] == choice_id:\n\n            amount = asset.get(\"amount\")\n\n            message = amount\n\n            return message\n\n    error = 'The account has not opted-in to the asset yet.'\n\n    return error\n\n\n\n# This function hashes a string using the SHA-512 cryptographic scheme.\n\n# SHA-512 is a post-quantum cryptographic scheme, thus ensuring that private information is made secure from malicious attackers.\n\n\n\n\n\ndef hashing(item):\n\n    # Assumes the default UTF-8.\n\n    # This encodes the string with the SHA-512 scheme.\n\n    hash_object = hashlib.sha512(item.encode())\n\n    # This returns the hexadecimal encode as a string.\n\n    item = hash_object.hexdigest()\n\n    return item\n\n\n\n# This function defines a stateless smart contract on the Algorand Network.\n\n# It sends Choice Coin to the appropriate destination address based on user input.\n\n\n\n\n\ndef choice_vote(sender, key, receiver, amount, comment):\n\n    parameters = algod_client.suggested_params()  # Sets suggested parameters\n\n    transaction = AssetTransferTxn(\n\n        sender, parameters, receiver, amount, choice_id, note=comment)\n\n    # Defines an inital transaction for Choice Coin\n\n    signature = transaction.sign(key)\n\n    # Signs the transaction with the senders private key\n\n    algod_client.send_transaction(signature)\n\n    # Sends the transaction with the signature\n\n    final = transaction.get_txid()\n\n    return True, final\n\n\n\n# This function describes a methodology for Electoral Voting on the Choice Coin platform.\n\n# It calls the choice_vote() function with the appropriate inputs based on which decision the voter selected.\n\n# It is currently defined for two candidates/decisions, but it can be easily amended to include more.\n\n\n\n\n\ndef election_voting(vote):\n\n    message = ''\n\n    # Add more boolean statements for more decisions or candidates.\n\n    if vote == 'YES':\n\n        # choice_vote() function called for \"YES\".\n\n        TX_ID = choice_vote(escrow_address, escrow_key,\n\n                            decision_one, 100, \"Tabulated using Choice Coin\")\n\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n\n            TX_ID[1] + \".\"\n\n        # AlgoExplorer returned for validation.\n\n    elif vote == 'NO':\n\n        TX_ID = choice_vote(escrow_address, escrow_key,\n\n                            decision_two, 100, \"Tabulated using Choice Coin\")\n\n        message = \"Ballot Tabulated. \\n You can validate that your vote was counted correctly at https://testnet.algoexplorer.io/tx/\" + \\\n\n            TX_ID[1] + \".\"\n\n    return message\n\n\n\n# This defines a corporate voting mechanism using Choice Coin.\n\n# It works very similarly to the electoral voting scheme defined earlier.\n\n# However, it does introduce the stake as a new variable.\n\n# The stake defines the ownership stake of the shareholder that is voting.\n\n\n\n\n\ndef corporate_voting(vote, stake):\n\n    message = ''\n\n    stake = int(stake)  # Define the ownership stake.\n\n    amount = 100 * stake\n\n    if vote == 'YES':\n\n        comment = \"Tabulated using Choice Coin\"\n\n        choice_vote(escrow_address, escrow_key,\n\n                    corporate_decision_one, amount, comment)\n\n        # Call the choice_vote() function that sends the appropriate number of Choice Coin based on the ownership stake.\n\n        message = \"Ballot Tabulated\"\n\n    elif vote == 'NO':\n\n        comment = \"Tabulated using Choice Coin\"\n\n        choice_vote(escrow_address, escrow_key,\n\n                    corporate_decision_two, amount, comment)\n\n        message = \"Ballot Tabulated\"\n\n    return message\n\n\n\n# Returns a dynamic bar-graph showing the results of the vote.\n\n# Uses PyPlot for both corporate and electoral voting.\n\n\n\n\n\ndef show_results(yes_count, no_count):\n\n    names = ['Candidate 1', 'Candidate 2']  # Define the two decisions.\n\n    # Fetch the total number of votes for each decision.\n\n    values = [yes_count, no_count]\n\n    # Define a new pyplot\n\n    data = np.arange(4000).reshape((100,40))\n\n    plt.figure(figsize=(15, 6))\n\n    plt.subplot(131)\n\n    plt.bar(names, values)\n\n    plt.title('Election Results', fontdict = {'fontsize' : 20})\n\n    plt.savefig('static/img/Figure_1', bbox_inches='tight')\n\n   \n\n    # Return the results.\n\n\n\n\n\ndef show_corporate_results(yes_count, no_count):\n\n    names = ['Decision 1', 'Decision 2']\n\n    values = [yes_count, no_count]\n\n    plt.figure(figsize=(9, 3))\n\n    plt.subplot(131)\n\n    plt.bar(names, values)\n\n    plt.suptitle('Corporate Voting Results')\n\n    plt.savefig('/home/archie/Inital_Demo/static/img/Figure_2.png')\n\n\n\n# Counts the total number of votes to return a statement regarding which candidate has won.\n\n# Applies to both corporate and electoral voting.\n\n\n\n\n\ndef count_votes():\n\n    yes_count = int(count(decision_one)/100)\n\n    no_count = int(count(decision_two)/100)\n\n    show_results(yes_count, no_count)\n\n    if yes_count > no_count:\n\n        if yes_count == 1:\n\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} vote.\".format(yes_count)\n\n        else:\n\n            return \"The Voting Process has ended. Candidate One received the most votes with {0} votes.\".format(yes_count)\n\n    if no_count > yes_count:\n\n        if no_count == 1:\n\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} vote.\".format(no_count)\n\n        else:\n\n            return \"The Voting Process has ended. Candidate Two received the most votes with {0} votes.\".format(no_count)\n\n\n\n    else:\n\n        # Random sample generated from adiabatic quantum computer.\n\n        # Generated using QunatumQuery.py.\n\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,\n\n                          0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n\n        # Random sample from quantum sample.\n\n        Q = random.choice(quantum_sample)\n\n        if Q:\n\n            return(\"Tie. The Quantum Oracle selects Candidate One!\")\n\n        else:\n\n            return(\"Tie. The Quantum Oracle selects Candidate Two!\")\n\n\n\n\n\ndef count_corporate_votes():\n\n    yes_count = count(corporate_decision_one)\n\n    no_count = count(corporate_decision_two)\n\n    show_corporate_results(yes_count, no_count)\n\n    if yes_count > no_count:\n\n        return \"The Voting Process has ended. Decision One had the most votes!\"\n\n    if no_count > yes_count:\n\n        return \"Decision Two had the most votes!\"\n\n    else:\n\n        # Random sample generated from adiabatic quantum computer.\n\n        # Generated using QunatumQuery.py.\n\n        quantum_sample = [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,\n\n                          0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]\n\n        # Random sample from quantum sample.\n\n        Q = random.choice(quantum_sample)\n\n        if Q:\n\n            return(\"Tie. The Quantum Oracle selects Decision One!\")\n\n        else:\n\n            return(\"Tie. The Quantum Oracle selects Decision Two!\")\n\n\n\n# This function resets the voting accounts to start a new voting process.\n\n# It uses the clawback functionality built into Choice Coin to send the Choice Coin back to the main escrow account.\n\n\n\n\n\ndef reset_votes():\n\n    message = ''\n\n#    params = algod_client.suggested_params()\n\n#    yes_count = count(decision_one)\n\n#    no_count = count(decision_two)\n\n    # Fetches the total number of Choice Coin in each account.\n\n#    if yes_count > 0:\n\n#        transaction_2 = AssetTransferTxn(\n\n#            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=decision_one)\n\n#        signature_2 = transaction_2.sign(clawback_key)\n\n#        algod_client.send_transaction(signature_2)\n\n        # Defines a clawback transaction to send Choice Coin back to the escrow account if the number of Choice Coin in the account exceeds zero.\n\n#    if no_count > 0:\n\n#        transaction_3 = AssetTransferTxn(\n\n#            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=decision_two)\n\n#        signature_3 = transaction_3.sign(clawback_key)\n\n#        algod_client.send_transaction(signature_3)\n\n    message = 'Vote accounts reset. New Voting Process started.'\n\n    return message\n\n\n\n\n\ndef reset_corporate_votes():\n\n    message = ''\n\n    params = algod_client.suggested_params()\n\n    yes_count = count(corporate_decision_one)\n\n    no_count = count(corporate_decision_two)\n\n    if yes_count > 0:\n\n        transaction_2 = AssetTransferTxn(\n\n            clawback_address, params, escrow_address, yes_count, choice_id, revocation_target=corporate_decision_one)\n\n        signature_2 = transaction_2.sign(clawback_key)\n\n        algod_client.send_transaction(signature_2)\n\n    if no_count > 0:\n\n        transaction_3 = AssetTransferTxn(\n\n            clawback_address, params, escrow_address, no_count, choice_id, revocation_target=corporate_decision_two)\n\n        signature_3 = transaction_3.sign(clawback_key)\n\n        algod_client.send_transaction(signature_3)\n\n    message = 'Vote accounts reset. New Voting Process started.'\n\n    return message"}
{"instruction": "Implement a number guessing game using Algorand, where the user wagers a specified amount of TeeCoin. If the user guesses the correct number within six attempts, they receive the wagered TeeCoin amount from the creator's account; otherwise, the user transfers the wagered TeeCoin amount to the creator's account. The script interacts with the user to obtain their name, Algorand address, passphrase, and wager amount. It also automates the asset opt-in process for the user.", "output": "import random as r\nfrom algosdk import account, encoding, mnemonic,transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\n\n#This is an Algogenous Smart Contract for a guessing game where if  the user wins he/she gets a reward of a particular amount of a token of your choice and if the player loses he/she loses that same amount of a token of your choice \n#Connect to the Algorand Client (This is for sandbox) here. \nalgod_address = \"http://localhost:4001\"\nalgod_token = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n#Initializes Client for node\nheaders = {\"X-API-Key\": algod_token }\nalgod_client = algod.AlgodClient(algod_token,algod_address,headers)\n\n\n#The fund address and fund mnemonic defined below should belong to the creator account that controls the asset that you want to offer.\n\n#In this code I created an ASA TEE COIN on the testnet which I used to reward the user, but you can decide to change it up and use your own asa with a diffrent address and passphrase\n\n#The address I used is  KE3P22YHKMC23OHDPYIMGVG7DHA6GP6T6DBROYRTZX3RQJ73Y2EFM5OEO4\n#The passphrase  is : light truck alley era debris mango country lake solution impact captain casual steel mechanic coil ceiling exhibit reject skirt february apart parent master able random\n#Warning !!!! This is solely for development purposes and the tokens have 0 value.\n\ncreator_address = \"KE3P22YHKMC23OHDPYIMGVG7DHA6GP6T6DBROYRTZX3RQJ73Y2EFM5OEO4\" #Put the creator address here. \ncreator_mnemonic = \"light truck alley era debris mango country lake solution impact captain casual steel mechanic coil ceiling exhibit reject skirt february apart parent master able random\" #Put the creator mnemonic here. \nfund_key = mnemonic.to_private_key(creator_mnemonic)\n\n#Asset ID for Tee Coin\nasset_id = \"88713385\"\n\n#Welocome Screen\n#This prompts the user to input his/her name,testnet address with sufficent algos and the required asa, and their passpharase\nprint(\"WELCOME TO THE PRICE IS RIGHT \\nGUESS THE RIGHT NUMBER AND GET A CHANCE TO WIN ANY AMOUNT TEECOIN\\n---------DISCLAIMER---------\\nYOU CAN ALSO LOSE THAT AMOUNT OF TEECOIN IF YOU DONT GUESS RIGHT.\")\nuser_name = input('Type your name : ').title()\nprint(f'Hello {user_name}.')\nuser_said = input(f'{user_name} do you want to play Number Guessing game (Y/N) : ').lower()\n\nwhile True:\n    try: \n        user_wage =int(input(\"ENTER THE AMOUNT OF TEECOIN YOU WANT TO WAGER: \"))\n\n    \n\n    except ValueError:\n        print(\"THIS IS NOT A NUMBER\")\n        continue\n    else:\n        break\n        \n\nuser_address = input(\"\\n ENTER YOUR TESTNET ADDRESS WITH SUFFICIENT TESTNET ALGOS: \")\nuser_key = input(\"\\n PASTE YOUR PASSPHRASE IN THE CORRECT SYNTAX: \")\nreciver_address = user_address\nreciver_mnemonic = user_key\nreciver_key = mnemonic.to_private_key(reciver_mnemonic)\namount = int(user_wage) * 100 \namount2 = amount / 100 \nindex = asset_id\n\n\n\n\n\n\n#This defines a stateless transfer of funds from the creator account  to the user account.  \ndef asset_transfer_fund(creator_address, fund_key, reciver_address,amount, index = asset_id):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(creator_address, parameters, reciver_address, amount, index =  asset_id )\n    signature = transaction.sign(fund_key)\n    #Signs the transaction\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    print(\"TRANSACTION ID : \" ,final)\n    return True, final\n\n#This defines a stateless transfer of funds from the  user account to the creator account. \ndef asset_transfer_user(reciver_address, reciver_key, creator_address, amount, index = asset_id):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(reciver_address, parameters, creator_address, amount, index =  asset_id )\n    signature = transaction.sign(reciver_key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    print(\"TRANSACTION ID : \",final)\n    return True, final\n\n#This automates the optin action so the user can recieve the token\ndef optin(reciver_mnemonic,reciver_address,amount,index):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(reciver_address, parameters, reciver_address, 0, index = asset_id)\n    key = mnemonic.to_private_key(reciver_mnemonic)\n    signature = transaction.sign(key)\n    algod_client.send_transaction(signature)\n    #Opts-in the account to the asset\n    return True\n\n\n\n\n#This defines the game logic\ndef Main(user_said):\n\n    while True:\n        \n\n        if ('y' not in user_said) and ('n' not in user_said) and (user_said != True):\n            user_said = input('Invalid keyword\\nType again : ').lower()\n\n        elif 'y' in user_said:\n            winning_number = r.randint(1,100)\n            user_guessed = int(input('\\nYou have 6 guesses.\\nGuess any number between 1 and 100\\nGuess the number : '))\n            turn = 1\n\n            while True:\n            \n                if winning_number == user_guessed:\n                    print(f'Congrats you guessed the number in {turn} times.')\n                    \n                    return 1\n                    \n\n                elif turn == 6:\n                    print(f'Sorry You can\\'t guess the number. The number is {winning_number}.')\n                    return 0\n                   \n\n                else:\n                    if winning_number > user_guessed:\n                        print('Too Low')\n                    else:\n                        print('Too High')\n\n                    print(f'You have {6-turn} guesses left.')\n                    \n                    turn += 1\n                    user_guessed = int(input('Guess again : '))\n\n        \n\n#This checks if the user wins or loses and calls the respective functions to carry out the appropriate transaction which prints out the transaction id which can be verified on algoexplorer.\nif Main(user_said) == 1:\n    print(\"YOU WON\" ,amount2, \" TeeCoin\" )\n    optin(reciver_mnemonic,reciver_address,amount,index)\n    asset_transfer_fund(creator_address, fund_key, reciver_address,amount, index = asset_id)\nelse :\n    print(\"YOU LOST\",amount2, \" TeeCoin\" )\n    optin(reciver_mnemonic,reciver_address,amount,index)\n    asset_transfer_user(reciver_address, reciver_key, creator_address, amount, index = asset_id)"}
{"instruction": "Analyze the TEAL code to identify execution paths where the transaction fee ('Fee') is not explicitly checked or validated. Report any paths where the transaction can be approved without a fee check, as this could allow an attacker to set an excessively high fee and drain the account's funds.", "output": "\"\"\"Detector for finding execution paths missing Fee check.\"\"\"\n\nfrom typing import List, TYPE_CHECKING, Tuple\n\nfrom tealer.detectors.abstract_detector import (\n    AbstractDetector,\n    DetectorClassification,\n    DetectorType,\n)\nfrom tealer.detectors.utils import (\n    detect_missing_tx_field_validations_group,\n    detect_missing_tx_field_validations_group_complete,\n)\nfrom tealer.utils.algorand_constants import MAX_TRANSACTION_COST\nfrom tealer.utils.output import ExecutionPaths\n\nif TYPE_CHECKING:\n    from tealer.utils.output import Listoutput\n    from tealer.teal.basic_blocks import BasicBlock\n    from tealer.teal.context.block_transaction_context import BlockTransactionContext\n    from tealer.teal.teal import Teal\n\n\nclass MissingFeeCheck(AbstractDetector):  # pylint: disable=too-few-public-methods\n    \"\"\"Detector to find execution paths missing Fee check.\n\n    The fee for stateless contract transactions will be deducted\n    from the contract account or the LogicSig signer account. An\n    attacker could set the fee to high value and drain the account\n    funds in form of fees.\n\n    This detector tries to find execution paths that approve the algorand\n    transaction(\"return 1\") and doesn't check the Fee field.\n    \"\"\"\n\n    NAME = \"missing-fee-check\"\n    DESCRIPTION = \"Missing Fee Field Validation\"\n    TYPE = DetectorType.STATELESS\n\n    IMPACT = DetectorClassification.HIGH\n    CONFIDENCE = DetectorClassification.HIGH\n\n    WIKI_URL = (\n        \"https://github.com/crytic/tealer/wiki/Detector-Documentation#missing-fee-field-validation\"\n    )\n    WIKI_TITLE = \"Missing Fee Field Validation\"\n    WIKI_DESCRIPTION = (\n        \"LogicSig does not validate `Fee` field.\"\n        \" Attacker can submit a transaction with `Fee` field set to large value and drain the account balance.\"\n        \" More at [building-secure-contracts/not-so-smart-contracts/algorand/unchecked_transaction_fee]\"\n        \"(https://github.com/crytic/building-secure-contracts/tree/master/not-so-smart-contracts/algorand/unchecked_transaction_fee)\"\n    )\n    WIKI_EXPLOIT_SCENARIO = \"\"\"\n```py\ndef withdraw(...) -> Expr:\n    return Seq(\n        [\n            Assert(\n                And(\n                    Txn.type_enum() == TxnType.Payment,\n                    Txn.first_valid() % period == Int(0),\n                    Txn.last_valid() == Txn.first_valid() + duration,\n                    Txn.receiver() == receiver,\n                    Txn.amount() == amount,\n                    Txn.first_valid() < timeout,\n                )\n            ),\n            Approve(),\n        ]\n    )\n```\n\nAlice signs the logic-sig to allow recurring payments to Bob.\\\n Eve uses the logic-sig and submits a valid transaction with `Fee` set to 1 million ALGOs.\\\n Alice loses 1 million ALGOs.\n\"\"\"\n\n    WIKI_RECOMMENDATION = \"\"\"\nValidate `Fee` field in the LogicSig.\n\"\"\"\n\n    def detect(self) -> \"Listoutput\":\n        \"\"\"Detect execution paths with missing Fee check.\n\n        Returns:\n            ExecutionPaths instance containing the list of vulnerable execution\n            paths along with name, check, impact, confidence and other detector\n            information.\n        \"\"\"\n\n        def checks_field(block_ctx: \"BlockTransactionContext\") -> bool:\n            # returns True if fee is bounded by some unknown value\n            # or is bounded by some known value less than maximum transaction cost.\n            return block_ctx.max_fee_unknown or block_ctx.max_fee <= MAX_TRANSACTION_COST\n\n        # there should be a better to decide which function to call ??\n        if self.tealer.output_group:\n            # mypy complains if the value is returned directly. Uesd the second suggestion mentioned here:\n            # https://mypy.readthedocs.io/en/stable/common_issues.html#variance\n            return list(\n                detect_missing_tx_field_validations_group_complete(self.tealer, self, checks_field)\n            )\n\n        output: List[\n            Tuple[\"Teal\", List[List[\"BasicBlock\"]]]\n        ] = detect_missing_tx_field_validations_group(self.tealer, checks_field)\n        detector_output: \"Listoutput\" = []\n        for contract, vulnerable_paths in output:\n            detector_output.append(ExecutionPaths(contract, self, vulnerable_paths))\n\n        return detector_output"}
{"instruction": "Implement a smart contract on the Algorand blockchain to distribute Choice Coin rewards for democratic participation. The contract includes functions to initialize the reward program and award Choice Coins to participants based on their actions, such as sending letters to local legislatures or general participation.", "output": "#Stateless Smart Contracts on the Algorand Blockhain to send rewards for Democratic Participation.\n#Choice Coin seeks to provide rewards to its community for participating in their local democracy.\n#The inagaural democratic rewards program will focus on the advocacy for blockchain and cryptocurrency acceptance.\n\n  \nfrom algosdk import account, encoding, mnemonic,transaction\nfrom algosdk.future.transaction import AssetTransferTxn, PaymentTxn\nfrom algosdk.v2client import algod\n\n\nalgod_address = \"\"\nalgod_token = \"\"\n# Initializes Client for node\nheaders = {\"X-API-Key\": algod_token }\nalgod_client = algod.AlgodClient(algod_token,algod_address,headers)\nreserve_address = \"\" # Put in main fund address here\nreserve_mnemonic = \"\" # Put in main fund receiver_mnemonic here\nreserve_key = mnemonic.to_private_key(reserve_mnemonic)\nasset_id =  # Probably will want to change if when we create a new asset\n\ndef choice_trade(sender, key, receiver, amount, index,comment):\n    parameters = algod_client.suggested_params()\n    transaction = AssetTransferTxn(sender, parameters, receiver, amount, index,note=comment)\n    #Defines an inital transaction for choice Coin\n    signature = transaction.sign(key)\n    #Signs the transaction with the senders private key\n    algod_client.send_transaction(signature)\n    #Sends the transaction with the signature\n    final = transaction.get_txid()\n    return True, final\n\n\n\n\ndef init_democratic_participation():\n    parameters = algod_client.suggested_params()\n    choice_trade(reserve_address,reserve_key,participation_awards,\"Value\",asset_id,'Initial Democratic Participation Rewards')\n\n\ndef democratic_awards(query,address):\n    if query == 'Letter to local legistature':\n        comment = 'Here is your Choice Coin Reward. \\n Thanks for sending a letter to your local government'\n        reward_amount = \"\"#Amount of Reward\n        choice_trade(fund_address, fund_key, address, reward_amount, asset_id,comment)\n    else:\n        comment = \"Here is you Choice Coin Reward! \\n Thanks for participating in our democracy!\"\n        reward_amount = \"\"#Amount of Reward\n        choice_trade(fund_address, fund_key, address, reward_amount, asset_id,comment)"}
{"instruction": "Compile and deploy a smart signature that verifies a VRF proof against a block seed, and then prints the compiled program and its contract address. The smart signature requires a two-transaction group, where the first transaction has zero fee. The smart signature verifies that a proposed random number matches the first byte of a proof. The logic signature checks that the second transaction is sent by a specified fee provider address and received by the same address.", "output": "import base64\nfrom email import message\n\nfrom algosdk.future import transaction\nfrom algosdk import mnemonic\nfrom algosdk.v2client import algod\nfrom pyteal import *\nfrom pytealutils.strings import atoi\n\nsender_mnemonic = \"paste your own mnemonic here\"\nreceiver_public_key = \"UFAGBH5BHBAKDSSSBKP6LAZ7VFIA3ETNK7LVNEH6KXRRNTYE6WYHTEMEGU\"\nfee_provider_public_key = \"I4P7CYNN2S24FJ546IS76M2RJDIAAHJ6CHF7MGH3RBJAPFSDZNNZDRGRSE\"\n#algod_address = \"http://localhost:4001\"\n#algod_token = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\nalgod_address = \"https://node.testnet.algoexplorerapi.io\"\nalgod_token = \"\"\n\n\ndef compile_smart_signature(client, source_code):\n    compile_response = client.compile(source_code)\n    return compile_response['result'], compile_response['hash']\n\n\ndef wait_for_confirmation(client, transaction_id, timeout):\n    start_round = client.status()[\"last-round\"] + 1\n    current_round = start_round\n\n    while current_round < start_round + timeout:\n        try:\n            pending_txn = client.pending_transaction_info(transaction_id)\n        except Exception:\n            return\n        if pending_txn.get(\"confirmed-round\", 0) > 0:\n            return pending_txn\n        elif pending_txn[\"pool-error\"]:\n            raise Exception('pool error: {}'.format(pending_txn[\"pool-error\"]))\n        client.status_after_block(current_round)\n        current_round += 1\n    raise Exception(\n        'pending tx not found in timeout rounds, timeout value = {}'.format(timeout))\n\n#{\"blockSeedTakenFromBlockWithId\": \"25010658\", \"publicKey\": \"40ps3+H7aCMHsosRXB8D/cT/T/SyErbpVVYjI9/SxcY=\", \"randNumber\": \"230\", \"proof\": \"5rQ79zemy800T2Gze6Lf6E+u3S/+6W0RwHOOBXlFHnolsHKJzHlXABlOf0ZBdSUFdTYyznEpj4MOpJCZX9NMgFajlpwHPRbp8Oa7E5hAswI=\"}\n\n\ndef verified_random_announcer(benefactor, feeprovider):\n    #fee_cond = Txn.fee() <= Global.min_txn_fee()\n    fee_cond = Gtxn[0].fee() == Int(0)\n    safety_cond = And(\n        Global.group_size() == Int(2),\n        Gtxn[0].type_enum() == TxnType.Payment,\n        Gtxn[0].close_remainder_to() == Global.zero_address(),\n        Gtxn[0].asset_close_to() == Global.zero_address(),\n        Gtxn[0].rekey_to() == Global.zero_address(),\n        Gtxn[0].amount() == Int(0),\n        Gtxn[1].type_enum() == TxnType.Payment,\n        Gtxn[1].close_remainder_to() == Global.zero_address(),\n        Gtxn[1].asset_close_to() == Global.zero_address(),\n        Gtxn[1].rekey_to() == Global.zero_address(),\n        Gtxn[1].amount() == Int(0),\n    )\n\n    futureBlockId = JsonRef.as_uint64(\n        Txn.note(), Bytes(\"blockSeedTakenFromBlockWithId\"))\n    blockSeed = Block.seed(futureBlockId)\n    #message = Sha256(blockSeed)\n    message = blockSeed\n    proof = Base64Decode.std(JsonRef.as_string(\n        Txn.note(), Bytes(\"proof\")))\n    randNumber0 = JsonRef.as_uint64(\n        Txn.note(), Bytes(\"randNumber\"))\n\n    publicKey = Base64Decode.std(JsonRef.as_string(\n        Txn.note(), Bytes(\"publicKey\")))\n\n    program = And(\n        Gtxn[1].sender() == Addr(feeprovider),\n        Gtxn[1].receiver() == Addr(feeprovider),\n        randNumber0 == GetByte(proof, Int(0)),\n        #blockSeed == actualBlockSeed,\n        VrfVerify.algorand(message, proof, publicKey).outputReducer(\n            lambda x, y: y == Int(1))\n    )\n    safe_program = And(fee_cond, safety_cond, program)\n    return compileTeal(safe_program, Mode.Signature, version=7)\n\n\ndef payment_transaction(creator_mnemonic, amt, rcv, algod_client):\n    params = algod_client.suggested_params()\n    add = mnemonic.to_public_key(creator_mnemonic)\n    key = mnemonic.to_private_key(creator_mnemonic)\n    unsigned_txn = transaction.PaymentTxn(\n        add, params, rcv, amt, note=\"Yeah\".encode())\n    signed = unsigned_txn.sign(key)\n    txid = algod_client.send_transaction(signed)\n    pmtx = wait_for_confirmation(algod_client, txid, 5)\n    return pmtx\n\n\n#{\"blockSeed\": \"3P5WUDZKFHH7BLSYJYZUGJ5KLCFO72M7733MVWAE5JXD7N7MY54A\", \"proof\": \"bICa1Ajt27oTDzMf5O02vdfuYNvfBBAsrqr8f05jh0vuqTfHy7yV+82QRCw52erX6rlhzZ6Pdv8XyhWZTvOG4eksdNN6QhAYZyJo408wYgs=\", \"publicKey\": \"H/IBtJ8dSMRjYo344o/gtfiZToq9+cfPOHtCG6dfZ/U=\", \"randNumber\": \"087\"}\n\n\ndef lsig_payment_txn(escrowProg, escrow_address, amt, rcv, algod_client):\n    params = algod_client.suggested_params()\n    unsigned_txn = transaction.PaymentTxn(\n        escrow_address, params, rcv, amt, note='''{\"blockSeed\": \"3P5WUDZKFHH7BLSYJYZUGJ5KLCFO72M7733MVWAE5JXD7N7MY54A\", \"proof\": \"bICa1Ajt27oTDzMf5O02vdfuYNvfBBAsrqr8f05jh0vuqTfHy7yV+82QRCw52erX6rlhzZ6Pdv8XyhWZTvOG4eksdNN6QhAYZyJo408wYgs=\", \"publicKey\": \"H/IBtJ8dSMRjYo344o/gtfiZToq9+cfPOHtCG6dfZ/U=\"}'''.encode())\n    encodedProg = escrowProg.encode()\n    program = base64.decodebytes(encodedProg)\n    lsig = transaction.LogicSig(program)\n    stxn = transaction.LogicSigTransaction(unsigned_txn, lsig)\n    tx_id = algod_client.send_transaction(stxn)\n    pmtx = wait_for_confirmation(algod_client, tx_id, 10)\n    return pmtx\n\n\ndef main():\n    algod_client = algod.AlgodClient(algod_token, algod_address)\n\n    print(\"--------------------------------------------\")\n    print(\"Compiling Donation Smart Signature ...\")\n    stateless_program_teal = verified_random_announcer(\n        receiver_public_key, fee_provider_public_key)\n    escrow_result, escrow_address = compile_smart_signature(\n        algod_client, stateless_program_teal)\n    print(\"Program:\", escrow_result)\n    print(\"Contract Address:\", escrow_address)\n\n    # print(\"--------------------------------------------\")\n    #print(\"Sending Fund to Donation Smart Signature ...\")\n    #amt = 220000\n    #payment_transaction(sender_mnemonic, amt, escrow_address, algod_client)\n\n    # print(\"--------------------------------------------\")\n    #print(\"Withdraw from Donation Smart Signature ...\")\n    #withdrawal_amt = 0\n    # lsig_payment_txn(escrow_result, escrow_address,\n    #                withdrawal_amt, receiver_public_key, algod_client)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"instruction": "Perform an atomic transfer of a user-specified amount of Algo from two predefined accounts on the Algorand testnet to a newly generated receiver account. Display account balances before the transfer, prompt the user for the transfer amount, create and group two transactions, sign them, submit them to the Algorand testnet, and display the transaction ID and confirmation details.", "output": "import os , json\nimport easygui\n\nfrom algosdk import account, mnemonic \nfrom algosdk.v2client import algod\nfrom algosdk.future import transaction\n\nmn1 = 'shuffle speed split bread mansion limb daughter destroy minimum town pistol slam leaf slide potato mule alpha furnace glass humble ladder kiss eight abandon gasp'\nmn2 = 'hazard dust join live water venue few grant neglect road illegal sad mammal demand often must infant horn magic piano goat exchange deny ability tag'\n\ndef createAccount():\n    private_key, address = account.generate_account()\n    print(\"Receiver address: {}\".format(address))\n    print(\"Receivers mnemonic passphrase: {}\".format(mnemonic.from_private_key(private_key)))\n    return private_key, address\n\ndef get_address(mn):\n    pk_account_a = mnemonic.to_private_key(mn)\n    address = account.address_from_private_key(pk_account_a)\n    print(\"Address :\", address)\n    return address\n\ndef getInfo(algod_client, addr):\n    try:\n        accountInfo = algod_client.account_info(addr)\n        return accountInfo\n    except Exception as e:\n        print(\"Error Occured {}\".format(str(e)))\n        exit()\n\n\ndef printAccount(account_info_1, account_info_2, indent=4):\n    try:\n        data = [[account_info_1['address'], account_info_1['amount'] / 1000000],\n                [account_info_2['address'], account_info_2['amount'] / 1000000]]\n        format_row = \"{:<2}{:>12}\"\n        print(\"{:<60} {:<15}\".format(\"Address\",\"Amount(Algo)\"))\n        for account in data:\n            print(format_row.format(*account))\n        print(\"\")\n    except Exception as e:\n        print(\"Error Occur: \" + str(e))\n\n\ndef transfer():\n    try:\n        print(\"########### CHOICE-COIN ATOMIC TRANSFER ##################\")\n           # user declared algod connection parameters\n        algod_address = \"https://testnet-algorand.api.purestake.io/ps2\"\n        algod_token = \"HfiEnjsWGW28EEEdqURGt40hxXT3hVSs6nkGAr9Y\"\n        headers = {\"X-API-Key\": algod_token }\n\n\n        # Initialize an algodClient\n        algod_client = algod.AlgodClient(algod_token, algod_address, headers)\n\n        account_1 = get_address(mn1)\n        account_2 = get_address(mn2)\n\n        account_1_key = mnemonic.to_private_key(mn1)\n        account_2_key = mnemonic.to_private_key(mn2)\n        print('Getting account information....')\n        account_1_info = getInfo(algod_client, account_1)\n        account_2_info = getInfo(algod_client, account_2)\n        printAccount(account_1_info, account_2_info)\n\n\n        print('Generating receivers account...')\n        acount_3_key, account_3 = createAccount()\n\n        amount = easygui.enterbox(\"Algo amount\")\n        amount = int(amount) * 1000000\n        print(\"Creating transactions...\")\n        params = algod_client.suggested_params()\n        txn_1 = transaction.PaymentTxn(account_1, params, account_3, amount)\n        txn_2 = transaction.PaymentTxn(account_2, params, account_3, amount)\n        print('Calculating Group ID...')\n        gid = transaction.calculate_group_id([txn_1, txn_2])\n        txn_1.group = gid\n        txn_2.group = gid\n\n        print('Signing transaction....')\n        stxn_1 = txn_1.sign(account_1_key)\n        stxn_2 = txn_2.sign(account_2_key)\n        signed_group = [stxn_1, stxn_2]\n        print('Sending Transaction')\n        tx_id = algod_client.send_transactions(signed_group)\n        print(\"TransactionId: {}\".format(tx_id))\n        confirmed_txn = transaction.wait_for_confirmation(algod_client, tx_id)\n        print(\"Transaction confirmed\")\n        print(f'Visit https://testnet.algoexplorer.io/tx/{tx_id}')\n        print(\"Transaction information: {}\\n\".format(json.dumps(confirmed_txn)))\n    except Exception as e:\n        print(\"Error occured: \" + str(e))\n\n\n\n\nif __name__ == '__main__':\n    transfer()"}
{"instruction": "Transfer a specified amount of Algos or a specified asset to a receiver account from a sender account on the Algorand network. The amount can be specified in whole units or the smallest divisible units. The network to use can also be specified.", "output": "import logging\n\nimport click\nfrom algokit_utils import AlgoAmount, AssetTransferParams, PaymentParams, SendAtomicTransactionComposerResults\n\nfrom algokit.cli.common.constants import AlgorandNetwork, ExplorerEntityType\nfrom algokit.cli.common.utils import get_explorer_url\nfrom algokit.cli.tasks.utils import (\n    get_account_with_private_key,\n    get_address,\n    get_asset_decimals,\n    load_algod_client,\n    validate_address,\n    validate_balance,\n)\nfrom algokit.core.utils import get_algorand_client_for_network\n\nlogger = logging.getLogger(__name__)\n\n# TODO: upon algokit nfd lookup being implemented receiver will also allow nfd lookups\n\n\n@click.command(name=\"transfer\", help=\"\"\"Transfer algos or assets from one account to another.\"\"\")\n@click.option(\"--sender\", \"-s\", type=click.STRING, help=\"Address or alias of the sender account.\", required=True)\n@click.option(\n    \"--receiver\",\n    \"-r\",\n    type=click.STRING,\n    help=\"Address or alias to an account that will receive the asset(s).\",\n    required=True,\n)\n@click.option(\n    \"--asset\",\n    \"--id\",\n    \"asset_id\",\n    type=click.INT,\n    help=\"Asset ID to transfer. Defaults to 0 (Algo).\",\n    default=0,\n    required=False,\n)\n@click.option(\"--amount\", \"-a\", type=click.INT, help=\"Amount to transfer.\", required=True)\n@click.option(\n    \"--whole-units\",\n    \"whole_units\",\n    is_flag=True,\n    type=click.BOOL,\n    help=(\n        \"Use whole units (Algos | ASAs) instead of smallest divisible units (for example, microAlgos). \"\n        \"Disabled by default.\"\n    ),\n    default=False,\n    required=False,\n)\n@click.option(\n    \"-n\",\n    \"--network\",\n    type=click.Choice([choice.value for choice in AlgorandNetwork]),\n    default=AlgorandNetwork.LOCALNET,\n    required=False,\n    help=f\"Network to use. Refers to `{AlgorandNetwork.LOCALNET}` by default.\",\n)\ndef transfer(  # noqa: PLR0913\n    *,\n    sender: str,\n    receiver: str,\n    asset_id: int,\n    amount: int,\n    whole_units: bool,\n    network: AlgorandNetwork,\n) -> None:\n    # Load addresses and accounts from mnemonics or aliases\n    sender_account = get_account_with_private_key(sender)\n    receiver_address = get_address(receiver)\n\n    # Get algod client\n    algod_client = load_algod_client(network)\n\n    # Convert amount to whole units if specified\n    if whole_units:\n        amount = amount * (10 ** get_asset_decimals(asset_id, algod_client))\n\n    # Validate inputs\n    validate_address(receiver_address)\n    validate_balance(algod_client, sender_account, asset_id, amount)\n    validate_balance(algod_client, receiver_address, asset_id)\n\n    # Transfer algos or assets depending on asset_id\n    txn_response: SendAtomicTransactionComposerResults | None = None\n    algorand = get_algorand_client_for_network(network)\n    try:\n        if asset_id == 0:\n            txn_response = (\n                algorand.new_group()\n                .add_payment(\n                    PaymentParams(\n                        sender=sender_account.address,\n                        receiver=receiver_address,\n                        amount=AlgoAmount(micro_algo=amount),\n                        signer=sender_account.signer,\n                    )\n                )\n                .send()\n            )\n        else:\n            txn_response = (\n                algorand.new_group()\n                .add_asset_transfer(\n                    AssetTransferParams(\n                        sender=sender_account.address,\n                        receiver=receiver_address,\n                        amount=amount,\n                        asset_id=asset_id,\n                        signer=sender_account.signer,\n                    ),\n                )\n                .send()\n            )\n\n        txn_url = get_explorer_url(\n            identifier=txn_response.tx_ids[0],\n            network=network,\n            entity_type=ExplorerEntityType.TRANSACTION,\n        )\n        click.echo(f\"Successfully performed transfer. See details at {txn_url}\")\n\n    except Exception as err:\n        logger.debug(err, exc_info=True)\n        raise click.ClickException(\"Failed to perform transfer\") from err"}
{"instruction": "Implement functions to transfer Algos and Assets between accounts using the Algorand SDK. The functions should handle transaction creation, signing, and sending, including fee management and clawback functionality for asset transfers.", "output": "import dataclasses\nimport logging\nfrom typing import TYPE_CHECKING\n\nimport algosdk.transaction\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner\nfrom algosdk.transaction import AssetTransferTxn, PaymentTxn, SuggestedParams\n\nfrom algokit_utils.models import Account\n\nif TYPE_CHECKING:\n    from algosdk.v2client.algod import AlgodClient\n\n__all__ = [\"TransferParameters\", \"transfer\", \"TransferAssetParameters\", \"transfer_asset\"]\nlogger = logging.getLogger(__name__)\n\n\n@dataclasses.dataclass(kw_only=True)\nclass TransferParametersBase:\n    \"\"\"Parameters for transferring ALGOs between accounts\n\n    Args:\n        from_account (Account | AccountTransactionSigner): The account (with private key) or signer that will send\n            the ALGOs\n        to_address (str): The account address that will receive the ALGOs\n        suggested_params (SuggestedParams | None): (optional) transaction parameters\n        note (str | bytes | None): (optional) transaction note\n        fee_micro_algos (int | None): (optional) The flat fee you want to pay, useful for covering extra fees in a\n            transaction group or app call\n        max_fee_micro_algos (int | None): (optional) The maximum fee that you are happy to pay (default: unbounded)\n            - if this is set it's possible the transaction could get rejected during network congestion\n    \"\"\"\n\n    from_account: Account | AccountTransactionSigner\n    to_address: str\n    suggested_params: SuggestedParams | None = None\n    note: str | bytes | None = None\n    fee_micro_algos: int | None = None\n    max_fee_micro_algos: int | None = None\n\n\n@dataclasses.dataclass(kw_only=True)\nclass TransferParameters(TransferParametersBase):\n    \"\"\"Parameters for transferring ALGOs between accounts\"\"\"\n\n    micro_algos: int\n\n\n@dataclasses.dataclass(kw_only=True)\nclass TransferAssetParameters(TransferParametersBase):\n    \"\"\"Parameters for transferring assets between accounts\n\n    Args:\n       asset_id (int): The asset id that will be transfered\n       amount (int): The amount to send\n       clawback_from (str | None): An address of a target account from which to perform a clawback operation. Please\n           note, in such cases senderAccount must be equal to clawback field on ASA metadata.\n    \"\"\"\n\n    asset_id: int\n    amount: int\n    clawback_from: str | None = None\n\n\ndef _check_fee(transaction: PaymentTxn | AssetTransferTxn, max_fee: int | None) -> None:\n    if max_fee is not None:\n        # Once a transaction has been constructed by algosdk, transaction.fee indicates what the total transaction fee\n        # Will be based on the current suggested fee-per-byte value.\n        if transaction.fee > max_fee:\n            raise Exception(\n                f\"Cancelled transaction due to high network congestion fees. \"\n                f\"Algorand suggested fees would cause this transaction to cost {transaction.fee} ALGOs. \"\n                f\"Cap for this transaction is {max_fee} ALGOs.\"\n            )\n        if transaction.fee > algosdk.constants.MIN_TXN_FEE:\n            logger.warning(\n                f\"Algorand network congestion fees are in effect. \"\n                f\"This transaction will incur a fee of {transaction.fee} ALGOs.\"\n            )\n\n\ndef transfer(client: \"AlgodClient\", parameters: TransferParameters) -> PaymentTxn:\n    \"\"\"Transfer ALGOs between accounts\"\"\"\n\n    params = parameters\n    params.suggested_params = parameters.suggested_params or client.suggested_params()\n    from_account = params.from_account\n    sender = _get_address(from_account)\n    transaction = PaymentTxn(\n        sender=sender,\n        receiver=params.to_address,\n        amt=params.micro_algos,\n        note=params.note.encode(\"utf-8\") if isinstance(params.note, str) else params.note,\n        sp=params.suggested_params,\n    )  # type: ignore[no-untyped-call]\n\n    result = _send_transaction(client=client, transaction=transaction, parameters=params)\n    assert isinstance(result, PaymentTxn)\n    return result\n\n\ndef transfer_asset(client: \"AlgodClient\", parameters: TransferAssetParameters) -> AssetTransferTxn:\n    \"\"\"Transfer assets between accounts\"\"\"\n\n    params = parameters\n    params.suggested_params = parameters.suggested_params or client.suggested_params()\n    sender = _get_address(parameters.from_account)\n    suggested_params = parameters.suggested_params or client.suggested_params()\n    xfer_txn = AssetTransferTxn(\n        sp=suggested_params,\n        sender=sender,\n        receiver=params.to_address,\n        close_assets_to=None,\n        revocation_target=params.clawback_from,\n        amt=params.amount,\n        note=params.note,\n        index=params.asset_id,\n        rekey_to=None,\n    )  # type: ignore[no-untyped-call]\n\n    result = _send_transaction(client=client, transaction=xfer_txn, parameters=params)\n    assert isinstance(result, AssetTransferTxn)\n    return result\n\n\ndef _send_transaction(\n    client: \"AlgodClient\",\n    transaction: PaymentTxn | AssetTransferTxn,\n    parameters: TransferAssetParameters | TransferParameters,\n) -> PaymentTxn | AssetTransferTxn:\n    if parameters.fee_micro_algos:\n        transaction.fee = parameters.fee_micro_algos\n\n    if parameters.suggested_params is not None and not parameters.suggested_params.flat_fee:\n        _check_fee(transaction, parameters.max_fee_micro_algos)\n\n    signed_transaction = transaction.sign(parameters.from_account.private_key)  # type: ignore[no-untyped-call]\n    client.send_transaction(signed_transaction)\n\n    txid = transaction.get_txid()  # type: ignore[no-untyped-call]\n    logger.debug(f\"Sent transaction {txid} type={transaction.type} from {_get_address(parameters.from_account)}\")\n\n    return transaction\n\n\ndef _get_address(account: Account | AccountTransactionSigner) -> str:\n    if type(account) is Account:\n        return account.address\n    else:\n        address = address_from_private_key(account.private_key)  # type: ignore[no-untyped-call]\n        return str(address)"}
{"instruction": "Create an atomic transaction group using the Algorand SDK. The group should include two payment transactions: one transferring 1,000,000 microAlgos from 'receiver_one' to 'receiver_two', and another transferring 1,000,000 microAlgos from 'receiver_two' back to 'receiver_one'. Execute the transaction group to ensure both payments occur atomically.", "output": "'''\nThis script demonstrates how to execute multiple transactions atomically, ensuring all transactions in a group either succeed or fail together.\n\nThis is where you would include any setup code needed, such as:\n\n- Import the necessary libraries and modules:\n  from algokit_utils.beta.algorand_client import *\n- Generate Algorand Accounts\n- Fund the accounts\n\nYou can find all the foundational code in the 'Beginner' folder.\n'''\n\n# Initialize the Algorand Client\nalgorand = AlgorandClient.default_local_net()\n\n# Group transactions for atomic transfer\ngroup_tx = algorand.new_group()\n\n# Add the first payment transaction to the group\ngroup_tx.add_payment(\n    PayParams(\n        sender=receiver_one.address,   # Address of the first sender\n        receiver=receiver_two.address, # Address of the first receiver\n        amount=1_000_000               # Amount to transfer (in microAlgos)\n    ))\n\n# Add the second payment transaction to the group\ngroup_tx.add_payment(\n    PayParams(\n        sender=receiver_two.address,   # Address of the second sender\n        receiver=receiver_one.address, # Address of the second receiver\n        amount=1_000_000               # Amount to transfer (in microAlgos)\n    ))\n\n# Execute the grouped transactions atomically\ngroup_tx.execute()\n\n'''\nAbout atomic transfers:\n- Atomic transfers or swaps ensure that every transaction in a group either all succeed or else all fail.\n- You can use this structure to execute multiple transactions as a single atomic unit.\n\nWhy Use Atomic Transfers?\n- Atomic transfers are essential when you need to ensure consistency and reliability across multiple transactions. For example:\n  - When performing a swap or exchange where multiple parties are involved, you want to ensure that all parts of the transaction complete successfully before finalizing.\n  - In decentralized finance (DeFi) applications, atomic transfers can be used to maintain integrity and prevent partial or failed transactions that could lead to unexpected outcomes.\n\nRemember:\n- Atomic transfers are subject to the Algorand networks transaction limits and fees. Make sure you account for these in your planning.\n- The success of atomic transfers depends on the overall validity of the group transaction. If any single transaction fails validation, the entire group will be rejected.\n'''"}
{"instruction": "Create an Algorand Standard Asset (ASA) called 'BUILDH3R' with a total supply of 1000 units. Create two accounts: a creator and a receiver. Fund both accounts with Algos from a dispenser account. Opt-in the receiver account to the new ASA. Transfer 10 units of the ASA from the creator to the receiver in a group transaction that also includes a payment from the receiver to the creator. Finally, claw back 2 units of the ASA from the receiver to the creator and print the ASA balance of both creator and receiver accounts.", "output": "# import the modules to interactive with the chain\nfrom algokit_utils.beta.algorand_client import (\n    AlgorandClient,\n    AssetCreateParams,\n    AssetOptInParams,\n    AssetTransferParams,\n    PayParams,\n)\n# Create our client\nalgorand = AlgorandClient.default_local_net()\n\n# dispenser.address = public key | dispenser.signer = private key\ndispenser = algorand.account.dispenser()\n#print(\"Dispenser Address:\", dispenser.address)\n\n#Create a Wallet & first algorand account\ncreator = algorand.account.random()\n#print(\"Creator Address:\", creator.address)\n#print(algorand.account.get_information(creator.address))\n\n#Create first transaction\nalgorand.send.payment(\n    PayParams(\n        sender=dispenser.address,\n        receiver=creator.address,\n        amount=10_000_000\n    )\n)\n\n#print(algorand.account.get_information(creator.address))\n\n#Create Token\nsent_txn = algorand.send.asset_create(\n    AssetCreateParams(\n        sender=creator.address,\n        total=1000,\n        asset_name=\"BUILDH3R\",\n        unit_name=\"H3R\",\n        manager=creator.address,\n        clawback=creator.address,\n        freeze=creator.address\n        \n    )\n)\n\n#Extract asset ID to identify in blockchain\nasset_id = sent_txn[\"confirmation\"][\"asset-index\"]\n#print(\"Asset ID\", asset_id)\n\n\n# Create the receiver\nreceiver_vrads = algorand.account.random()\n#print(\"Receiver Address:\", receiver_vrads.address)\n\n# Transfer the asset from creator to receiver\n\nalgorand.send.payment(\n    PayParams(\n        sender=dispenser.address,\n        receiver=receiver_vrads.address,\n        amount=10_000_000\n    )\n)\n\n# The atomic transfer segment : add opt_in\ngroup_tx = algorand.new_group()\n\ngroup_tx.add_asset_opt_in(\n    AssetOptInParams(\n        sender=receiver_vrads.address,\n        asset_id=asset_id\n    )\n)\n\ngroup_tx.add_payment(\n    PayParams(\n        sender=receiver_vrads.address,\n        receiver=creator.address,\n        amount=1_000_000\n    )\n)\n\ngroup_tx.add_asset_transfer(\n    AssetTransferParams(\n        sender=creator.address,\n        receiver=receiver_vrads.address,\n        asset_id=asset_id,\n        amount=10\n    )\n)\n\ngroup_tx.execute()\n\n#print(algorand.account.get_information(receiver_vrads.address))\n\nprint(\"Receiver Account Asset Balance:\", algorand.account.get_information(receiver_vrads.address)['assets'][0]['amount'])\nprint(\"Creator Account Asset Balance:\", algorand.account.get_information(creator.address)['assets'][0]['amount'])\n\nalgorand.send.asset_transfer(\n    AssetTransferParams(\n        sender=creator.address,\n        receiver=creator.address,\n        asset_id=asset_id,\n        amount=2,\n        clawback_target=receiver_vrads.address\n    )\n)\n\nprint(\"Post clawback\")\n\nprint(\"Receiver Account Asset Balance:\", algorand.account.get_information(receiver_vrads.address)['assets'][0]['amount'])\nprint(\"Creator Account Asset Balance:\", algorand.account.get_information(creator.address)['assets'][0]['amount'])"}
{"instruction": "This Algorand smart contract manages a request balance for whitelisted accounts. It allows an admin to set other accounts as admins, whitelist accounts, and allocate request balances to whitelisted accounts. Whitelisted accounts can buy request balances by sending a payment to a designated seller or spend their request balance by sending transactions with a specific note to request a market exchange rate. The contract also handles standard application lifecycle actions like creation, deletion, update, opt-in, and close-out.", "output": "from pyteal import *\n\nADMIN_KEY = Bytes(\"admin\")\nWHITELISTED_KEY = Bytes(\"whitelisted\")\nREQUESTS_BALANCE_KEY = Bytes(\"requests_balance\")\nMAX_BUY_AMOUNT = Int(1000000000)\nMIN_BUY_AMOUNT = Int(10000000)\nREQUESTS_SELLER = Addr(\"N5ICVTFKS7RJJHGWWM5QXG2L3BV3GEF6N37D2ZF73O4PCBZCXP4HV3K7CY\")\nMARKET_EXCHANGE_NOTE = Bytes(\"algo-oracle-app-4\")\n\ndef approval_program():\n    on_creation = Seq([\n        Assert(Txn.application_args.length() == Int(0)),\n        App.localPut(Int(0), ADMIN_KEY, Int(1)),\n        Return(Int(1))\n    ])\n\n    is_contract_admin = App.localGet(Int(0), ADMIN_KEY)\n\n    admin_status = Btoi(Txn.application_args[2])\n    set_admin = Seq([\n        Assert(And(is_contract_admin, Txn.application_args.length() == Int(3), Txn.accounts.length() == Int(1))),\n        App.localPut(Int(1), ADMIN_KEY, admin_status),\n        Return(Int(1))\n    ])\n\n    register = Seq([\n        App.localPut(Int(0), WHITELISTED_KEY, Int(0)),\n        Return(Int(1))\n    ])\n\n    whitelist = Seq([\n        Assert(And(is_contract_admin, Txn.application_args.length() == Int(2), Txn.accounts.length() == Int(1))),\n        App.localPut(Int(1), WHITELISTED_KEY, Int(1)),\n        Return(Int(1))\n    ])\n\n    is_whitelisted = App.localGet(Int(0), WHITELISTED_KEY)\n\n    requests_amount = Btoi(Txn.application_args[1])\n    allocate_requests = Seq([\n        Assert(And(is_contract_admin, Txn.application_args.length() == Int(3), Txn.accounts.length() == Int(1), App.localGet(Int(1), WHITELISTED_KEY))),\n        App.localPut(Int(1), REQUESTS_BALANCE_KEY, App.localGet(Int(1), REQUESTS_BALANCE_KEY) + requests_amount),\n        Return(Int(1))\n    ])\n\n    buy_requests = Seq([\n        Assert(And(is_whitelisted, Global.group_size() == Int(2), Gtxn[0].type_enum() == TxnType.Payment, Gtxn[0].receiver() == REQUESTS_SELLER, Gtxn[0].amount() >= MIN_BUY_AMOUNT, Gtxn[0].amount() <= MAX_BUY_AMOUNT, Txn.group_index() == Int(1), Txn.application_args.length() == Int(2), Txn.accounts.length() == Int(1))),\n        App.localPut(Int(1), REQUESTS_BALANCE_KEY, App.localGet(Int(1), REQUESTS_BALANCE_KEY) + (Gtxn[0].amount() / Int(100000))),\n        Return(Int(1))\n    ])\n\n    market_exchange_rate_request = Seq([\n        Assert(And(is_whitelisted, Txn.note() == MARKET_EXCHANGE_NOTE, Txn.application_args.length() == Int(4), Txn.accounts.length() == Int(0), App.localGet(Int(0), REQUESTS_BALANCE_KEY) >= Int(1))),\n        App.localPut(Int(0), REQUESTS_BALANCE_KEY, App.localGet(Int(0), REQUESTS_BALANCE_KEY) - Int(1)),\n        Return(Int(1))\n    ])\n\n    program = Cond([\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_contract_admin)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_contract_admin)],\n        [Txn.on_completion() == OnComplete.CloseOut, Return(Int(1))],\n        [Txn.on_completion() == OnComplete.OptIn, register],\n        [Txn.application_args[0] == Bytes(\"set_admin\"), set_admin],\n        [Txn.application_args[0] == Bytes(\"whitelist\"), whitelist],\n        [Txn.application_args[0] == Bytes(\"allocate_requests\"), allocate_requests],\n        [Txn.application_args[0] == Bytes(\"buy_requests\"), buy_requests],\n        [Txn.application_args[0] == Bytes(\"get_market_exchange_rate\"), market_exchange_rate_request]\n    ])\n    return program\n\ndef clear_state_program():\n    return Seq([Return(Int(1))])"}
{"instruction": "Create a PyTeal application that validates a group of transactions, ensuring that the group size does not exceed 16 and that all transactions within the group are payment transactions. The application exposes a method that takes a transaction group as input and returns a boolean indicating whether the validation was successful.", "output": "from pyteal import *\nfrom beaker import Application, external, abi\n\nMAX_TXN_GROUP_SIZE = 16\n\nclass AtomicPaymentApp(Application):\n\n    @external\n    def validate_payment_batch(\n        self,\n        txn_group: abi.TransactionGroup,\n        *,\n        output: abi.Bool\n    ):\n        group_size = ScratchVar(TealType.uint64)\n        i = ScratchVar(TealType.uint64)\n\n        return Seq(\n            group_size.store(Len(txn_group.transactions())),\n            Assert(group_size.load() <= Int(MAX_TXN_GROUP_SIZE)),\n            i.store(Int(0)),\n            While(i.load() < group_size.load()).Do(Seq(\n                Assert(txn_group.transactions()[i.load()].type_enum() == TxnType.Payment),\n                i.store(i.load() + Int(1))\n            )),\n            output.set(Int(1))\n        )\n\nAtomicPaymentApp().dump(\"atomic_payment_app\")"}
{"instruction": "Create a PyTeal application called `IndexerInterface` with external methods to simulate fetching data from an indexer. The application includes methods to check if an account exists (always returns true), retrieve a transaction by ID, retrieve an asset by ID (returns a string containing 'Asset: ' and the asset ID), and retrieve application transactions by app ID and round (returns a string containing 'AppID: ', the app ID, ' Round: ', and the round).", "output": "import json\nfrom pyteal import *\nfrom beaker import Application, external, abi\n\nclass IndexerInterface(Application):\n\n    @external\n    def check_account_exists(self, address: abi.Address, *, output: abi.Bool):\n        return output.set(Int(1))\n\n    @external\n    def get_transaction(self, txid: abi.String, *, output: abi.String):\n        return output.set(txid.get())\n\n    @external\n    def get_asset(self, asset_id: abi.Uint64, *, output: abi.String):\n        return output.set(Concat(Bytes(\"Asset: \"), Itob(asset_id.get())))\n\n    @external\n    def get_app_transactions(self, app_id: abi.Uint64, round: abi.Uint64, *, output: abi.String):\n        return output.set(Concat(Bytes(\"AppID: \"), Itob(app_id.get()), Bytes(\" Round: \"), Itob(round.get())))\n\nIndexerInterface().dump(\"indexer_interface\")"}
{"instruction": "Implement a smart contract for voting, allowing users to create proposals, vote 'yes' or 'no', and retrieve the voting result. The contract manages application state for proposal details, start/end times, results, and vote counts. Accounts must opt-in to participate and can only vote if they have staked assets on a different staking application, and they have not already voted. Voters can also clear their vote which will decrement the total votes.", "output": "from pyteal import *\nfrom typing import Final\nfrom beaker import Application, AccountStateValue, ApplicationStateValue, Authorize, bare_external, external, create, opt_in\n\n\nclass Voting(Application):\n    proposal: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    start_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    end_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    result: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    num_of_yays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    num_of_nays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    vote_choice: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.bytes\n    )\n    has_vote: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.uint64\n    )\n\n    @create\n    def create(self):\n        return self.initialize_application_state()\n\n    @opt_in\n    def optin(self):\n        return self.initialize_account_state()\n\n    @external(authorize=Authorize.only(Global.creator_address()))\n    def create_proposal(self, proposal: abi.String, end_time: abi.Uint64):\n        return Seq(\n            self.proposal.set(proposal.get()),\n            self.start_time.set(Global.latest_timestamp()),\n            self.end_time.set(Global.latest_timestamp() + end_time.get())\n        )\n\n    @external(authorize=Authorize.opted_in(Global.current_application_id()))\n    def vote(\n        self,\n        vote_choice: abi.String,\n        key: abi.String,\n        app: abi.Application # type: ignore[assignment]\n    ):\n        return Seq(\n            (is_staking := App.localGetEx(account=Txn.sender(), app=app.application_id(), key=key.get())),\n            Assert(is_staking.hasValue()),\n            Assert(\n                And(\n                    Global.latest_timestamp() >= self.start_time,\n                    Global.latest_timestamp() <= self.end_time\n                )\n            ),\n            Assert(is_staking.value() == Int(1)),\n            Assert(self.has_vote == Int(0)),\n            If(vote_choice.get() == Bytes(\"yes\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"yes\")),\n                self.num_of_yays.increment()\n            )\n            .ElseIf(vote_choice.get() == Bytes(\"no\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"no\")),\n                self.num_of_nays.increment()\n            ),\n            self.has_vote.set(Int(1))\n        )\n\n    @external\n    def get_vote_result(self):\n        return Seq(\n            Assert(Global.latest_timestamp() > self.end_time),\n            If(self.num_of_yays > self.num_of_nays)\n            .Then(self.result.set(Bytes(\"passed\")))\n            .ElseIf(self.num_of_yays < self.num_of_nays)\n            .Then(self.result.set(Bytes(\"rejected\")))\n            .Else(self.result.set(Bytes(\"tie\")))\n        )\n\n    @bare_external(close_out=CallConfig.CALL, clear_state=CallConfig.CALL)\n    def clear_vote(self):\n        return Seq(\n            Assert(self.has_vote == Int(1)),\n            If(self.vote_choice == Bytes(\"yes\"))\n            .Then(\n                Assert(self.num_of_yays >= Int(1)),\n                self.num_of_yays.decrement()\n            )\n            .ElseIf(self.vote_choice == Bytes(\"no\")).\n            Then(\n                Assert(self.num_of_nays >= Int(1)),\n                self.num_of_nays.decrement()\n            ),\n            self.vote_choice.set(Bytes(\"\")),\n            self.has_vote.set(Int(0))\n        )\n\n\nVoting().dump()"}
{"instruction": "Implement a permissioned voting application. The application allows a creator to set registration and voting round ranges, and an asset ID for a voting token. Users can register during the registration period and then vote for either candidate A or candidate B during the voting period by transferring their voting token back to the creator. The contract tracks votes for each candidate and ensures users can only vote once.", "output": "from pyteal import *\n\ndef approval_program():\n    \"\"\"\n    https://developer.algorand.org/solutions/example-permissioned-voting-stateful-smart-contract-application/?query=asset%2520contract\n    To implement a permissioned voting application on Algorand, a central authority is needed to\n    provide users the right to vote. In this example, this is handled by an Algorand Standard\n    Asset. The central authority creates a vote token and then gives voters who have registered\n    one voting token. The voter then registers within a round range with the voting smart\n    contract, by Opting into the contract. Voters then vote by grouping two transactions.\n    The first is a smart contract call to vote for either candidate A or candidate B, and\n    the second is transferring the vote token back to the central authority. Voting is only\n    allowed within the voting range.\n    \"\"\"\n    # Check to see that the application ID is not set, indicating this is a creation call.\n    # Store the creator address to global state.\n    # Store both register and voting round ranges to global state.\n    # Store Asset ID to global state\n    on_creation = Seq([\n        App.globalPut(Bytes(\"Creator\"), Txn.sender()),\n        Assert(Txn.application_args.length() == Int(5)),\n        App.globalPut(Bytes(\"RegBegin\"), Btoi(Txn.application_args[0])),\n        App.globalPut(Bytes(\"RegEnd\"), Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"VoteBegin\"), Btoi(Txn.application_args[2])),\n        App.globalPut(Bytes(\"VoteEnd\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"AssetID\"), Btoi(Txn.application_args[4])),\n        Return(Int(1))\n    ])\n\n    # Always verify that the RekeyTo property of any transaction is set to the ZeroAddress\n    # unless the contract is specifically involved ina rekeying operation.\n    no_rekey_addr = Txn.rekey_to() == Global.zero_address()\n\n    # Checks whether the sender is creator.\n    is_creator = Txn.sender() == App.globalGet(Bytes(\"Creator\"))\n\n    # Checks whether sender has voted before or not.\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n\n    on_closeout = Seq([\n        get_vote_of_sender,\n        If(And(Global.round() <= App.globalGet(Bytes(\"VoteEnd\")), get_vote_of_sender.hasValue()),\n            App.globalPut(get_vote_of_sender.value(), App.globalGet(get_vote_of_sender.value()) - Int(1))\n        ),\n        Return(Int(1))\n    ])\n\n    # Checks that the first argument to the smart contract is the word register.\n    # Verifies that the round is currently between registration begin and end rounds.\n    on_register = Return(\n        And(\n        no_rekey_addr,\n        Txn.application_args[0] == Bytes(\"register\"),\n        Global.round() >= App.globalGet(Bytes(\"RegBegin\")),\n        Global.round() <= App.globalGet(Bytes(\"RegEnd\")))\n    )\n\n    # Verifies the first application argument contains the string vote.\n    # Verifies the vote call is between the beginning and end of the voting round ranges.\n    # Verifies that two transactions are in the group.\n    # Checks that the second transaction is an asset transfer, and the token transferred is the vote token.\n    # Checks that the second transaction receiver is the creator of the application.\n    # Checks if the account has already voted, and if so, just returns true with no change to global state.\n    # Verifies that the user is either voting for candidate A or B.\n    # Reads the candidates current total from the global state and increments the value.\n    # Stores the candidate choice to the users local state.\n    choice = Txn.application_args[1]\n    choice_tally = App.globalGet(choice)\n    on_vote = Seq([\n        Assert(And(\n            no_rekey_addr,\n            Global.round() >= App.globalGet(Bytes(\"VoteBegin\")),\n            Global.round() <= App.globalGet(Bytes(\"VoteEnd\"))\n        )),\n        Assert(And(\n            Global.group_size() == Int(2),\n            Gtxn[1].type_enum() == TxnType.AssetTransfer,\n            Gtxn[1].asset_receiver() == App.globalGet(Bytes(\"Creator\")),\n            Gtxn[1].xfer_asset() == App.globalGet(Bytes(\"AssetID\")),\n            Gtxn[1].asset_amount() == Int(1),\n            Or(choice == Bytes(\"candidatea\"), choice == Bytes(\"candidateb\"))\n        )),\n        get_vote_of_sender,\n        If(get_vote_of_sender.hasValue(),\n            Return(Int(0))\n        ),\n        App.globalPut(choice, choice_tally + Int(1)),\n        App.localPut(Int(0), Bytes(\"voted\"), choice),\n        Return(Int(1))\n    ])\n\n    # Verfies that the application_id is 0, jumps to on_creation.\n    # Verifies that DeleteApplication is used and verifies that sender is creator.\n    # Verifies that UpdateApplication is used and verifies that sender is creator.\n    # Verifies that closeOut is used and jumps to on_closeout.\n    # Verifies that the account has opted in and jumps to on_register.\n    # Verifies that first argument is \"vote\" and jumps to on_vote.\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, on_register],\n        [Txn.application_args[0] == Bytes(\"vote\"), on_vote]\n    )\n\n    return program\n\noptimize_options = OptimizeOptions(scratch_slots=True)\nif __name__ == \"__main__\":\n    print(compileTeal(approval_program(), Mode.Application, version = 5, optimize=optimize_options))"}
{"instruction": "Implement a vote escrow contract that allows users to lock governance tokens for a specified duration to receive veTokens. The contract manages user lock information, total locked tokens, total veTokens, and DAO addresses, enabling administrative functions such as setting the governance token ID and an admin contract application ID. It includes creation, opt-in, and close-out functionalities, along with logic for managing token deposits, lock extensions, and withdrawals, calculating veToken amounts, and handling user boosts and lock expirations.", "output": "\"\"\"Vote Escrow Contract\"\"\"\n\nfrom pyteal import *\n\nfrom contracts.governance.constants import *\nfrom contracts.governance.contract_strings import VotingEscrowStrings\nfrom contracts.governance.subroutines import (\n    MagicAssert,\n    decrement,\n    increment,\n    opt_into_asa,\n    send_asa,\n    verify_txn_is_sending_asa_to_contract,\n)\nfrom contracts.utils.wrapped_var import *\n\n\nclass VotingEscrowUser:\n    \"\"\"Data structure for user state in the voting escrow contract\"\"\"\n\n    def __init__(self, user_index):\n        # LOCAL STATE\n        self.amount_locked = WrappedVar(\n            VotingEscrowStrings.user_amount_locked, LOCAL_VAR, user_index\n        )\n        self.lock_start_time = WrappedVar(\n            VotingEscrowStrings.user_lock_start_time,\n            LOCAL_VAR,\n            user_index,\n        )\n        self.lock_duration = WrappedVar(\n            VotingEscrowStrings.user_lock_duration, LOCAL_VAR, user_index\n        )\n        self.amount_vebank = WrappedVar(\n            VotingEscrowStrings.user_amount_vebank, LOCAL_VAR, user_index\n        )\n        self.boost_multiplier = WrappedVar(\n            VotingEscrowStrings.user_boost_multiplier,\n            LOCAL_VAR,\n            user_index,\n        )\n        self.update_time = WrappedVar(\n            VotingEscrowStrings.user_last_update_time,\n            LOCAL_VAR,\n            user_index,\n        )\n\n    def get_lock_end_time(self):\n        \"\"\"Get the time at which the lock expires\"\"\"\n        return self.lock_start_time.get() + self.lock_duration.get()\n\n\nclass VotingEscrow:\n    \"\"\"Vote Escrow Contract\"\"\"\n\n    def __init__(self):\n        # GLOBAL STATE\n        self.dao_address = WrappedVar(\n            VotingEscrowStrings.dao_address, GLOBAL_VAR\n        )\n        self.emergency_dao_address = WrappedVar(\n            VotingEscrowStrings.emergency_dao_address, GLOBAL_VAR\n        )\n        self.asset_id = WrappedVar(\n            VotingEscrowStrings.asset_id, GLOBAL_VAR\n        )\n        self.total_locked = WrappedVar(\n            VotingEscrowStrings.total_locked, GLOBAL_VAR\n        )\n        self.total_vebank = WrappedVar(\n            VotingEscrowStrings.total_vebank, GLOBAL_VAR\n        )\n        self.admin_contract_app_id = WrappedVar(\n            VotingEscrowStrings.admin_contract_app_id, GLOBAL_VAR\n        )\n\n        # HELPER CLASSES\n        self.sending_user = VotingEscrowUser(Int(0))\n        self.target_user = VotingEscrowUser(Int(1))\n\n    # CREATION\n\n    def on_creation(self):\n        \"\"\"Creates the voting escrow contract\"\"\"\n        dao_address = Txn.accounts[1]\n        emergency_dao_address = Txn.accounts[2]\n\n        return Seq(\n            self.dao_address.put(dao_address),\n            self.emergency_dao_address.put(emergency_dao_address),\n            self.total_vebank.put(ZERO_AMOUNT),\n            self.total_locked.put(ZERO_AMOUNT),\n            Approve(),\n        )\n\n    # ADMIN\n\n    def on_set_admin_contract_app_id(self):\n        admin_contract_app_id = Txn.applications[1]\n        return Seq(\n            self.admin_contract_app_id.put(admin_contract_app_id),\n            Approve(),\n        )\n\n    def on_set_gov_token_id(self):\n        return Seq(\n            self.asset_id.put(Txn.assets[0]),\n            opt_into_asa(self.asset_id.get()),\n            Approve(),\n        )\n\n    # OPT IN / CLOSE OUT\n\n    def on_opt_in(self):\n        return Seq(\n            MagicAssert(Gtxn[PREVIOUS_TRANSACTION].sender() == Txn.sender()),\n            MagicAssert(Gtxn[PREVIOUS_TRANSACTION].application_id() == self.admin_contract_app_id.get()),\n            MagicAssert(Gtxn[PREVIOUS_TRANSACTION].on_completion() == OnComplete.OptIn),\n            Approve(),\n        )\n\n    def on_close_out(self):\n        return Seq(\n            MagicAssert(self.sending_user.amount_locked.get() == ZERO_AMOUNT),\n            Approve(),\n        )\n\n    # Additional logic omitted for brevity\n\n    def approval_program(self):\n        sender_is_dao = Or(\n            Txn.sender() == self.dao_address.get(),\n            Txn.sender() == self.emergency_dao_address.get(),\n        )\n        is_no_op = Txn.on_completion() == OnComplete.NoOp\n        is_opt_in = Txn.on_completion() == OnComplete.OptIn\n        is_close_out = Txn.on_completion() == OnComplete.CloseOut\n        on_call_method = Txn.application_args[0]\n\n        return Cond(\n            [Txn.application_id() == Int(0), self.on_creation()],\n            [Txn.on_completion() == OnComplete.DeleteApplication, Reject()],\n            [is_opt_in, self.on_opt_in()],\n            [is_close_out, self.on_close_out()],\n            [sender_is_dao,\n                Cond([\n                    [is_no_op, Cond([\n                        [on_call_method == Bytes(VotingEscrowStrings.set_gov_token_id), self.on_set_gov_token_id()],\n                        [on_call_method == Bytes(VotingEscrowStrings.set_admin_contract_app_id), self.on_set_admin_contract_app_id()],\n                    ])]\n                ])\n            ]\n        )\n\n    def clear_state_program(self):\n        return Seq(\n            decrement(self.total_vebank, self.sending_user.amount_vebank.get()),\n            decrement(self.total_locked, self.sending_user.amount_locked.get()),\n            Approve(),\n        )"}
{"instruction": "Implement the clear state program logic: If the user voted in the current voting round, approve the transaction. Otherwise, if the user voted in a previous round, reimburse the user for the box storage cost and delete the box. Finally, approve the transaction.", "output": "from pyteal import *\nfrom .key_map import key_map\nimport sys\nimport pathlib\nimport os\nfrom voting_approval import hash_type\nsys.path.append(os.path.join(pathlib.Path(__file__).parent.resolve(),'../..'))\nfrom utils.abi_types import LocalHistoryEntry,ProposalsEntry\nfrom utils.gora_pyteal_utils import calc_box_cost,SmartAssert\nglobal_keys = key_map[\"voting_global\"]\nmain_local_keys = key_map[\"main_local\"]\n\ndef on_clear_logic():\n    MAIN_APP = App.globalGet(global_keys[\"main_app\"])\n    current_round = App.globalGet(global_keys[\"round\"])\n    local_stake_account_pk = App.localGetEx(Txn.accounts[1], MAIN_APP, main_local_keys[\"local_public_key\"])\n\n    return Seq([\n        local_stake_account_pk,\n        SmartAssert(local_stake_account_pk.value() == Txn.sender()),\n        (previous_vote_bytes := App.box_get(Txn.accounts[1])),\n        previous_vote_bytes,\n        (previous_vote := LocalHistoryEntry()).decode(previous_vote_bytes.value()),\n        (previous_proposal_entry := ProposalsEntry()).set(previous_vote.proposal_entry),\n        (sender_vote_round := abi.Uint64()).set(previous_proposal_entry.vote_round),\n        (sender_vote_hash := abi.make(hash_type)).set(previous_proposal_entry.vote_hash),\n        If(sender_vote_round.get() == current_round)\n        .Then(\n            Approve()\n        )\n        .ElseIf(\n            sender_vote_round.get() < current_round\n        )\n        .Then(\n            Seq([\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields({\n                    TxnField.type_enum: TxnType.Payment,\n                    TxnField.receiver: Txn.sender(),\n                    TxnField.amount: calc_box_cost(abi.size_of(hash_type),abi.size_of(ProposalsEntry))\n                }),\n                InnerTxnBuilder.Submit(),\n                App.box_delete(sender_vote_hash.get())\n            ])\n        ),\n        Approve()\n    ])"}
{"instruction": "Implement a voting application smart contract with the following functionality: Upon creation, the contract initializes global state with the application name, descriptions for two voting options ('Option A' and 'Option B'), the creator's address, and the block numbers for the registration and voting periods (RegBegin, RegEnd, VoteBegin, VoteEnd). The contract allows users to opt-in during the registration period. A 'vote' call allows users to cast their vote for either 'Option A' or 'Option B' during the voting period, updating the corresponding tally in global state and recording their vote in their local state. On closeout (app deletion), if the voting period hasn't ended and the user has voted, their vote is removed from the global tally. Only the creator can update or delete the application.", "output": "from pyteal import *\n\ndef approval_program():\n    on_creation = Seq(\n        [\n            # name of this application\n            App.globalPut(Bytes(\"AppName\"), Bytes(\"Community 1 Governance Application\")),\n            # choice A\n            App.globalPut(Bytes(\"Option A\"), Bytes(\"Description for option one.\")),\n            # choice B\n            App.globalPut(Bytes(\"Option B\"), Bytes(\"Description for option two.\")),\n            # creator is set to the contract creator\n            App.globalPut(Bytes(\"Creator\"), Txn.sender()),\n            # expecting four arguments for the registration and voting time frames\n            Assert(Txn.application_args.length() == Int(4)),\n            # registration begins blockround\n            App.globalPut(Bytes(\"RegBegin\"), Btoi(Txn.application_args[0])),\n            # registration ending blockround\n            App.globalPut(Bytes(\"RegEnd\"), Btoi(Txn.application_args[1])),\n            # vote begining blockround\n            App.globalPut(Bytes(\"VoteBegin\"), Btoi(Txn.application_args[2])),\n            # vote ending blockround\n            App.globalPut(Bytes(\"VoteEnd\"), Btoi(Txn.application_args[3])),\n            Return(Int(1)),\n        ]\n    )\n\n    # checks to see if txn sender is the contract creator\n    is_creator = Txn.sender() == App.globalGet(Bytes(\"Creator\"))\n\n    # this gets the sender vote from an external application's local state\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n\n    # when delete app is called get vote of sender is called and the if statement is called\n    on_closeout = Seq(\n        [\n            get_vote_of_sender,\n            # if vote hasnt ended and the user has voted, we delete their vote\n            If(\n                And(\n                    Global.round() <= App.globalGet(Bytes(\"VoteEnd\")),\n                    get_vote_of_sender.hasValue(),\n                ),\n                App.globalPut(\n                    get_vote_of_sender.value(),\n                    App.globalGet(get_vote_of_sender.value()) - Int(1),\n                ),\n            ),\n            # otherwise we just approve the app deletion\n            Return(Int(1)),\n        ]\n    )\n\n    # checks that the registration period is active before approving opt in\n    on_register = Return(\n        And(\n            Global.round() >= App.globalGet(Bytes(\"RegBegin\")),\n            Global.round() <= App.globalGet(Bytes(\"RegEnd\")),\n        )\n    )\n\n    # first app arg is assigned to choice variable\n    choice = Txn.application_args[1]\n    # gets the current choice count value\n    choice_tally = App.globalGet(choice)\n\n    # this is the only noop call in this application\n    on_vote = Seq(\n        [\n            # first we check that the voting period is active\n            Assert(\n                And(\n                    Global.round() >= App.globalGet(Bytes(\"VoteBegin\")),\n                    Global.round() <= App.globalGet(Bytes(\"VoteEnd\")),\n                )\n            ),\n            # next the vote of the txn sender is retrieved\n            get_vote_of_sender,\n            # if the vote exists then we continue executing the sequence\n            If(get_vote_of_sender.hasValue(), Return(Int(0))),\n            # the choice key is accessed and the tally is updated by adding one \n            App.globalPut(choice, choice_tally + Int(1)),\n            # records the voter's choice in the voted key of the voter's local state\n            App.localPut(Int(0), Bytes(\"voted\"), choice),\n            Return(Int(1)),\n        ]\n    )\n\n    program = Cond(\n        [Txn.application_id() == Int(0), on_creation],\n        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],\n        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],\n        [Txn.on_completion() == OnComplete.OptIn, on_register],\n        [Txn.application_args[0] == Bytes(\"vote\"), on_vote],\n    )\n\n    return program\n\n\ndef clear_state_program():\n    # gets the vote of the voted value from the external app\n    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes(\"voted\"))\n    program = Seq(\n        [\n            get_vote_of_sender,\n            # if the vote has not ended, then remove the account's vote\n            If(\n                And(\n                    Global.round() <= App.globalGet(Bytes(\"VoteEnd\")),\n                    get_vote_of_sender.hasValue(),\n                ),\n                App.globalPut(\n                    get_vote_of_sender.value(),\n                    App.globalGet(get_vote_of_sender.value()) - Int(1),\n                ),\n            ),\n            Return(Int(1)),\n        ]\n    )\n\n    return program\n\n\nif __name__ == \"__main__\":\n    with open(\"vote_approval.teal\", \"w\") as f:\n        compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)\n        f.write(compiled)\n\n    with open(\"vote_clear_state.teal\", \"w\") as f:\n        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)\n        f.write(compiled)"}
{"instruction": "Implement a smart contract for voting on proposals, allowing users to vote 'yes' or 'no'. The contract manages proposal creation with a specified end time, voting based on staking status, result calculation, and clearing votes. State variables track proposal details, voting times, vote counts, and individual voter choices.", "output": "from pyteal import *\nfrom typing import Final\nfrom beaker import Application, AccountStateValue, ApplicationStateValue, Authorize, bare_external, external, create, opt_in\n\n\nclass Voting(Application):\n    proposal: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    start_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    end_time: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    result: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.bytes\n    )\n    num_of_yays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    num_of_nays: Final[ApplicationStateValue] = ApplicationStateValue(\n        stack_type=TealType.uint64\n    )\n    vote_choice: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.bytes\n    )\n    has_vote: Final[AccountStateValue] = AccountStateValue(\n        stack_type=TealType.uint64\n    )\n\n    @create\n    def create(self):\n        return self.initialize_application_state()\n\n    @opt_in\n    def optin(self):\n        return self.initialize_account_state()\n\n    @external(authorize=Authorize.only(Global.creator_address()))\n    def create_proposal(self, proposal: abi.String, end_time: abi.Uint64):\n        return Seq(\n            self.proposal.set(proposal.get()),\n            self.start_time.set(Global.latest_timestamp()),\n            self.end_time.set(Global.latest_timestamp() + end_time.get())\n        )\n\n    @external(authorize=Authorize.opted_in(Global.current_application_id()))\n    def vote(\n        self,\n        vote_choice: abi.String,\n        key: abi.String,\n        app: abi.Application # type: ignore[assignment]\n    ):\n        return Seq(\n            (is_staking := App.localGetEx(account=Txn.sender(), app=app.application_id(), key=key.get())),\n            Assert(is_staking.hasValue()),\n            Assert(\n                And(\n                    Global.latest_timestamp() >= self.start_time,\n                    Global.latest_timestamp() <= self.end_time\n                )\n            ),\n            Assert(is_staking.value() == Int(1)),\n            Assert(self.has_vote == Int(0)),\n            If(vote_choice.get() == Bytes(\"yes\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"yes\")),\n                self.num_of_yays.increment()\n            )\n            .ElseIf(vote_choice.get() == Bytes(\"no\"))\n            .Then(\n                self.vote_choice.set(Bytes(\"no\")),\n                self.num_of_nays.increment()\n            ),\n            self.has_vote.set(Int(1))\n        )\n\n    @external(authorize=Authorize.only(Global.creator_address()))\n    def get_vote_result(self, *, output: abi.String):\n        return Seq(\n            Assert(Global.latest_timestamp() > self.end_time),\n            If(self.num_of_yays > self.num_of_nays)\n            .Then(self.result.set(Bytes(\"passed\")))\n            .ElseIf(self.num_of_yays < self.num_of_nays)\n            .Then(self.result.set(Bytes(\"rejected\")))\n            .Else(self.result.set(Bytes(\"undecided\"))),\n            output.set(self.result)\n        )\n\n    @bare_external(close_out=CallConfig.CALL, clear_state=CallConfig.CALL)\n    def clear_vote(self):\n        return Seq(\n            Assert(self.has_vote == Int(1)),\n            If(self.vote_choice == Bytes(\"yes\"))\n            .Then(\n                Assert(self.num_of_yays > Int(0)),\n                self.num_of_yays.decrement()\n            )\n            .ElseIf(self.vote_choice == Bytes(\"no\"))\n            .Then(\n                Assert(self.num_of_nays > Int(0)),\n                self.num_of_nays.decrement()\n            ),\n            self.vote_choice.set(Bytes(\"\")),\n            self.has_vote.set(Int(0))\n        )\n\n\nVoting().dump()"}
{"instruction": "The code defines functions for creating ABI method signatures and tuples, and a function `make_request` that constructs ABI-encoded request and destination tuples, then performs an inner transaction method call to a main application with arguments including these tuples and various references (apps, assets, accounts, boxes).  It also defines functions for loading JSON files to get ABI methods and error strings.", "output": "# pylint: disable=W1514,W0401,C0114,C0116,C0115,C0103,W0105,W0614,C0301,R0913\nimport json\nimport sys\nimport os\nfrom pyteal import *\nfrom .abi_types import *\nfrom .inline import InlineAssembly\nfrom assets.abi import ABI_PATH,system_delima\n\n\n\nmain_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}main-contract.json\"))\nvoting_contract_abi = json.load(open(ABI_PATH + f\"{system_delima}voting-contract.json\"))\nsmart_assert_errors = json.load(open(ABI_PATH + f\"{system_delima}..{system_delima}smart_assert_errors.json\"))\n\n# This is not used as it hard codes the costs of a box\n# But is kept here as a record of how it is calculated\n# The current method is by checking min balances before\n# and after the box is created.\n# def calc_box_cost(key_size_bytes:int,box_size_bytes:int):\n#     # (2500 per box) + (400 * (key size + box size))\n#     if key_size_bytes > 64:\n#         raise Exception(\"key size is over 64 bytes\")\n#     cost = (\n#         Int(2500) + Int(400) * \n#         (\n#             Int(key_size_bytes) +\n#             Int(box_size_bytes)\n#         )\n#     )\n#     return cost\n\ndef get_abi_method(method_name,contract:str):\n    method_dict = {\n        \"main\": main_contract_abi[\"methods\"],\n        \"voting\": voting_contract_abi[\"methods\"]\n    }\n    method_list = method_dict[contract]\n    for method in method_list:\n        if method[\"name\"] == method_name:\n            return method\n    return None\n\ndef get_method_signature(method_name, contract:str):\n    method = get_abi_method(method_name,contract)\n    if method is None:\n        raise RuntimeError\n    signature = method_name + \"(\"\n    num_args = len(method[\"args\"])\n    for index, arg in enumerate(method[\"args\"]):\n        signature += arg[\"type\"] \n        if index < num_args - 1:\n            signature += \",\"\n        else:\n            signature += f'){method[\"returns\"][\"type\"]}'\n            return signature\n\n@ABIReturnSubroutine\ndef create_source_tuple(\n    source_id: Expr, #Int\n    source_arg_list: Expr, #Bytes\n    max_age: Expr,\n    *,\n    output: SourceSpec\n) -> Expr: #Int\n    return Seq([\n        (source_id_param := abi.Uint32()).set(source_id),\n        (source_arg_list_param := abi.DynamicBytes()).set(source_arg_list),\n        (max_age_param := abi.Uint64()).set(max_age),\n        output.set(\n            source_id_param,\n            source_arg_list_param,\n            max_age_param\n        ),\n    ])\n\n\"\"\"\nKEEP IN MIND THAT WHEN MAKING A REQUEST YOU WILL NEED TO INCLUDE \nTHE BOX REFERENCE OF Concat(<REQUEST_SENDER_PK>, KEY)\n\nSourceSpec: SourceSpec that is already encoded\naggregation: pyteal.Int\nuser_data: pyteal.Bytes\nmethod_signature: pyteal.Bytes\napp_id: pyteal.Int\ngoracle_main_app_id: pyteal.Int\nrequest_types: pyteal.Int\nkey: pyteal.Bytes\n\"\"\"\n@Subroutine(TealType.none)\ndef make_request(\n    source_specs: abi.DynamicArray[SourceSpec],\n    aggregation: Expr, #Int\n    user_data: Expr, #Bytes\n    app_id: Expr, #Int\n    method_signature: Expr, #Bytes\n    goracle_main_app_id: Expr,  #Int\n    request_type: Expr,\n    key: Expr,\n    app_refs: Expr, #static array of uint64\n    asset_refs: Expr, #static array of uint64\n    account_refs: Expr, #static array of byte[32]\n    box_refs: Expr # dynamic array of  (byte[],uint64)\n): # Int\n\n    request_tuple = abi.make(RequestSpec)\n    destination_tuple = abi.make(DestinationSpec)\n\n    return Seq([\n        (user_data_param := abi.DynamicBytes()).set(user_data),\n        (agg_param := abi.Uint32()).set(aggregation),\n        (app_id_param := abi.Uint64()).set(app_id),\n        (request_type_param := abi.Uint64()).set(request_type),\n        (method_sig_param := abi.DynamicBytes()).set(method_signature),\n        (key_abi := abi.DynamicBytes()).set(key),\n\n        request_tuple.set(\n            source_specs,\n            agg_param,\n            user_data_param\n        ),\n\n        destination_tuple.set(\n            app_id_param,\n            method_sig_param\n        ),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.MethodCall(\n            app_id=goracle_main_app_id,\n            method_signature=get_method_signature(\"request\",\"main\"),\n            args=[\n                request_tuple.encode(),\n                destination_tuple.encode(),\n                request_type_param.encode(),\n                key_abi.encode(),\n                app_refs,\n                asset_refs,\n                account_refs,\n                box_refs\n            ],\n            extra_fields={\n                TxnField.fee: Int(0)\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n    ])\n\n... [truncated for brevity; full output continues in the original] ..."}
{"instruction": "Implement a smart contract that manages a Decentralized Autonomous Organization (DAO) with functionalities including deploying the contract, initializing with an asset, activating proposals (creating a new application based on a successful vote), deactivating the contract, voting on proposals, reclaiming assets after voting, proposing new applications, ending voting rounds, invoking other applications with added checks and account rekeying, and handling clear state calls.", "output": "#!/usr/bin/env python3\n\nfrom configparser import NoOptionError\nimport json\n\nfrom pyteal import * \n\nrouter = Router(\"ExtendableDAO\")\n\n\n@router.method(no_op=CallConfig.CREATE)\ndef deploy(name: abi.String, *, output: abi.Bool) -> Expr:\n    return Seq(\n        App.globalPut(Bytes(\"uninitialised\"), Int(1)),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef initialise(token: abi.Asset, *, output: abi.Bool) -> Expr:\n    return Seq(\n        Assert(App.globalGet(Bytes(\"uninitialised\"))),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: Global.current_application_address(),\n                TxnField.xfer_asset: token.asset_id(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(Bytes(\"asset_id\"), token.asset_id()),\n        App.globalDel(Bytes(\"uninitialised\")),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef activate(app: abi.Application, *, output: abi.Uint64) -> Expr:\n    proposal_for = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_for\"),\n    )\n    proposal_against = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_against\"),\n    )\n    return Seq(\n        votes_for := App.globalGetEx(Global.current_application_id(), proposal_for),\n        votes_against := App.globalGetEx(Global.current_application_id(), proposal_against),\n        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),\n        Assert(Not(voting_allowed.hasValue())),\n        Assert(votes_for.hasValue()),\n        Assert(votes_against.hasValue()),\n        Assert(votes_for.value() > votes_against.value()),\n        app_approval := AppParam.approvalProgram(app.application_id()),\n        Assert(app_approval.hasValue()),\n        app_clearstate := AppParam.clearStateProgram(app.application_id()),\n        Assert(app_clearstate.hasValue()),\n        app_global_byteslices := AppParam.globalNumByteSlice(app.application_id()),\n        app_global_ints := AppParam.globalNumUint(app.application_id()),\n        app_local_byteslices := AppParam.localNumByteSlice(app.application_id()),\n        app_local_ints := AppParam.localNumUint(app.application_id()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.ApplicationCall,\n                TxnField.application_args: [MethodSignature(\"deploy()bool\")],\n                TxnField.approval_program: app_approval.value(),\n                TxnField.clear_state_program: app_clearstate.value(),\n                TxnField.global_num_byte_slices: app_global_byteslices.value(),\n                TxnField.global_num_uints: app_global_ints.value(),\n                TxnField.local_num_byte_slices: app_local_byteslices.value(),\n                TxnField.local_num_uints: app_local_ints.value(),\n                TxnField.fee: Int(0),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        App.globalDel(proposal_for),\n        App.globalDel(proposal_against),\n        output.set(InnerTxn.created_application_id()),\n    )\n\n\n@router.method(delete_application=CallConfig.CALL)\ndef deactivate(*, output: abi.Bool) -> Expr:\n    return output.set(True)\n\n\n@router.method(no_op=CallConfig.CALL,opt_in=CallConfig.CALL)\ndef vote(\n    app: abi.Application, votes: abi.AssetTransferTransaction, for_or_against: abi.Bool, *, output: abi.Bool\n) -> Expr:\n    prop_for_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_for\"),\n    )\n    prop_against_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_against\"),\n    )\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        (proposal_for := ScratchVar()).store(prop_for_bytes),\n        (proposal_against := ScratchVar()).store(prop_against_bytes),\n        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),\n        Assert(voting_allowed.hasValue()),\n        Assert(votes.get().asset_receiver() == Global.current_application_address()),\n        Assert(votes.get().xfer_asset() == asset_id),\n        If(for_or_against.get(), Seq(\n            App.localPut(Int(0), proposal_for.load(), App.localGet(Int(0), proposal_for.load()) + votes.get().asset_amount()),\n            App.globalPut(proposal_for.load(), App.globalGet(proposal_for.load()) + votes.get().asset_amount()),\n        ), Seq(\n            App.localPut(Int(0), proposal_against.load(), App.localGet(Int(0), proposal_against.load()) + votes.get().asset_amount()),\n            App.globalPut(proposal_against.load(), App.globalGet(proposal_against.load()) + votes.get().asset_amount()),\n        )),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef reclaim(app: abi.Application, asset: abi.Asset, *, output: abi.Uint64) -> Expr:\n    prop_for_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_for\"),\n    )\n    prop_against_bytes = Concat(\n        Bytes(\"proposal_\"),\n        Itob(app.application_id()),\n        Bytes(\"_against\"),\n    )\n    asset_id = App.globalGet(Bytes(\"asset_id\"))\n    return Seq(\n        Assert(asset_id == asset.asset_id()),\n        (total := ScratchVar(TealType.uint64)).store(\n            App.localGet(Int(0), prop_for_bytes) + App.localGet(Int(0), prop_against_bytes)\n        ),\n        Assert(total.load()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.AssetTransfer,\n                TxnField.asset_receiver: Txn.sender(),\n                TxnField.xfer_asset: asset_id,\n                TxnField.asset_amount: total.load(),\n            }\n        ),\n        InnerTxnBuilder.Submit(),\n        votes_for := App.globalGetEx(Global.current_application_id(), prop_for_bytes),\n        votes_against := App.globalGetEx(Global.current_application_id(), prop_against_bytes),\n        # Reduce global for\n        If(votes_for.hasValue()).Then(\n            App.globalPut(prop_for_bytes, App.globalGet(prop_for_bytes) - App.localGet(Int(0), prop_for_bytes)),\n        ),\n        # Reduce global against\n        If(votes_against.hasValue()).Then(\n            App.globalPut(prop_against_bytes, App.globalGet(prop_against_bytes) - App.localGet(Int(0), prop_against_bytes)),\n        ),\n        # Delete local amounts\n        App.localDel(Int(0), prop_for_bytes),\n        App.localDel(Int(0), prop_against_bytes),\n        output.set(total.load()),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef propose(appl: abi.ApplicationCallTransaction, *, output: abi.Uint64) -> Expr:\n    proposal_for = Concat(\n        Bytes(\"proposal_\"),\n        Itob(appl.get().created_application_id()),\n        Bytes(\"_for\"),\n    )\n    proposal_against = Concat(\n        Bytes(\"proposal_\"),\n        Itob(appl.get().created_application_id()),\n        Bytes(\"_against\"),\n    )\n    return Seq(\n        Assert(appl.get().type_enum() == TxnType.ApplicationCall),\n        Assert(Not(appl.get().application_id())),\n        Assert(appl.get().on_completion() == OnComplete.NoOp),\n        (new_app_pages := AppParam.extraProgramPages(appl.get().created_application_id())),\n        Assert(Not(new_app_pages.value())),\n        Comment(\"TODO: Some sort of validation on proposed app\"),\n        (new_app_approval := AppParam.approvalProgram(appl.get().created_application_id())),\n        Assert(Extract(new_app_approval.value(), Int(1), Int(4)) == Bytes(\"base16\", \"0x20020100\")),\n        Comment(\"TODO: Some sort of validation on proposed app\"),\n        (new_app_clearstate := AppParam.clearStateProgram(appl.get().created_application_id())),\n        Assert(new_app_clearstate.hasValue()),\n        App.globalPut(proposal_for, Int(0)),\n        App.globalPut(proposal_against, Int(0)),\n        App.globalPut(Itob(GeneratedID(appl.index())), Global.round()),\n        output.set(appl.get().created_application_id()),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef end_voting(app: abi.Application, *, output: abi.Bool) -> Expr:\n    return Seq(\n        (app_params := AppParam.creator(app.application_id())),\n        Assert(Txn.sender() == app_params.value()),\n        voting_allowed := App.globalGetEx(Int(0), Itob(app.application_id())),\n        Assert(voting_allowed.hasValue()),\n        Assert(Global.round() > voting_allowed.value()),\n        App.globalDel(Itob(app.application_id())),\n        output.set(True),\n    )\n\n\n@router.method(no_op=CallConfig.CALL)\ndef invoke(app: abi.Application, *, output: abi.Bool) -> Expr:\n    i = ScratchVar(TealType.uint64)\n    return Seq(\n        (app_creator := AppParam.creator(app.application_id())),\n        (app_addr := AppParam.address(app.application_id())),\n        Assert(app_creator.value() == Global.current_application_address()),\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields(\n            {\n                TxnField.type_enum: TxnType.ApplicationCall,\n                TxnField.application_id: app.application_id(),\n                TxnField.application_args: [ MethodSignature(\"invoke()bool\") ],\n                TxnField.rekey_to: app_addr.value(),\n            }\n        ),\n        Comment(\"Add all assets\"),\n        For(i.store(Int(0)), i.load() < Txn.assets.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.assets, [Txn.assets[i.load()]]),\n        ),\n        Comment(\"Add all apps\"),\n        For(i.store(Int(2)), i.load() <= Txn.applications.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.applications, [Txn.applications[i.load()]]),\n        ),\n        Comment(\"Add all accounts\"),\n        For(i.store(Int(1)), i.load() < Txn.accounts.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.accounts, [Txn.accounts[i.load()]]),\n        ),\n        Comment(\"Add all args\"),\n        For(i.store(Int(2)), i.load() < Txn.application_args.length(), i.store(i.load() + Int(1))).Do(\n            InnerTxnBuilder.SetField(TxnField.application_args, [Txn.application_args[i.load()]]),\n        ),\n        InnerTxnBuilder.Submit(),\n        Comment(\"Check we've been rekeyed back to our own account\"),\n        (acct_auth := AccountParam.authAddr(Global.current_application_address())),\n        Assert(acct_auth.value() == Global.zero_address()),\n        output.set(True),\n    )\n\n\n@router.method(clear_state=CallConfig.CALL)\ndef clear_state() -> Expr:\n    return Approve()\n\n\napproval, clearstate, abi = router.compile_program(\n    version=7,\n    optimize=OptimizeOptions(scratch_slots=True),\n)\n\nif __name__ == \"__main__\":\n    with open(\"dao_approval.teal\", \"w\") as f:\n        f.write(approval)\n    \n    with open(\"dao_clearstate.teal\", \"w\") as f:\n        f.write(clearstate)\n\n    with open(\"dao_abi.json\", \"w\") as f:\n        f.write(json.dumps(abi.dictify()))"}
{"instruction": "Create a smart contract for managing voting area initialization. The contract allows for initializing data related to constituencies (Duns), parliaments, and candidates. It also includes functions to read the stored data. Specifically, the contract provides methods to store and retrieve: Dun names, the number of Duns, parliament names, the number of parliament members, states, candidate names, and party affiliations, all associated with the transaction sender's local storage. The initialization methods enforce length restrictions on the string inputs. The contract also writes the compiled teal code and contract description to artifacts.", "output": "from pyteal import *\n\nk_dun = Bytes(\"dun\")\nk_dun_no = Bytes(\"dun_no\")\nk_parliament = Bytes(\"parliament\")\nk_parliament_no = Bytes(\"parliament_no\")\nk_state = Bytes(\"state\")\nk_c_name = Bytes(\"c_name\")\nk_party = Bytes(\"party\")\n\nrouter = Router(\"voting_area_initialisation\", BareCallActions(no_op=OnCompleteAction.create_only(Approve()), opt_in=OnCompleteAction.call_only(Approve())))\n\n@router.method\ndef init_dun(dun: abi.String, n: abi.Uint8, state: abi.String):\n    check = And(Len(dun.get()) <= Int(20), n.get() > Int(0), n.get() < Int(83), Len(state.get()) <= Int(15))\n    return If(check, Seq(App.localPut(Txn.sender(), k_dun, dun.get()), App.localPut(Txn.sender(), k_dun_no, n.get()), App.localPut(Txn.sender(), k_state, state.get())))\n\n@router.method\ndef init_parliament(parliamen: abi.String, n: abi.Uint8, state: abi.String):\n    check = And(Len(parliamen.get()) <= Int(20), n.get() > Int(0), n.get() < Int(223), Len(state.get()) <= Int(15))\n    return If(check, Seq(App.localPut(Txn.sender(), k_parliament, parliamen.get()), App.localPut(Txn.sender(), k_parliament_no, n.get()), App.localPut(Txn.sender(), k_state, state.get())))\n\n@router.method\ndef init_candidate(name: abi.String, party: abi.String):\n    check = And(Len(name.get()) <= Int(40), Len(party.get()) <= Int(20))\n    return If(check, Seq(App.localPut(Txn.sender(), k_c_name, name.get()), App.localPut(Txn.sender(), k_party, party.get())))\n\n@router.method\ndef read_dun(*, output: abi.String):\n    return output.set(App.localGet(Txn.sender(), k_dun))\n\n@router.method\ndef read_dun_no(*, output: abi.Uint8):\n    return output.set(App.localGet(Txn.sender(), k_dun_no))\n\n@router.method\ndef read_parliament(*, output: abi.String):\n    return output.set(App.localGet(Txn.sender(), k_parliament))\n\n@router.method\ndef read_parliament_no(*, output: abi.Uint8):\n    return output.set(App.localGet(Txn.sender(), k_parliament_no))\n\n@router.method\ndef read_state(*, output: abi.String):\n    return output.set(App.localGet(Txn.sender(), k_state))\n\n@router.method\ndef read_c_name(*, output: abi.String):\n    return output.set(App.localGet(Txn.sender(), k_c_name))\n\n@router.method\ndef read_party(*, output: abi.String):\n    return output.set(App.localGet(Txn.sender(), k_party))\n\nif __name__ == \"__main__\":\n    import os, json\n    path = os.path.dirname(os.path.abspath(__file__))\n    approval, clear, contract = router.compile_program(version=8)\n    with open(os.path.join(path, \"artifacts/approval.teal\"), \"w\") as f: f.write(approval)\n    with open(os.path.join(path, \"artifacts/clear.teal\"), \"w\") as f: f.write(clear)\n    with open(os.path.join(path, \"artifacts/contract.json\"), \"w\") as f: f.write(json.dumps(contract.dictify(), indent=2))"}
{"instruction": "Analyze a markdown file for documentation conventions. Specifically, check if the file contains links with text matching the regular expression 'ARC.*' and the string 'Audit'. Report any failures related to missing links or if the file cannot be read.", "output": "def _check_doc_conventions(name: str, path: Path) -> list[str]:\n    failures = []\n    try:\n        # convert markdown to HTML and then parse\n        html = markdown.markdown(path.read_text())\n        soup = BeautifulSoup(html, \"html.parser\")\n\n        if not soup.find(\"a\", string=re.compile(\"ARC.*\")):\n            failures.append(f\"{name} missing ARC reference\")\n\n        if not soup.find(\"a\", string=\"Audit\"):\n            failures.append(f\"{name} missing Audit reference\")\n    except IOError:\n        failures.append(f\"{name} missing documentation ({path})\")\n    return failures"}
{"instruction": "Identify all members of the `algokit_arc` module that are subclasses of the `Application` class and do not have names starting with an underscore. Return these members' names as an iterable of strings.", "output": "def _get_arc_exports() -> Iterable[str]:\n    exports = vars(algokit_arc)\n    for name, value in exports.items():\n        if not name.startswith(\"_\") and issubclass(value, Application):\n            yield name"}
{"instruction": "Iterate through a list of exported class names. For each name, construct a file path to a corresponding markdown document in the 'docs/arcs' directory. Then, execute checks on the document to ensure it adheres to specified conventions. If any checks fail, accumulate the failure messages. Finally, assert that the accumulated failure messages string is empty, indicating that all documents meet the required conventions.", "output": "def test_exported_classes_meet_conventions(request: pytest.FixtureRequest):\n    root_dir = request.config.rootdir\n    failures = []\n    for name in _get_arc_exports():\n        doc_name = name.lower()\n        path = Path(root_dir, \"docs\", \"arcs\", f\"{doc_name}.md\")\n        failures.extend(_check_doc_conventions(name, path))\n\n    failures = \"\\n\".join(failures)\n    assert failures == \"\""}
{"instruction": "Verify that all values within the input dictionary, 'traits', are either of type integer or string. Raise an assertion error if any value violates this type constraint.", "output": "def check_traits(traits: dict):\n    \n    for trait in traits.values():\n        assert (type(trait)==int) | (type(trait)==str), '''\n        ARC-16 check failed https://arc.algorand.foundation/ARCs/arc-0016\n        \"traits\": {\n            \"type\": \"object\",\n            \"description\": \"Traits (attributes) that can be used to calculate things like rarity. Values may be strings or numbers\"\n        }\n        '''"}
{"instruction": "Given a CID string, decode its multihash, derive a reserve address from the decoded digest, validate the address, and return the resulting reserve address.", "output": "def reserve_address_from_cid(cid: str):\n    decoded_cid = multihash.decode(make_cid(cid).multihash)\n    reserve_address = encoding.encode_address(decoded_cid.digest)\n    assert encoding.is_valid_address(reserve_address)\n    return reserve_address"}
{"instruction": "Extract the CID version from a given CID string.", "output": "def version_from_cid(cid: str):\n    return make_cid(cid).version"}
{"instruction": "Return the codec of a CID string.", "output": "def codec_from_cid(cid: str):\n    return make_cid(cid).codec"}
{"instruction": "Given a CID string, decode it into a multihash object and return the name of the hashing algorithm used in the multihash.", "output": "def hash_from_cid(cid: str):\n    return multihash.decode(make_cid(cid).multihash).name"}
{"instruction": "Generate a template-ipfs URL from a CID string. The URL should follow the format 'template-ipfs://{ipfscid:<version>:<codec>:reserve:<hash>}', where <version>, <codec>, and <hash> are derived from the input CID, and 'reserve' is a fixed string. Ensure the generated URL matches a predefined regular expression pattern.", "output": "def create_url_from_cid(cid: str):\n    version = version_from_cid(cid)\n    codec = codec_from_cid(cid)\n    hash = hash_from_cid(cid)\n    url = \"template-ipfs://{ipfscid:\" + f\"{version}:{codec}:reserve:{hash}\" + \"}\"\n    valid = re.compile(\n        r\"template-ipfs://{ipfscid:(?P<version>[01]):(?P<codec>[a-z0-9\\-]+):(?P<field>[a-z0-9\\-]+):(?P<hash>[a-z0-9\\-]+)}\"\n    )\n    assert bool(valid.match(url))\n    return url"}
{"instruction": "Generate a list of unsigned Algorand asset creation transactions (ARC-19 and ARC-3 compliant) for a collection of NFTs. Each NFT's metadata is read from a JSON file within a specified folder, and combined with a CID-based URL and a unique unit name derived from a prefix and an incrementing index. The transactions are configured with specified sender, manager, and reserve addresses.", "output": "def create_acgf_txn(\n    client: any,\n    nfts_metadata: dict,\n    folder_json: str,\n    unitname_prefix: str,\n    sender: str,\n    manager: str,\n) -> list:\n    cid_folder_metadata = arc3.ipfs_cid_from_folder(folder_json, upload=False)\n    url_prefix_arc19 = create_url_from_cid(cid_folder_metadata)\n    reserve_address_arc19 = reserve_address_from_cid(cid_folder_metadata)\n\n    print(\"Cid_Metadata_Folder: \" + cid_folder_metadata)\n    unsigned_txns_arc_19_arc_3 = []\n    idx = 1\n    for nft_metadata in nfts_metadata:\n        json_file = pathlib.Path(nft_metadata[\"image\"]).stem + \".json\"\n        with open(folder_json + json_file, \"r+\") as file1:\n            json_metadata = file1.read()\n        unsigned_txns_arc_19_arc_3.append(\n            arc3.create_asset_txn(\n                json_metadata=json_metadata,\n                unit_name=unitname_prefix + str(idx).zfill(4),  # zfill to get ALGO0001 ALGO0002 ... ALGO9999\n                asset_name=nft_metadata[\"name\"],\n                url=url_prefix_arc19 + \"/\" + json_file + \"#arc3\",\n                sender=sender,\n                sp=client.suggested_params(),\n                manager=manager,\n                reserve=reserve_address_arc19,\n                metadata_hash=False,\n            )\n        )\n        idx + 1\n    return unsigned_txns_arc_19_arc_3"}
{"instruction": "Calculate the SHA256 hash of a given file and return the hash value prefixed with \"sha256-\".", "output": "def file_integrity(filename: str) -> str:\n    with open(filename, \"rb\") as f:\n        bytes = f.read()  # read entire file as bytes\n        readable_hash = hashlib.sha256(bytes).hexdigest()\n        return \"sha256-\" + readable_hash"}
{"instruction": "Determine the MIME type of a file based on its extension.", "output": "def file_mimetype(filename: str) -> str:\n    extension = pathlib.Path(filename).suffix\n    return mimetypes.types_map[extension]"}
{"instruction": "Generate a new Algorand account consisting of a private key, address, and mnemonic phrase.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "{\n  \"instruction\": \"Create a JSON metadata object from provided arguments. The function should check if 'traits' exist in the properties and print a message if they don't. It validates the data types of the input parameters such as name, description, image, image_integrity, image_mimetype, background_color, external_url, external_url_integrity, external_url_mimetype, animation_url, animation_url_integrity, animation_url_mimetype, properties, decimals, localization, and extra_metadata. If an image or animation URL is provided, the function requires the corresponding integrity and mimetype values to be provided as well. Empty string values for optional fields like background\\_color, external\\_url, animation\\_url and empty localization dictionaries are skipped. The function returns a JSON string with indentation for readability.\"\n}", "output": "def create_metadata(\n    name: str,\n    description: str,\n    image: str,\n    image_integrity: str,\n    image_mimetype: str,\n    properties: dict,\n    decimals=0,\n    background_color=\"\",\n    external_url=\"\",\n    external_url_integrity=\"\",\n    external_url_mimetype=\"\",\n    animation_url=\"\",\n    animation_url_integrity=\"\",\n    animation_url_mimetype=\"\",\n    localization={\"uri\": \"\", \"default\": \"\", \"locales\": []},\n    extra_metadata=\"\",\n):\n    if \"traits\" in properties.keys():\n        arc16.check_traits(properties[\"traits\"])\n    else:\n        print(\"No traits provided\")\n    assert (\n        type(name) == str\n    ), \"\"\"\n        \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Identifies the asset to which this token represents\"\n        }\n    \"\"\"\n    assert (\n        type(decimals) == int\n    ), \"\"\"\n        \"decimals\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of decimal places that the token amount should display - e.g. 18, means to divide the token amount by 1000000000000000000 to get its user representation.\"\n        }\n    \"\"\"\n    if decimals != 0:\n        print(\"If provided, decimals must match the Number of Digits after the Decimal Point of the assets \")\n    assert (\n        type(description) == str\n    ), \"\"\"\n        \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Describes the asset to which this token represents\"\n        }\n    \"\"\"\n    assert (\n        type(image) == str\n    ), \"\"\"\n        \"image\": {\n            \"type\": \"string\",\n            \"description\": \"A URI pointing to a file with MIME type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\"\n        }\n    \"\"\"\n    assert (\n        type(image_integrity) == str\n    ), \"\"\"\n        \"image_integrity\": {\n            \"type\": \"string\",\n            \"description\": \"The SHA-256 digest of the file pointed by the URI image. The field value is a single SHA-256 integrity metadata as defined in the W3C subresource integrity specification (https://w3c.github.io/webappsec-subresource-integrity).\"\n        }\n    \"\"\"\n    assert (\n        type(image_mimetype) == str\n    ), \"\"\"\n        \"image_mimetype\": {\n            \"type\": \"string\",\n            \"description\": \"The MIME type of the file pointed by the URI image. MUST be of the form 'image/*'.\"\n        }\n    \"\"\"\n    assert (\n        type(background_color) == str\n    ), \"\"\"\n        \"background_color\": {\n            \"type\": \"string\",\n            \"description\": \"Background color do display the asset. MUST be a six-character hexadecimal without a pre-pended #.\"\n        }\n    \"\"\"\n    if image != \"\":\n        assert (\n            image_integrity != \"\"\n        ), \"\"\"\n        image_integrity not provided, you can get it with \"arc3.file_integrity(path_to_file)\"\n        \"\"\"\n        assert (\n            image_mimetype != \"\"\n        ), \"\"\"\n        image_mimetype not provided, you can get it with \"arc3.file_mimetype(path_to_file)\"\n    \"\"\"\n    assert (\n        type(external_url) == str\n    ), \"\"\"\n        \"external_url\": {\n            \"type\": \"string\",\n            \"description\": \"A URI pointing to an external website presenting the asset.\"\n        }\n    \"\"\"\n    assert (\n        type(external_url_integrity) == str\n    ), \"\"\"\n        \"external_url_integrity\": {\n            \"type\": \"string\",\n            \"description\": \"The SHA-256 digest of the file pointed by the URI external_url. The field value is a single SHA-256 integrity metadata as defined in the W3C subresource integrity specification (https://w3c.github.io/webappsec-subresource-integrity).\"\n        }\n    \"\"\"\n    assert (\n        type(external_url_mimetype) == str\n    ), \"\"\"\n        \"external_url_mimetype\": {\n            \"type\": \"string\",\n            \"description\": \"The MIME type of the file pointed by the URI external_url. It is expected to be 'text/html' in almost all cases.\"\n        }\n    \"\"\"\n    assert (\n        type(animation_url) == str\n    ), \"\"\"\n        \"animation_url\": {\n            \"type\": \"string\",\n            \"description\": \"A URI pointing to a multi-media file representing the asset.\"\n        }\n    \"\"\"\n    assert (\n        type(animation_url_integrity) == str\n    ), \"\"\"\n        \"animation_url_integrity\": {\n            \"type\": \"string\",\n            \"description\": \"The SHA-256 digest of the file pointed by the URI external_url. The field value is a single SHA-256 integrity metadata as defined in the W3C subresource integrity specification (https://w3c.github.io/webappsec-subresource-integrity).\"\n        }\n    \"\"\"\n    assert (\n        type(animation_url_mimetype) == str\n    ), \"\"\"\n        \"animation_url_mimetype\": {\n            \"type\": \"string\",\n            \"description\": \"The MIME type of the file pointed by the URI animation_url. If the MIME type is not specified, clients MAY guess the MIME type from the file extension or MAY decide not to display the asset at all. It is STRONGLY RECOMMENDED to include the MIME type.\"\n        }\n    \"\"\"\n    if animation_url != \"\":\n        assert (\n            animation_url_integrity != \"\"\n        ), \"\"\"\n        animation_url_integrity not provided, you can get it with \"arc3.file_integrity(path_to_file)\"\n        \"\"\"\n        assert (\n            animation_url_mimetype != \"\"\n        ), \"\"\"\n        animation_url_mimetype not provided, you can get it with \"arc3.file_mimetype(path_to_file)\"\n        \"\"\"\n\n    assert (\n        type(properties) == dict\n    ), \"\"\"\n        \"properties\": {\n            \"type\": \"object\",\n            \"description\": \"Arbitrary properties (also called attributes). Values may be strings, numbers, object or arrays.\"\n        },\n    \"\"\"\n    assert (\n        type(extra_metadata) == str\n    ), \"\"\"\n        \"extra_metadata\": {\n            \"type\": \"string\",\n            \"description\": \"Extra metadata in base64. If the field is specified (even if it is an empty string) the asset metadata (am) of the ASA is computed differently than if it is not specified.\"\n        }\n    \"\"\"\n    assert (\n        (type(localization) == dict)\n        & (type(localization[\"uri\"]) == str)\n        & (type(localization[\"default\"]) == str)\n        & (type(localization[\"locales\"]) == list)\n    ), \"\"\"\n        \"localization\": {\n            \"type\": \"object\",\n            \"required\": [\"uri\", \"default\", \"locales\"],\n            \"properties\": {\n                \"uri\": {\n                    \"type\": \"string\",\n                    \"description\": \"The URI pattern to fetch localized data from. This URI should contain the substring `{locale}` which will be replaced with the appropriate locale value before sending the request.\"\n                },\n                \"default\": {\n                    \"type\": \"string\",\n                    \"description\": \"The locale of the default data within the base JSON\"\n                },\n                \"locales\": {\n                    \"type\": \"array\",\n                    \"description\": \"The list of locales for which data is available. These locales should conform to those defined in the Unicode Common Locale Data Repository (http://cldr.unicode.org/).\"\n                },\n                \"integrity\": {\n                    \"type\": \"object\",\n                    \"patternProperties\": {\n                        \".*\": { \"type\": \"string\" }\n                    },\n                    \"description\": \"The SHA-256 digests of the localized JSON files (except the default one). The field name is the locale. The field value is a single SHA-256 integrity metadata as defined in the W3C subresource integrity specification (https://w3c.github.io/webappsec-subresource-integrity).\"\n                }\n            }\n        }\n    \"\"\"\n    if localization != {\"uri\": \"\", \"default\": \"\", \"locales\": []}:\n        print(\n            \"\"\"\n    If the JSON Metadata file contains a localization attribute, its content MAY be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three REQUIRED attributes: uri, default, locales, and one RECOMMENDED attribute: integrity. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.\n    It is RECOMMENDED that integrity contains the digests of all the locales but the default one.\n    \"\"\"\n        )\n    args = locals()\n    metadata_dict = {}\n    for key in args.keys():\n        if (type(args[key]) == str) & (args[key] == \"\"):\n            pass\n        elif (key == \"localization\") & (args[key] == {\"uri\": \"\", \"default\": \"\", \"locales\": []}):\n            pass\n        elif (key == \"decimals\") & (args[key] == 0):\n            pass\n        elif key == \"traits\":\n            pass\n        else:\n            metadata_dict[key] = args[key]\n    return json.dumps(metadata_dict, indent=4)"}
{"instruction": "Create an Algorand Asset Configuration Transaction. The transaction creates a new asset using parameters such as total supply, number of decimals, metadata, and manager/reserve/freeze/clawback addresses. The function calculates a metadata hash based on the JSON metadata provided and whether to include an extra metadata field according to ARC-3, and includes safety checks to ensure URL ends with #arc3, total supply is valid (either 1 or a power of 10), and the number of decimals is correct. Finally, it constructs and returns an AssetConfigTxn object.", "output": "def create_asset_txn(\n    json_metadata: str,\n    sender: str,\n    sp: object,\n    unit_name: str,\n    asset_name: str,\n    url: str,\n    manager: str,\n    reserve: str,\n    freeze=\"\",\n    clawback=\"\",\n    note=\"\",\n    decimals=0,\n    total=1,\n    default_frozen=False,\n    lease=\"\",\n    rekey_to=\"\",\n    metadata_hash=True,\n):\n    metadata = json.loads(json_metadata)\n\n    if metadata_hash:\n        if \"extra_metadata\" in metadata.keys():\n            h = hashlib.new(\"sha512_256\")\n            h.update(b\"arc0003/amj\")\n            h.update(json_metadata.encode(\"utf-8\"))\n            json_metadata_hash = h.digest()\n\n            h = hashlib.new(\"sha512_256\")\n            h.update(b\"arc0003/am\")\n\n            h.update(json_metadata_hash)\n            h.update(base64.b64decode(metadata[\"extra_metadata\"]))\n            am = h.digest()\n        else:\n            h = hashlib.new(\"sha256\")\n            h.update(json_metadata.encode(\"utf-8\"))\n            am = h.digest()\n    else:\n        am = \"\"\n    assert (\n        url[-5:] == \"#arc3\"\n    ), \"\"\"\n        Asset URL SHOULD ends with #arc3\n    \"\"\"\n\n    assert (total == 1) | (\n        total % 10 == 0\n    ), \"\"\"\n    Total Number of Units (t) MUST be a power of 10 larger than 1: 10, 100, 1000, ...\n    \"\"\"\n\n    assert (\n        10**decimals * total == 1\n    ), \"\"\"\n    Number of Digits after the Decimal Point (dc) MUST be equal to the logarithm in base 10 of total number of units.\n    In other words, the total supply of the ASA is exactly 1.\n    \"\"\"\n\n    transaction_dict = {\n        \"sender\": sender,\n        \"sp\": sp,\n        \"total\": total,\n        \"default_frozen\": default_frozen,\n        \"manager\": manager,\n        \"reserve\": reserve,\n        \"freeze\": freeze,\n        \"clawback\": clawback,\n        \"unit_name\": unit_name,\n        \"asset_name\": asset_name,\n        \"url\": url,\n        \"metadata_hash\": am,\n        \"note\": note,\n        \"lease\": lease,\n        \"strict_empty_address_check\": False,\n        \"rekey_to\": rekey_to,\n    }\n    return transaction.AssetConfigTxn(**transaction_dict)"}
{"instruction": "Compute the IPFS CID (Content Identifier) of a specified folder using the `ipfs add` command.  If `upload` is True, upload the folder to IPFS; otherwise, only compute the hash locally without uploading. The CID version is 1 and the hash function is SHA-256. Recursively add all files in the folder, ignoring the `__pycache__` directory. Return the resulting CID as a string.", "output": "def ipfs_cid_from_folder(folder: str, upload=False) -> str:\n    \"\"\"\n    Compute the (encoded) information byte string corresponding to all the files inside the folder `folder`\n    \"\"\"\n    # Use Kubo IPFS command line\n    # We don't use --wrap-directory as we are already in a folder\n    if upload:\n        output = subprocess.run(\n            [\n                \"ipfs\",\n                \"add\",\n                \"--cid-version=1\",\n                \"--hash=sha2-256\",\n                \"--recursive\",\n                \"--quiet\",\n                \"--ignore=__pycache__\",\n                folder,\n            ],\n            capture_output=True,\n        )\n    else:\n        output = subprocess.run(\n            [\n                \"ipfs\",\n                \"add\",\n                \"--cid-version=1\",\n                \"--hash=sha2-256\",\n                \"--recursive\",\n                \"--only-hash\",\n                \"--quiet\",\n                \"--ignore=__pycache__\",\n                folder,\n            ],\n            capture_output=True,\n        )\n    # The CID is the last non-empty line\n    text_cid = output.stdout.decode().strip().split(\"\\n\")[-1]\n    return text_cid"}
{"instruction": "Generate NFT metadata JSON files based on a template and upload them to IPFS. First, upload a folder of images to IPFS and get its CID. Then, for each NFT, construct metadata including the name, description, IPFS URL of the image, integrity hash and MIME type of the image, and other properties. Save each NFT's metadata as a JSON file in a specified folder. Finally, upload the folder containing the JSON files to IPFS and return its CID.", "output": "def upload_ipfs(folder_image: str, folder_json: str, nfts_metadata: dict, upload=False) -> str:\n    cid_folder_images = ipfs_cid_from_folder(folder_image, upload)\n    print(\"Cid_Image_Folder: \" + cid_folder_images)\n\n    url_prefix_images = \"ipfs://\" + cid_folder_images\n    # Check everything is fine\n    for nft_metadata in nfts_metadata:\n        current_file = folder_image + nft_metadata[\"image\"]\n        image_integrity = file_integrity(current_file)\n        image_mimetype = file_mimetype(current_file)\n        nft_metadata_string = create_metadata(\n            name=nft_metadata[\"name\"],\n            description=nft_metadata[\"description\"],\n            image=url_prefix_images + \"/\" + nft_metadata[\"image\"],\n            image_integrity=image_integrity,\n            image_mimetype=image_mimetype,\n            properties=nft_metadata[\"properties\"],\n        )\n        pathlib.Path(folder_json).mkdir(parents=True, exist_ok=True)\n        with open(folder_json + pathlib.Path(nft_metadata[\"image\"]).stem + \".json\", \"w\") as json_file:\n            json_file.write(nft_metadata_string)\n\n    return ipfs_cid_from_folder(folder_json, upload=True)"}
{"instruction": "Implement a smart contract for issuing Proof of Attendance (POA) tokens. The contract allows users to confirm their attendance, mint a unique POA token (ASA), store the POA ID, and claim the token using an opt-in transaction. The contract utilizes boxes and box maps to manage the claimed POAs. The contract has methods to retrieve the poa id using boxes and box maps. The contract also has methods that uses box references to perform the same actions.", "output": "class ProofOfAttendance(algopy.ARC4Contract):\n    def __init__(self) -> None:\n        self.max_attendees = algopy.UInt64(30)\n        self.asset_url = algopy.String(\n            \"ipfs://QmW5vERkgeJJtSY1YQdcWU6gsHCZCyLFtM1oT9uyy2WGm8\"\n        )\n        self.total_attendees = algopy.UInt64(0)\n        self.box_map = algopy.BoxMap(algopy.Bytes, algopy.UInt64)\n\n    @algopy.arc4.abimethod(create=\"require\")\n    def init(self, max_attendees: algopy.UInt64) -> None:\n        assert (\n            algopy.Txn.sender == algopy.Global.creator_address\n        ), \"Only creator can initialize\"\n        self.max_attendees = max_attendees\n\n    @algopy.arc4.abimethod()\n    def confirm_attendance(self) -> None:\n        assert self.total_attendees < self.max_attendees, \"Max attendees reached\"\n\n        minted_asset = self._mint_poa(algopy.Txn.sender)\n        self.total_attendees += TemplateVar[UInt64](\"INCREMENT\")\n\n        _id, has_claimed = algopy.op.Box.get(algopy.Txn.sender.bytes)\n        assert not has_claimed, \"Already claimed POA\"\n\n        algopy.op.Box.put(algopy.Txn.sender.bytes, algopy.op.itob(minted_asset.id))\n\n    @algopy.arc4.abimethod()\n    def confirm_attendance_with_box(self) -> None:\n        assert self.total_attendees < self.max_attendees, \"Max attendees reached\"\n\n        minted_asset = self._mint_poa(algopy.Txn.sender)\n        self.total_attendees += 1\n\n        box = algopy.Box(algopy.UInt64, key=algopy.Txn.sender.bytes)\n        has_claimed = bool(box)\n        assert not has_claimed, \"Already claimed POA\"\n\n        box.value = minted_asset.id\n\n    @algopy.arc4.abimethod()\n    def confirm_attendance_with_box_ref(self) -> None:\n        assert self.total_attendees < self.max_attendees, \"Max attendees reached\"\n\n        minted_asset = self._mint_poa(algopy.Txn.sender)\n        self.total_attendees += 1\n\n        box_ref = algopy.BoxRef(key=algopy.Txn.sender.bytes)\n        has_claimed = bool(box_ref)\n        assert not has_claimed, \"Already claimed POA\"\n\n        box_ref.put(algopy.op.itob(minted_asset.id))\n\n    @algopy.arc4.abimethod()\n    def confirm_attendance_with_box_map(self) -> None:\n        assert self.total_attendees < self.max_attendees, \"Max attendees reached\"\n\n        minted_asset = self._mint_poa(algopy.Txn.sender)\n        self.total_attendees += 1\n\n        has_claimed = algopy.Txn.sender.bytes in self.box_map\n        assert not has_claimed, \"Already claimed POA\"\n\n        self.box_map[algopy.Txn.sender.bytes] = minted_asset.id\n\n    @algopy.arc4.abimethod(readonly=True)\n    def get_poa_id(self) -> algopy.UInt64:\n        poa_id, exists = algopy.op.Box.get(algopy.Txn.sender.bytes)\n        assert exists, \"POA not found\"\n        return algopy.op.btoi(poa_id)\n\n    @algopy.arc4.abimethod(readonly=True)\n    def get_poa_id_with_box(self) -> algopy.UInt64:\n        box = algopy.Box(algopy.UInt64, key=algopy.Txn.sender.bytes)\n        poa_id, exists = box.maybe()\n        assert exists, \"POA not found\"\n        return poa_id\n\n    @algopy.arc4.abimethod(readonly=True)\n    def get_poa_id_with_box_ref(self) -> algopy.UInt64:\n        box_ref = algopy.BoxRef(key=algopy.Txn.sender.bytes)\n        poa_id, exists = box_ref.maybe()\n        assert exists, \"POA not found\"\n        return algopy.op.btoi(poa_id)\n\n    @algopy.arc4.abimethod(readonly=True)\n    def get_poa_id_with_box_map(self) -> algopy.UInt64:\n        poa_id, exists = self.box_map.maybe(algopy.Txn.sender.bytes)\n        assert exists, \"POA not found\"\n        return poa_id\n\n    @algopy.arc4.abimethod()\n    def claim_poa(self, opt_in_txn: algopy.gtxn.AssetTransferTransaction) -> None:\n        poa_id, exists = algopy.op.Box.get(algopy.Txn.sender.bytes)\n        assert exists, \"POA not found, attendance validation failed!\"\n        assert opt_in_txn.xfer_asset.id == algopy.op.btoi(poa_id), \"POA ID mismatch\"\n        assert opt_in_txn.fee == algopy.UInt64(0), \"We got you covered for free!\"\n        assert opt_in_txn.asset_amount == algopy.UInt64(0)\n        assert (\n            opt_in_txn.sender == opt_in_txn.asset_receiver == algopy.Txn.sender\n        ), \"Opt-in transaction sender and receiver must be the same\"\n        assert (\n            opt_in_txn.asset_close_to\n            == opt_in_txn.rekey_to\n            == algopy.Global.zero_address\n        ), \"Opt-in transaction close to must be zero address\"\n\n        self._send_poa(\n            algopy.Txn.sender,\n            algopy.op.btoi(poa_id),\n        )\n\n    @algopy.arc4.abimethod()\n    def claim_poa_with_box(\n        self, opt_in_txn: algopy.gtxn.AssetTransferTransaction\n    ) -> None:\n        box = algopy.Box(algopy.UInt64, key=algopy.Txn.sender.bytes)\n        poa_id, exists = box.maybe()\n        assert exists, \"POA not found, attendance validation failed!\"\n        assert opt_in_txn.xfer_asset.id == poa_id, \"POA ID mismatch\"\n        assert opt_in_txn.fee == algopy.UInt64(0), \"We got you covered for free!\"\n        assert opt_in_txn.asset_amount == algopy.UInt64(0)\n        assert (\n            opt_in_txn.sender == opt_in_txn.asset_receiver == algopy.Txn.sender\n        ), \"Opt-in transaction sender and receiver must be the same\"\n        assert (\n            opt_in_txn.asset_close_to\n            == opt_in_txn.rekey_to\n            == algopy.Global.zero_address\n        ), \"Opt-in transaction close to must be zero address\"\n\n        self._send_poa(\n            algopy.Txn.sender,\n            poa_id,\n        )\n\n    @algopy.arc4.abimethod()\n    def claim_poa_with_box_ref(\n        self, opt_in_txn: algopy.gtxn.AssetTransferTransaction\n    ) -> None:\n        box_ref = algopy.BoxRef(key=algopy.Txn.sender.bytes)\n        poa_id, exists = box_ref.maybe()\n        assert exists, \"POA not found, attendance validation failed!\"\n        assert opt_in_txn.xfer_asset.id == algopy.op.btoi(poa_id), \"POA ID mismatch\"\n        assert opt_in_txn.fee == algopy.UInt64(0), \"We got you covered for free!\"\n        assert opt_in_txn.asset_amount == algopy.UInt64(0)\n        assert (\n            opt_in_txn.sender == opt_in_txn.asset_receiver == algopy.Txn.sender\n        ), \"Opt-in transaction sender and receiver must be the same\"\n        assert (\n            opt_in_txn.asset_close_to\n            == opt_in_txn.rekey_to\n            == algopy.Global.zero_address\n        ), \"Opt-in transaction close to must be zero address\"\n\n        self._send_poa(\n            algopy.Txn.sender,\n            algopy.op.btoi(poa_id),\n        )\n\n    @algopy.arc4.abimethod()\n    def claim_poa_with_box_map(\n        self, opt_in_txn: algopy.gtxn.AssetTransferTransaction\n    ) -> None:\n        poa_id, exists = self.box_map.maybe(algopy.Txn.sender.bytes)\n        assert exists, \"POA not found, attendance validation failed!\"\n        assert opt_in_txn.xfer_asset.id == poa_id, \"POA ID mismatch\"\n        assert opt_in_txn.fee == algopy.UInt64(0), \"We got you covered for free!\"\n        assert opt_in_txn.asset_amount == algopy.UInt64(0)\n        assert (\n            opt_in_txn.sender == opt_in_txn.asset_receiver == algopy.Txn.sender\n        ), \"Opt-in transaction sender and receiver must be the same\"\n        assert (\n            opt_in_txn.asset_close_to\n            == opt_in_txn.rekey_to\n            == algopy.Global.zero_address\n        ), \"Opt-in transaction close to must be zero address\"\n\n        self._send_poa(\n            algopy.Txn.sender,\n            poa_id,\n        )\n\n    @algopy.subroutine\n    def _mint_poa(self, claimer: algopy.Account) -> algopy.Asset:\n        algopy.ensure_budget(algopy.UInt64(10000), algopy.OpUpFeeSource.AppAccount)\n        asset_name = b\"AlgoKit POA #\" + algopy.op.itob(self.total_attendees)\n        return (\n            algopy.itxn.AssetConfig(\n                asset_name=asset_name,\n                unit_name=algopy.String(\"POA\"),\n                total=algopy.UInt64(1),\n                decimals=0,\n                url=self.asset_url,\n                manager=claimer,\n            )\n            .submit()\n            .created_asset\n        )\n\n    @algopy.subroutine\n    def _send_poa(self, receiver: algopy.Account, asset_id: algopy.UInt64) -> None:\n        algopy.itxn.AssetTransfer(\n            xfer_asset=asset_id,\n            sender=algopy.Global.current_application_address,\n            asset_receiver=receiver,\n            asset_amount=1,\n        ).submit()"}
{"instruction": "Verify that an Algorand application call transaction exists with an application ID of 1012, and then approve the transaction.", "output": "def approve_hello_call() -> bool:\n    app_txn = gtxn.ApplicationCallTransaction(0)\n    assert app_txn.app_id == 1012\n    return True"}
{"instruction": "Generate a new Algorand account, including its private key, public address, and mnemonic phrase.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Create an Algorand smart contract method named 'hello' that takes a string 'name' and an application ID 'app_id' as input. This method performs an inner transaction application call to the application specified by 'app_id', passing the input 'name' as an argument (prefixed by the hex-encoded bytes 'ee67fb50').  The method then returns the last log emitted by the inner transaction as a string.", "output": "class HelloWorld2(ARC4Contract):\n    @abimethod()\n    def hello(self, name: String, app_id: Application) -> String:\n        response = itxn.ApplicationCall(\n            app_id=app_id, app_args=(Bytes.from_hex(\"ee67fb50\"), name.bytes), fee=0\n        ).submit()\n\n        return String.from_bytes(response.last_log)"}
{"instruction": "Implement a method `pkcs1_v15_verify` that takes a message digest info, signature, RSA modulus (n), RSA public exponent (e), and Barrett reduction factor as byte strings. The method should first ensure a budget of 20000 using group credit as the fee source. Then, call an external `pkcs1_v15_verify` function with the provided arguments.", "output": "class RSATester(arc4.ARC4Contract):\n    @arc4.abimethod()\n    def pkcs1_v15_verify(\n        self,\n        msg_digest_info: Bytes,\n        s: Bytes,\n        n: Bytes,\n        e: Bytes,\n        barrett_reduction_factor: Bytes,\n    ) -> None:\n        ensure_budget(20000, fee_source=OpUpFeeSource.GroupCredit)\n        pkcs1_v15_verify(msg_digest_info, s, n, e, barrett_reduction_factor)"}
{"instruction": "Based on the provided action ('build', 'deploy', or 'all'), iterate through a collection of contracts. If the action is 'build', build the application associated with each contract and store the resulting artifact. If the action is 'deploy', deploy the application based on its artifact and deployment configuration if it exists. If the action is 'all', build and then deploy each application if a deployment configuration exists.", "output": "def main(action: str) -> None:\n    artifact_path = root_path / \"artifacts\"\n    match action:\n        case \"build\":\n            for contract in contracts:\n                logger.info(f\"Building app {contract.app.name}\")\n                build(artifact_path / contract.app.name, contract.app)\n        case \"deploy\":\n            for contract in contracts:\n                logger.info(f\"Deploying app {contract.app.name}\")\n                app_spec_path = artifact_path / contract.app.name / \"application.json\"\n                if contract.deploy:\n                    deploy(app_spec_path, contract.deploy)\n        case \"all\":\n            for contract in contracts:\n                logger.info(f\"Building app {contract.app.name}\")\n                app_spec_path = build(artifact_path / contract.app.name, contract.app)\n                logger.info(f\"Deploying {contract.app.name}\")\n                if contract.deploy:\n                    deploy(app_spec_path, contract.deploy)"}
{"instruction": "Generate a PyTeal expression that asserts the integer value stored in the updatable template variable is non-zero, effectively checking if the application is updatable.", "output": "def update() -> pt.Expr:\n    return pt.Assert(\n        pt.Tmpl.Int(UPDATABLE_TEMPLATE_NAME),\n        comment=\"Check app is updatable\",\n    )"}
{"instruction": "Create an Algorand transaction expression that asserts the value of the integer template variable 'DELETABLE_TEMPLATE_NAME' is non-zero. This ensures that the application is deletable.", "output": "def delete() -> pt.Expr:\n    return pt.Assert(\n        pt.Tmpl.Int(DELETABLE_TEMPLATE_NAME),\n        comment=\"Check app is deletable\",\n    )"}
{"instruction": "Create a PyTeal expression that concatenates the string 'Hello, ' with the input string 'name' and assigns the result to the output string 'output'.", "output": "def hello(name: pt.abi.String, *, output: pt.abi.String) -> pt.Expr:\n    return output.set(pt.Concat(pt.Bytes(\"Hello, \"), name.get()))"}
{"instruction": "Deploy a smart contract named 'CoolContract' using an Algorand client and indexer. The deployment strategy depends on whether the network is MainNet. If MainNet, append the app on schema break and update. Otherwise, replace the app on schema break and update the app. Deletion and updates are only allowed on non-MainNet environments. After deployment, call the 'hello' method of the contract with the name 'world' and log the response.", "output": "def deploy(\n    algod_client: AlgodClient,\n    indexer_client: IndexerClient,\n    app_spec: algokit_utils.ApplicationSpecification,\n    deployer: algokit_utils.Account,\n) -> None:\n    from smart_contracts.artifacts.cool_contract.client import (\n        CoolContractClient,\n    )\n\n    app_client = CoolContractClient(\n        algod_client,\n        creator=deployer,\n        indexer_client=indexer_client,\n    )\n    is_mainnet = algokit_utils.is_mainnet(algod_client)\n    app_client.deploy(\n        on_schema_break=(\n            algokit_utils.OnSchemaBreak.AppendApp\n            if is_mainnet\n            else algokit_utils.OnSchemaBreak.ReplaceApp\n        ),\n        on_update=(\n            algokit_utils.OnUpdate.AppendApp\n            if is_mainnet\n            else algokit_utils.OnUpdate.UpdateApp\n        ),\n        allow_delete=not is_mainnet,\n        allow_update=not is_mainnet,\n    )\n\n    name = \"world\"\n    response = app_client.hello(name=name)\n    logger.info(\n        f\"Called hello on {app_spec.contract.name} ({app_client.app_id}) \"\n        f\"with name={name}, received: {response.return_value}\"\n    )"}
{"instruction": "Build an Algorand application by first removing the output directory if it exists, then creating the directory. Export the application's specification to 'application.json' within the output directory. Generate a typed client for the application using AlgoKit, saving it as 'client.py' (or a similar extension). Raise an exception if the AlgoKit command fails, particularly if the version is too old.", "output": "def build(output_dir: Path, app: beaker.Application) -> Path:\n    output_dir = output_dir.resolve()\n    if output_dir.exists():\n        rmtree(output_dir)\n    output_dir.mkdir(exist_ok=True, parents=True)\n    logger.info(f\"Exporting {app.name} to {output_dir}\")\n    specification = app.build()\n    specification.export(output_dir)\n\n    result = subprocess.run(\n        [\n            \"algokit\",\n            \"generate\",\n            \"client\",\n            output_dir / \"application.json\",\n            \"--output\",\n            output_dir / f\"client.{deployment_extension}\",\n        ],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n    )\n    if result.returncode:\n        if \"No such command\" in result.stdout:\n            raise Exception(\n                \"Could not generate typed client, requires AlgoKit 2.0.0 or \"\n                \"later. Please update AlgoKit\"\n            )\n        else:\n            raise Exception(f\"Could not generate typed client:\\n{result.stdout}\")\n\n    return output_dir / \"application.json\""}
{"instruction": "Define a SmartContract class with an 'app' attribute of type Application and a 'deploy' attribute that is a callable function accepting an AlgodClient, IndexerClient, ApplicationSpecification, and Account as arguments, and returns None. The 'deploy' attribute can also be None.", "output": "class SmartContract:\n    app: Application\n    deploy: (\n        Callable[[AlgodClient, IndexerClient, ApplicationSpecification, Account], None]\n        | None\n    ) = None"}
{"instruction": "Import a Python module named 'contract' from a specified directory and return an attribute named 'app' from that module. If the module cannot be imported, raise an exception indicating that the contract was not found.", "output": "def import_contract(folder: Path) -> Application:\n    \"\"\"Imports the contract from a folder if it exists.\"\"\"\n    try:\n        contract_module = importlib.import_module(\n            f\"{folder.parent.name}.{folder.name}.contract\"\n        )\n        return contract_module.app\n    except ImportError as e:\n        raise Exception(f\"Contract not found in {folder}\") from e"}
{"instruction": "Dynamically import the 'deploy' function from a Python module located at 'folder.parent.name.folder.name.deploy_config'. If the module or function does not exist, return None.", "output": "def import_deploy_if_exists(\n    folder: Path,\n) -> (\n    Callable[[AlgodClient, IndexerClient, ApplicationSpecification, Account], None]\n    | None\n):\n    \"\"\"Imports the deploy function from a folder if it exists.\"\"\"\n    try:\n        deploy_module = importlib.import_module(\n            f\"{folder.parent.name}.{folder.name}.deploy_config\"\n        )\n        return deploy_module.deploy\n    except ImportError:\n        return None"}
{"instruction": "Determine if a specified directory contains a file named 'contract.py'.", "output": "def has_contract_file(directory: Path) -> bool:\n    \"\"\"Checks whether the directory contains contract.py file.\"\"\"\n    return (directory / \"contract.py\").exists()"}
{"instruction": "Create an Algod client object configured to connect to a local Algorand network.", "output": "def algod_client() -> AlgodClient:\n    # by default we are using localnet algod\n    client = get_algod_client(get_default_localnet_config(\"algod\"))\n    return client"}
{"instruction": "Create and return an IndexerClient configured using the default local network settings for the indexer.", "output": "def indexer_client() -> IndexerClient:\n    return get_indexer_client(get_default_localnet_config(\"indexer\"))"}
{"instruction": "Generate an Algorand account, derive the corresponding private key and address, and then convert the private key into its mnemonic phrase representation.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Deploy a HelloWorld application to Algorand using the provided Algod and Indexer clients. The application is configured for debugging and deployed with the ReplaceApp schema break policy and UpdateApp update policy, allowing both delete and update.", "output": "def hello_world_client(\n    algod_client: AlgodClient, indexer_client: IndexerClient\n) -> HelloWorldClient:\n    config.configure(\n        debug=True,\n        # trace_all=True,\n    )\n\n    client = HelloWorldClient(\n        algod_client,\n        creator=get_localnet_default_account(algod_client),\n        indexer_client=indexer_client,\n    )\n\n    client.deploy(\n        on_schema_break=algokit_utils.OnSchemaBreak.ReplaceApp,\n        on_update=algokit_utils.OnUpdate.UpdateApp,\n        allow_delete=True,\n        allow_update=True,\n    )\n    return client"}
{"instruction": "Write a test case that asserts the `hello` method of a `HelloWorldClient` object, when called with the name 'World', returns the string 'Hello, World'.", "output": "def test_says_hello(hello_world_client: HelloWorldClient) -> None:\n    result = hello_world_client.hello(name=\"World\")\n\n    assert result.return_value == \"Hello, World\""}
{"instruction": "Simulate a transaction group consisting of two calls to the 'hello' method of a smart contract, passing 'World' and 'Jane' as the name arguments respectively. Verify that the return values of the calls are 'Hello, World' and 'Hello, Jane', and that the app budget consumed by the transaction group is less than 100.", "output": "def test_simulate_says_hello_with_correct_budget_consumed(\n    hello_world_client: HelloWorldClient, algod_client: AlgodClient\n) -> None:\n    result = (\n        hello_world_client.compose().hello(name=\"World\").hello(name=\"Jane\").simulate()\n    )\n\n    assert result.abi_results[0].return_value == \"Hello, World\"\n    assert result.abi_results[1].return_value == \"Hello, Jane\"\n    assert result.simulate_response[\"txn-groups\"][0][\"app-budget-consumed\"] < 100"}
{"instruction": "Load and parse a YAML file into a Python dictionary. The file is opened in read mode with UTF-8 encoding and then parsed using `yaml.safe_load()`.", "output": "def _load_copier_yaml(path: Path) -> dict[str, str | bool | dict]:\n    with path.open(\"r\", encoding=\"utf-8\") as stream:\n        return yaml.safe_load(stream)"}
{"instruction": "Create a temporary directory, copy the contents of a root directory into a 'template' subdirectory within it, initialize a Git repository in the 'template' directory, add all files, commit the changes, and then yield the 'template' directory path. After yielding, iterate through subdirectories within a generated folder inside the 'template' directory, remove the corresponding directory in a destination generated root, and copy the contents of the subdirectory from the temporary directory to the destination, ignoring specified patterns.", "output": "def working_dir() -> Iterator[Path]:\n    with tempfile.TemporaryDirectory(ignore_cleanup_errors=True) as temp:\n        working_dir = Path(temp) / \"template\"\n        working_generated_root = working_dir / generated_folder\n        shutil.copytree(root, working_dir)\n        subprocess.run([\"git\", \"add\", \"-A\"], cwd=working_dir)\n        subprocess.run(\n            [\"git\", \"commit\", \"-m\", \"draft changes\", \"--no-verify\"], cwd=working_dir\n        )\n\n        yield working_dir\n\n        for src_dir in working_generated_root.iterdir():\n            if not src_dir.is_dir():\n                continue\n\n            dest_dir = generated_root / src_dir.stem\n            shutil.rmtree(dest_dir, ignore_errors=True)\n            shutil.copytree(\n                src_dir,\n                dest_dir,\n                dirs_exist_ok=True,\n                ignore=shutil.ignore_patterns(\".*_cache\", \".venv\", \"__pycache__\"),\n            )"}
{"instruction": "Execute the 'algokit init' command to generate a new project. The project will be created in a subdirectory named after the test case, within a 'generated' folder in the specified working directory. The command uses a specified template URL (or defaults to the working directory if none is provided) and a template branch (determined automatically from the current git branch if not provided). It configures the project with default parameters, answers to interactive questions (if provided), and disables IDE integration, Git initialization, and workspace creation. It then runs the command and returns the result.", "output": "def run_init(\n    working_dir: Path,\n    test_name: str,\n    *args: str,\n    template_url: str | None = None,\n    template_branch: str | None = None,\n    answers: dict[str, str] | None = None,\n) -> subprocess.CompletedProcess:\n    copy_to = working_dir / generated_folder / test_name\n    shutil.rmtree(copy_to, ignore_errors=True)\n    if template_url is None:\n        template_url = str(working_dir)\n\n        if template_branch is None:\n            git_output = subprocess.run(\n                [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"],\n                cwd=working_dir,\n                stdout=subprocess.PIPE,\n            )\n            template_branch = git_output.stdout.decode(\"utf-8\").strip()\n\n    init_args = [\n        \"algokit\",\n        \"--verbose\",\n        \"init\",\n        \"--name\",\n        str(copy_to.stem),\n        \"--template-url\",\n        template_url,\n        \"--UNSAFE-SECURITY-accept-template-url\",\n        \"--defaults\",\n        \"--no-ide\",\n        \"--no-git\",\n        \"--no-workspace\",\n    ]\n    answers = {**DEFAULT_PARAMETERS, **(answers or {})}\n\n    for question, answer in answers.items():\n        init_args.extend([\"-a\", question, answer])\n    if template_branch:\n        init_args.extend([\"--template-url-ref\", template_branch])\n    init_args.extend(args)\n\n    result = subprocess.run(\n        init_args,\n        input=\"y\",  # acknowledge that input is not a tty\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n        cwd=copy_to.parent,\n    )\n\n    return result"}
{"instruction": "After copying a project template to a working directory, normalize the `.copier-answers.yml` file by replacing commit hashes and source paths with placeholders. Then, run a series of code quality checks (black and build) on the copied project. If the project preset is 'production', also run linting and testing checks. Return the result of the last subprocess execution.", "output": "def check_codebase(working_dir: Path, test_name: str) -> subprocess.CompletedProcess:\n    copy_to = working_dir / generated_folder / test_name\n\n    # if successful, normalize .copier-answers.yml to make observing diffs easier\n    copier_answers = Path(copy_to / \".algokit\" / \".copier-answers.yml\")\n    content = copier_answers.read_text(\"utf-8\")\n    content = commit_pattern.sub(\"_commit: <commit>\", content)\n    content = src_path_pattern.sub(\"_src_path: <src>\", content)\n    copier_answers.write_text(content, \"utf-8\")\n\n    check_args = [BLACK_ARGS, BUILD_ARGS]\n\n    # Starter template does not have ruff config or mypy config by default\n    # so only check for them if the starter template is not used\n    processed_questions = _load_copier_yaml(copier_answers)\n    if processed_questions[\"preset_name\"] == \"production\":\n        check_args += [LINT_ARGS, TEST_ARGS]\n\n    for check_arg in check_args:\n        result = subprocess.run(\n            check_arg,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n            cwd=copy_to,\n        )\n        if result.returncode:\n            break\n\n    return result"}
{"instruction": "Execute the specified generator within a designated directory using the 'algokit generate' command. The generator is invoked with provided answers to interactive prompts via the '-a question answer' flag, and automatically acknowledges the input with 'y'. The standard output and standard error streams are merged and captured, and the execution directory is set to a subdirectory named after the test.", "output": "def run_generator(\n    working_dir: Path,\n    test_name: str,\n    generator_name: str,\n    answers: dict[str, str] | None = None,\n) -> subprocess.CompletedProcess:\n    copy_to = working_dir / generated_folder / test_name\n\n    init_args = [\n        \"algokit\",\n        \"--verbose\",\n        \"generate\",\n        str(generator_name),\n    ]\n\n    if answers:\n        for question, answer in answers.items():\n            init_args.extend([\"-a\", question, answer])\n\n    result = subprocess.run(\n        init_args,\n        input=\"y\",  # acknowledge that input is not a tty\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n        cwd=copy_to.absolute(),\n    )\n\n    return result"}
{"instruction": "Initialize a project with the 'starter' preset and then generate a smart contract named 'cool_contract' within that project, using the specified deployment language. Finally, check the generated codebase for errors.", "output": "def test_smart_contract_generator_default_starter_preset(\n    language: str, working_dir: Path\n) -> None:\n    test_name = f\"starter_beaker_smart_contract_{language}\"\n\n    response = run_init(\n        working_dir,\n        test_name,\n        answers={\n            \"preset_name\": \"starter\",\n            \"deployment_language\": language,\n        },\n    )\n    assert response.returncode == 0, response.stdout\n\n    response = run_generator(\n        working_dir,\n        test_name,\n        \"smart-contract\",\n        {\n            \"contract_name\": \"cool_contract\",\n            \"deployment_language\": language,\n        },\n    )\n    assert response.returncode == 0, response.stdout\n\n    response = check_codebase(working_dir, test_name)\n    assert response.returncode == 0, response.stdout"}
{"instruction": "Initialize a project with the 'production' preset and a specified deployment language, then generate a smart contract named 'cool_contract' using the same deployment language. Finally, check the generated codebase.", "output": "def test_smart_contract_generator_default_production_preset(\n    language: str, working_dir: Path\n) -> None:\n    test_name = f\"production_beaker_smart_contract_{language}\"\n\n    response = run_init(\n        working_dir,\n        test_name,\n        answers={\n            \"preset_name\": \"production\",\n            \"deployment_language\": language,\n        },\n    )\n    assert response.returncode == 0, response.stdout\n\n    response = run_generator(\n        working_dir,\n        test_name,\n        \"smart-contract\",\n        {\n            \"contract_name\": \"cool_contract\",\n            \"deployment_language\": language,\n        },\n    )\n    assert response.returncode == 0, response.stdout\n\n    response = check_codebase(working_dir, test_name)\n    assert response.returncode == 0, response.stdout"}
{"instruction": "Initialize a project named 'production_beaker_smart_contract_fail' using the 'starter' preset and 'python' as the deployment language, and assert that the initialization process fails (returns a non-zero exit code).", "output": "def test_template_fail() -> None:\n    test_name = \"production_beaker_smart_contract_fail\"\n\n    response = run_init(\n        root,\n        test_name,\n        answers={\n            \"preset_name\": \"starter\",\n            \"deployment_language\": \"python\",\n        },\n    )\n    assert response.returncode == 1, response.stdout"}
{"instruction": "Create a name suffix by joining values from the input keyword arguments with '_beaker'. Then, execute 'run_init' with the specified working directory, the generated name suffix, and the keyword arguments as answers.", "output": "def run_init_kwargs(\n    working_dir: Path, **kwargs: str | bool\n) -> subprocess.CompletedProcess:\n    answers = {k: str(v) for k, v in kwargs.items()}\n    name_suffix = \"_\".join(f\"{v}_beaker\" for _, v in answers.items())\n    return run_init(working_dir, f\"{name_suffix}\", answers=answers)"}
{"instruction": "Generate key-value pairs from a loaded 'copier.yaml' file, specifically focusing on the 'preset_name' question. For the 'preset_name' question, yield two pairs: ('preset_name', 'starter') and ('preset_name', 'production'). Filter questions based on a provided list of allowed question names if present.", "output": "def get_questions_from_copier_yaml(\n    allowed_questions: list[str] | None = None,\n) -> Iterator[tuple[str, str | bool]]:\n    copier_yaml = root / \"copier.yaml\"\n\n    questions = _load_copier_yaml(copier_yaml)\n    for question_name, details in questions.items():\n        if allowed_questions and question_name not in allowed_questions:\n            continue\n        if isinstance(details, dict):\n            is_preset_question = question_name == \"preset_name\"\n\n            if is_preset_question:\n                for preset_choice in [\"starter\", \"production\"]:\n                    yield question_name, preset_choice"}
{"instruction": "Run a command with specified keyword arguments, where the keyword arguments represent answers to interactive questions. Assert that the command executes successfully and returns a zero exit code.", "output": "def test_parameters(working_dir: Path, question_name: str, answer: str | bool) -> None:\n    response = run_init_kwargs(working_dir, **{question_name: answer})\n    assert response.returncode == 0, response.stdout"}
{"instruction": "Assign the value of the input string 'v' to the output string 'output'.", "output": "def echo(v: pt.abi.String, *, output: pt.abi.String) -> pt.Expr:\n    \"\"\"echos the string back unchanged\"\"\"\n    return output.set(v)"}
{"instruction": "Convert the input expression 'i' to a 16-bit unsigned integer by first converting it to a byte representation, and then padding it with 6 zero bits on the end.", "output": "def to_u16(i: pt.Expr) -> pt.Expr:\n    return pt.Suffix(pt.Itob(i), pt.Int(6))"}
{"instruction": "Implement an Algorand smart contract that demonstrates array manipulation using PyTeal. The contract should include functions to sum the elements of a dynamic array of unsigned 64-bit integers, concatenate static arrays of unsigned 64-bit integers, concatenate dynamic arrays of unsigned 64-bit integers, and concatenate dynamic arrays of strings. The concatenation functions should handle the length prefixes and offsets appropriately to ensure correct ABI encoding.", "output": "def array_blueprint(app: beaker.Application) -> None:\n    @app.external\n    def sum_dynamic_array(\n        v: pt.abi.DynamicArray[pt.abi.Uint64], *, output: pt.abi.Uint64\n    ) -> pt.Expr:\n        \"\"\"sums the array of ints\"\"\"\n        return pt.Seq(\n            # Use a scratch var to store the running sum\n            (running_sum := pt.ScratchVar(pt.TealType.uint64)).store(pt.Int(0)),\n            # Iterate over the elements of the array\n            pt.For(\n                (i := pt.ScratchVar()).store(pt.Int(0)),\n                i.load() < v.length(),\n                i.store(i.load() + pt.Int(1)),\n            ).Do(\n                # Access the element with square bracket annotation\n                # and call `use` on it to use the value since its a\n                # computed type like tuple elements\n                v[i.load()].use(\n                    lambda val: running_sum.store(running_sum.load() + val.get())\n                )\n            ),\n            # Set the value we're returning\n            output.set(running_sum.load()),\n        )\n\n    # While its not advisable to make heavy use dynamic ABI\n    # types within the logic of the contract due to the inefficient\n    # access to elements, below are some examples of how you\n    # might construct a larger array from 2 smaller ones\n    @app.external\n    def concat_static_arrays(\n        a: pt.abi.StaticArray[pt.abi.Uint64, Literal[3]],\n        b: pt.abi.StaticArray[pt.abi.Uint64, Literal[3]],\n        *,\n        output: pt.abi.StaticArray[pt.abi.Uint64, Literal[6]],\n    ) -> pt.Expr:\n        # Static arrays are easy to concat since there is no\n        # length prefix or offsets to track. The typing of the\n        # value includes the length explicitly.\n        return output.decode(pt.Concat(a.encode(), b.encode()))\n\n    @app.external\n    def concat_dynamic_arrays(\n        a: pt.abi.DynamicArray[pt.abi.Uint64],\n        b: pt.abi.DynamicArray[pt.abi.Uint64],\n        *,\n        output: pt.abi.DynamicArray[pt.abi.Uint64],\n    ) -> pt.Expr:\n        \"\"\"demonstrate how two dynamic arrays of static elements could be concat'd\"\"\"\n        # A Dynamic array of static types is encoded as:\n        # [uint16 length, element 0, element 1]\n        # so to concat them, we must remove the 2 byte length prefix\n        # from each, and prepend the new length (of elements!) as 2 byte integer\n        return output.decode(\n            pt.Concat(\n                pt.Suffix(pt.Itob(a.length() + b.length()), pt.Int(6)),\n                pt.Suffix(a.encode(), pt.Int(2)),\n                pt.Suffix(b.encode(), pt.Int(2)),\n            )\n        )\n\n    @app.external\n    def concat_dynamic_string_arrays(\n        a: pt.abi.DynamicArray[pt.abi.String],\n        b: pt.abi.DynamicArray[pt.abi.String],\n        *,\n        output: pt.abi.DynamicArray[pt.abi.String],\n    ) -> pt.Expr:\n        \"\"\"demonstrate how two dynamic arrays of dynamic elements could be concat'd\"\"\"\n        # NOTE: this is not efficient (clearly), static types should\n        # always be preferred if possible. Otherwise use some encoding\n        # other than the abi encoding, which is more for serializing/deserializing data\n\n        # A Dynamic array of dynamic types is encoded as:\n        # [uint16 length, uint16 pos elem 0, uint16 pos elem 1, elem 0, elem 1]\n        # so to concat them, we must remove the 2 byte length prefix\n        # from each, and prepend the new length (of elements!) as 2 byte integer\n        return pt.Seq(\n            # Make a couple bufs for the header (offsets) and elements\n            (_head_buf := pt.ScratchVar()).store(\n                pt.Suffix(pt.Itob(a.length() + b.length()), pt.Int(6))\n            ),\n            # Take the element contents of the 2 arrays\n            (_tail_buf := pt.ScratchVar()).store(\n                pt.Concat(\n                    # strip length and positions, now its [elem0, elem1, elem2]\n                    pt.Suffix(a.encode(), pt.Int(2) + (pt.Int(2) * a.length())),\n                    pt.Suffix(b.encode(), pt.Int(2) + (pt.Int(2) * b.length())),\n                )\n            ),\n            # Create the offset value we'll use for the position header\n            # we know the first string will start at 2 * combined length\n            (offset := pt.ScratchVar()).store(((a.length() + b.length()) * pt.Int(2))),\n            # We'll track the current string we're working on here\n            (curr_str_len := pt.ScratchVar()).store(pt.Int(0)),\n            (cursor := pt.ScratchVar()).store(pt.Int(0)),\n            pt.While(\n                (cursor.load() + curr_str_len.load()) <= pt.Len(_tail_buf.load())\n            ).Do(\n                # Add the offset for this string to the head buf\n                _head_buf.store(pt.Concat(_head_buf.load(), to_u16(offset.load()))),\n                # Get the length of the current string + 2 bytes for uint16 len\n                curr_str_len.store(\n                    pt.ExtractUint16(_tail_buf.load(), cursor.load()) + pt.Int(2)\n                ),\n                # update our cursor to point to the next str element\n                cursor.store(cursor.load() + curr_str_len.load()),\n                # update our offset similarly\n                offset.store(offset.load() + curr_str_len.load()),\n            ),\n            output.decode(pt.Concat(_head_buf.load(), _tail_buf.load())),\n        )"}
{"instruction": "Define a named tuple, 'StructyTuple', using PyTeal's ABI functionality.  The tuple has two fields: 'a' and 'b', both of which are unsigned 64-bit integers represented using PyTeal's ABI field wrapper.", "output": "class StructyTuple(pt.abi.NamedTuple):\n    # Note that the type is wrapped in a `pt.abi.Field`\n    a: pt.abi.Field[pt.abi.Uint64]\n    b: pt.abi.Field[pt.abi.Uint64]"}
{"instruction": "Implement two external methods for a PyTeal application that operate on a tuple of two Uint64 elements (StructyTuple). The first method, `sum_tuple_elements_with_use`, calculates the sum of the tuple's elements using the `use` method with a lambda function to access the elements as ABI types. The second method, `sum_tuple_elements_with_store_into`, calculates the sum by storing the tuple elements into ABI Uint64 variables using the `.set` method, which implicitly calls `store_into`, and then adding the values.", "output": "def named_tuple_blueprint(app: beaker.Application) -> None:\n    @app.external\n    def sum_tuple_elements_with_use(\n        t: StructyTuple, *, output: pt.abi.Uint64\n    ) -> pt.Expr:\n        \"\"\"sum the elements of the tuple with `use` and lambda\"\"\"\n        return pt.Seq(\n            (running_sum := pt.ScratchVar(pt.TealType.uint64)).store(pt.Int(0)),\n            # we can pass a lambda into the `use` method to access the value\n            # as the abi type it was declared as\n            t.a.use(lambda a: running_sum.store(running_sum.load() + a.get())),\n            t.b.use(lambda b: running_sum.store(running_sum.load() + b.get())),\n            output.set(running_sum.load()),\n        )\n\n    @app.external\n    def sum_tuple_elements_with_store_into(\n        t: StructyTuple, *, output: pt.abi.Uint64\n    ) -> pt.Expr:\n        \"\"\"sum the elements of the tuple with `.set` on matching abi type\"\"\"\n        return pt.Seq(\n            # we can pass the tuple element into a `set` method for the same type\n            # under the covers this calls the `store_into` method on the element\n            # with the abi type as the argument\n            (a := pt.abi.Uint64()).set(t.a),\n            (b := pt.abi.Uint64()).set(t.b),\n            output.set(a.get() + b.get()),\n        )"}
{"instruction": "Implement a Beaker application blueprint named 'calculator' that provides external methods for performing basic arithmetic operations (addition, subtraction, division, and multiplication) on unsigned 64-bit integers. Each operation should take two Uint64 inputs (a and b) and return a Uint64 output representing the result of the operation.", "output": "def calculator(app: beaker.Application) -> None:\n    \"\"\"blueprint to add math operations to an application\"\"\"\n\n    @app.external\n    def add(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:\n        \"\"\"Add b to a\"\"\"\n        return output.set(a.get() + b.get())\n\n    @app.external\n    def sub(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:\n        \"\"\"Subtract b from a\"\"\"\n        return output.set(a.get() - b.get())\n\n    @app.external\n    def div(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:\n        \"\"\"Divide a by b\"\"\"\n        return output.set(a.get() / b.get())\n\n    @app.external\n    def mul(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:\n        \"\"\"Multiply a and b\"\"\"\n        return output.set(a.get() * b.get())"}
{"instruction": "Define a PyTeal application that adds a fixed integer 'n' to a Uint64 input 'a' and returns the result as a Uint64 output.", "output": "def add_n(app: beaker.Application, n: int) -> None:\n    \"\"\"blueprint to add n to the input number\"\"\"\n\n    @app.external\n    def add_n(a: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:\n        \"\"\"Add n to a\"\"\"\n        return output.set(a.get() + pt.Int(n))"}
{"instruction": "Define a stateful smart contract with Box storage. It includes a BoxMapping to store account balances (address to uint64), a BoxList to store a fixed-size list of member addresses, and a GlobalStateValue to track the total number of members. The BoxMapping creates a new box for each new address, and the BoxList has a pre-defined maximum capacity.", "output": "class BoxExampleState:\n    # Declares a BoxMapping, where each key is an address and each value is a uint64\n    # every new key creates a new box.\n    balances = storage.BoxMapping(pt.abi.Address, pt.abi.Uint64)\n\n    # Declares a BoxList, where each element is a 32 byte array and\n    # creates a box with space for MAX_MEMBERS elements\n    members = storage.BoxList(pt.abi.Address, MAX_MEMBERS)\n\n    # Add a global state value to track the total count of elements in the box\n    member_count = beaker.GlobalStateValue(pt.TealType.uint64)"}
{"instruction": "Create an Algorand smart contract logic that initializes the global state of the application and creates a box named 'members', discarding the boolean result of the box creation.", "output": "def bootstrap() -> pt.Expr:\n    return pt.Seq(\n        app.initialize_global_state(),\n        # create returns a bool value indicating if the box was created\n        # we just pop it here to discard it\n        pt.Pop(app.state.members.create()),\n    )"}
{"instruction": "Set the balance for a given address to a specified amount. The balance is stored in the application's state under the 'balances' key, using the address as the key within the balances dictionary, and setting the corresponding value to the provided amount.", "output": "def set_balance(addr: pt.abi.Address, amount: pt.abi.Uint64) -> pt.Expr:\n    \"\"\"Sets the balance of an address\"\"\"\n    return app.state.balances[addr].set(amount)"}
{"instruction": "Read the balance associated with a given address from the application's state and decode it into a Uint64.", "output": "def read_balance(addr: pt.abi.Address, *, output: pt.abi.Uint64) -> pt.Expr:\n    return output.decode(app.state.balances[addr].get())"}
{"instruction": "Implement a function that adds a new member address to a list of members if the list is not full. Store the address in a dedicated member slot, initialize the balance associated with that address to zero, and increment the member count.", "output": "def add_member(addr: pt.abi.Address) -> pt.Expr:\n    \"\"\"Adds a new member to the list\"\"\"\n    return pt.Seq(\n        pt.Assert(app.state.member_count < pt.Int(MAX_MEMBERS), comment=\"List is full\"),\n        app.state.members[app.state.member_count].set(addr),\n        # Write a zero balance to the balance box\n        # for this address\n        app.state.balances[addr].set(pt.Itob(pt.Int(0))),\n        app.state.member_count.increment(),\n    )"}
{"instruction": "Write an Algorand PyTeal expression that puts data into a box. The expression should take a box name (string) and box data (a dynamic array of strings) as input. The expression should encode the box data and then store it in the box with the given name.", "output": "def fill_box(\n    box_name: pt.abi.String, box_data: pt.abi.DynamicArray[pt.abi.String]\n) -> pt.Expr:\n    return pt.BoxPut(box_name.get(), box_data.encode())"}
{"instruction": "Calculate the minimum balance required for an application based on the number of members. The calculation includes the minimum balance for the member token, balance boxes for each member, and a member list box, taking into account flat minimum balance, byte minimum balance, the size of Uint64, and the size of an Address.", "output": "def compute_min_balance(members: int):\n    \"\"\"Compute the min balance for the app to hold the boxes we need\"\"\"\n    return (\n        consts.ASSET_MIN_BALANCE  # Cover min bal for member token\n        + (\n            consts.BOX_FLAT_MIN_BALANCE\n            + (pt.abi.size_of(pt.abi.Uint64) * consts.BOX_BYTE_MIN_BALANCE)\n        )\n        * members  # cover min bal for balance boxes we might create\n        + (\n            consts.BOX_FLAT_MIN_BALANCE\n            + (members * pt.abi.size_of(pt.abi.Address) * consts.BOX_BYTE_MIN_BALANCE)\n        )  # cover min bal for member list box\n    )"}
{"instruction": "Call the 'echo' method of another Algorand smart contract application, passing a string as an argument. Extract the echoed string from the inner transaction's last log and store it in the output variable.", "output": "def call_other_application(\n    other_application: pt.abi.Application,\n    string_to_echo: pt.abi.String,\n    *,\n    output: pt.abi.String,\n) -> pt.Expr:\n    \"\"\"calls another contract and returns the result\"\"\"\n    return pt.Seq(\n        # Call the echo method on the other application\n        pt.InnerTxnBuilder.ExecuteMethodCall(\n            app_id=other_application.application_id(),\n            method_signature=echo.method_signature(),\n            args=[string_to_echo],\n            extra_fields={\n                # Set the fee to 0 so we don't have to\n                # fund the app account. We'll have to cover\n                # the fee ourselves when we call this method\n                # from off chain\n                pt.TxnField.fee: pt.Int(0),\n            },\n        ),\n        # Set the output to whatever it sent us back\n        output.set(pt.Suffix(pt.InnerTxn.last_log(), pt.Int(4))),\n    )"}
{"instruction": "Create two application clients using the same application definition. Deploy both applications to the blockchain. Fund the first application client and then call a method on the first application that calls a method on the second application, passing a string to be echoed. Finally, print the return value of the first application client call.", "output": "def demo() -> None:\n    algod_client = beaker.sandbox.get_algod_client()\n    account = beaker.sandbox.get_accounts().pop()\n\n    # create a couple of clients for the same underlying application\n    # definition\n    first_app_client = beaker.client.ApplicationClient(\n        algod_client,\n        application.app,\n        signer=account.signer,\n    )\n\n    second_app_client = beaker.client.ApplicationClient(\n        algod_client,\n        application.app,\n        signer=account.signer,\n    )\n\n    # Deploy the apps on-chain\n    first_app_client.create()\n    second_app_client.create()\n\n    # fund the first app client\n\n    # Set up our suggested params\n    # to cover the fee for the inner transaction\n    # that the app executes\n    sp = algod_client.suggested_params()\n    sp.fee = sp.min_fee * 2\n    sp.flat_fee = True\n\n    # Call the `call_other_application` method\n    call_response = first_app_client.call(\n        application.call_other_application,\n        other_application=second_app_client.app_id,\n        string_to_echo=\"Echo this\",\n        suggested_params=sp,\n    )\n    print(call_response.return_value)"}
{"instruction": "Define an application state with various global and local state variables, including declared values with static properties and defaults, reserved values with key limits, and blobs for storing byte arrays.", "output": "class ExampleState:\n    # A single global byte slice will be reserved for the application.\n    # The key for the global state value will be the name of the attribute by default.\n    # The `default` argument is used to set the initial value of the state variable.\n    # The `static` flag is indicates the value shouldn't change after it's been set.\n    declared_global_value = beaker.GlobalStateValue(\n        stack_type=pt.TealType.bytes,\n        default=pt.Bytes(\n            \"A declared state value that is protected with the `static` flag\"\n        ),\n        descr=\"A static declared value, nothing at the protocol level protects it, \"\n        \"only the methods defined on ApplicationState do\",\n        static=True,\n    )\n\n    # Use `Reserved*` if the application cant know the names of the keys\n    # or exactly how many keys might be used. The `max_keys` argument\n    # is used to reserve schema space in the application state.\n    reserved_global_value = beaker.ReservedGlobalStateValue(\n        stack_type=pt.TealType.uint64,\n        max_keys=32,\n        descr=\"A reserved app state variable, with 32 possible keys\",\n    )\n\n    # A blob is a Binary Large OBject, it is a way to store bytes as a contiguous\n    # array of bytes that can be read and written to.\n    global_blob = beaker.GlobalStateBlob(\n        keys=16,\n    )\n\n    # Similar to `declared_global_value`, a single local state value (of type uint64)\n    # will be reserved for each account that opts in to the application.\n    declared_local_value = beaker.LocalStateValue(\n        stack_type=pt.TealType.uint64,\n        default=pt.Int(1),\n        descr=\"An int stored for each account that opts in\",\n    )\n\n    # Similar to `reserved_global_value`, but for local state\n    reserved_local_value = beaker.ReservedLocalStateValue(\n        stack_type=pt.TealType.bytes,\n        max_keys=8,\n        descr=\"A reserved state value, allowing 8 keys to be reserved, \"\n        \"in this case byte type\",\n    )\n\n    # Similar to `global_blob`, but for local state\n    local_blob = beaker.LocalStateBlob(keys=3)"}
{"instruction": "Initialize the application's global state.", "output": "def create() -> pt.Expr:\n    return app.initialize_global_state()"}
{"instruction": "Implement a function that opts in a user to the application by initializing their local state.", "output": "def opt_in() -> pt.Expr:\n    return app.initialize_local_state()"}
{"instruction": "Write the value of the input string 'v' to the application's local storage 'local_blob' at index 0.", "output": "def write_local_blob(v: pt.abi.String) -> pt.Expr:\n    return app.state.local_blob.write(pt.Int(0), v.get())"}
{"instruction": "Read all but the last byte of the local_blob state variable into the output DynamicBytes.", "output": "def read_local_blob(*, output: pt.abi.DynamicBytes) -> pt.Expr:\n    return output.set(\n        app.state.local_blob.read(\n            pt.Int(0), app.state.local_blob.blob.max_bytes - pt.Int(1)\n        )\n    )"}
{"instruction": "Write the value of the string variable 'v' to the global state variable 'global_blob' at index 0.", "output": "def write_global_blob(v: pt.abi.String) -> pt.Expr:\n    return app.state.global_blob.write(pt.Int(0), v.get())"}
{"instruction": "Read almost the entire contents of the global 'global_blob' state variable, excluding the last byte, and store the result in the 'output' variable.", "output": "def read_global_blob(*, output: pt.abi.DynamicBytes) -> pt.Expr:\n    return output.set(\n        app.state.global_blob.read(\n            pt.Int(0), app.state.global_blob.blob.max_bytes - pt.Int(1)\n        )\n    )"}
{"instruction": "Set the value of the application's global state variable 'declared_global_value' to the value provided by the input 'v', which is assumed to be a pt.abi.String, after extracting its underlying string representation.", "output": "def set_global_state_val(v: pt.abi.String) -> pt.Expr:\n    # This will fail, since it was declared as `static` and initialized to\n    # a default value during create\n    return app.state.declared_global_value.set(v.get())"}
{"instruction": "Assign the value of the declared global application state to the output string.", "output": "def get_global_state_val(*, output: pt.abi.String) -> pt.Expr:\n    return output.set(app.state.declared_global_value)"}
{"instruction": "Set a reserved global state value for an application. The key, `k`, is a Uint8 ABI type. The value, `v`, is a Uint64 ABI type. The value stored in the global state will be the decoded value of the Uint64 ABI type.", "output": "def set_reserved_global_state_val(k: pt.abi.Uint8, v: pt.abi.Uint64) -> pt.Expr:\n    # Accessing the key with square brackets, accepts both Expr and an ABI type\n    # If the value is an Expr it must evaluate to `TealType.bytes`\n    # If the value is an ABI type, the `encode` method is used to convert it to bytes\n    return app.state.reserved_global_value[k].set(v.get())"}
{"instruction": "Retrieve a value from the application's global state, specifically from the 'reserved_global_value' mapping using the provided Uint8 key 'k', and assign that value to the Uint64 ABI type 'output'.", "output": "def get_reserved_global_state_val(k: pt.abi.Uint8, *, output: pt.abi.Uint64) -> pt.Expr:\n    return output.set(app.state.reserved_global_value[k])"}
{"instruction": "Set the value of a user's local state variable to the value provided as input.", "output": "def set_local_state_val(v: pt.abi.Uint64) -> pt.Expr:\n    # Accessing with `[Txn.sender()]` is redundant but\n    # more clear what is happening\n    return app.state.declared_local_value[pt.Txn.sender()].set(v.get())"}
{"instruction": "Increment the value of the declared local state for the current application by the amount specified in the input argument.", "output": "def incr_local_state_val(v: pt.abi.Uint64) -> pt.Expr:\n    # Omitting [Txn.sender()] just for demo purposes\n    return app.state.declared_local_value.increment(v.get())"}
{"instruction": "Set the value of the Uint64 variable 'output' to the value of the 'declared_local_value' state variable for the sender of the current transaction.", "output": "def get_local_state_val(*, output: pt.abi.Uint64) -> pt.Expr:\n    return output.set(app.state.declared_local_value[pt.Txn.sender()])"}
{"instruction": "Set the value of a reserved local state key for the transaction sender to a given string. The key is a Uint8 and the value is a String.", "output": "def set_reserved_local_state_val(k: pt.abi.Uint8, v: pt.abi.String) -> pt.Expr:\n    return app.state.reserved_local_value[k][pt.Txn.sender()].set(v.get())"}
{"instruction": "Retrieve a reserved local state value from the application's state. The value is accessed using a key `k` of type Uint8 and the current transaction's sender. Store the retrieved value into the `output` variable of type String.", "output": "def get_reserved_local_state_val(k: pt.abi.Uint8, *, output: pt.abi.String) -> pt.Expr:\n    return output.set(app.state.reserved_local_value[k][pt.Txn.sender()])"}
{"instruction": "Verify that the `run_init` function, when executed in the specified working directory with the project name 'test_default_parameters', returns a successful exit code (0).", "output": "def test_default_parameters(working_dir: Path) -> None:\n    response = run_init(working_dir, \"test_default_parameters\")\n\n    assert response.returncode == 0"}
{"instruction": "Validate that the provided integer value representing a timeout is within the acceptable range defined by CODESPACE_FORWARD_TIMEOUT_MIN and CODESPACE_FORWARD_TIMEOUT_MAX. If the value is outside this range, raise a click.BadParameter exception with an informative message. Otherwise, return the validated value.", "output": "def _validate_run_timeout(_ctx: click.Context, _param: click.Parameter, value: int) -> int:\n    if value < CODESPACE_FORWARD_TIMEOUT_MIN or value > CODESPACE_FORWARD_TIMEOUT_MAX:\n        raise click.BadParameter(\n            f\"Timeout must be between {CODESPACE_FORWARD_TIMEOUT_MIN} and {CODESPACE_FORWARD_TIMEOUT_MAX} minutes.\"\n        )\n    return value"}
{"instruction": "Manage an AlgoKit LocalNet environment within a GitHub Codespace. This includes: optionally deleting existing codespaces with a specific prefix, creating a new codespace from a given repository with specified machine type and timeout, waiting for the codespace to become ready, forwarding specified ports (algod, kmd, indexer), and finally deleting the codespace upon completion, timeout, keyboard interrupt, or other error.", "output": "def codespace_command(  # noqa: PLR0913\n    *,\n    machine: str,\n    algod_port: int,\n    indexer_port: int,\n    kmd_port: int,\n    codespace_name: str,\n    repo_url: str,\n    timeout_minutes: int,\n    force: bool,\n) -> None:\n    \"\"\"Manage the AlgoKit LocalNet in GitHub Codespaces.\"\"\"\n    ensure_github_cli_installed()\n\n    if not authenticate_with_github():\n        return\n\n    codespaces = list_github_codespaces()\n\n    # Delete existing codespaces with the default name\n    if codespaces and (\n        force\n        or questionary_extensions.prompt_confirm(\n            f\"Delete previously used codespaces with `{CODESPACE_NAME_PREFIX}*` name prefix?\", default=True\n        )\n    ):\n        delete_codespaces_with_prefix(codespaces, CODESPACE_NAME_PREFIX)\n\n    # Create a new codespace\n    codespace_name = codespace_name or f\"{CODESPACE_NAME_PREFIX}_{int(time())}\"\n    # Add a 5 minute timeout buffer, so the codespace doesn't terminate before the port forwarding\n    codespace_timeout = (\n        (timeout_minutes + 5)\n        if (timeout_minutes + 5) < CODESPACE_FORWARD_TIMEOUT_MAX\n        else CODESPACE_FORWARD_TIMEOUT_MAX\n    )\n    create_codespace(\n        repo_url,\n        codespace_name,\n        machine,\n        codespace_timeout,\n    )\n\n    codespace_data: dict[str, Any] | None = None\n\n    try:\n        logger.info(f\"Waiting for codespace {codespace_name} to be ready...\")\n        codespace_data = is_codespace_ready(codespace_name)\n        if not codespace_data:\n            raise RuntimeError(\"Error creating codespace. Please check your internet connection and try again.\")\n\n        logger.info(f\"Codespace {codespace_name} is now ready.\")\n        logger.warning(\n            \"Keep the terminal open during the LocalNet session. \"\n            \"Terminating the session will delete the codespace instance.\"\n        )\n\n        forward_ports_for_codespace(\n            codespace_data[\"name\"], algod_port, kmd_port, indexer_port, timeout=timeout_minutes * 60\n        )\n        logger.info(\"LocalNet started in GitHub Codespace\")\n\n    except subprocess.TimeoutExpired:\n        logger.warning(\"Timeout reached. Shutting down the codespace...\")\n    except KeyboardInterrupt:\n        logger.warning(\"Keyboard interrupt received. Shutting down the codespace...\")\n    except Exception as e:\n        logger.error(e)\n    finally:\n        logger.info(\"Exiting...\")\n        if codespace_data:\n            delete_codespace(codespace_data=codespace_data, force=force)"}
{"instruction": "Set the 'version' key in the click context's object to the provided 'version' value.", "output": "def compile_group(context: click.Context, version: str | None) -> None:\n    \"\"\"\n    Compile smart contracts and smart signatures written in a supported high-level language\n    to a format deployable on the Algorand Virtual Machine (AVM).\n    \"\"\"\n    context.ensure_object(dict)\n    context.obj[\"version\"] = version"}
{"instruction": "Define an empty function named `completions_group` that takes no arguments and returns nothing (None).", "output": "def completions_group() -> None:\n    pass"}
{"instruction": "Install shell completions for the specified or detected shell by updating the interactive profile script to enable algokit completions.", "output": "def install(shell: str | None) -> None:\n    \"\"\"Install shell completions, this command will attempt to update the interactive profile script\n    for the current shell to support algokit completions. To specify a specific shell use --shell.\"\"\"\n    shell_completion = ShellCompletion(shell)\n    shell_completion.install()"}
{"instruction": "Uninstall shell completions by removing any algokit completions from the interactive profile script of the current or specified shell.", "output": "def uninstall(shell: str | None) -> None:\n    \"\"\"Uninstall shell completions, this command will attempt to update the interactive profile script\n    for the current shell to remove any algokit completions that have been added.\n    To specify a specific shell use --shell.\"\"\"\n    shell_completion = ShellCompletion(shell)\n    shell_completion.uninstall()"}
{"instruction": "Install or uninstall shell completions for the 'algokit' command-line tool. The installation process involves saving a completion script to a file and adding a line to the user's shell profile file (e.g., .bashrc, .zshrc) to source the completion script. The uninstallation process removes the completion script and the corresponding line from the shell profile.", "output": "class ShellCompletion:\n    def __init__(self, shell: str | None) -> None:\n        shell = shell or _get_current_shell()\n        self.shell = shell\n        self.source_path = get_app_config_dir() / f\".algokit-completions.{shell}\"\n        self.profile_path = Path(f\"~/.{shell}rc\").expanduser()\n        home_based_source_path = _get_home_based_path(self.source_path)\n        self.profile_line = f\". {home_based_source_path}\\n\"\n\n    def install(self) -> None:\n        try:\n            self._save_source()\n        except click.exceptions.Exit:\n            raise\n        if self._insert_profile_line():\n            logger.info(f\"AlgoKit completions installed for {self.shell} \")\n        else:\n            logger.info(f\"{self.profile_path} already contains completion source \")\n        home_based_profile_path = _get_home_based_path(self.profile_path)\n        logger.info(f\"Restart shell or run `. {home_based_profile_path}` to enable completions\")\n\n    def uninstall(self) -> None:\n        self._remove_source()\n        if self._remove_profile_line():\n            logger.info(f\"AlgoKit completions uninstalled for {self.shell} \")\n        else:\n            logger.info(f\"AlgoKit completions not installed for {self.shell} \")\n\n    @property\n    def source(self) -> str:\n        completion_class = click.shell_completion.get_completion_class(self.shell)\n        if completion_class is None:\n            raise click.ClickException(f\"Unsupported shell for completions: {self.shell}\")\n        completion = completion_class(\n            # class is only instantiated to get source snippet, so don't need to pass a real command\n            cli=None,  # type: ignore[arg-type]\n            ctx_args={},\n            prog_name=\"algokit\",\n            complete_var=\"_ALGOKIT_COMPLETE\",\n        )\n        try:\n            return completion.source()\n        except RuntimeError as ex:\n            logger.debug(f\"Failed to generate completion source. {ex}\")\n            if self.shell == \"bash\":\n                logger.error(\"Shell completion is not supported for Bash versions older than 4.4.\")\n            else:\n                logger.error(\"Failed to install completions .\")\n            raise click.exceptions.Exit(code=1) from ex\n\n    def _save_source(self) -> None:\n        # grab source before attempting to write file in case it fails\n        source = self.source\n        logger.debug(f\"Writing source script {self.source_path}\")\n        self.source_path.write_text(source, encoding=\"utf-8\")\n\n    def _remove_source(self) -> None:\n        logger.debug(f\"Removing source script {self.source_path}\")\n        self.source_path.unlink(missing_ok=True)\n\n    def _insert_profile_line(self) -> bool:\n        try:\n            content = self.profile_path.read_text(encoding=\"utf-8\")\n        except FileNotFoundError:\n            pass\n        else:\n            if self.profile_line in content:\n                # profile already contains source of completion script. nothing to do\n                return False\n\n        logger.debug(f\"Appending completion source to {self.profile_path}\")\n        # got to end of file, so append profile line\n        atomic_write(self.profile_line, self.profile_path, \"a\")\n        return True\n\n    def _remove_profile_line(self) -> bool:\n        try:\n            content = self.profile_path.read_text(encoding=\"utf-8\")\n        except FileNotFoundError:\n            logger.debug(f\"{self.profile_path} not found\")\n            return False\n        # see if profile script contains profile_line, if it does remove it\n        if self.profile_line not in content:\n            return False\n        logger.debug(f\"Completion source found in {self.profile_path}\")\n        content = content.replace(self.profile_line, \"\")\n\n        logger.debug(f\"Removing completion source found in {self.profile_path}\")\n        atomic_write(content, self.profile_path, \"w\")\n        return True"}
{"instruction": "Given a path, check if it's within the user's home directory. If it is, return the path relative to the home directory, prefixed with '~'. Otherwise, return the original path.", "output": "def _get_home_based_path(path: Path) -> Path:\n    home = Path.home()\n    try:\n        home_based_path = path.relative_to(home)\n    except ValueError:\n        return path\n    else:\n        return \"~\" / home_based_path"}
{"instruction": "Detect the current shell using the `shellingham` library. If detection fails or the detected shell is not supported, log a warning, suggest specifying a supported shell via command-line argument, and exit with a non-zero exit code.", "output": "def _get_current_shell() -> str:\n    try:\n        shell_name, *_ = shellingham.detect_shell()\n    except Exception as ex:\n        logger.debug(\"Could not determine current shell\", exc_info=ex)\n        logger.warning(\"Could not determine current shell. Try specifying a supported shell with --shell\")\n        raise click.exceptions.Exit(code=1) from ex\n\n    if shell_name not in SUPPORTED_SHELLS:\n        logger.warning(f\"{shell_name} is not a supported shell. \")\n        raise click.exceptions.Exit(code=1)\n    return str(shell_name)"}
{"instruction": "Configure settings for AlgoKit.", "output": "def config_group() -> None:\n    \"\"\"Configure settings used by AlgoKit\"\"\""}
{"instruction": "Define a data class `DispenserAsset` with attributes `asset_id` (integer), `decimals` (integer), and `description` (string).", "output": "class DispenserAsset:\n    asset_id: int\n    decimals: int\n    description: str"}
{"instruction": "Define an enumeration named `outputMode` with two possible values: `STDOUT` which corresponds to the string 'stdout', and `FILE` which corresponds to the string 'file'.", "output": "class outputMode(enum.Enum):\n    STDOUT = \"stdout\"\n    FILE = \"file\""}
{"instruction": "Define an enumeration called `DispenserAssetName` that uses integer values, with a member named `ALGO` assigned the value 0.", "output": "class DispenserAssetName(enum.IntEnum):\n    ALGO = 0"}
{"instruction": "Generate a new Algorand account, retrieve its private key, public address, and mnemonic phrase representation.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate a new Algorand account, derive the private key and corresponding Algorand address, and then generate the mnemonic phrase from the private key.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate a new Algorand account, deriving both the private key and corresponding address, then convert the private key into its mnemonic phrase representation.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Given a token and an output destination (either stdout or a specified file), write the token to the specified destination and log a warning about keeping the token secure.", "output": "def _handle_ci_token(output_mode: str, output_filename: str, token_data: dict) -> None:\n    if output_mode == outputMode.STDOUT.value:\n        click.echo(f'\\n{DISPENSER_ACCESS_TOKEN_KEY} (valid for 30 days):\\n\\n{token_data[\"access_token\"]}\\n')\n        logger.warning(\n            \"Your CI access token has been printed to stdout.\\n\"\n            \"Please ensure you keep this token safe!\\n\"\n            \"If needed, clear your terminal history after copying the token!\"\n        )\n    else:\n        with Path.open(Path(output_filename), mode=\"w\", encoding=\"utf-8\") as token_file:\n            token_file.write(token_data[\"access_token\"])\n        logger.warning(\n            f\"Your CI access token has been saved to `{output_filename}`.\\n\"\n            \"Please ensure you keep this file safe or remove after copying the token!\"\n        )"}
{"instruction": "Modify a click.Group subclass called DispenserGroup to override the get_command method. If a command is found normally using the superclass's get_command method, check for network connectivity. If a network connection is available, return the found command. If a network connection is unavailable, log an error message and exit the program with an exit code of 1.", "output": "class DispenserGroup(click.Group):\n    def get_command(self, ctx: click.Context, cmd_name: str) -> click.Command | None:\n        return_value = super().get_command(ctx, cmd_name)\n\n        if return_value is None:\n            return None\n        elif is_network_available():\n            return return_value\n        else:\n            logger.error(\"Please connect to internet first\")\n            raise click.exceptions.Exit(code=1)"}
{"instruction": "Interact with the AlgoKit TestNet Dispenser.", "output": "def dispenser_group() -> None:\n    \"\"\"Interact with the AlgoKit TestNet Dispenser.\"\"\""}
{"instruction": "Implement a logout functionality. If the user is authenticated, revoke the refresh token and clear dispenser credentials. Handle potential exceptions during the logout process and log relevant information. If the user is not authenticated, indicate that they are already logged out.", "output": "def logout_command() -> None:\n    if is_authenticated():\n        try:\n            revoke_refresh_token()\n            clear_dispenser_credentials()\n        except Exception as e:\n            logger.debug(f\"Error logging out {e}\")\n            raise click.ClickException(\"Error logging out\") from e\n        logger.info(\"Logout successful\")\n    else:\n        logger.warning(\"Already logged out\")"}
{"instruction": "Log the user in to the dispenser API. If the 'ci' flag is set, obtain an API token for CI/CD environments and handle the token based on the specified output mode and filename. Otherwise, obtain a user API token with offline access, store the credentials, and log a success message. Handle any exceptions during the token retrieval process.", "output": "def login_command(*, ci: bool, output_mode: str, output_filename: str) -> None:\n    if not ci and is_authenticated():\n        logger.info(\"You are already logged in\")\n        return\n\n    try:\n        audience = DispenserApiAudiences.CI if ci else DispenserApiAudiences.USER\n        custom_scopes = None if ci else \"offline_access\"\n        token_data = get_oauth_tokens(api_audience=audience, custom_scopes=custom_scopes)\n\n        if not token_data:\n            raise click.ClickException(\"Error obtaining auth token\")\n\n        if ci:\n            _handle_ci_token(output_mode, output_filename, token_data)\n        else:\n            set_dispenser_credentials(token_data)\n            logger.info(\"Login successful\")\n\n    except Exception as e:\n        raise click.ClickException(str(e)) from e"}
{"instruction": "Fund a specified receiver address with a given amount of ALGOs. If 'whole_units' is true, the amount is interpreted as ALGOs and converted to microALGOs before sending to the dispenser. The dispenser then processes the fund request, and the function logs the transaction details and explorer URL upon successful funding, displaying the amount in ALGOs or microALGOs depending on the 'whole_units' setting.", "output": "def fund_command(*, receiver: str, amount: int, whole_units: bool) -> None:\n    if not is_authenticated():\n        logger.error(NOT_AUTHENTICATED_MESSAGE)\n        return\n\n    receiver_address = get_address(receiver)\n\n    default_asset = DISPENSER_ASSETS[DispenserAssetName.ALGO]\n    if whole_units:\n        amount = amount * (10**default_asset.decimals)\n        logger.debug(f\"Converted algos to microAlgos: {amount}\")\n\n    try:\n        response = process_dispenser_request(\n            url_suffix=f\"fund/{DISPENSER_ASSETS[DispenserAssetName.ALGO].asset_id}\",\n            data={\"receiver\": receiver_address, \"amount\": amount, \"assetID\": default_asset.asset_id},\n            method=\"POST\",\n        )\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n    else:\n        response_body = response.json()\n        processed_amount = (\n            response_body[\"amount\"] / (10**default_asset.decimals) if whole_units else response_body[\"amount\"]\n        )\n        asset_description = default_asset.description if whole_units else f\"{default_asset.description}\"\n        txn_url = get_explorer_url(\n            identifier=response_body[\"txID\"], network=\"testnet\", entity_type=ExplorerEntityType.TRANSACTION\n        )\n        logger.info(f\"Successfully funded {processed_amount} {asset_description}. Browse transaction at {txn_url}\")"}
{"instruction": "Execute a refund operation by sending a request to a remote server. The request includes a transaction ID to be refunded. Only authenticated users are allowed to perform this action.", "output": "def refund_command(*, tx_id: str) -> None:\n    if not is_authenticated():\n        logger.error(NOT_AUTHENTICATED_MESSAGE)\n        return\n\n    try:\n        process_dispenser_request(url_suffix=\"refund\", data={\"refundTransactionID\": tx_id})\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n    else:\n        logger.info(\"Successfully processed refund transaction\")"}
{"instruction": "Retrieve and display the remaining daily funding limit for the default asset. If `whole_units` is true, format the amount in whole units and display the asset description; otherwise, format the amount in micro units and prepend '' to the asset description. Ensure the user is authenticated before proceeding.", "output": "def get_fund_limit(*, whole_units: bool) -> None:\n    if not is_authenticated():\n        logger.error(NOT_AUTHENTICATED_MESSAGE)\n        return\n\n    default_asset = DISPENSER_ASSETS[DispenserAssetName.ALGO]\n    try:\n        response = process_dispenser_request(url_suffix=f\"fund/{default_asset.asset_id}/limit\", data={}, method=\"GET\")\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n    else:\n        response_amount = response.json()[\"amount\"]\n        processed_amount = response_amount / (10**default_asset.decimals) if whole_units else response_amount\n        asset_description = default_asset.description if whole_units else f\"{default_asset.description}\"\n\n        logger.info(f\"Remaining daily fund limit: {processed_amount} {asset_description}\")"}
{"instruction": "Diagnose potential issues with the AlgoKit environment by checking the versions of its dependencies (AlgoKit itself, Python, OS, container engine (e.g., Docker), Compose, Git, Node.js, npm, pipx, poetry, and optionally winget or brew depending on the OS). Output the versions and installation status of these dependencies, highlighting critical services (container engine, compose, git) if they are not working. In verbose mode, also list the AlgoKit CLI's package dependencies. If requested, copy the output to the clipboard. Exit with a non-zero code if any dependency check fails.", "output": "def doctor_command(*, copy_to_clipboard: bool) -> None:  # noqa: C901, PLR0912\n    \"\"\"Diagnose potential environment issues that may affect AlgoKit.\n\n    Will search the system for AlgoKit dependencies and show their versions, as well as identifying any\n    potential issues.\"\"\"\n    from algokit.core.config_commands.container_engine import get_container_engine\n\n    # Check if we're in verbose mode by examining the console log handler level\n    verbose = False\n    for handler in logging.getLogger().handlers:\n        if handler.name == CONSOLE_LOG_HANDLER_NAME and handler.level <= logging.DEBUG:\n            verbose = True\n            break\n\n    os_type = platform.system()\n    is_windows = get_is_windows()\n    container_engine = get_container_engine()\n    docs_url = f\"https://{container_engine}.io\"\n    compose_minimum_version = get_min_compose_version()\n    service_outputs = {\n        \"timestamp\": DoctorResult(ok=True, output=dt.datetime.now(dt.timezone.utc).replace(microsecond=0).isoformat()),\n        \"AlgoKit\": _get_algokit_version_output(),\n        \"AlgoKit Python\": DoctorResult(ok=True, output=f\"{sys.version} (location: {sys.prefix})\"),\n        \"OS\": DoctorResult(ok=True, output=platform.platform()),\n        container_engine: check_dependency(\n            [container_engine, \"--version\"],\n            missing_help=[f\"`{container_engine}` required to run `algokit localnet` command; install via {docs_url}\"],\n        ),\n        f\"{container_engine} compose\": check_dependency(\n            COMPOSE_VERSION_COMMAND,\n            minimum_version=compose_minimum_version,\n            minimum_version_help=[\n                f\"{container_engine.capitalize()} Compose {compose_minimum_version} required to run `algokit localnet` command;\",  # noqa: E501\n                f\"install via {docs_url}\",\n            ],\n        ),\n        \"git\": check_dependency(\n            [\"git\", \"--version\"],\n            missing_help=(\n                [\n                    \"Git required to `run algokit init`; install via `winget install -e --id Git.Git` if using winget,\",\n                    \"or via https://github.com/git-guides/install-git#install-git-on-windows\",\n                ]\n                if is_windows\n                else [\"Git required to run `algokit init`; install via https://github.com/git-guides/install-git\"]\n            ),\n        ),\n        \"python\": check_dependency([\"python\", \"--version\"], include_location=True),\n        \"python3\": check_dependency([\"python3\", \"--version\"], include_location=True),\n        \"pipx\": check_dependency(\n            [\"pipx\", \"--version\"],\n            missing_help=[\n                \"pipx is required if poetry is not installed in order to install it automatically;\",\n                \"install via https://pypa.github.io/pipx/\",\n            ],\n        ),\n        \"poetry\": check_dependency(\n            [\"poetry\", \"--version\"],\n            missing_help=[\n                \"Poetry is required for some Python-based templates;\",\n                \"install via `algokit project bootstrap` within project directory, or via:\",\n                \"https://python-poetry.org/docs/#installation\",\n            ],\n        ),\n        \"node\": check_dependency(\n            [\"node\", \"--version\"],\n            missing_help=[\n                \"Node.js is required for some Node.js-based templates;\",\n                \"install via `algokit project bootstrap` within project directory, or via:\",\n                \"https://nodejs.dev/en/learn/how-to-install-nodejs/\",\n            ],\n        ),\n        \"npm\": check_dependency([\"npm\" if not is_windows else \"npm.cmd\", \"--version\"]),\n    }\n    if is_windows:\n        service_outputs[\"winget\"] = check_dependency([\"winget\", \"--version\"])\n    elif os_type == \"Darwin\":\n        service_outputs[\"brew\"] = check_dependency([\"brew\", \"--version\"])\n\n    critical_services = [container_engine, f\"{container_engine} compose\", \"git\"]\n    # Print the status details\n    for key, value in service_outputs.items():\n        if value.ok:\n            color = None\n        else:\n            color = CRITICAL_COLOR if key in critical_services else WARNING_COLOR\n        msg = click.style(f\"{key}: \", bold=True) + click.style(value.output, fg=color)\n        for ln in value.extra_help or []:\n            msg += f\"\\n  {ln}\"\n        logger.info(msg)\n\n    # Get dependencies info if in verbose mode and not running from a binary\n    dependencies = {}\n    if verbose and not is_binary_mode():\n        # Add package dependencies section\n        logger.info(\"\\nCLI package dependencies:\")\n        dependencies = _get_production_dependencies()\n        for package, version in dependencies.items():\n            logger.info(f\"{package}: {version}\")\n\n    # print end message anyway\n    logger.info(\n        \"\\n\"\n        \"If you are experiencing a problem with AlgoKit, feel free to submit an issue via:\\n\"\n        \"https://github.com/algorandfoundation/algokit-cli/issues/new\\n\"\n        \"Please include this output, if you want to populate this message in your clipboard, run `algokit doctor -c`\"\n    )\n\n    if copy_to_clipboard:\n        output_lines = []\n\n        # Add service outputs\n        for key, value in service_outputs.items():\n            output_lines.append(f\"* {key}: \" + \"\\n  \".join([value.output, *(value.extra_help or [])]))\n\n        # Add package dependencies if verbose\n        if verbose:\n            output_lines.append(\"\\n* Package dependencies:\")\n            for package, version in dependencies.items():\n                output_lines.append(f\"  * {package}: {version}\")\n\n        pyclip.copy(\"\\n\".join(output_lines))\n\n    if any(not value.ok for value in service_outputs.values()):\n        raise click.exceptions.Exit(code=1)"}
{"instruction": "Determine the current and latest available versions of the AlgoKit package. If the current version is the latest, display the current version. Otherwise, display the current version with a warning color and indicate the latest available version.", "output": "def _get_algokit_version_output() -> DoctorResult:\n    current = get_current_package_version()\n    try:\n        latest = get_latest_github_version()\n    except Exception as ex:\n        logger.warning(\"Failed to check latest AlgoKit release version\", exc_info=ex)\n        latest = None\n    if latest is None or current == latest:\n        output = current\n    else:\n        output = click.style(current, fg=WARNING_COLOR) + f\" (latest: {latest})\"\n    return DoctorResult(ok=True, output=output)"}
{"instruction": "Extract the versions of the direct production dependencies of the 'algokit' package. For each dependency, retrieve its version using `importlib.metadata.version`. If a dependency is not found, mark its version as 'Not installed'. If any error occurs during the process, return a dictionary with an 'Error' key indicating the failure.", "output": "def _get_production_dependencies() -> dict[str, str]:\n    \"\"\"Gets versions of all direct production dependencies.\"\"\"\n    try:\n        import importlib.metadata\n        import re\n\n        # Get package dependencies from metadata\n        dist = importlib.metadata.distribution(\"algokit\")\n        requires = dist.requires or []\n\n        result = {}\n        for req in requires:\n            if match := re.match(r\"^([A-Za-z0-9_\\-\\.]+)\", req):\n                dep = match.group(1)\n                try:\n                    result[dep] = importlib.metadata.version(dep)\n                except importlib.metadata.PackageNotFoundError:\n                    result[dep] = \"Not installed\"\n\n        return result\n\n    except Exception:\n        return {\"Error\": \"Could not retrieve dependencies\"}"}
{"instruction": "Define a typed dictionary called 'NetworkConfigurationRequired' that specifies the required fields for network configuration: 'algod_url' (string) and 'indexer_url' (string).", "output": "class NetworkConfigurationRequired(TypedDict):\n    algod_url: str\n    indexer_url: str"}
{"instruction": "Define a dataclass (or type) named 'NetworkConfiguration' that represents network settings. It should inherit from 'NetworkConfigurationRequired'. It should have the following optional integer fields: 'algod_port', 'indexer_port', and 'kmd_port'. It should also have the following optional string fields: 'algod_token', 'indexer_token', 'kmd_token', and 'kmd_url'.", "output": "class NetworkConfiguration(NetworkConfigurationRequired, total=False):\n    algod_port: int\n    algod_token: str\n\n    indexer_port: int\n    indexer_token: str\n\n    kmd_token: str\n    kmd_url: str\n    kmd_port: int"}
{"instruction": "Return a URL string for AlgoKit Explore based on the given network name. The URL follows the format 'https://explore.algokit.io/{network}', where '{network}' is replaced with the input network value.", "output": "def get_algokit_url(network: str) -> str:\n    return f\"https://explore.algokit.io/{network}\""}
{"instruction": "Generate a new Algorand account, deriving both the public address and the mnemonic phrase representing the private key.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Construct a URL to access the Algorand explorer. If the network is 'localnet' and its 'algod_url' is not the default, then construct a query string from the 'algod_url', 'algod_port', 'indexer_url', 'indexer_port', 'kmd_url', and 'kmd_port' parameters of the network configuration and append it to the Algorand explorer base URL. Otherwise, return the base URL directly.", "output": "def get_explore_url(network: str) -> str:\n    if network == \"localnet\" and NETWORKS[network].get(\"algod_url\") != DEFAULT_ALGOD_SERVER:\n        query_string = urlencode(\n            [\n                (key, value)\n                for key, value in NETWORKS[network].items()\n                if key in [\"algod_url\", \"algod_port\", \"indexer_url\", \"indexer_port\", \"kmd_url\", \"kmd_port\"]\n            ]\n        )\n        return f\"{get_algokit_url(network)}?{query_string}\"\n\n    return get_algokit_url(network)"}
{"instruction": "Open a blockchain explorer URL in the user's default web browser. Handle the case where the script is running in a Windows Subsystem for Linux (WSL) environment by providing a warning and instructions to install 'wslu' if the browser cannot be opened automatically. Log the URL being opened and any warnings encountered.", "output": "def explore_command(network: str) -> None:\n    url = get_explore_url(network)\n    logger.info(f\"Opening {network} explorer in your default browser\")\n\n    if is_wsl():\n        import webbrowser\n\n        warning = (\n            \"Unable to open browser from WSL environment.\\n\"\n            \"Ensure 'wslu' is installed: (https://wslutiliti.es/wslu/install.html),\\n\"\n            f\"or open the URL manually: '{url}'.\"\n        )\n        try:\n            if not webbrowser.open(url):\n                logger.warning(warning)\n        except Exception as e:\n            logger.warning(warning, exc_info=e)\n    else:\n        click.launch(url)"}
{"instruction": "Define a function that loads custom click commands from a project's configuration, specifically designed for code generation. Each command is dynamically created based on generator definitions, allowing users to answer prompts, specify paths, and force execution. The function returns a dictionary mapping command names to their corresponding click command objects, with a safety check that requires git to be installed.", "output": "def _load_custom_generate_commands(project_dir: Path) -> dict[str, click.Command]:\n    \"\"\"\n    Load custom generate commands from .algokit.toml file.\n    :param project_dir: Project directory path.\n    :return: Custom generate commands.\n    \"\"\"\n\n    generators = load_generators(project_dir)\n    commands_table: dict[str, click.Command] = {}\n\n    for generator in generators:\n\n        @click.command(\n            name=generator.name, help=generator.description or \"Generator command description is not supplied.\"\n        )\n        @click.option(\n            \"answers\",\n            \"--answer\",\n            \"-a\",\n            multiple=True,\n            help=\"Answers key/value pairs to pass to the template.\",\n            nargs=2,\n            default=[],\n            metavar=\"<key> <value>\",\n        )\n        @click.option(\n            \"path\",\n            \"--path\",\n            \"-p\",\n            help=f\"Path to {generator.name} generator. (Default: {generator.path})\",\n            type=click.Path(exists=True),\n            default=generator.path,\n        )\n        @click.option(\n            \"--force\",\n            \"-f\",\n            is_flag=True,\n            required=False,\n            default=False,\n            type=click.BOOL,\n            help=\"Executes generator without confirmation. Use with trusted sources only.\",\n        )\n        def command(\n            *,\n            answers: list[tuple[str, str]],\n            path: Path,\n            force: bool,\n        ) -> None:\n            if not shutil.which(\"git\"):\n                raise click.ClickException(\n                    \"Git not found; please install git and add to path.\\n\"\n                    \"See https://github.com/git-guides/install-git for more information.\"\n                )\n\n            answers_dict = dict(answers)\n\n            if not force and not click.confirm(\n                \"You are about to run a generator. Please make sure it's from a \"\n                \"trusted source (for example, official AlgoKit Templates). Do you want to proceed?\",\n                default=False,\n            ):\n                logger.warning(\"Generator execution cancelled.\")\n                return None\n\n            return run_generator(answers_dict, path)\n\n        commands_table[generator.name] = command\n\n    return commands_table"}
{"instruction": "Dynamically extend a Click command group by loading custom commands from the current working directory. When a command is requested, first check for predefined commands. If not found, load custom commands and check if the requested command exists there. List available commands by combining the predefined commands with the dynamically loaded custom commands, then sort the result.", "output": "class GeneratorGroup(click.Group):\n    def get_command(self, ctx: click.Context, cmd_name: str) -> click.Command | None:\n        return_value = super().get_command(ctx, cmd_name)\n\n        if return_value is not None:\n            return return_value\n\n        commands = _load_custom_generate_commands(Path.cwd())\n        return commands.get(cmd_name)\n\n    def list_commands(self, ctx: click.Context) -> list[str]:\n        predefined_command_names = super().list_commands(ctx)\n        dynamic_commands = _load_custom_generate_commands(Path.cwd())\n        dynamic_command_names = list(dynamic_commands)\n\n        return sorted(predefined_command_names + dynamic_command_names)"}
{"instruction": "Generate the source code for an Algorand project, including necessary files and directory structure.", "output": "def generate_group() -> None:\n    \"\"\"Generate code for an Algorand project.\"\"\""}
{"instruction": "Generate a new Algorand account, deriving the address, private key, and mnemonic phrase.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate a client SDK for an application based on its specification (either a single JSON file or a directory of JSON files). The target language is determined either explicitly via a language flag or implicitly from the output file extension. If neither language nor extension is specified, or if no application specifications are found, raise an error.", "output": "def generate_client(\n    output_path_pattern: str | None, app_spec_path_or_dir: Path, language: str | None, version: str | None\n) -> None:\n    \"\"\"Create a typed ApplicationClient from an ARC-32/56 application.json\n\n    Supply the path to an application specification file or a directory to recursively search\n    for \"application.json\" files\"\"\"\n    if language is not None:\n        generator = ClientGenerator.create_for_language(language, version)\n    elif output_path_pattern is not None:\n        extension = Path(output_path_pattern).suffix\n        try:\n            generator = ClientGenerator.create_for_extension(extension, version)\n        except KeyError as ex:\n            raise click.ClickException(\n                \"Could not determine language from file extension, Please use the --language option to specify a \"\n                \"target language\"\n            ) from ex\n    else:\n        raise click.ClickException(\n            \"One of --language or --output is required to determine the client language to generate\"\n        )\n\n    try:\n        generator.generate_all(\n            app_spec_path_or_dir,\n            output_path_pattern,\n            raise_on_path_resolution_failure=False,\n        )\n    except AppSpecsNotFoundError as ex:\n        raise click.ClickException(\"No app specs found\") from ex"}
{"instruction": "Execute the Algorand `goal` command within the AlgoKit LocalNet environment, handling container engine checks, LocalNet status, interactive shell options, and file input/output preprocessing, with appropriate error handling and logging.", "output": "def goal_command(*, console: bool, interactive: bool, goal_args: list[str]) -> None:  # noqa: C901, PLR0912\n    \"\"\"\n    Run the Algorand goal CLI against the AlgoKit LocalNet.\n\n    Look at https://dev.algorand.co/algokit/algokit-cli/goal for more information.\n    \"\"\"\n    goal_args = list(goal_args)\n    container_engine = get_container_engine()\n    try:\n        proc.run(\n            [container_engine, \"version\"],\n            bad_return_code_error_message=f\"{container_engine} engine isn't running; please start it.\",\n        )\n    except OSError as ex:\n        # an IOError (such as PermissionError or FileNotFoundError) will only occur if \"docker\"\n        # isn't an executable in the user's path, which means docker isn't installed\n        docs_url = (\n            \"https://www.docker.com/get-started/\" if container_engine == \"docker\" else \"https://podman.io/get-started\"\n        )\n        raise click.ClickException(\n            f\"{container_engine} not found; please install {container_engine} and add to path.\\n\"\n            f\"See {docs_url} for more information.\"\n        ) from ex\n\n    sandbox = ComposeSandbox.from_environment()\n    if sandbox is None:\n        sandbox = ComposeSandbox()\n\n    if sandbox.name != SANDBOX_BASE_NAME:\n        logger.info(\"A named LocalNet is running, goal command will be executed against the named LocalNet\")\n\n    volume_mount_path_local = get_volume_mount_path_local(directory_name=sandbox.name)\n    volume_mount_path_docker = get_volume_mount_path_docker()\n\n    compose_file_status = sandbox.compose_file_status()\n    if compose_file_status is not ComposeFileStatus.UP_TO_DATE and sandbox.name == SANDBOX_BASE_NAME:\n        raise click.ClickException(\"LocalNet definition is out of date; please run `algokit localnet reset` first!\")\n    ps_result = sandbox.ps(\"algod\")\n    match ps_result:\n        case [{\"State\": \"running\"}]:\n            pass\n        case _:\n            logger.info(\"LocalNet isn't running\")\n            sandbox.up()\n\n    if console:\n        if goal_args:\n            logger.warning(\"--console opens an interactive shell, remaining arguments are being ignored\")\n        logger.info(\"Opening Bash console on the algod node; execute `exit` to return to original console\")\n        result = proc.run_interactive(f\"{container_engine} exec -it -w /root algokit_{sandbox.name}_algod bash\".split())\n    else:\n        cmd = f\"{container_engine} exec {'--tty' if interactive else ''} --interactive --workdir /root algokit_{sandbox.name}_algod goal\".split()  # noqa: E501\n        input_files, output_files, goal_args = preprocess_command_args(\n            goal_args, volume_mount_path_local, volume_mount_path_docker\n        )\n        cmd = cmd + goal_args\n\n        if interactive:\n            result = proc.run_interactive(cmd)\n        else:\n            # Try non-interactive first, fallback to interactive if it fails with input-related error\n            result = proc.run(\n                cmd,\n                stdout_log_level=logging.INFO,\n                prefix_process=False,\n                pass_stdin=True,\n            )\n            if result.exit_code != 0 and \"inappropriate ioctl\" in (result.output or \"\"):\n                # Fallback to interactive mode if we detect TTY-related errors\n                logger.debug(\"Command failed with TTY error, retrying in interactive mode\")\n                cmd.insert(2, \"--tty\")\n                result = proc.run_interactive(cmd)\n\n        post_process(input_files, output_files, volume_mount_path_local)\n\n    if result.exit_code != 0:\n        raise click.exceptions.Exit(result.exit_code)"}
{"instruction": "Create a dictionary that combines the contents of 'DEFAULT_STATIC_ANSWERS' with a dictionary generated by calling the functions in 'DEFAULT_DYNAMIC_ANSWERS' and assigning the results to corresponding keys.", "output": "def _get_default_answers() -> dict[str, str]:\n    \"\"\"get all default answers\"\"\"\n    return {**DEFAULT_STATIC_ANSWERS, **{k: v() for k, v in DEFAULT_DYNAMIC_ANSWERS.items()}}"}
{"instruction": "Define an enumeration named `TemplatePresetType` with string values representing different project template options: Smart Contracts, DApp Frontend, Smart Contracts & DApp Frontend, and Custom Template. This enumeration is intended for use in `algokit init` to determine the type of project template to initialize.", "output": "class TemplatePresetType(str, Enum):\n    \"\"\"\n    For distinguishing main template preset type question invoked by `algokit init`\n    \"\"\"\n\n    SMART_CONTRACT = \"Smart Contracts \"\n    DAPP_FRONTEND = \"DApp Frontend \"\n    SMART_CONTRACT_AND_DAPP_FRONTEND = \"Smart Contracts & DApp Frontend \"\n    CUSTOM_TEMPLATE = \"Custom Template \""}
{"instruction": "Create an enumeration named `ContractLanguage` to represent programming languages that have corresponding smart contract languages.  The enumeration should have two members: `PYTHON` representing Python (with a snake emoji) and `TYPESCRIPT` representing TypeScript (with a blue book emoji). Each member should be associated with its language name and emoji.", "output": "class ContractLanguage(Enum):\n    \"\"\"\n    For programming languages that have corresponding smart contract languages\n    \"\"\"\n\n    PYTHON = \"Python \"\n    TYPESCRIPT = \"TypeScript \""}
{"instruction": "Define an enumeration called `TemplateKey` that inherits from both `str` and `Enum`. The enumeration should define string-based keys representing different project templates: `BASE`, `PYTHON`, `TYPESCRIPT`, `TEALSCRIPT`, `FULLSTACK`, and `REACT`.", "output": "class TemplateKey(str, Enum):\n    \"\"\"\n    For templates included in wizard v2 by default\n    \"\"\"\n\n    BASE = \"base\"\n    PYTHON = \"python\"\n    TYPESCRIPT = \"typescript\"\n    TEALSCRIPT = \"tealscript\"\n    FULLSTACK = \"fullstack\"\n    REACT = \"react\""}
{"instruction": "Define a class named 'TemplateSource' with attributes 'url' (string), 'commit' (optional string), 'branch' (optional string), and 'answers' (optional list of string tuples). Implement a '__str__' method that returns the URL string appended with the commit hash if commit is defined, or the URL string otherwise.", "output": "class TemplateSource:\n    url: str\n    commit: str | None = None\n    \"\"\"when adding a blessed template that is verified but not controlled by Algorand,\n    ensure a specific commit is used\"\"\"\n    branch: str | None = None\n    answers: list[tuple[str, str]] | None = None\n\n    def __str__(self) -> str:\n        if self.commit:\n            return \"@\".join([self.url, self.commit])\n        return self.url"}
{"instruction": "Define a class `BlessedTemplateSource` inheriting from `TemplateSource`.  Include a string attribute `description`. Implement an equality check (`__eq__`) that returns True if the other object is also a `BlessedTemplateSource` instance and its `description` and `url` attributes are equal to the current instance's attributes. Otherwise, returns `NotImplemented` if the other object is not a `BlessedTemplateSource`.", "output": "class BlessedTemplateSource(TemplateSource):\n    description: str\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BlessedTemplateSource):\n            return NotImplemented\n        return self.description == other.description and self.url == other.url"}
{"instruction": "Define a function that returns a dictionary mapping template keys (TEALSCRIPT, TYPESCRIPT, PYTHON, REACT, FULLSTACK, BASE) to corresponding blessed template sources. Each template source specifies a URL (GitHub repository) and a descriptive text for an official Algorand application starter template.", "output": "def _get_blessed_templates() -> dict[TemplateKey, BlessedTemplateSource]:\n    return {\n        TemplateKey.TEALSCRIPT: BlessedTemplateSource(\n            url=\"gh:algorand-devrel/tealscript-algokit-template\",\n            description=\"Official starter template for TEALScript applications.\",\n        ),\n        TemplateKey.TYPESCRIPT: BlessedTemplateSource(\n            url=\"gh:algorandfoundation/algokit-typescript-template\",\n            description=\"Official starter template for Algorand TypeScript (Beta) applications\",\n        ),\n        TemplateKey.PYTHON: BlessedTemplateSource(\n            url=\"gh:algorandfoundation/algokit-python-template\",\n            description=\"Official starter template for Algorand Python applications\",\n        ),\n        TemplateKey.REACT: BlessedTemplateSource(\n            url=\"gh:algorandfoundation/algokit-react-frontend-template\",\n            description=\"Official template for React frontend applications (smart contracts not included).\",\n        ),\n        TemplateKey.FULLSTACK: BlessedTemplateSource(\n            url=\"gh:algorandfoundation/algokit-fullstack-template\",\n            description=\"Official template for starter or production fullstack applications.\",\n        ),\n        TemplateKey.BASE: BlessedTemplateSource(\n            url=\"gh:algorandfoundation/algokit-base-template\",\n            description=\"Official base template for enforcing workspace structure for standalone AlgoKit projects.\",\n        ),\n    }"}
{"instruction": "Validate a directory name string. Raise an error if the name is invalid (doesn't conform to allowed characters or is already in use) and return the name if valid. Allowed characters are letters, numbers, dashes, periods, and underscores.", "output": "def _validate_dir_name(context: click.Context, param: click.Parameter, value: str | None) -> str | None:\n    if value is not None and not is_valid_project_dir_name(value):\n        raise click.BadParameter(\n            \"Invalid directory name. Ensure it's a mix of letters, numbers, dashes, \"\n            \"periods, and/or underscores, and not already used.\",\n            context,\n            param,\n        )\n    return value"}
{"instruction": "Check if a workspace path is provided. If so, and if the 'use_workspace' flag is enabled but the workspace path is not the parent directory of the project path, log an error indicating workspace nesting and instruct the user to run 'init' from the workspace root, then exit the program.", "output": "def _prevent_workspace_nesting(*, workspace_path: Path | None, project_path: Path, use_workspace: bool) -> None:\n    if not workspace_path:\n        return\n\n    if use_workspace and workspace_path != project_path.parent:\n        logger.error(\n            \"Error: Workspace nesting detected. Please run 'init' from the workspace root: \"\n            f\"'{workspace_path}'. For more info, refer to \"\n            \"https://github.com/algorandfoundation/algokit-cli/blob/main/docs/features/project/run.md\"\n        )\n        _fail_and_bail()"}
{"instruction": "Initialize a project from a template, allowing for custom answers, Git initialization, Algokit project bootstrapping, and automatic opening of Visual Studio Code. The project is created in a specified directory, which can be within a workspace or as a standalone project. The template can be a default template or a custom template from a Git repository. After template rendering, the code initializes Git, bootstraps the project (if requested), and potentially opens Visual Studio Code if configuration files are found. Also, the function outputs the template URL, if present, to allow for quick access to the documentation of the selected template.", "output": "def init_command(  # noqa: PLR0913, C901, PLR0915\n    *,\n    directory_name: str | None,\n    template_name: str | None,\n    template_url: str | None,\n    template_url_ref: str | None,\n    unsafe_security_accept_template_url: bool,\n    use_git: bool | None,\n    answers: list[tuple[str, str]],\n    use_defaults: bool,\n    run_bootstrap: bool | None,\n    use_workspace: bool,\n    open_ide: bool,\n) -> None:\n    \"\"\"\n    Initializes a new project from a template, including prompting\n    for template specific questions to be used in template rendering.\n\n    Templates can be default templates shipped with AlgoKit, or custom\n    templates in public Git repositories.\n\n    Includes ability to initialise Git repository, run algokit project bootstrap and\n    automatically open Visual Studio Code.\n\n    This should be run in the parent directory that you want the project folder\n    created in.\n\n    By default, the `--workspace` flag creates projects within a workspace structure or integrates them into an existing\n    one, promoting organized management of multiple projects. Alternatively,\n    to disable this behavior use the `--no-workspace` flag, which ensures\n    the new project is created in a standalone target directory. This is\n    suitable for isolated projects or when workspace integration is unnecessary.\n    \"\"\"\n\n    if not shutil.which(\"git\"):\n        raise click.ClickException(\n            \"Git not found; please install git and add to path.\\n\"\n            \"See https://github.com/git-guides/install-git for more information.\"\n        )\n\n    # parse the input early to prevent frustration - combined with some defaults but they can be overridden\n    answers_dict = _get_default_answers() | dict(answers)\n\n    template = _get_template(\n        name=template_name,\n        url=template_url,\n        commit=template_url_ref,\n        unsafe_security_accept_template_url=unsafe_security_accept_template_url,\n    )\n\n    for custom_answer in template.answers or []:\n        answers_dict.setdefault(*custom_answer)\n\n    logger.debug(f\"template source = {template}\")\n\n    # allow skipping prompt if the template is the base template to avoid redundant\n    # 're-using existing directory' warning in fullstack template init\n    project_path, overwrite_existing_dir = _get_project_path(\n        directory_name_option=directory_name, force=template == _get_blessed_templates()[TemplateKey.BASE]\n    )\n    workspace_path = get_workspace_project_path(project_path)\n    if not overwrite_existing_dir:\n        _prevent_workspace_nesting(\n            workspace_path=workspace_path, project_path=project_path, use_workspace=use_workspace\n        )\n\n    logger.debug(f\"project path = {project_path}\")\n    directory_name = project_path.name\n    # provide the directory name as an answer to the template, if not explicitly overridden by user\n    answers_dict.setdefault(\"project_name\", directory_name)\n\n    system_python_path = next(get_python_paths(), None)\n    if system_python_path is not None:\n        answers_dict.setdefault(\"python_path\", system_python_path)\n    else:\n        answers_dict.setdefault(\"python_path\", \"no_system_python_available\")\n\n    project_path = _resolve_workspace_project_path(\n        template_source=template, project_path=project_path, use_workspace=use_workspace\n    )\n    answers_dict.setdefault(\"use_workspace\", \"yes\" if use_workspace else \"no\")\n\n    logger.info(f\"Starting template copy and render at {project_path}...\")\n    # copier is lazy imported for two reasons\n    # 1. it is slow to import on first execution after installing\n    # 2. the import fails if git is not installed (which we check above)\n    # TODO: copier is typed, need to figure out how to force mypy to accept that or submit a PR\n    #       to their repo to include py.typed file\n    from copier._main import Worker\n\n    from algokit.core.init import populate_default_answers\n\n    expected_answers_file = project_path / \".algokit\" / \".copier-answers.yml\"\n    relative_answers_file = expected_answers_file.relative_to(project_path) if expected_answers_file.exists() else None\n\n    # Ensure target directory exists (`copier` >=9.6.0 not creating parent directories during copy automatically)\n    project_path.mkdir(parents=True, exist_ok=True)\n\n    with Worker(\n        src_path=template.url,\n        dst_path=project_path,\n        answers_file=relative_answers_file,\n        data=answers_dict,\n        quiet=True,\n        vcs_ref=template.branch or template.commit,\n        unsafe=True,\n    ) as copier_worker:\n        if use_defaults:\n            populate_default_answers(copier_worker)\n        expanded_template_url = copier_worker.template.url_expanded\n        logger.debug(f\"final clone URL = {expanded_template_url}\")\n        copier_worker.run_copy()\n\n    logger.info(\"Template render complete!\")\n\n    # reload workspace path cause it might have been just introduced with new project instance\n    workspace_path = get_workspace_project_path(project_path)\n\n    _maybe_move_github_folder(project_path=project_path, use_workspace=use_workspace)\n\n    _maybe_bootstrap(project_path, run_bootstrap=run_bootstrap, use_defaults=use_defaults, use_workspace=use_workspace)\n\n    logger.info(\n        f\" Project initialized at `{directory_name}`! For template specific next steps, \"\n        \"consult the documentation of your selected template \"\n    )\n    if re.search(\"https?://\", expanded_template_url):\n        # if the URL looks like an HTTP URL (should be the case for blessed templates), be helpful\n        # and print it out so the user can (depending on terminal) click it to open in browser\n        logger.info(f\"Your selected template comes from:\\n  {expanded_template_url.removesuffix('.git')}\")\n\n    # Check if a README file exists\n    readme_path = next(project_path.glob(\"README*\"), None)\n\n    # Check if a .workspace file exists\n    vscode_workspace_file = resolve_vscode_workspace_file(workspace_path or project_path)\n\n    if vscode_workspace_file:\n        append_project_to_vscode_workspace(project_path=project_path, workspace_path=vscode_workspace_file)\n\n    # Below must be ensured to run after all required filesystem changes are applied to ensure first commit captures\n    # all the changes introduced by init invocation\n    _maybe_git_init(\n        workspace_path or project_path,\n        use_git=use_git,\n        commit_message=f\"Project initialised with AlgoKit CLI using template: {expanded_template_url}\",\n    )\n\n    if (\n        open_ide\n        and ((project_path / \".vscode\").is_dir() or vscode_workspace_file)\n        and (code_cmd := shutil.which(\"code\"))\n    ):\n        target_path = str(vscode_workspace_file if vscode_workspace_file else project_path)\n\n        logger.info(\n            \"VSCode configuration detected in project directory, and 'code' command is available on path, \"\n            \"attempting to launch VSCode\"\n        )\n\n        code_cmd_and_args = [code_cmd, target_path]\n\n        if readme_path:\n            code_cmd_and_args.append(str(readme_path))\n\n        proc.run(code_cmd_and_args)\n    elif readme_path:\n        logger.info(f\"Your template includes a {readme_path.name} file, you might want to review that as a next step.\")"}
{"instruction": "Conditionally run the `algokit project bootstrap` command based on user input or default settings. If the user didn't specify whether to bootstrap, prompt them, defaulting to 'yes' if default settings are being used. If bootstrapping is enabled, execute it while handling potential exceptions by logging an error message and suggesting manual execution if it fails. The depth of the bootstrap operation depends on whether a workspace setup is being used.", "output": "def _maybe_bootstrap(\n    project_path: Path, *, run_bootstrap: bool | None, use_defaults: bool, use_workspace: bool\n) -> None:\n    if run_bootstrap is None:\n        # if user didn't specify a bootstrap option, then assume yes if using defaults, otherwise prompt\n        run_bootstrap = use_defaults or questionary_extensions.prompt_confirm(\n            \"Do you want to run `algokit project bootstrap` for this new project? \"\n            \"This will install and configure dependencies allowing it to be run immediately.\",\n            default=True,\n        )\n    if run_bootstrap:\n        # note: we run bootstrap before git commit so that we can commit any lock files,\n        # but if something goes wrong, we don't want to block\n        try:\n            project_minimum_algokit_version_check(project_path)\n\n            # if user prefers to ignore creating the `workspace` setup, set bootstrap depth to 1 else default\n            bootstrap_depth = 1 if not use_workspace else MAX_BOOTSTRAP_DEPTH\n            bootstrap_any_including_subdirs(project_path, ci_mode=False, max_depth=bootstrap_depth)\n        except Exception as e:\n            logger.error(f\"Received an error while attempting bootstrap: {e}\")\n            logger.exception(\n                \"Bootstrap failed. Once any errors above are resolved, \"\n                f\"you can run `algokit project bootstrap` in {project_path}\",\n                exc_info=e,\n            )"}
{"instruction": "Conditionally initialize a Git repository in the specified project path if the 'use_git' option is enabled or defaults to enabled and the project path does not already contain a Git repository. If initialization occurs, commit with the provided message.", "output": "def _maybe_git_init(project_path: Path, *, use_git: bool | None, commit_message: str) -> None:\n    if _should_attempt_git_init(use_git_option=use_git, project_path=project_path):\n        _git_init(project_path, commit_message=commit_message)"}
{"instruction": "If a '.github' directory exists within the project path and the workspace flag is enabled, move all files from the project's '.github' directory to the '.github' directory in the workspace root, skipping any files that already exist in the target location. If the move fails for any file, log a debug message. After attempting the move, if any files remain in the project's '.github' directory, display a warning message to the user instructing them to manually move the remaining files. Otherwise, remove the project's '.github' directory.", "output": "def _maybe_move_github_folder(*, project_path: Path, use_workspace: bool) -> None:\n    \"\"\"Move contents of .github folder from project_path to the root of the workspace if exists\n    and the workspace is used.\n\n    Args:\n        project_path: The path to the project directory.\n        use_workspace: A flag to indicate if the project is initialized with workspace flag\n    \"\"\"\n\n    source_dir = project_path / \".github\"\n\n    if (\n        not use_workspace\n        or not source_dir.exists()\n        or not (workspace_root := get_workspace_project_path(project_path.parent))\n    ):\n        return\n\n    target_dir = workspace_root / \".github\"\n\n    for source_file in source_dir.rglob(\"*\"):\n        if source_file.is_file():\n            target_file = target_dir / source_file.relative_to(source_dir)\n\n            if target_file.exists():\n                logger.debug(f\"Skipping move of {source_file.name} to {target_file} (duplicate exists)\")\n                continue\n\n            try:\n                target_file.parent.mkdir(parents=True, exist_ok=True)\n                shutil.move(str(source_file), str(target_file))\n            except shutil.Error as e:\n                logger.debug(f\"Skipping move of {source_file} to {target_file}: {e}\")\n\n    if any(p.is_file() for p in source_dir.rglob(\"*\")):\n        click.secho(\n            \"Failed to move all files within your project's .github folder to the workspace root. \"\n            \"Please review any files that remain in your project's .github folder and manually include \"\n            \"in the root .github directory as required.\",\n            fg=\"yellow\",\n        )\n    else:\n        shutil.rmtree(source_dir)\n        logger.debug(f\"No files found in .github folder after merge. Removing `.github` directory at {source_dir}...\")"}
{"instruction": "Exit the program with an error code and log a message indicating the program is exiting.", "output": "def _fail_and_bail() -> NoReturn:\n    logger.info(\" Bailing out... \")\n    raise click.exceptions.Exit(code=1)"}
{"instruction": "Determine if a given repository URL is valid by attempting to access the repository using the `copier` library. Return `True` if the repository can be accessed, `False` otherwise. Handle potential exceptions during the access attempt and log any errors encountered.", "output": "def _repo_url_is_valid(url: str) -> bool:\n    \"\"\"Check the repo URL is valid according to copier\"\"\"\n    from copier._vcs import get_repo\n\n    if not url:\n        return False\n    try:\n        return get_repo(url) is not None\n    except Exception:\n        logger.exception(f\"Error parsing repo URL = {url}\", extra=EXTRA_EXCLUDE_FROM_CONSOLE)\n        return False"}
{"instruction": "Create a validator that checks if a directory name is valid. The validator should ensure that: 1) a file with the same name does not already exist in the specified base directory; 2) the name is a valid project directory name, allowing letters, numbers, dashes, periods, and underscores, and ensuring uniqueness.", "output": "class DirectoryNameValidator(questionary.Validator):\n    def __init__(self, base_path: Path) -> None:\n        self._base_path = base_path\n\n    def validate(self, document: prompt_toolkit.document.Document) -> None:\n        name = document.text.strip()\n        new_path = self._base_path / name\n        if new_path.exists() and not new_path.is_dir():\n            raise questionary.ValidationError(\n                message=\"File with same name already exists in current directory, please enter a different name\"\n            )\n        if not is_valid_project_dir_name(document.text):\n            raise questionary.ValidationError(\n                message=\"Invalid name. Use letters, numbers, dashes, periods, underscores, and ensure it's unique.\",\n                cursor_position=len(document.text),\n            )"}
{"instruction": "Determine the project path. If a directory name is provided, use it. Otherwise, prompt the user for a directory name. If a file with the same name exists, exit. If the directory exists and 'force' is not set, prompt the user to confirm overwriting the directory. Return the project path and a boolean indicating if the user confirmed overwriting.", "output": "def _get_project_path(*, directory_name_option: str | None = None, force: bool = False) -> tuple[Path, bool]:\n    \"\"\"\n    Determines the project path based on the provided directory name option.\n\n    Args:\n        directory_name_option: The name of the directory provided by the user.\n                               If None, the user will be prompted to enter a name.\n        force: A flag to auto accept warning prompts.\n\n    Returns:\n        The path to the project directory and a flag to indicate if the user agreed to overwrite the directory.\n    \"\"\"\n\n    base_path = Path.cwd()\n    overwrite_existing_dir = force\n    directory_name = (\n        directory_name_option\n        if directory_name_option is not None\n        else questionary_extensions.prompt_text(\n            \"Name of project / directory to create the project in:\",\n            validators=[questionary_extensions.NonEmptyValidator(), DirectoryNameValidator(base_path)],\n        )\n    ).strip()\n\n    project_path = base_path / directory_name\n    if project_path.exists() and not project_path.is_dir():\n        logger.error(\"A file with the same name already exists in the current directory. Please use a different name.\")\n        _fail_and_bail()\n\n    if project_path.is_dir() and not force:\n        logger.warning(\n            \"Re-using existing directory, this is not recommended because if project \"\n            \"generation fails, then we can't automatically cleanup.\"\n        )\n        overwrite_existing_dir = questionary_extensions.prompt_confirm(\"Continue anyway?\", default=False)\n        if not overwrite_existing_dir:\n            return _get_project_path() if directory_name_option is None else _fail_and_bail()\n\n    return project_path, overwrite_existing_dir"}
{"instruction": "Determine the template source based on the provided arguments. If a template name is given, retrieve the corresponding template from a list of blessed templates. If a URL is provided, validate it, potentially prompt the user for confirmation due to security concerns, and create a template source from the URL and commit hash. If neither a name nor a URL is provided, interactively prompt the user to select a template. Raise exceptions if both name and URL are provided, or if a commit is provided when a name is specified.", "output": "def _get_template(\n    *,\n    name: str | None,\n    url: str | None,\n    commit: str | None,\n    unsafe_security_accept_template_url: bool,\n) -> TemplateSource:\n    if name:\n        if url:\n            raise click.ClickException(\"Cannot specify both --template and --template-url\")\n        if commit:\n            raise click.ClickException(\"--template-url-ref has no effect when template name is specified\")\n        blessed_templates = _get_blessed_templates()\n        template: TemplateSource = blessed_templates[TemplateKey(name)]\n    elif not url:\n        template = _get_template_interactive()\n    else:\n        if not _repo_url_is_valid(url):\n            logger.error(f\"Couldn't parse repo URL {url}. Try prefixing it with git+ ?\")\n            _fail_and_bail()\n        logger.warning(_unofficial_template_warning)\n        # note: we use unsafe_ask here (and everywhere else) so we don't have to\n        # handle None returns for KeyboardInterrupt - click will handle these nicely enough for us\n        # at the root level\n        if not (\n            unsafe_security_accept_template_url\n            or questionary_extensions.prompt_confirm(\"Continue anyway?\", default=False)\n        ):\n            _fail_and_bail()\n        template = TemplateSource(url=url, commit=commit)\n    return template"}
{"instruction": "Validate that a provided string is a valid Git repository URL. If the URL is not valid, raise a validation error suggesting the user prefix it with 'git+'.", "output": "class GitRepoValidator(questionary.Validator):\n    def validate(self, document: prompt_toolkit.document.Document) -> None:\n        value = document.text.strip()\n        if value and not _repo_url_is_valid(value):\n            raise questionary.ValidationError(message=f\"Couldn't parse repo URL {value}. Try prefixing it with git+ ?\")"}
{"instruction": "Prompt the user to select a project type from a list of options (Smart Contract, DApp Frontend, Smart Contract and DApp Frontend, Custom Template). If the user selects Smart Contract or Smart Contract and DApp Frontend, prompt the user to select a smart contract language. Determine the appropriate template key based on the project type and language selections. If the selected template is a Fullstack template and a language is selected, set the contract_template answer for the template source. If the project type is Custom Template, prompt the user for a custom template URL with validation. If the user provides an empty URL, re-prompt for the project type. Return the appropriate TemplateSource object based on the user's selections.", "output": "def _get_template_interactive() -> TemplateSource:\n    project_type = questionary_extensions.prompt_select(\n        \"Which of these options best describes the project you want to build?\",\n        *[questionary.Choice(title=p_type.value, value=p_type) for p_type in TemplatePresetType],  # Modified line\n    )\n    logger.debug(f\"selected project_type = {project_type.value}\")\n\n    template = None\n    language = None\n    if project_type in [TemplatePresetType.SMART_CONTRACT, TemplatePresetType.SMART_CONTRACT_AND_DAPP_FRONTEND]:\n        language = questionary_extensions.prompt_select(\n            \"Which language would you like to use for the smart contract?\",\n            *[questionary.Choice(title=lang.value, value=lang) for lang in ContractLanguage],\n        )\n        logger.debug(f\"selected language = {language}\")\n        template = (\n            TemplateKey.FULLSTACK\n            if project_type == TemplatePresetType.SMART_CONTRACT_AND_DAPP_FRONTEND\n            else LANGUAGE_TO_TEMPLATE_MAP[language]\n        )\n\n    elif project_type == TemplatePresetType.DAPP_FRONTEND:\n        template = TemplateKey.REACT\n\n    # Ensure a template has been selected\n    if not template and not project_type == TemplatePresetType.CUSTOM_TEMPLATE:\n        raise click.ClickException(\"No template selected. Please try again.\")\n\n    # Map the template string directly to the TemplateSource\n    # This is needed to be able to reuse fullstack to work with python and typescript templates\n    blessed_templates = _get_blessed_templates()\n    if template in blessed_templates:\n        selected_template_source = blessed_templates[template]\n        if template == TemplateKey.FULLSTACK and language is not None:\n            smart_contract_template = LANGUAGE_TO_TEMPLATE_MAP[language]\n            selected_template_source.answers = [(\"contract_template\", smart_contract_template)]\n        return selected_template_source\n\n    # else: user selected custom url\n    # note we print the warning but don't prompt for confirmation like we would when the URL is passed\n    # as a command line argument, instead we allow the user to return to the official selection list\n    # by entering a blank string\n    logger.warning(f\"\\n{_unofficial_template_warning}\\n\")\n    logger.info(\n        \"Enter a custom project URL, or leave blank and press enter to go back to official template selection.\\n\"\n        \"Note that you can use gh: as a shorthand for github.com and likewise gl: for gitlab.com\\n\"\n        \"Valid examples:\\n\"\n        \" - gh:copier-org/copier\\n\"\n        \" - gl:copier-org/copier\\n\"\n        \" - git@github.com:copier-org/copier.git\\n\"\n        \" - git+https://mywebsiteisagitrepo.example.com/\\n\"\n        \" - /local/path/to/git/repo\\n\"\n        \" - /local/path/to/git/bundle/file.bundle\\n\"\n        \" - ~/path/to/git/repo\\n\"\n        \" - ~/path/to/git/repo.bundle\\n\"\n    )\n    template_url = questionary_extensions.prompt_text(\"Custom template URL:\", validators=[GitRepoValidator()]).strip()\n    if not template_url:\n        # re-prompt if empty response\n        return _get_template_interactive()\n    return TemplateSource(url=template_url)"}
{"instruction": "Determine whether to initialize a Git repository based on the 'use_git_option' and the project's Git status. If 'use_git_option' is False, skip initialization. If the project is already in a Git repository, skip initialization and log a message (warning if 'use_git_option' was explicitly set, info otherwise). If not already in a git repo, prompt the user to initialize a git repository if 'use_git_option' is not set or is set to True.", "output": "def _should_attempt_git_init(use_git_option: bool | None, project_path: Path) -> bool:\n    if use_git_option is False:\n        return False\n    try:\n        git_rev_parse_result = proc.run([\"git\", \"rev-parse\", \"--show-toplevel\"], cwd=project_path)\n    except FileNotFoundError:\n        logger.warning(\"git command wasn't found on your PATH, can not perform repository initialisation\")\n        return False\n    is_in_git_repo = git_rev_parse_result.exit_code == 0\n    if is_in_git_repo:\n        logger.log(\n            msg=\"Directory is already under git revision control, skipping git setup\",\n            # warning if the user explicitly requested to set up git, info otherwise\n            level=logging.WARNING if use_git_option else logging.INFO,\n        )\n        return False\n\n    return use_git_option or questionary_extensions.prompt_confirm(\n        \"Would you like to initialise a git repository and perform an initial commit?\",\n        default=True,\n    )"}
{"instruction": "Initialize a Git repository in the specified directory, checkout a new branch named 'main', add all files to the staging area, and commit the changes with the provided commit message. Log a success message if all operations are successful, and log warning messages if any operation fails.", "output": "def _git_init(project_path: Path, commit_message: str) -> None:\n    def git(*args: str, bad_exit_warn_message: str) -> bool:\n        result = proc.run([\"git\", *args], cwd=project_path)\n        success = result.exit_code == 0\n        if not success:\n            logger.warning(bad_exit_warn_message)\n        return success\n\n    if (\n        git(\"init\", bad_exit_warn_message=\"Failed to initialise git repository\")\n        and git(\"checkout\", \"-b\", \"main\", bad_exit_warn_message=\"Failed to name initial branch\")\n        and git(\"add\", \"--all\", bad_exit_warn_message=\"Failed to add generated project files\")\n        and git(\"commit\", \"-m\", commit_message, bad_exit_warn_message=\"Initial commit failed\")\n    ):\n        logger.info(\" Performed initial git commit successfully! \")"}
{"instruction": "Determine the final project path based on the template source, project type (standalone or fullstack), whether to use a workspace, and the presence of an existing AlgoKit configuration. If a standalone project is being created within a workspace and 'use_workspace' is enabled, place the project within the designated projects folder of the workspace. If no workspace exists, bootstrap the algokit-base-template and place the new project within the newly created workspace structure. Otherwise, return the original project path.", "output": "def _resolve_workspace_project_path(\n    *, template_source: TemplateSource, project_path: Path, use_workspace: bool = True\n) -> Path:\n    blessed_template = _get_blessed_templates()\n\n    # If its already a Base template, do not modify project path\n    if template_source == blessed_template[TemplateKey.BASE]:\n        return project_path\n\n    cwd = Path.cwd()\n    is_standalone = template_source != blessed_template[TemplateKey.FULLSTACK]\n    config = get_algokit_config(project_dir=cwd)\n\n    # 1. If standalone project (not fullstack) and use_workspace is True, bootstrap algokit-base-template\n    if config is None and is_standalone and use_workspace:\n        _init_base_template(target_path=project_path, is_blessed=template_source in blessed_template.values())\n\n        config = get_algokit_config(project_dir=project_path)\n        if not config:\n            logger.error(\"Failed to instantiate workspace structure for standalone project\")\n            _fail_and_bail()\n\n        sub_projects_path = config.get(\"project\", {}).get(\"projects_root_path\") or \"projects\"\n        new_project_path = cwd / project_path.name / sub_projects_path / project_path.name\n        new_project_path.mkdir(parents=True, exist_ok=True)\n\n        logger.debug(f\"Workspace structure is ready! The project is to be placed under {new_project_path}\")\n        return new_project_path\n\n    # 2. If its a standalone project being instantiated inside an existing workspace project and use_workspace is True\n    # then place the new project inside expected projects folder defined by workspace toml\n    if (\n        config\n        and config.get(\"project\", {}).get(\"type\") == ProjectType.WORKSPACE.value\n        and is_standalone\n        and use_workspace\n    ):\n        sub_projects_path = config.get(\"project\", {}).get(\"projects_root_path\") or \"projects\"\n        projects_root = cwd / sub_projects_path\n        logger.debug(f\"Workspace structure detected! Moving the project to be instantiated into {projects_root}\")\n        return projects_root / project_path.name\n\n    return project_path"}
{"instruction": "Instantiate a base template from a remote source using copier, configuring it with project-specific data such as the project name, a flag to use the default readme, a projects root path, and a flag to include a github workflow based on whether it's a blessed template. The template is copied to the specified target path.", "output": "def _init_base_template(*, target_path: Path, is_blessed: bool) -> None:\n    \"\"\"\n    Instantiate the base template for a standalone project.\n    Sets up the common workspace structure for standalone projects.\n\n    Args:\n        target_path: The path to the project directory.\n        is_blessed: Whether the template is a blessed template.\n    \"\"\"\n\n    # Instantiate the base template\n    blessed_templates = _get_blessed_templates()\n    base_template = blessed_templates[TemplateKey.BASE]\n    base_template_answers = {\n        \"use_default_readme\": \"yes\",\n        \"project_name\": target_path.name,\n        \"projects_root_path\": \"projects\",\n        \"include_github_workflow_template\": not is_blessed,\n    }\n    from copier._main import Worker\n\n    with Worker(\n        src_path=base_template.url,\n        dst_path=target_path,\n        data=base_template_answers,\n        quiet=True,\n        vcs_ref=base_template.branch or base_template.commit,\n        unsafe=True,\n    ) as copier_worker:\n        copier_worker.run_copy()"}
{"instruction": "Verify that a container engine (Docker or Podman) and its Compose plugin are installed and accessible, and that the Compose version meets the minimum required version. If validation fails, raise an exception with instructions on how to resolve the issue. Finally, verify that the container engine is running.", "output": "def localnet_group(ctx: click.Context) -> None:\n    if ctx.invoked_subcommand and \"codespace\" in ctx.invoked_subcommand or not ctx.invoked_subcommand:\n        return\n\n    try:\n        compose_version_result = proc.run(COMPOSE_VERSION_COMMAND)\n    except OSError as ex:\n        # an IOError (such as PermissionError or FileNotFoundError) will only occur if \"docker\"\n        # isn't an executable in the user's path, which means docker isn't installed\n        raise click.ClickException(\n            \"Container engine not found; please install Docker or Podman and add to path.\"\n        ) from ex\n    if compose_version_result.exit_code != 0:\n        raise click.ClickException(\n            \"Container engine compose not found; please install Docker Compose or Podman Compose and add to path.\"\n        )\n\n    compose_minimum_version = get_min_compose_version()\n    try:\n        compose_version_str = extract_version_triple(compose_version_result.output)\n        compose_version_ok = is_minimum_version(compose_version_str, compose_minimum_version)\n    except Exception:\n        logger.warning(\n            \"Unable to extract compose version from output: \\n\"\n            + compose_version_result.output\n            + f\"\\nPlease ensure a minimum of compose v{compose_minimum_version} is used\",\n            exc_info=True,\n        )\n    else:\n        if not compose_version_ok:\n            raise click.ClickException(\n                f\"Minimum compose version supported: v{compose_minimum_version}, \"\n                f\"installed = v{compose_version_str}\\n\"\n                \"Please update your compose install\"\n            )\n\n    if ctx.invoked_subcommand and ctx.invoked_subcommand == \"config\":\n        return\n\n    proc.run(\n        [get_container_engine(), \"version\"],\n        bad_return_code_error_message=\"Container engine isn't running; please start it.\",\n    )"}
{"instruction": "Set the preferred container engine (Docker or Podman) for running local network images. If no engine is provided, prompt the user to select one. If a local network instance is running, prompt the user to restart it with the selected engine, unless forced to do so. Save the chosen engine configuration and restart the local network instance if requested.", "output": "def config_command(*, engine: str | None, force: bool) -> None:\n    \"\"\"Set the default container engine for use by AlgoKit CLI to run LocalNet images.\"\"\"\n    if engine is None:\n        current_engine = get_container_engine()\n        choices = [\n            f\"Docker {'(Active)' if current_engine == ContainerEngine.DOCKER else ''}\".strip(),\n            f\"Podman {'(Active)' if current_engine == ContainerEngine.PODMAN else ''}\".strip(),\n        ]\n        engine = questionary.select(\"Which container engine do you prefer?\", choices=choices).ask()\n        if engine is None:\n            raise click.ClickException(\"No valid container engine selected. Aborting...\")\n        engine = engine.split()[0].lower()\n\n    sandbox = ComposeSandbox.from_environment()\n    has_active_instance = sandbox is not None and (\n        force\n        or click.confirm(\n            f\"Detected active localnet instance, would you like to restart it with '{engine}'?\",\n            default=True,\n        )\n    )\n    if sandbox and has_active_instance:\n        sandbox.down()\n        save_container_engine(engine)\n        sandbox.write_compose_file()\n        sandbox.up()\n    else:\n        save_container_engine(engine)\n\n    logger.info(f\"Container engine set to `{engine}`\")"}
{"instruction": "Start or update an AlgoKit LocalNet instance. Check if a LocalNet is already running and prompt to stop it if necessary. Create or update the Docker Compose file based on the provided configuration and check for new image versions. Configure Algod in development mode if specified and restart LocalNet if required. Finally, start the LocalNet instance.", "output": "def start_localnet(*, name: str | None, config_path: Path | None, algod_dev_mode: bool, force: bool) -> None:\n    sandbox = ComposeSandbox.from_environment()\n    full_name = f\"{SANDBOX_BASE_NAME}_{name}\" if name is not None else SANDBOX_BASE_NAME\n    if sandbox is not None and full_name != sandbox.name:\n        logger.debug(\"LocalNet is already running.\")\n        if click.confirm(\"This will stop any running AlgoKit LocalNet instance. Are you sure?\", default=True):\n            sandbox.stop()\n        else:\n            raise click.ClickException(\"LocalNet is already running. Please stop it first\")\n    sandbox = ComposeSandbox(SANDBOX_BASE_NAME, config_path) if name is None else ComposeSandbox(name, config_path)\n    compose_file_status = sandbox.compose_file_status()\n    sandbox.check_docker_compose_for_new_image_versions()\n    if compose_file_status is ComposeFileStatus.MISSING:\n        logger.debug(\"LocalNet compose file does not exist yet; writing it out for the first time\")\n        sandbox.write_compose_file()\n        if name is not None:\n            logger.info(\n                f\"The named LocalNet configuration has been created in {sandbox.directory}. \\n\"\n                f\"You can edit the configuration by changing those files. \"\n                f\"Running `algokit localnet reset` will ensure the configuration is applied\"\n            )\n    elif compose_file_status is ComposeFileStatus.UP_TO_DATE:\n        logger.debug(\"LocalNet compose file does not require updating\")\n    elif compose_file_status is ComposeFileStatus.OUT_OF_DATE and name is None:\n        logger.warning(\"LocalNet definition is out of date; please run `algokit localnet reset`\")\n    if name is not None:\n        logger.info(\n            \"A named LocalNet is running, update checks are disabled. If you wish to synchronize with the latest \"\n            \"version, run `algokit localnet reset --update`\"\n        )\n    if sandbox.is_algod_dev_mode() != algod_dev_mode:\n        sandbox.set_algod_dev_mode(dev_mode=algod_dev_mode)\n        logger.info(f\"Refreshed 'DevMode' flag to '{algod_dev_mode}'\")\n        if not force and click.confirm(\n            f\"Would you like to restart 'LocalNet' to apply 'DevMode' flag set to '{algod_dev_mode}'? \"\n            \"Otherwise, the next `algokit localnet reset` will restart with the new flag\",\n            default=True,\n        ):\n            sandbox.down()\n            sandbox.up()\n    else:\n        sandbox.up()"}
{"instruction": "Stop the local Algorand network if it is running using Docker Compose. If no Compose environment is detected, log a message indicating that the local network is not running and suggest starting it with 'algokit localnet start'.", "output": "def stop_localnet() -> None:\n    sandbox = ComposeSandbox.from_environment()\n    if sandbox is not None:\n        compose_file_status = sandbox.compose_file_status()\n        if compose_file_status is not ComposeFileStatus.MISSING:\n            sandbox.stop()\n    else:\n        logger.debug(\"LocalNet is not running; run `algokit localnet start` to start the AlgoKit LocalNet\")"}
{"instruction": "Reset and restart a local network environment using Docker Compose. The process involves checking for an existing environment, updating its configuration based on a compose file, and pulling new images if specified. If a named environment is running, the user is prompted for confirmation before resetting. The environment is then brought up again.", "output": "def reset_localnet(*, update: bool, config_path: Path | None) -> None:\n    sandbox = ComposeSandbox.from_environment()\n    if sandbox is None:\n        sandbox = ComposeSandbox(config_path=config_path)\n    compose_file_status = sandbox.compose_file_status()\n    if compose_file_status is ComposeFileStatus.MISSING:\n        logger.debug(\"Existing LocalNet not found; creating from scratch...\")\n        sandbox.write_compose_file()\n    elif sandbox.name == SANDBOX_BASE_NAME:\n        sandbox.down()\n        if compose_file_status is not ComposeFileStatus.UP_TO_DATE:\n            logger.info(\"Syncing LocalNet configuration\")\n            sandbox.write_compose_file()\n        if update:\n            sandbox.pull()\n        else:\n            sandbox.check_docker_compose_for_new_image_versions()\n    elif update:\n        if click.confirm(\n            f\"A named LocalNet is running, are you sure you want to reset the LocalNet configuration \"\n            f\"in {sandbox.directory}?\\nThis will stop the running LocalNet and overwrite any changes \"\n            \"you've made to the configuration\",\n            default=True,\n        ):\n            sandbox.down()\n            sandbox.write_compose_file()\n            sandbox.pull()\n        else:\n            raise click.ClickException(\"LocalNet configuration has not been reset\")\n    else:\n        sandbox.down()\n    sandbox.up()"}
{"instruction": "Check the status of the AlgoKit LocalNet, displaying the container engine in use, the status of the 'algod' and 'indexer' services (including details fetched from their respective status endpoints via a proxy), and raise an exception if the LocalNet has not been initialized or if any required container is not running.", "output": "def localnet_status() -> None:\n    sandbox = ComposeSandbox.from_environment()\n    if sandbox is None:\n        sandbox = ComposeSandbox()\n\n    logger.info(\"# container engine\")\n    logger.info(\n        \"Name: \" + click.style(get_container_engine(), bold=True) + \" (change with `algokit config container-engine`)\"\n    )\n\n    ps = sandbox.ps()\n    ps_by_name = {stats[\"Service\"]: stats for stats in ps}\n    # if any of the required containers does not exist (ie it's not just stopped but hasn't even been created),\n    # then they will be missing from the output dictionary\n    if set(SERVICE_NAMES) != ps_by_name.keys():\n        raise click.ClickException(\"LocalNet has not been initialized yet, please run 'algokit localnet start'\")\n    # initialise output dict by setting status\n    output_by_name = {\n        name: {\"Status\": \"Running\" if ps_by_name[name][\"State\"] == \"running\" else \"Not running\"}\n        for name in SERVICE_NAMES\n    }\n    # fill out remaining output_by_name[\"algod\"] values\n    if output_by_name[\"algod\"][\"Status\"] == \"Running\":\n        output_by_name[\"algod\"].update(fetch_algod_status_data(ps_by_name[\"proxy\"]))\n    # fill out remaining output_by_name[\"indexer\"] values\n    if output_by_name[\"indexer\"][\"Status\"] == \"Running\":\n        output_by_name[\"indexer\"].update(fetch_indexer_status_data(ps_by_name[\"proxy\"]))\n\n    # Print the status details\n    for service_name, service_info in output_by_name.items():\n        logger.info(click.style(f\"# {service_name} status\", bold=True))\n        for key, value in service_info.items():\n            logger.info(click.style(f\"{key}:\", bold=True) + f\" {value}\")\n\n    # return non-zero if any container is not running\n    if not all(item[\"Status\"] == \"Running\" for item in output_by_name.values()):\n        raise click.ClickException(\n            \"At least one container isn't running; execute `algokit localnet start` to start the LocalNet\"\n        )"}
{"instruction": "Execute the 'goal_command' with the 'console' flag set to True within the given click context.", "output": "def localnet_console(context: click.Context) -> None:\n    context.invoke(goal_command, console=True)"}
{"instruction": "Generate a new Algorand account, deriving both the private key and corresponding Algorand address. Then, convert the private key into its mnemonic phrase representation.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate a new Algorand account consisting of a private key, corresponding address, and the mnemonic phrase derived from the private key.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Invoke the 'explore_command' command within the provided context.", "output": "def localnet_explore(context: click.Context) -> None:\n    context.invoke(explore_command)"}
{"instruction": "Generate an Algorand account, derive its mnemonic phrase from the private key, and obtain the corresponding address.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate a new Algorand account, derive its mnemonic phrase from the private key, and store the private key and corresponding Algorand address.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate an Algorand account, derive its mnemonic phrase from the private key, and store the private key and address.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Generate a new Algorand account, derive the corresponding private key, public address, and mnemonic phrase.", "output": "from algosdk import account, mnemonic\nprivate_key, address = account.generate_account()\nmnemonic_phrase = mnemonic.from_private_key(private_key)"}
{"instruction": "Display and optionally follow logs from a Docker Compose sandbox environment, allowing customization of whether to use color and how many lines to display from the end.", "output": "def localnet_logs(ctx: click.Context, *, follow: bool, tail: str) -> None:\n    sandbox = ComposeSandbox()\n    sandbox.logs(follow=follow, no_color=ctx.color is False, tail=tail)"}
{"instruction": "Modify the command-line interface such that the command 'analyse' acts as an alias for the 'analyze' command.", "output": "class AliasedGroup(click.Group):\n    def get_command(self, ctx: click.Context, cmd_name: str) -> click.Command | None:\n        rv = click.Group.get_command(self, ctx, cmd_name)\n        if rv is not None:\n            return rv\n\n        if cmd_name == \"analyse\":\n            return click.Group.get_command(self, ctx, \"analyze\")\n\n        return None"}
{"instruction": "Generate a collection of Algorand development tasks.", "output": "def task_group() -> None:\n    \"\"\"Collection of useful tasks to help you develop on Algorand.\"\"\""}
